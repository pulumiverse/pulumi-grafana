// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package fleetmanagement

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/pulumiverse/pulumi-grafana/sdk/go/grafana/internal"
)

// Manages Grafana Fleet Management collectors.
//
// * [Official documentation](https://grafana.com/docs/grafana-cloud/send-data/fleet-management/)
// * [API documentation](https://grafana.com/docs/grafana-cloud/send-data/fleet-management/api-reference/collector-api/)
//
// **Note:** Fleet Management is in [public preview](https://grafana.com/docs/release-life-cycle/#public-preview) and this resource is experimental. Grafana Labs offers limited support, and breaking changes might occur.
//
// Required access policy scopes:
//
// * fleet-management:read
// * fleet-management:write
//
// ## Import
//
// ```sh
// $ pulumi import grafana:fleetManagement/collector:Collector name "{{ id }}"
// ```
type Collector struct {
	pulumi.CustomResourceState

	// Whether the collector is enabled or not
	Enabled pulumi.BoolOutput `pulumi:"enabled"`
	// Remote attributes for the collector
	RemoteAttributes pulumi.StringMapOutput `pulumi:"remoteAttributes"`
}

// NewCollector registers a new resource with the given unique name, arguments, and options.
func NewCollector(ctx *pulumi.Context,
	name string, args *CollectorArgs, opts ...pulumi.ResourceOption) (*Collector, error) {
	if args == nil {
		args = &CollectorArgs{}
	}

	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Collector
	err := ctx.RegisterResource("grafana:fleetManagement/collector:Collector", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetCollector gets an existing Collector resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetCollector(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *CollectorState, opts ...pulumi.ResourceOption) (*Collector, error) {
	var resource Collector
	err := ctx.ReadResource("grafana:fleetManagement/collector:Collector", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Collector resources.
type collectorState struct {
	// Whether the collector is enabled or not
	Enabled *bool `pulumi:"enabled"`
	// Remote attributes for the collector
	RemoteAttributes map[string]string `pulumi:"remoteAttributes"`
}

type CollectorState struct {
	// Whether the collector is enabled or not
	Enabled pulumi.BoolPtrInput
	// Remote attributes for the collector
	RemoteAttributes pulumi.StringMapInput
}

func (CollectorState) ElementType() reflect.Type {
	return reflect.TypeOf((*collectorState)(nil)).Elem()
}

type collectorArgs struct {
	// Whether the collector is enabled or not
	Enabled *bool `pulumi:"enabled"`
	// Remote attributes for the collector
	RemoteAttributes map[string]string `pulumi:"remoteAttributes"`
}

// The set of arguments for constructing a Collector resource.
type CollectorArgs struct {
	// Whether the collector is enabled or not
	Enabled pulumi.BoolPtrInput
	// Remote attributes for the collector
	RemoteAttributes pulumi.StringMapInput
}

func (CollectorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*collectorArgs)(nil)).Elem()
}

type CollectorInput interface {
	pulumi.Input

	ToCollectorOutput() CollectorOutput
	ToCollectorOutputWithContext(ctx context.Context) CollectorOutput
}

func (*Collector) ElementType() reflect.Type {
	return reflect.TypeOf((**Collector)(nil)).Elem()
}

func (i *Collector) ToCollectorOutput() CollectorOutput {
	return i.ToCollectorOutputWithContext(context.Background())
}

func (i *Collector) ToCollectorOutputWithContext(ctx context.Context) CollectorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CollectorOutput)
}

// CollectorArrayInput is an input type that accepts CollectorArray and CollectorArrayOutput values.
// You can construct a concrete instance of `CollectorArrayInput` via:
//
//	CollectorArray{ CollectorArgs{...} }
type CollectorArrayInput interface {
	pulumi.Input

	ToCollectorArrayOutput() CollectorArrayOutput
	ToCollectorArrayOutputWithContext(context.Context) CollectorArrayOutput
}

type CollectorArray []CollectorInput

func (CollectorArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Collector)(nil)).Elem()
}

func (i CollectorArray) ToCollectorArrayOutput() CollectorArrayOutput {
	return i.ToCollectorArrayOutputWithContext(context.Background())
}

func (i CollectorArray) ToCollectorArrayOutputWithContext(ctx context.Context) CollectorArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CollectorArrayOutput)
}

// CollectorMapInput is an input type that accepts CollectorMap and CollectorMapOutput values.
// You can construct a concrete instance of `CollectorMapInput` via:
//
//	CollectorMap{ "key": CollectorArgs{...} }
type CollectorMapInput interface {
	pulumi.Input

	ToCollectorMapOutput() CollectorMapOutput
	ToCollectorMapOutputWithContext(context.Context) CollectorMapOutput
}

type CollectorMap map[string]CollectorInput

func (CollectorMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Collector)(nil)).Elem()
}

func (i CollectorMap) ToCollectorMapOutput() CollectorMapOutput {
	return i.ToCollectorMapOutputWithContext(context.Background())
}

func (i CollectorMap) ToCollectorMapOutputWithContext(ctx context.Context) CollectorMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CollectorMapOutput)
}

type CollectorOutput struct{ *pulumi.OutputState }

func (CollectorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Collector)(nil)).Elem()
}

func (o CollectorOutput) ToCollectorOutput() CollectorOutput {
	return o
}

func (o CollectorOutput) ToCollectorOutputWithContext(ctx context.Context) CollectorOutput {
	return o
}

// Whether the collector is enabled or not
func (o CollectorOutput) Enabled() pulumi.BoolOutput {
	return o.ApplyT(func(v *Collector) pulumi.BoolOutput { return v.Enabled }).(pulumi.BoolOutput)
}

// Remote attributes for the collector
func (o CollectorOutput) RemoteAttributes() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Collector) pulumi.StringMapOutput { return v.RemoteAttributes }).(pulumi.StringMapOutput)
}

type CollectorArrayOutput struct{ *pulumi.OutputState }

func (CollectorArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Collector)(nil)).Elem()
}

func (o CollectorArrayOutput) ToCollectorArrayOutput() CollectorArrayOutput {
	return o
}

func (o CollectorArrayOutput) ToCollectorArrayOutputWithContext(ctx context.Context) CollectorArrayOutput {
	return o
}

func (o CollectorArrayOutput) Index(i pulumi.IntInput) CollectorOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Collector {
		return vs[0].([]*Collector)[vs[1].(int)]
	}).(CollectorOutput)
}

type CollectorMapOutput struct{ *pulumi.OutputState }

func (CollectorMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Collector)(nil)).Elem()
}

func (o CollectorMapOutput) ToCollectorMapOutput() CollectorMapOutput {
	return o
}

func (o CollectorMapOutput) ToCollectorMapOutputWithContext(ctx context.Context) CollectorMapOutput {
	return o
}

func (o CollectorMapOutput) MapIndex(k pulumi.StringInput) CollectorOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Collector {
		return vs[0].(map[string]*Collector)[vs[1].(string)]
	}).(CollectorOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*CollectorInput)(nil)).Elem(), &Collector{})
	pulumi.RegisterInputType(reflect.TypeOf((*CollectorArrayInput)(nil)).Elem(), CollectorArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*CollectorMapInput)(nil)).Elem(), CollectorMap{})
	pulumi.RegisterOutputType(CollectorOutput{})
	pulumi.RegisterOutputType(CollectorArrayOutput{})
	pulumi.RegisterOutputType(CollectorMapOutput{})
}
