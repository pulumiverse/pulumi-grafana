# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities
from . import outputs

__all__ = [
    'BuiltinRoleAssignmentRole',
    'ContactPointAlertmanager',
    'ContactPointDingding',
    'ContactPointDiscord',
    'ContactPointEmail',
    'ContactPointGooglechat',
    'ContactPointKafka',
    'ContactPointOpsgeny',
    'ContactPointPagerduty',
    'ContactPointPushover',
    'ContactPointSensugo',
    'ContactPointSlack',
    'ContactPointTeam',
    'ContactPointTelegram',
    'ContactPointThreema',
    'ContactPointVictorop',
    'ContactPointWebhook',
    'ContactPointWecom',
    'DashboardPermissionPermission',
    'DataSourceJsonData',
    'DataSourceJsonDataDerivedField',
    'DataSourcePermissionPermission',
    'DataSourceSecureJsonData',
    'FolderPermissionPermission',
    'MuteTimingInterval',
    'MuteTimingIntervalTime',
    'NotificationPolicyPolicy',
    'NotificationPolicyPolicyMatcher',
    'NotificationPolicyPolicyPolicy',
    'NotificationPolicyPolicyPolicyMatcher',
    'NotificationPolicyPolicyPolicyPolicy',
    'NotificationPolicyPolicyPolicyPolicyMatcher',
    'NotificationPolicyPolicyPolicyPolicyPolicy',
    'NotificationPolicyPolicyPolicyPolicyPolicyMatcher',
    'OncallIntegrationDefaultRoute',
    'OncallIntegrationDefaultRouteMsteams',
    'OncallIntegrationDefaultRouteSlack',
    'OncallIntegrationDefaultRouteTelegram',
    'OncallIntegrationTemplates',
    'OncallIntegrationTemplatesSlack',
    'OncallRouteMsteams',
    'OncallRouteSlack',
    'OncallRouteTelegram',
    'OncallScheduleSlack',
    'PlaylistItem',
    'ReportSchedule',
    'ReportTimeRange',
    'RolePermission',
    'RuleGroupRule',
    'RuleGroupRuleData',
    'RuleGroupRuleDataRelativeTimeRange',
    'ServiceAccountPermissionPermission',
    'SyntheticMonitoringCheckSettings',
    'SyntheticMonitoringCheckSettingsDns',
    'SyntheticMonitoringCheckSettingsDnsValidateAdditionalRr',
    'SyntheticMonitoringCheckSettingsDnsValidateAnswerRrs',
    'SyntheticMonitoringCheckSettingsDnsValidateAuthorityRrs',
    'SyntheticMonitoringCheckSettingsHttp',
    'SyntheticMonitoringCheckSettingsHttpBasicAuth',
    'SyntheticMonitoringCheckSettingsHttpFailIfHeaderMatchesRegexp',
    'SyntheticMonitoringCheckSettingsHttpFailIfHeaderNotMatchesRegexp',
    'SyntheticMonitoringCheckSettingsHttpTlsConfig',
    'SyntheticMonitoringCheckSettingsPing',
    'SyntheticMonitoringCheckSettingsTcp',
    'SyntheticMonitoringCheckSettingsTcpQueryResponse',
    'SyntheticMonitoringCheckSettingsTcpTlsConfig',
    'SyntheticMonitoringCheckSettingsTraceroute',
    'GetDashboardsDashboardResult',
    'GetFoldersFolderResult',
]

@pulumi.output_type
class BuiltinRoleAssignmentRole(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "global":
            suggest = "global_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BuiltinRoleAssignmentRole. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BuiltinRoleAssignmentRole.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BuiltinRoleAssignmentRole.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 uid: str,
                 global_: Optional[bool] = None):
        """
        :param str uid: Unique identifier of the role to assign to `builtin_role`.
        :param bool global_: States whether the assignment is available across all organizations or not. Defaults to `false`.
        """
        pulumi.set(__self__, "uid", uid)
        if global_ is not None:
            pulumi.set(__self__, "global_", global_)

    @property
    @pulumi.getter
    def uid(self) -> str:
        """
        Unique identifier of the role to assign to `builtin_role`.
        """
        return pulumi.get(self, "uid")

    @property
    @pulumi.getter(name="global")
    def global_(self) -> Optional[bool]:
        """
        States whether the assignment is available across all organizations or not. Defaults to `false`.
        """
        return pulumi.get(self, "global_")


@pulumi.output_type
class ContactPointAlertmanager(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "basicAuthPassword":
            suggest = "basic_auth_password"
        elif key == "basicAuthUser":
            suggest = "basic_auth_user"
        elif key == "disableResolveMessage":
            suggest = "disable_resolve_message"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContactPointAlertmanager. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContactPointAlertmanager.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContactPointAlertmanager.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: str,
                 basic_auth_password: Optional[str] = None,
                 basic_auth_user: Optional[str] = None,
                 disable_resolve_message: Optional[bool] = None,
                 settings: Optional[Mapping[str, str]] = None,
                 uid: Optional[str] = None):
        """
        :param str url: The URL of the Alertmanager instance.
        :param str basic_auth_password: The password component of the basic auth credentials to use.
        :param str basic_auth_user: The username component of the basic auth credentials to use.
        :param bool disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param Mapping[str, str] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param str uid: The UID of the contact point.
        """
        pulumi.set(__self__, "url", url)
        if basic_auth_password is not None:
            pulumi.set(__self__, "basic_auth_password", basic_auth_password)
        if basic_auth_user is not None:
            pulumi.set(__self__, "basic_auth_user", basic_auth_user)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        The URL of the Alertmanager instance.
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter(name="basicAuthPassword")
    def basic_auth_password(self) -> Optional[str]:
        """
        The password component of the basic auth credentials to use.
        """
        return pulumi.get(self, "basic_auth_password")

    @property
    @pulumi.getter(name="basicAuthUser")
    def basic_auth_user(self) -> Optional[str]:
        """
        The username component of the basic auth credentials to use.
        """
        return pulumi.get(self, "basic_auth_user")

    @property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[bool]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @property
    @pulumi.getter
    def settings(self) -> Optional[Mapping[str, str]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @property
    @pulumi.getter
    def uid(self) -> Optional[str]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")


@pulumi.output_type
class ContactPointDingding(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disableResolveMessage":
            suggest = "disable_resolve_message"
        elif key == "messageType":
            suggest = "message_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContactPointDingding. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContactPointDingding.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContactPointDingding.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: str,
                 disable_resolve_message: Optional[bool] = None,
                 message: Optional[str] = None,
                 message_type: Optional[str] = None,
                 settings: Optional[Mapping[str, str]] = None,
                 uid: Optional[str] = None):
        """
        :param str url: The DingDing webhook URL.
        :param bool disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param str message: The templated content of the message.
        :param str message_type: The format of message to send - either 'link' or 'actionCard'
        :param Mapping[str, str] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param str uid: The UID of the contact point.
        """
        pulumi.set(__self__, "url", url)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if message_type is not None:
            pulumi.set(__self__, "message_type", message_type)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        The DingDing webhook URL.
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[bool]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        The templated content of the message.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter(name="messageType")
    def message_type(self) -> Optional[str]:
        """
        The format of message to send - either 'link' or 'actionCard'
        """
        return pulumi.get(self, "message_type")

    @property
    @pulumi.getter
    def settings(self) -> Optional[Mapping[str, str]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @property
    @pulumi.getter
    def uid(self) -> Optional[str]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")


@pulumi.output_type
class ContactPointDiscord(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "avatarUrl":
            suggest = "avatar_url"
        elif key == "disableResolveMessage":
            suggest = "disable_resolve_message"
        elif key == "useDiscordUsername":
            suggest = "use_discord_username"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContactPointDiscord. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContactPointDiscord.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContactPointDiscord.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: str,
                 avatar_url: Optional[str] = None,
                 disable_resolve_message: Optional[bool] = None,
                 message: Optional[str] = None,
                 settings: Optional[Mapping[str, str]] = None,
                 uid: Optional[str] = None,
                 use_discord_username: Optional[bool] = None):
        """
        :param str url: The discord webhook URL.
        :param str avatar_url: The URL of a custom avatar image to use. Defaults to ``.
        :param bool disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param str message: The templated content of the message. Defaults to ``.
        :param Mapping[str, str] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param str uid: The UID of the contact point.
        :param bool use_discord_username: Whether to use the bot account's plain username instead of "Grafana." Defaults to `false`.
        """
        pulumi.set(__self__, "url", url)
        if avatar_url is not None:
            pulumi.set(__self__, "avatar_url", avatar_url)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)
        if use_discord_username is not None:
            pulumi.set(__self__, "use_discord_username", use_discord_username)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        The discord webhook URL.
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter(name="avatarUrl")
    def avatar_url(self) -> Optional[str]:
        """
        The URL of a custom avatar image to use. Defaults to ``.
        """
        return pulumi.get(self, "avatar_url")

    @property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[bool]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        The templated content of the message. Defaults to ``.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def settings(self) -> Optional[Mapping[str, str]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @property
    @pulumi.getter
    def uid(self) -> Optional[str]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")

    @property
    @pulumi.getter(name="useDiscordUsername")
    def use_discord_username(self) -> Optional[bool]:
        """
        Whether to use the bot account's plain username instead of "Grafana." Defaults to `false`.
        """
        return pulumi.get(self, "use_discord_username")


@pulumi.output_type
class ContactPointEmail(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disableResolveMessage":
            suggest = "disable_resolve_message"
        elif key == "singleEmail":
            suggest = "single_email"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContactPointEmail. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContactPointEmail.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContactPointEmail.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 addresses: Sequence[str],
                 disable_resolve_message: Optional[bool] = None,
                 message: Optional[str] = None,
                 settings: Optional[Mapping[str, str]] = None,
                 single_email: Optional[bool] = None,
                 subject: Optional[str] = None,
                 uid: Optional[str] = None):
        """
        :param Sequence[str] addresses: The addresses to send emails to.
        :param bool disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param str message: The templated content of the email. Defaults to ``.
        :param Mapping[str, str] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param bool single_email: Whether to send a single email CC'ing all addresses, rather than a separate email to each address. Defaults to `false`.
        :param str subject: The templated subject line of the email. Defaults to ``.
        :param str uid: The UID of the contact point.
        """
        pulumi.set(__self__, "addresses", addresses)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if single_email is not None:
            pulumi.set(__self__, "single_email", single_email)
        if subject is not None:
            pulumi.set(__self__, "subject", subject)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter
    def addresses(self) -> Sequence[str]:
        """
        The addresses to send emails to.
        """
        return pulumi.get(self, "addresses")

    @property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[bool]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        The templated content of the email. Defaults to ``.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def settings(self) -> Optional[Mapping[str, str]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @property
    @pulumi.getter(name="singleEmail")
    def single_email(self) -> Optional[bool]:
        """
        Whether to send a single email CC'ing all addresses, rather than a separate email to each address. Defaults to `false`.
        """
        return pulumi.get(self, "single_email")

    @property
    @pulumi.getter
    def subject(self) -> Optional[str]:
        """
        The templated subject line of the email. Defaults to ``.
        """
        return pulumi.get(self, "subject")

    @property
    @pulumi.getter
    def uid(self) -> Optional[str]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")


@pulumi.output_type
class ContactPointGooglechat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disableResolveMessage":
            suggest = "disable_resolve_message"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContactPointGooglechat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContactPointGooglechat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContactPointGooglechat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: str,
                 disable_resolve_message: Optional[bool] = None,
                 message: Optional[str] = None,
                 settings: Optional[Mapping[str, str]] = None,
                 uid: Optional[str] = None):
        """
        :param str url: The Google Chat webhook URL.
        :param bool disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param str message: The templated content of the message.
        :param Mapping[str, str] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param str uid: The UID of the contact point.
        """
        pulumi.set(__self__, "url", url)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        The Google Chat webhook URL.
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[bool]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        The templated content of the message.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def settings(self) -> Optional[Mapping[str, str]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @property
    @pulumi.getter
    def uid(self) -> Optional[str]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")


@pulumi.output_type
class ContactPointKafka(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "restProxyUrl":
            suggest = "rest_proxy_url"
        elif key == "disableResolveMessage":
            suggest = "disable_resolve_message"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContactPointKafka. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContactPointKafka.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContactPointKafka.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 rest_proxy_url: str,
                 topic: str,
                 disable_resolve_message: Optional[bool] = None,
                 settings: Optional[Mapping[str, str]] = None,
                 uid: Optional[str] = None):
        """
        :param str rest_proxy_url: The URL of the Kafka REST proxy to send requests to.
        :param str topic: The name of the Kafka topic to publish to.
        :param bool disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param Mapping[str, str] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param str uid: The UID of the contact point.
        """
        pulumi.set(__self__, "rest_proxy_url", rest_proxy_url)
        pulumi.set(__self__, "topic", topic)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="restProxyUrl")
    def rest_proxy_url(self) -> str:
        """
        The URL of the Kafka REST proxy to send requests to.
        """
        return pulumi.get(self, "rest_proxy_url")

    @property
    @pulumi.getter
    def topic(self) -> str:
        """
        The name of the Kafka topic to publish to.
        """
        return pulumi.get(self, "topic")

    @property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[bool]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @property
    @pulumi.getter
    def settings(self) -> Optional[Mapping[str, str]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @property
    @pulumi.getter
    def uid(self) -> Optional[str]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")


@pulumi.output_type
class ContactPointOpsgeny(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"
        elif key == "autoClose":
            suggest = "auto_close"
        elif key == "disableResolveMessage":
            suggest = "disable_resolve_message"
        elif key == "overridePriority":
            suggest = "override_priority"
        elif key == "sendTagsAs":
            suggest = "send_tags_as"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContactPointOpsgeny. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContactPointOpsgeny.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContactPointOpsgeny.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: str,
                 auto_close: Optional[bool] = None,
                 description: Optional[str] = None,
                 disable_resolve_message: Optional[bool] = None,
                 message: Optional[str] = None,
                 override_priority: Optional[bool] = None,
                 send_tags_as: Optional[str] = None,
                 settings: Optional[Mapping[str, str]] = None,
                 uid: Optional[str] = None,
                 url: Optional[str] = None):
        """
        :param str api_key: The OpsGenie API key to use.
        :param bool auto_close: Whether to auto-close alerts in OpsGenie when they resolve in the Alertmanager.
        :param str description: A templated high-level description to use for the alert.
        :param bool disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param str message: The templated content of the message.
        :param bool override_priority: Whether to allow the alert priority to be configured via the value of the `og_priority` annotation on the alert.
        :param str send_tags_as: Whether to send annotations to OpsGenie as Tags, Details, or both. Supported values are `tags`, `details`, `both`, or empty to use the default behavior of Tags.
        :param Mapping[str, str] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param str uid: The UID of the contact point.
        :param str url: Allows customization of the OpsGenie API URL.
        """
        pulumi.set(__self__, "api_key", api_key)
        if auto_close is not None:
            pulumi.set(__self__, "auto_close", auto_close)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if override_priority is not None:
            pulumi.set(__self__, "override_priority", override_priority)
        if send_tags_as is not None:
            pulumi.set(__self__, "send_tags_as", send_tags_as)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> str:
        """
        The OpsGenie API key to use.
        """
        return pulumi.get(self, "api_key")

    @property
    @pulumi.getter(name="autoClose")
    def auto_close(self) -> Optional[bool]:
        """
        Whether to auto-close alerts in OpsGenie when they resolve in the Alertmanager.
        """
        return pulumi.get(self, "auto_close")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        A templated high-level description to use for the alert.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[bool]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        The templated content of the message.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter(name="overridePriority")
    def override_priority(self) -> Optional[bool]:
        """
        Whether to allow the alert priority to be configured via the value of the `og_priority` annotation on the alert.
        """
        return pulumi.get(self, "override_priority")

    @property
    @pulumi.getter(name="sendTagsAs")
    def send_tags_as(self) -> Optional[str]:
        """
        Whether to send annotations to OpsGenie as Tags, Details, or both. Supported values are `tags`, `details`, `both`, or empty to use the default behavior of Tags.
        """
        return pulumi.get(self, "send_tags_as")

    @property
    @pulumi.getter
    def settings(self) -> Optional[Mapping[str, str]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @property
    @pulumi.getter
    def uid(self) -> Optional[str]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        """
        Allows customization of the OpsGenie API URL.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class ContactPointPagerduty(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "integrationKey":
            suggest = "integration_key"
        elif key == "class":
            suggest = "class_"
        elif key == "disableResolveMessage":
            suggest = "disable_resolve_message"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContactPointPagerduty. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContactPointPagerduty.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContactPointPagerduty.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 integration_key: str,
                 class_: Optional[str] = None,
                 component: Optional[str] = None,
                 disable_resolve_message: Optional[bool] = None,
                 group: Optional[str] = None,
                 settings: Optional[Mapping[str, str]] = None,
                 severity: Optional[str] = None,
                 summary: Optional[str] = None,
                 uid: Optional[str] = None):
        """
        :param str integration_key: The PagerDuty API key.
        :param str class_: The class or type of event, for example `ping failure`.
        :param str component: The component being affected by the event.
        :param bool disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param str group: The group to which the provided component belongs to.
        :param Mapping[str, str] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param str severity: The PagerDuty event severity level. Default is `critical`.
        :param str summary: The templated summary message of the event.
        :param str uid: The UID of the contact point.
        """
        pulumi.set(__self__, "integration_key", integration_key)
        if class_ is not None:
            pulumi.set(__self__, "class_", class_)
        if component is not None:
            pulumi.set(__self__, "component", component)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if group is not None:
            pulumi.set(__self__, "group", group)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)
        if summary is not None:
            pulumi.set(__self__, "summary", summary)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="integrationKey")
    def integration_key(self) -> str:
        """
        The PagerDuty API key.
        """
        return pulumi.get(self, "integration_key")

    @property
    @pulumi.getter(name="class")
    def class_(self) -> Optional[str]:
        """
        The class or type of event, for example `ping failure`.
        """
        return pulumi.get(self, "class_")

    @property
    @pulumi.getter
    def component(self) -> Optional[str]:
        """
        The component being affected by the event.
        """
        return pulumi.get(self, "component")

    @property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[bool]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @property
    @pulumi.getter
    def group(self) -> Optional[str]:
        """
        The group to which the provided component belongs to.
        """
        return pulumi.get(self, "group")

    @property
    @pulumi.getter
    def settings(self) -> Optional[Mapping[str, str]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @property
    @pulumi.getter
    def severity(self) -> Optional[str]:
        """
        The PagerDuty event severity level. Default is `critical`.
        """
        return pulumi.get(self, "severity")

    @property
    @pulumi.getter
    def summary(self) -> Optional[str]:
        """
        The templated summary message of the event.
        """
        return pulumi.get(self, "summary")

    @property
    @pulumi.getter
    def uid(self) -> Optional[str]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")


@pulumi.output_type
class ContactPointPushover(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiToken":
            suggest = "api_token"
        elif key == "userKey":
            suggest = "user_key"
        elif key == "disableResolveMessage":
            suggest = "disable_resolve_message"
        elif key == "okPriority":
            suggest = "ok_priority"
        elif key == "okSound":
            suggest = "ok_sound"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContactPointPushover. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContactPointPushover.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContactPointPushover.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_token: str,
                 user_key: str,
                 device: Optional[str] = None,
                 disable_resolve_message: Optional[bool] = None,
                 expire: Optional[int] = None,
                 message: Optional[str] = None,
                 ok_priority: Optional[int] = None,
                 ok_sound: Optional[str] = None,
                 priority: Optional[int] = None,
                 retry: Optional[int] = None,
                 settings: Optional[Mapping[str, str]] = None,
                 sound: Optional[str] = None,
                 uid: Optional[str] = None):
        """
        :param str api_token: The Pushover API token.
        :param str user_key: The Pushover user key.
        :param str device: Comma-separated list of devices to which the event is associated.
        :param bool disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param int expire: How many seconds for which the notification will continue to be retried by Pushover.
        :param str message: The templated notification message content.
        :param int ok_priority: The priority level of the resolved event.
        :param str ok_sound: The sound associated with the resolved notification.
        :param int priority: The priority level of the event.
        :param int retry: How often, in seconds, the Pushover servers will send the same notification to the user.
        :param Mapping[str, str] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param str sound: The sound associated with the notification.
        :param str uid: The UID of the contact point.
        """
        pulumi.set(__self__, "api_token", api_token)
        pulumi.set(__self__, "user_key", user_key)
        if device is not None:
            pulumi.set(__self__, "device", device)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if expire is not None:
            pulumi.set(__self__, "expire", expire)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if ok_priority is not None:
            pulumi.set(__self__, "ok_priority", ok_priority)
        if ok_sound is not None:
            pulumi.set(__self__, "ok_sound", ok_sound)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if retry is not None:
            pulumi.set(__self__, "retry", retry)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if sound is not None:
            pulumi.set(__self__, "sound", sound)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="apiToken")
    def api_token(self) -> str:
        """
        The Pushover API token.
        """
        return pulumi.get(self, "api_token")

    @property
    @pulumi.getter(name="userKey")
    def user_key(self) -> str:
        """
        The Pushover user key.
        """
        return pulumi.get(self, "user_key")

    @property
    @pulumi.getter
    def device(self) -> Optional[str]:
        """
        Comma-separated list of devices to which the event is associated.
        """
        return pulumi.get(self, "device")

    @property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[bool]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @property
    @pulumi.getter
    def expire(self) -> Optional[int]:
        """
        How many seconds for which the notification will continue to be retried by Pushover.
        """
        return pulumi.get(self, "expire")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        The templated notification message content.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter(name="okPriority")
    def ok_priority(self) -> Optional[int]:
        """
        The priority level of the resolved event.
        """
        return pulumi.get(self, "ok_priority")

    @property
    @pulumi.getter(name="okSound")
    def ok_sound(self) -> Optional[str]:
        """
        The sound associated with the resolved notification.
        """
        return pulumi.get(self, "ok_sound")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        The priority level of the event.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def retry(self) -> Optional[int]:
        """
        How often, in seconds, the Pushover servers will send the same notification to the user.
        """
        return pulumi.get(self, "retry")

    @property
    @pulumi.getter
    def settings(self) -> Optional[Mapping[str, str]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @property
    @pulumi.getter
    def sound(self) -> Optional[str]:
        """
        The sound associated with the notification.
        """
        return pulumi.get(self, "sound")

    @property
    @pulumi.getter
    def uid(self) -> Optional[str]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")


@pulumi.output_type
class ContactPointSensugo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"
        elif key == "disableResolveMessage":
            suggest = "disable_resolve_message"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContactPointSensugo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContactPointSensugo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContactPointSensugo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: str,
                 url: str,
                 check: Optional[str] = None,
                 disable_resolve_message: Optional[bool] = None,
                 entity: Optional[str] = None,
                 handler: Optional[str] = None,
                 message: Optional[str] = None,
                 namespace: Optional[str] = None,
                 settings: Optional[Mapping[str, str]] = None,
                 uid: Optional[str] = None):
        """
        :param str api_key: The SensuGo API key.
        :param str url: The SensuGo URL to send requests to.
        :param str check: The SensuGo check to which the event should be routed.
        :param bool disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param str entity: The entity being monitored.
        :param str handler: A custom handler to execute in addition to the check.
        :param str message: Templated message content describing the alert.
        :param str namespace: The namespace in which the check resides.
        :param Mapping[str, str] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param str uid: The UID of the contact point.
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "url", url)
        if check is not None:
            pulumi.set(__self__, "check", check)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if entity is not None:
            pulumi.set(__self__, "entity", entity)
        if handler is not None:
            pulumi.set(__self__, "handler", handler)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> str:
        """
        The SensuGo API key.
        """
        return pulumi.get(self, "api_key")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        The SensuGo URL to send requests to.
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter
    def check(self) -> Optional[str]:
        """
        The SensuGo check to which the event should be routed.
        """
        return pulumi.get(self, "check")

    @property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[bool]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @property
    @pulumi.getter
    def entity(self) -> Optional[str]:
        """
        The entity being monitored.
        """
        return pulumi.get(self, "entity")

    @property
    @pulumi.getter
    def handler(self) -> Optional[str]:
        """
        A custom handler to execute in addition to the check.
        """
        return pulumi.get(self, "handler")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        Templated message content describing the alert.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        The namespace in which the check resides.
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def settings(self) -> Optional[Mapping[str, str]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @property
    @pulumi.getter
    def uid(self) -> Optional[str]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")


@pulumi.output_type
class ContactPointSlack(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disableResolveMessage":
            suggest = "disable_resolve_message"
        elif key == "endpointUrl":
            suggest = "endpoint_url"
        elif key == "iconEmoji":
            suggest = "icon_emoji"
        elif key == "iconUrl":
            suggest = "icon_url"
        elif key == "mentionChannel":
            suggest = "mention_channel"
        elif key == "mentionGroups":
            suggest = "mention_groups"
        elif key == "mentionUsers":
            suggest = "mention_users"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContactPointSlack. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContactPointSlack.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContactPointSlack.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disable_resolve_message: Optional[bool] = None,
                 endpoint_url: Optional[str] = None,
                 icon_emoji: Optional[str] = None,
                 icon_url: Optional[str] = None,
                 mention_channel: Optional[str] = None,
                 mention_groups: Optional[str] = None,
                 mention_users: Optional[str] = None,
                 recipient: Optional[str] = None,
                 settings: Optional[Mapping[str, str]] = None,
                 text: Optional[str] = None,
                 title: Optional[str] = None,
                 token: Optional[str] = None,
                 uid: Optional[str] = None,
                 url: Optional[str] = None,
                 username: Optional[str] = None):
        """
        :param bool disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param str endpoint_url: Use this to override the Slack API endpoint URL to send requests to.
        :param str icon_emoji: The name of a Slack workspace emoji to use as the bot icon.
        :param str icon_url: A URL of an image to use as the bot icon.
        :param str mention_channel: Describes how to ping the slack channel that messages are being sent to. Options are `here` for an @here ping, `channel` for @channel, or empty for no ping.
        :param str mention_groups: Comma-separated list of groups to mention in the message.
        :param str mention_users: Comma-separated list of users to mention in the message.
        :param str recipient: Channel, private group, or IM channel (can be an encoded ID or a name) to send messages to.
        :param Mapping[str, str] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param str text: Templated content of the message.
        :param str title: Templated title of the message.
        :param str token: A Slack API token,for sending messages directly without the webhook method.
        :param str uid: The UID of the contact point.
        :param str url: A Slack webhook URL,for sending messages via the webhook method.
        :param str username: Username for the bot to use.
        """
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if endpoint_url is not None:
            pulumi.set(__self__, "endpoint_url", endpoint_url)
        if icon_emoji is not None:
            pulumi.set(__self__, "icon_emoji", icon_emoji)
        if icon_url is not None:
            pulumi.set(__self__, "icon_url", icon_url)
        if mention_channel is not None:
            pulumi.set(__self__, "mention_channel", mention_channel)
        if mention_groups is not None:
            pulumi.set(__self__, "mention_groups", mention_groups)
        if mention_users is not None:
            pulumi.set(__self__, "mention_users", mention_users)
        if recipient is not None:
            pulumi.set(__self__, "recipient", recipient)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if text is not None:
            pulumi.set(__self__, "text", text)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if token is not None:
            pulumi.set(__self__, "token", token)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[bool]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @property
    @pulumi.getter(name="endpointUrl")
    def endpoint_url(self) -> Optional[str]:
        """
        Use this to override the Slack API endpoint URL to send requests to.
        """
        return pulumi.get(self, "endpoint_url")

    @property
    @pulumi.getter(name="iconEmoji")
    def icon_emoji(self) -> Optional[str]:
        """
        The name of a Slack workspace emoji to use as the bot icon.
        """
        return pulumi.get(self, "icon_emoji")

    @property
    @pulumi.getter(name="iconUrl")
    def icon_url(self) -> Optional[str]:
        """
        A URL of an image to use as the bot icon.
        """
        return pulumi.get(self, "icon_url")

    @property
    @pulumi.getter(name="mentionChannel")
    def mention_channel(self) -> Optional[str]:
        """
        Describes how to ping the slack channel that messages are being sent to. Options are `here` for an @here ping, `channel` for @channel, or empty for no ping.
        """
        return pulumi.get(self, "mention_channel")

    @property
    @pulumi.getter(name="mentionGroups")
    def mention_groups(self) -> Optional[str]:
        """
        Comma-separated list of groups to mention in the message.
        """
        return pulumi.get(self, "mention_groups")

    @property
    @pulumi.getter(name="mentionUsers")
    def mention_users(self) -> Optional[str]:
        """
        Comma-separated list of users to mention in the message.
        """
        return pulumi.get(self, "mention_users")

    @property
    @pulumi.getter
    def recipient(self) -> Optional[str]:
        """
        Channel, private group, or IM channel (can be an encoded ID or a name) to send messages to.
        """
        return pulumi.get(self, "recipient")

    @property
    @pulumi.getter
    def settings(self) -> Optional[Mapping[str, str]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @property
    @pulumi.getter
    def text(self) -> Optional[str]:
        """
        Templated content of the message.
        """
        return pulumi.get(self, "text")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        Templated title of the message.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def token(self) -> Optional[str]:
        """
        A Slack API token,for sending messages directly without the webhook method.
        """
        return pulumi.get(self, "token")

    @property
    @pulumi.getter
    def uid(self) -> Optional[str]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        """
        A Slack webhook URL,for sending messages via the webhook method.
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        Username for the bot to use.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ContactPointTeam(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disableResolveMessage":
            suggest = "disable_resolve_message"
        elif key == "sectionTitle":
            suggest = "section_title"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContactPointTeam. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContactPointTeam.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContactPointTeam.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: str,
                 disable_resolve_message: Optional[bool] = None,
                 message: Optional[str] = None,
                 section_title: Optional[str] = None,
                 settings: Optional[Mapping[str, str]] = None,
                 title: Optional[str] = None,
                 uid: Optional[str] = None):
        """
        :param str url: A Teams webhook URL.
        :param bool disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param str message: The templated message content to send.
        :param str section_title: The templated subtitle for each message section.
        :param Mapping[str, str] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param str title: The templated title of the message.
        :param str uid: The UID of the contact point.
        """
        pulumi.set(__self__, "url", url)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if section_title is not None:
            pulumi.set(__self__, "section_title", section_title)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        A Teams webhook URL.
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[bool]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        The templated message content to send.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter(name="sectionTitle")
    def section_title(self) -> Optional[str]:
        """
        The templated subtitle for each message section.
        """
        return pulumi.get(self, "section_title")

    @property
    @pulumi.getter
    def settings(self) -> Optional[Mapping[str, str]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The templated title of the message.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def uid(self) -> Optional[str]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")


@pulumi.output_type
class ContactPointTelegram(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "chatId":
            suggest = "chat_id"
        elif key == "disableResolveMessage":
            suggest = "disable_resolve_message"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContactPointTelegram. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContactPointTelegram.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContactPointTelegram.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 chat_id: str,
                 token: str,
                 disable_resolve_message: Optional[bool] = None,
                 message: Optional[str] = None,
                 settings: Optional[Mapping[str, str]] = None,
                 uid: Optional[str] = None):
        """
        :param str chat_id: The chat ID to send messages to.
        :param str token: The Telegram bot token.
        :param bool disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param str message: The templated content of the message.
        :param Mapping[str, str] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param str uid: The UID of the contact point.
        """
        pulumi.set(__self__, "chat_id", chat_id)
        pulumi.set(__self__, "token", token)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="chatId")
    def chat_id(self) -> str:
        """
        The chat ID to send messages to.
        """
        return pulumi.get(self, "chat_id")

    @property
    @pulumi.getter
    def token(self) -> str:
        """
        The Telegram bot token.
        """
        return pulumi.get(self, "token")

    @property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[bool]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        The templated content of the message.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def settings(self) -> Optional[Mapping[str, str]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @property
    @pulumi.getter
    def uid(self) -> Optional[str]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")


@pulumi.output_type
class ContactPointThreema(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiSecret":
            suggest = "api_secret"
        elif key == "gatewayId":
            suggest = "gateway_id"
        elif key == "recipientId":
            suggest = "recipient_id"
        elif key == "disableResolveMessage":
            suggest = "disable_resolve_message"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContactPointThreema. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContactPointThreema.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContactPointThreema.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_secret: str,
                 gateway_id: str,
                 recipient_id: str,
                 disable_resolve_message: Optional[bool] = None,
                 settings: Optional[Mapping[str, str]] = None,
                 uid: Optional[str] = None):
        """
        :param str api_secret: The Threema API key.
        :param str gateway_id: The Threema gateway ID.
        :param str recipient_id: The ID of the recipient of the message.
        :param bool disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param Mapping[str, str] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param str uid: The UID of the contact point.
        """
        pulumi.set(__self__, "api_secret", api_secret)
        pulumi.set(__self__, "gateway_id", gateway_id)
        pulumi.set(__self__, "recipient_id", recipient_id)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="apiSecret")
    def api_secret(self) -> str:
        """
        The Threema API key.
        """
        return pulumi.get(self, "api_secret")

    @property
    @pulumi.getter(name="gatewayId")
    def gateway_id(self) -> str:
        """
        The Threema gateway ID.
        """
        return pulumi.get(self, "gateway_id")

    @property
    @pulumi.getter(name="recipientId")
    def recipient_id(self) -> str:
        """
        The ID of the recipient of the message.
        """
        return pulumi.get(self, "recipient_id")

    @property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[bool]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @property
    @pulumi.getter
    def settings(self) -> Optional[Mapping[str, str]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @property
    @pulumi.getter
    def uid(self) -> Optional[str]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")


@pulumi.output_type
class ContactPointVictorop(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disableResolveMessage":
            suggest = "disable_resolve_message"
        elif key == "messageType":
            suggest = "message_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContactPointVictorop. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContactPointVictorop.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContactPointVictorop.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: str,
                 disable_resolve_message: Optional[bool] = None,
                 message_type: Optional[str] = None,
                 settings: Optional[Mapping[str, str]] = None,
                 uid: Optional[str] = None):
        """
        :param str url: The VictorOps webhook URL.
        :param bool disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param str message_type: The VictorOps alert state - typically either `CRITICAL` or `RECOVERY`.
        :param Mapping[str, str] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param str uid: The UID of the contact point.
        """
        pulumi.set(__self__, "url", url)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if message_type is not None:
            pulumi.set(__self__, "message_type", message_type)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        The VictorOps webhook URL.
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[bool]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @property
    @pulumi.getter(name="messageType")
    def message_type(self) -> Optional[str]:
        """
        The VictorOps alert state - typically either `CRITICAL` or `RECOVERY`.
        """
        return pulumi.get(self, "message_type")

    @property
    @pulumi.getter
    def settings(self) -> Optional[Mapping[str, str]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @property
    @pulumi.getter
    def uid(self) -> Optional[str]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")


@pulumi.output_type
class ContactPointWebhook(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authorizationCredentials":
            suggest = "authorization_credentials"
        elif key == "authorizationScheme":
            suggest = "authorization_scheme"
        elif key == "basicAuthPassword":
            suggest = "basic_auth_password"
        elif key == "basicAuthUser":
            suggest = "basic_auth_user"
        elif key == "disableResolveMessage":
            suggest = "disable_resolve_message"
        elif key == "httpMethod":
            suggest = "http_method"
        elif key == "maxAlerts":
            suggest = "max_alerts"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContactPointWebhook. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContactPointWebhook.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContactPointWebhook.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: str,
                 authorization_credentials: Optional[str] = None,
                 authorization_scheme: Optional[str] = None,
                 basic_auth_password: Optional[str] = None,
                 basic_auth_user: Optional[str] = None,
                 disable_resolve_message: Optional[bool] = None,
                 http_method: Optional[str] = None,
                 max_alerts: Optional[int] = None,
                 settings: Optional[Mapping[str, str]] = None,
                 uid: Optional[str] = None):
        """
        :param str url: The URL to send webhook requests to.
        :param str authorization_credentials: Allows a custom authorization scheme - attaches an auth header with this value. Do not use in conjunction with basic auth parameters.
        :param str authorization_scheme: Allows a custom authorization scheme - attaches an auth header with this name. Do not use in conjunction with basic auth parameters.
        :param str basic_auth_password: The username to use in basic auth headers attached to the request. If omitted, basic auth will not be used.
        :param str basic_auth_user: The username to use in basic auth headers attached to the request. If omitted, basic auth will not be used.
        :param bool disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param str http_method: The HTTP method to use in the request. Defaults to `POST`.
        :param int max_alerts: The maximum number of alerts to send in a single request. This can be helpful in limiting the size of the request body. The default is 0, which indicates no limit.
        :param Mapping[str, str] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param str uid: The UID of the contact point.
        """
        pulumi.set(__self__, "url", url)
        if authorization_credentials is not None:
            pulumi.set(__self__, "authorization_credentials", authorization_credentials)
        if authorization_scheme is not None:
            pulumi.set(__self__, "authorization_scheme", authorization_scheme)
        if basic_auth_password is not None:
            pulumi.set(__self__, "basic_auth_password", basic_auth_password)
        if basic_auth_user is not None:
            pulumi.set(__self__, "basic_auth_user", basic_auth_user)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if http_method is not None:
            pulumi.set(__self__, "http_method", http_method)
        if max_alerts is not None:
            pulumi.set(__self__, "max_alerts", max_alerts)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        The URL to send webhook requests to.
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter(name="authorizationCredentials")
    def authorization_credentials(self) -> Optional[str]:
        """
        Allows a custom authorization scheme - attaches an auth header with this value. Do not use in conjunction with basic auth parameters.
        """
        return pulumi.get(self, "authorization_credentials")

    @property
    @pulumi.getter(name="authorizationScheme")
    def authorization_scheme(self) -> Optional[str]:
        """
        Allows a custom authorization scheme - attaches an auth header with this name. Do not use in conjunction with basic auth parameters.
        """
        return pulumi.get(self, "authorization_scheme")

    @property
    @pulumi.getter(name="basicAuthPassword")
    def basic_auth_password(self) -> Optional[str]:
        """
        The username to use in basic auth headers attached to the request. If omitted, basic auth will not be used.
        """
        return pulumi.get(self, "basic_auth_password")

    @property
    @pulumi.getter(name="basicAuthUser")
    def basic_auth_user(self) -> Optional[str]:
        """
        The username to use in basic auth headers attached to the request. If omitted, basic auth will not be used.
        """
        return pulumi.get(self, "basic_auth_user")

    @property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[bool]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @property
    @pulumi.getter(name="httpMethod")
    def http_method(self) -> Optional[str]:
        """
        The HTTP method to use in the request. Defaults to `POST`.
        """
        return pulumi.get(self, "http_method")

    @property
    @pulumi.getter(name="maxAlerts")
    def max_alerts(self) -> Optional[int]:
        """
        The maximum number of alerts to send in a single request. This can be helpful in limiting the size of the request body. The default is 0, which indicates no limit.
        """
        return pulumi.get(self, "max_alerts")

    @property
    @pulumi.getter
    def settings(self) -> Optional[Mapping[str, str]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @property
    @pulumi.getter
    def uid(self) -> Optional[str]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")


@pulumi.output_type
class ContactPointWecom(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disableResolveMessage":
            suggest = "disable_resolve_message"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContactPointWecom. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContactPointWecom.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContactPointWecom.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: str,
                 disable_resolve_message: Optional[bool] = None,
                 message: Optional[str] = None,
                 settings: Optional[Mapping[str, str]] = None,
                 title: Optional[str] = None,
                 uid: Optional[str] = None):
        """
        :param str url: The WeCom webhook URL.
        :param bool disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param str message: The templated content of the message to send.
        :param Mapping[str, str] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param str title: The templated title of the message to send.
        :param str uid: The UID of the contact point.
        """
        pulumi.set(__self__, "url", url)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        The WeCom webhook URL.
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[bool]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        The templated content of the message to send.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def settings(self) -> Optional[Mapping[str, str]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The templated title of the message to send.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def uid(self) -> Optional[str]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")


@pulumi.output_type
class DashboardPermissionPermission(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "teamId":
            suggest = "team_id"
        elif key == "userId":
            suggest = "user_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPermissionPermission. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPermissionPermission.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPermissionPermission.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 permission: str,
                 role: Optional[str] = None,
                 team_id: Optional[int] = None,
                 user_id: Optional[int] = None):
        """
        :param str permission: Permission to associate with item. Must be one of `View`, `Edit`, or `Admin`.
        :param str role: Manage permissions for `Viewer` or `Editor` roles.
        :param int team_id: ID of the team to manage permissions for. Defaults to `0`.
        :param int user_id: ID of the user to manage permissions for. Defaults to `0`.
        """
        pulumi.set(__self__, "permission", permission)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if team_id is not None:
            pulumi.set(__self__, "team_id", team_id)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)

    @property
    @pulumi.getter
    def permission(self) -> str:
        """
        Permission to associate with item. Must be one of `View`, `Edit`, or `Admin`.
        """
        return pulumi.get(self, "permission")

    @property
    @pulumi.getter
    def role(self) -> Optional[str]:
        """
        Manage permissions for `Viewer` or `Editor` roles.
        """
        return pulumi.get(self, "role")

    @property
    @pulumi.getter(name="teamId")
    def team_id(self) -> Optional[int]:
        """
        ID of the team to manage permissions for. Defaults to `0`.
        """
        return pulumi.get(self, "team_id")

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[int]:
        """
        ID of the user to manage permissions for. Defaults to `0`.
        """
        return pulumi.get(self, "user_id")


@pulumi.output_type
class DataSourceJsonData(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertmanagerUid":
            suggest = "alertmanager_uid"
        elif key == "assumeRoleArn":
            suggest = "assume_role_arn"
        elif key == "authType":
            suggest = "auth_type"
        elif key == "authenticationType":
            suggest = "authentication_type"
        elif key == "clientEmail":
            suggest = "client_email"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "cloudName":
            suggest = "cloud_name"
        elif key == "connMaxLifetime":
            suggest = "conn_max_lifetime"
        elif key == "customMetricsNamespaces":
            suggest = "custom_metrics_namespaces"
        elif key == "defaultBucket":
            suggest = "default_bucket"
        elif key == "defaultProject":
            suggest = "default_project"
        elif key == "defaultRegion":
            suggest = "default_region"
        elif key == "derivedFields":
            suggest = "derived_fields"
        elif key == "esVersion":
            suggest = "es_version"
        elif key == "externalId":
            suggest = "external_id"
        elif key == "githubUrl":
            suggest = "github_url"
        elif key == "graphiteVersion":
            suggest = "graphite_version"
        elif key == "httpMethod":
            suggest = "http_method"
        elif key == "logLevelField":
            suggest = "log_level_field"
        elif key == "logMessageField":
            suggest = "log_message_field"
        elif key == "manageAlerts":
            suggest = "manage_alerts"
        elif key == "maxConcurrentShardRequests":
            suggest = "max_concurrent_shard_requests"
        elif key == "maxIdleConns":
            suggest = "max_idle_conns"
        elif key == "maxLines":
            suggest = "max_lines"
        elif key == "maxOpenConns":
            suggest = "max_open_conns"
        elif key == "orgSlug":
            suggest = "org_slug"
        elif key == "outputLocation":
            suggest = "output_location"
        elif key == "postgresVersion":
            suggest = "postgres_version"
        elif key == "queryTimeout":
            suggest = "query_timeout"
        elif key == "sigv4AssumeRoleArn":
            suggest = "sigv4_assume_role_arn"
        elif key == "sigv4Auth":
            suggest = "sigv4_auth"
        elif key == "sigv4AuthType":
            suggest = "sigv4_auth_type"
        elif key == "sigv4ExternalId":
            suggest = "sigv4_external_id"
        elif key == "sigv4Profile":
            suggest = "sigv4_profile"
        elif key == "sigv4Region":
            suggest = "sigv4_region"
        elif key == "sslMode":
            suggest = "ssl_mode"
        elif key == "subscriptionId":
            suggest = "subscription_id"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "timeField":
            suggest = "time_field"
        elif key == "timeInterval":
            suggest = "time_interval"
        elif key == "tlsAuth":
            suggest = "tls_auth"
        elif key == "tlsAuthWithCaCert":
            suggest = "tls_auth_with_ca_cert"
        elif key == "tlsConfigurationMethod":
            suggest = "tls_configuration_method"
        elif key == "tlsSkipVerify":
            suggest = "tls_skip_verify"
        elif key == "tokenUri":
            suggest = "token_uri"
        elif key == "tracingDatasourceUid":
            suggest = "tracing_datasource_uid"
        elif key == "tsdbResolution":
            suggest = "tsdb_resolution"
        elif key == "tsdbVersion":
            suggest = "tsdb_version"
        elif key == "xpackEnabled":
            suggest = "xpack_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSourceJsonData. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSourceJsonData.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSourceJsonData.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alertmanager_uid: Optional[str] = None,
                 assume_role_arn: Optional[str] = None,
                 auth_type: Optional[str] = None,
                 authentication_type: Optional[str] = None,
                 catalog: Optional[str] = None,
                 client_email: Optional[str] = None,
                 client_id: Optional[str] = None,
                 cloud_name: Optional[str] = None,
                 conn_max_lifetime: Optional[int] = None,
                 custom_metrics_namespaces: Optional[str] = None,
                 database: Optional[str] = None,
                 default_bucket: Optional[str] = None,
                 default_project: Optional[str] = None,
                 default_region: Optional[str] = None,
                 derived_fields: Optional[Sequence['outputs.DataSourceJsonDataDerivedField']] = None,
                 encrypt: Optional[str] = None,
                 es_version: Optional[str] = None,
                 external_id: Optional[str] = None,
                 github_url: Optional[str] = None,
                 graphite_version: Optional[str] = None,
                 http_method: Optional[str] = None,
                 implementation: Optional[str] = None,
                 interval: Optional[str] = None,
                 log_level_field: Optional[str] = None,
                 log_message_field: Optional[str] = None,
                 manage_alerts: Optional[bool] = None,
                 max_concurrent_shard_requests: Optional[int] = None,
                 max_idle_conns: Optional[int] = None,
                 max_lines: Optional[int] = None,
                 max_open_conns: Optional[int] = None,
                 org_slug: Optional[str] = None,
                 organization: Optional[str] = None,
                 output_location: Optional[str] = None,
                 postgres_version: Optional[int] = None,
                 profile: Optional[str] = None,
                 query_timeout: Optional[str] = None,
                 sigv4_assume_role_arn: Optional[str] = None,
                 sigv4_auth: Optional[bool] = None,
                 sigv4_auth_type: Optional[str] = None,
                 sigv4_external_id: Optional[str] = None,
                 sigv4_profile: Optional[str] = None,
                 sigv4_region: Optional[str] = None,
                 ssl_mode: Optional[str] = None,
                 subscription_id: Optional[str] = None,
                 tenant_id: Optional[str] = None,
                 time_field: Optional[str] = None,
                 time_interval: Optional[str] = None,
                 timescaledb: Optional[bool] = None,
                 tls_auth: Optional[bool] = None,
                 tls_auth_with_ca_cert: Optional[bool] = None,
                 tls_configuration_method: Optional[str] = None,
                 tls_skip_verify: Optional[bool] = None,
                 token_uri: Optional[str] = None,
                 tracing_datasource_uid: Optional[str] = None,
                 tsdb_resolution: Optional[int] = None,
                 tsdb_version: Optional[int] = None,
                 version: Optional[str] = None,
                 workgroup: Optional[str] = None,
                 xpack_enabled: Optional[bool] = None):
        """
        :param str alertmanager_uid: (Prometheus) The name of the Alertmanager datasource to manage alerts via UI
        :param str assume_role_arn: (CloudWatch, Athena) The ARN of the role to be assumed by Grafana when using the CloudWatch or Athena data source.
        :param str auth_type: (CloudWatch, Athena) The authentication type used to access the data source.
        :param str authentication_type: (Stackdriver) The authentication type: `jwt` or `gce`.
        :param str catalog: (Athena) Athena catalog.
        :param str client_email: (Stackdriver) Service account email address.
        :param str client_id: (Azure Monitor) The service account client id.
        :param str cloud_name: (Azure Monitor) The cloud name.
        :param int conn_max_lifetime: (MySQL, PostgreSQL, and MSSQL) Maximum amount of time in seconds a connection may be reused (Grafana v5.4+).
        :param str custom_metrics_namespaces: (CloudWatch) A comma-separated list of custom namespaces to be queried by the CloudWatch data source.
        :param str database: (Athena) Name of the database within the catalog.
        :param str default_bucket: (InfluxDB) The default bucket for the data source.
        :param str default_project: (Stackdriver) The default project for the data source.
        :param str default_region: (CloudWatch, Athena) The default region for the data source.
        :param Sequence['DataSourceJsonDataDerivedFieldArgs'] derived_fields: (Loki) See https://grafana.com/docs/grafana/latest/datasources/loki/#derived-fields
        :param str encrypt: (MSSQL) Connection SSL encryption handling: 'disable', 'false' or 'true'.
        :param str es_version: (Elasticsearch) Elasticsearch semantic version (Grafana v8.0+).
        :param str external_id: (CloudWatch, Athena) If you are assuming a role in another account, that has been created with an external ID, specify the external ID here.
        :param str github_url: (Github) Github URL
        :param str graphite_version: (Graphite) Graphite version.
        :param str http_method: (Prometheus) HTTP method to use for making requests.
        :param str implementation: (Alertmanager) Implementation of Alertmanager. Either 'cortex' or 'prometheus'
        :param str interval: (Elasticsearch) Index date time format. nil(No Pattern), 'Hourly', 'Daily', 'Weekly', 'Monthly' or 'Yearly'.
        :param str log_level_field: (Elasticsearch) Which field should be used to indicate the priority of the log message.
        :param str log_message_field: (Elasticsearch) Which field should be used as the log message.
        :param bool manage_alerts: (Prometheus) Manage alerts.
        :param int max_concurrent_shard_requests: (Elasticsearch) Maximum number of concurrent shard requests.
        :param int max_idle_conns: (MySQL, PostgreSQL and MSSQL) Maximum number of connections in the idle connection pool (Grafana v5.4+).
        :param int max_lines: (Loki) Upper limit for the number of log lines returned by Loki
        :param int max_open_conns: (MySQL, PostgreSQL and MSSQL) Maximum number of open connections to the database (Grafana v5.4+).
        :param str org_slug: (Sentry) Organization slug.
        :param str organization: (InfluxDB) An organization is a workspace for a group of users. All dashboards, tasks, buckets, members, etc., belong to an organization.
        :param str output_location: (Athena) AWS S3 bucket to store execution outputs. If not specified, the default query result location from the Workgroup configuration will be used.
        :param int postgres_version: (PostgreSQL) Postgres version as a number (903/904/905/906/1000) meaning v9.3, v9.4, etc.
        :param str profile: (CloudWatch, Athena) The credentials profile name to use when authentication type is set as 'Credentials file'.
        :param str query_timeout: (Prometheus) Timeout for queries made to the Prometheus data source in seconds.
        :param str sigv4_assume_role_arn: (Elasticsearch and Prometheus) Specifies the ARN of an IAM role to assume.
        :param bool sigv4_auth: (Elasticsearch and Prometheus) Enable usage of SigV4.
        :param str sigv4_auth_type: (Elasticsearch and Prometheus) The Sigv4 authentication provider to use: 'default', 'credentials' or 'keys' (AMG: 'workspace-iam-role').
        :param str sigv4_external_id: (Elasticsearch and Prometheus) When assuming a role in another account use this external ID.
        :param str sigv4_profile: (Elasticsearch and Prometheus) Credentials profile name, leave blank for default.
        :param str sigv4_region: (Elasticsearch and Prometheus) AWS region to use for Sigv4.
        :param str ssl_mode: (PostgreSQL) SSLmode. 'disable', 'require', 'verify-ca' or 'verify-full'.
        :param str subscription_id: (Azure Monitor) The subscription id
        :param str tenant_id: (Azure Monitor) Service account tenant ID.
        :param str time_field: (Elasticsearch) Which field that should be used as timestamp.
        :param str time_interval: (Prometheus, Elasticsearch, InfluxDB, MySQL, PostgreSQL, and MSSQL) Lowest interval/step value that should be used for this data source. Sometimes called "Scrape Interval" in the Grafana UI.
        :param bool timescaledb: (PostgreSQL) Enable usage of TimescaleDB extension.
        :param bool tls_auth: (All) Enable TLS authentication using client cert configured in secure json data.
        :param bool tls_auth_with_ca_cert: (All) Enable TLS authentication using CA cert.
        :param str tls_configuration_method: (All) SSL Certificate configuration, either by file-path or file-content.
        :param bool tls_skip_verify: (All) Controls whether a client verifies the servers certificate chain and host name.
        :param str token_uri: (Stackdriver) The token URI used, provided in the service account key.
        :param str tracing_datasource_uid: (Cloudwatch) The X-Ray datasource uid to associate to this Cloudwatch datasource.
        :param int tsdb_resolution: (OpenTSDB) Resolution.
        :param int tsdb_version: (OpenTSDB) Version.
        :param str version: (InfluxDB) InfluxQL or Flux.
        :param str workgroup: (Athena) Workgroup to use.
        :param bool xpack_enabled: (Elasticsearch) Enable X-Pack support.
        """
        if alertmanager_uid is not None:
            pulumi.set(__self__, "alertmanager_uid", alertmanager_uid)
        if assume_role_arn is not None:
            pulumi.set(__self__, "assume_role_arn", assume_role_arn)
        if auth_type is not None:
            pulumi.set(__self__, "auth_type", auth_type)
        if authentication_type is not None:
            pulumi.set(__self__, "authentication_type", authentication_type)
        if catalog is not None:
            pulumi.set(__self__, "catalog", catalog)
        if client_email is not None:
            pulumi.set(__self__, "client_email", client_email)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if cloud_name is not None:
            pulumi.set(__self__, "cloud_name", cloud_name)
        if conn_max_lifetime is not None:
            pulumi.set(__self__, "conn_max_lifetime", conn_max_lifetime)
        if custom_metrics_namespaces is not None:
            pulumi.set(__self__, "custom_metrics_namespaces", custom_metrics_namespaces)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if default_bucket is not None:
            pulumi.set(__self__, "default_bucket", default_bucket)
        if default_project is not None:
            pulumi.set(__self__, "default_project", default_project)
        if default_region is not None:
            pulumi.set(__self__, "default_region", default_region)
        if derived_fields is not None:
            pulumi.set(__self__, "derived_fields", derived_fields)
        if encrypt is not None:
            pulumi.set(__self__, "encrypt", encrypt)
        if es_version is not None:
            pulumi.set(__self__, "es_version", es_version)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)
        if github_url is not None:
            pulumi.set(__self__, "github_url", github_url)
        if graphite_version is not None:
            pulumi.set(__self__, "graphite_version", graphite_version)
        if http_method is not None:
            pulumi.set(__self__, "http_method", http_method)
        if implementation is not None:
            pulumi.set(__self__, "implementation", implementation)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if log_level_field is not None:
            pulumi.set(__self__, "log_level_field", log_level_field)
        if log_message_field is not None:
            pulumi.set(__self__, "log_message_field", log_message_field)
        if manage_alerts is not None:
            pulumi.set(__self__, "manage_alerts", manage_alerts)
        if max_concurrent_shard_requests is not None:
            pulumi.set(__self__, "max_concurrent_shard_requests", max_concurrent_shard_requests)
        if max_idle_conns is not None:
            pulumi.set(__self__, "max_idle_conns", max_idle_conns)
        if max_lines is not None:
            pulumi.set(__self__, "max_lines", max_lines)
        if max_open_conns is not None:
            pulumi.set(__self__, "max_open_conns", max_open_conns)
        if org_slug is not None:
            pulumi.set(__self__, "org_slug", org_slug)
        if organization is not None:
            pulumi.set(__self__, "organization", organization)
        if output_location is not None:
            pulumi.set(__self__, "output_location", output_location)
        if postgres_version is not None:
            pulumi.set(__self__, "postgres_version", postgres_version)
        if profile is not None:
            pulumi.set(__self__, "profile", profile)
        if query_timeout is not None:
            pulumi.set(__self__, "query_timeout", query_timeout)
        if sigv4_assume_role_arn is not None:
            pulumi.set(__self__, "sigv4_assume_role_arn", sigv4_assume_role_arn)
        if sigv4_auth is not None:
            pulumi.set(__self__, "sigv4_auth", sigv4_auth)
        if sigv4_auth_type is not None:
            pulumi.set(__self__, "sigv4_auth_type", sigv4_auth_type)
        if sigv4_external_id is not None:
            pulumi.set(__self__, "sigv4_external_id", sigv4_external_id)
        if sigv4_profile is not None:
            pulumi.set(__self__, "sigv4_profile", sigv4_profile)
        if sigv4_region is not None:
            pulumi.set(__self__, "sigv4_region", sigv4_region)
        if ssl_mode is not None:
            pulumi.set(__self__, "ssl_mode", ssl_mode)
        if subscription_id is not None:
            pulumi.set(__self__, "subscription_id", subscription_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)
        if time_field is not None:
            pulumi.set(__self__, "time_field", time_field)
        if time_interval is not None:
            pulumi.set(__self__, "time_interval", time_interval)
        if timescaledb is not None:
            pulumi.set(__self__, "timescaledb", timescaledb)
        if tls_auth is not None:
            pulumi.set(__self__, "tls_auth", tls_auth)
        if tls_auth_with_ca_cert is not None:
            pulumi.set(__self__, "tls_auth_with_ca_cert", tls_auth_with_ca_cert)
        if tls_configuration_method is not None:
            pulumi.set(__self__, "tls_configuration_method", tls_configuration_method)
        if tls_skip_verify is not None:
            pulumi.set(__self__, "tls_skip_verify", tls_skip_verify)
        if token_uri is not None:
            pulumi.set(__self__, "token_uri", token_uri)
        if tracing_datasource_uid is not None:
            pulumi.set(__self__, "tracing_datasource_uid", tracing_datasource_uid)
        if tsdb_resolution is not None:
            pulumi.set(__self__, "tsdb_resolution", tsdb_resolution)
        if tsdb_version is not None:
            pulumi.set(__self__, "tsdb_version", tsdb_version)
        if version is not None:
            pulumi.set(__self__, "version", version)
        if workgroup is not None:
            pulumi.set(__self__, "workgroup", workgroup)
        if xpack_enabled is not None:
            pulumi.set(__self__, "xpack_enabled", xpack_enabled)

    @property
    @pulumi.getter(name="alertmanagerUid")
    def alertmanager_uid(self) -> Optional[str]:
        """
        (Prometheus) The name of the Alertmanager datasource to manage alerts via UI
        """
        return pulumi.get(self, "alertmanager_uid")

    @property
    @pulumi.getter(name="assumeRoleArn")
    def assume_role_arn(self) -> Optional[str]:
        """
        (CloudWatch, Athena) The ARN of the role to be assumed by Grafana when using the CloudWatch or Athena data source.
        """
        return pulumi.get(self, "assume_role_arn")

    @property
    @pulumi.getter(name="authType")
    def auth_type(self) -> Optional[str]:
        """
        (CloudWatch, Athena) The authentication type used to access the data source.
        """
        return pulumi.get(self, "auth_type")

    @property
    @pulumi.getter(name="authenticationType")
    def authentication_type(self) -> Optional[str]:
        """
        (Stackdriver) The authentication type: `jwt` or `gce`.
        """
        return pulumi.get(self, "authentication_type")

    @property
    @pulumi.getter
    def catalog(self) -> Optional[str]:
        """
        (Athena) Athena catalog.
        """
        return pulumi.get(self, "catalog")

    @property
    @pulumi.getter(name="clientEmail")
    def client_email(self) -> Optional[str]:
        """
        (Stackdriver) Service account email address.
        """
        return pulumi.get(self, "client_email")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        """
        (Azure Monitor) The service account client id.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="cloudName")
    def cloud_name(self) -> Optional[str]:
        """
        (Azure Monitor) The cloud name.
        """
        return pulumi.get(self, "cloud_name")

    @property
    @pulumi.getter(name="connMaxLifetime")
    def conn_max_lifetime(self) -> Optional[int]:
        """
        (MySQL, PostgreSQL, and MSSQL) Maximum amount of time in seconds a connection may be reused (Grafana v5.4+).
        """
        return pulumi.get(self, "conn_max_lifetime")

    @property
    @pulumi.getter(name="customMetricsNamespaces")
    def custom_metrics_namespaces(self) -> Optional[str]:
        """
        (CloudWatch) A comma-separated list of custom namespaces to be queried by the CloudWatch data source.
        """
        return pulumi.get(self, "custom_metrics_namespaces")

    @property
    @pulumi.getter
    def database(self) -> Optional[str]:
        """
        (Athena) Name of the database within the catalog.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter(name="defaultBucket")
    def default_bucket(self) -> Optional[str]:
        """
        (InfluxDB) The default bucket for the data source.
        """
        return pulumi.get(self, "default_bucket")

    @property
    @pulumi.getter(name="defaultProject")
    def default_project(self) -> Optional[str]:
        """
        (Stackdriver) The default project for the data source.
        """
        return pulumi.get(self, "default_project")

    @property
    @pulumi.getter(name="defaultRegion")
    def default_region(self) -> Optional[str]:
        """
        (CloudWatch, Athena) The default region for the data source.
        """
        return pulumi.get(self, "default_region")

    @property
    @pulumi.getter(name="derivedFields")
    def derived_fields(self) -> Optional[Sequence['outputs.DataSourceJsonDataDerivedField']]:
        """
        (Loki) See https://grafana.com/docs/grafana/latest/datasources/loki/#derived-fields
        """
        return pulumi.get(self, "derived_fields")

    @property
    @pulumi.getter
    def encrypt(self) -> Optional[str]:
        """
        (MSSQL) Connection SSL encryption handling: 'disable', 'false' or 'true'.
        """
        return pulumi.get(self, "encrypt")

    @property
    @pulumi.getter(name="esVersion")
    def es_version(self) -> Optional[str]:
        """
        (Elasticsearch) Elasticsearch semantic version (Grafana v8.0+).
        """
        return pulumi.get(self, "es_version")

    @property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[str]:
        """
        (CloudWatch, Athena) If you are assuming a role in another account, that has been created with an external ID, specify the external ID here.
        """
        return pulumi.get(self, "external_id")

    @property
    @pulumi.getter(name="githubUrl")
    def github_url(self) -> Optional[str]:
        """
        (Github) Github URL
        """
        return pulumi.get(self, "github_url")

    @property
    @pulumi.getter(name="graphiteVersion")
    def graphite_version(self) -> Optional[str]:
        """
        (Graphite) Graphite version.
        """
        return pulumi.get(self, "graphite_version")

    @property
    @pulumi.getter(name="httpMethod")
    def http_method(self) -> Optional[str]:
        """
        (Prometheus) HTTP method to use for making requests.
        """
        return pulumi.get(self, "http_method")

    @property
    @pulumi.getter
    def implementation(self) -> Optional[str]:
        """
        (Alertmanager) Implementation of Alertmanager. Either 'cortex' or 'prometheus'
        """
        return pulumi.get(self, "implementation")

    @property
    @pulumi.getter
    def interval(self) -> Optional[str]:
        """
        (Elasticsearch) Index date time format. nil(No Pattern), 'Hourly', 'Daily', 'Weekly', 'Monthly' or 'Yearly'.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter(name="logLevelField")
    def log_level_field(self) -> Optional[str]:
        """
        (Elasticsearch) Which field should be used to indicate the priority of the log message.
        """
        return pulumi.get(self, "log_level_field")

    @property
    @pulumi.getter(name="logMessageField")
    def log_message_field(self) -> Optional[str]:
        """
        (Elasticsearch) Which field should be used as the log message.
        """
        return pulumi.get(self, "log_message_field")

    @property
    @pulumi.getter(name="manageAlerts")
    def manage_alerts(self) -> Optional[bool]:
        """
        (Prometheus) Manage alerts.
        """
        return pulumi.get(self, "manage_alerts")

    @property
    @pulumi.getter(name="maxConcurrentShardRequests")
    def max_concurrent_shard_requests(self) -> Optional[int]:
        """
        (Elasticsearch) Maximum number of concurrent shard requests.
        """
        return pulumi.get(self, "max_concurrent_shard_requests")

    @property
    @pulumi.getter(name="maxIdleConns")
    def max_idle_conns(self) -> Optional[int]:
        """
        (MySQL, PostgreSQL and MSSQL) Maximum number of connections in the idle connection pool (Grafana v5.4+).
        """
        return pulumi.get(self, "max_idle_conns")

    @property
    @pulumi.getter(name="maxLines")
    def max_lines(self) -> Optional[int]:
        """
        (Loki) Upper limit for the number of log lines returned by Loki
        """
        return pulumi.get(self, "max_lines")

    @property
    @pulumi.getter(name="maxOpenConns")
    def max_open_conns(self) -> Optional[int]:
        """
        (MySQL, PostgreSQL and MSSQL) Maximum number of open connections to the database (Grafana v5.4+).
        """
        return pulumi.get(self, "max_open_conns")

    @property
    @pulumi.getter(name="orgSlug")
    def org_slug(self) -> Optional[str]:
        """
        (Sentry) Organization slug.
        """
        return pulumi.get(self, "org_slug")

    @property
    @pulumi.getter
    def organization(self) -> Optional[str]:
        """
        (InfluxDB) An organization is a workspace for a group of users. All dashboards, tasks, buckets, members, etc., belong to an organization.
        """
        return pulumi.get(self, "organization")

    @property
    @pulumi.getter(name="outputLocation")
    def output_location(self) -> Optional[str]:
        """
        (Athena) AWS S3 bucket to store execution outputs. If not specified, the default query result location from the Workgroup configuration will be used.
        """
        return pulumi.get(self, "output_location")

    @property
    @pulumi.getter(name="postgresVersion")
    def postgres_version(self) -> Optional[int]:
        """
        (PostgreSQL) Postgres version as a number (903/904/905/906/1000) meaning v9.3, v9.4, etc.
        """
        return pulumi.get(self, "postgres_version")

    @property
    @pulumi.getter
    def profile(self) -> Optional[str]:
        """
        (CloudWatch, Athena) The credentials profile name to use when authentication type is set as 'Credentials file'.
        """
        return pulumi.get(self, "profile")

    @property
    @pulumi.getter(name="queryTimeout")
    def query_timeout(self) -> Optional[str]:
        """
        (Prometheus) Timeout for queries made to the Prometheus data source in seconds.
        """
        return pulumi.get(self, "query_timeout")

    @property
    @pulumi.getter(name="sigv4AssumeRoleArn")
    def sigv4_assume_role_arn(self) -> Optional[str]:
        """
        (Elasticsearch and Prometheus) Specifies the ARN of an IAM role to assume.
        """
        return pulumi.get(self, "sigv4_assume_role_arn")

    @property
    @pulumi.getter(name="sigv4Auth")
    def sigv4_auth(self) -> Optional[bool]:
        """
        (Elasticsearch and Prometheus) Enable usage of SigV4.
        """
        return pulumi.get(self, "sigv4_auth")

    @property
    @pulumi.getter(name="sigv4AuthType")
    def sigv4_auth_type(self) -> Optional[str]:
        """
        (Elasticsearch and Prometheus) The Sigv4 authentication provider to use: 'default', 'credentials' or 'keys' (AMG: 'workspace-iam-role').
        """
        return pulumi.get(self, "sigv4_auth_type")

    @property
    @pulumi.getter(name="sigv4ExternalId")
    def sigv4_external_id(self) -> Optional[str]:
        """
        (Elasticsearch and Prometheus) When assuming a role in another account use this external ID.
        """
        return pulumi.get(self, "sigv4_external_id")

    @property
    @pulumi.getter(name="sigv4Profile")
    def sigv4_profile(self) -> Optional[str]:
        """
        (Elasticsearch and Prometheus) Credentials profile name, leave blank for default.
        """
        return pulumi.get(self, "sigv4_profile")

    @property
    @pulumi.getter(name="sigv4Region")
    def sigv4_region(self) -> Optional[str]:
        """
        (Elasticsearch and Prometheus) AWS region to use for Sigv4.
        """
        return pulumi.get(self, "sigv4_region")

    @property
    @pulumi.getter(name="sslMode")
    def ssl_mode(self) -> Optional[str]:
        """
        (PostgreSQL) SSLmode. 'disable', 'require', 'verify-ca' or 'verify-full'.
        """
        return pulumi.get(self, "ssl_mode")

    @property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> Optional[str]:
        """
        (Azure Monitor) The subscription id
        """
        return pulumi.get(self, "subscription_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[str]:
        """
        (Azure Monitor) Service account tenant ID.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter(name="timeField")
    def time_field(self) -> Optional[str]:
        """
        (Elasticsearch) Which field that should be used as timestamp.
        """
        return pulumi.get(self, "time_field")

    @property
    @pulumi.getter(name="timeInterval")
    def time_interval(self) -> Optional[str]:
        """
        (Prometheus, Elasticsearch, InfluxDB, MySQL, PostgreSQL, and MSSQL) Lowest interval/step value that should be used for this data source. Sometimes called "Scrape Interval" in the Grafana UI.
        """
        return pulumi.get(self, "time_interval")

    @property
    @pulumi.getter
    def timescaledb(self) -> Optional[bool]:
        """
        (PostgreSQL) Enable usage of TimescaleDB extension.
        """
        return pulumi.get(self, "timescaledb")

    @property
    @pulumi.getter(name="tlsAuth")
    def tls_auth(self) -> Optional[bool]:
        """
        (All) Enable TLS authentication using client cert configured in secure json data.
        """
        return pulumi.get(self, "tls_auth")

    @property
    @pulumi.getter(name="tlsAuthWithCaCert")
    def tls_auth_with_ca_cert(self) -> Optional[bool]:
        """
        (All) Enable TLS authentication using CA cert.
        """
        return pulumi.get(self, "tls_auth_with_ca_cert")

    @property
    @pulumi.getter(name="tlsConfigurationMethod")
    def tls_configuration_method(self) -> Optional[str]:
        """
        (All) SSL Certificate configuration, either by file-path or file-content.
        """
        return pulumi.get(self, "tls_configuration_method")

    @property
    @pulumi.getter(name="tlsSkipVerify")
    def tls_skip_verify(self) -> Optional[bool]:
        """
        (All) Controls whether a client verifies the servers certificate chain and host name.
        """
        return pulumi.get(self, "tls_skip_verify")

    @property
    @pulumi.getter(name="tokenUri")
    def token_uri(self) -> Optional[str]:
        """
        (Stackdriver) The token URI used, provided in the service account key.
        """
        return pulumi.get(self, "token_uri")

    @property
    @pulumi.getter(name="tracingDatasourceUid")
    def tracing_datasource_uid(self) -> Optional[str]:
        """
        (Cloudwatch) The X-Ray datasource uid to associate to this Cloudwatch datasource.
        """
        return pulumi.get(self, "tracing_datasource_uid")

    @property
    @pulumi.getter(name="tsdbResolution")
    def tsdb_resolution(self) -> Optional[int]:
        """
        (OpenTSDB) Resolution.
        """
        return pulumi.get(self, "tsdb_resolution")

    @property
    @pulumi.getter(name="tsdbVersion")
    def tsdb_version(self) -> Optional[int]:
        """
        (OpenTSDB) Version.
        """
        return pulumi.get(self, "tsdb_version")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        (InfluxDB) InfluxQL or Flux.
        """
        return pulumi.get(self, "version")

    @property
    @pulumi.getter
    def workgroup(self) -> Optional[str]:
        """
        (Athena) Workgroup to use.
        """
        return pulumi.get(self, "workgroup")

    @property
    @pulumi.getter(name="xpackEnabled")
    def xpack_enabled(self) -> Optional[bool]:
        """
        (Elasticsearch) Enable X-Pack support.
        """
        return pulumi.get(self, "xpack_enabled")


@pulumi.output_type
class DataSourceJsonDataDerivedField(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "datasourceUid":
            suggest = "datasource_uid"
        elif key == "matcherRegex":
            suggest = "matcher_regex"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSourceJsonDataDerivedField. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSourceJsonDataDerivedField.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSourceJsonDataDerivedField.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 datasource_uid: Optional[str] = None,
                 matcher_regex: Optional[str] = None,
                 name: Optional[str] = None,
                 url: Optional[str] = None):
        """
        :param str name: A unique name for the data source.
        :param str url: The URL for the data source. The type of URL required varies depending on the chosen data source type.
        """
        if datasource_uid is not None:
            pulumi.set(__self__, "datasource_uid", datasource_uid)
        if matcher_regex is not None:
            pulumi.set(__self__, "matcher_regex", matcher_regex)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter(name="datasourceUid")
    def datasource_uid(self) -> Optional[str]:
        return pulumi.get(self, "datasource_uid")

    @property
    @pulumi.getter(name="matcherRegex")
    def matcher_regex(self) -> Optional[str]:
        return pulumi.get(self, "matcher_regex")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        A unique name for the data source.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        """
        The URL for the data source. The type of URL required varies depending on the chosen data source type.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class DataSourcePermissionPermission(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "builtInRole":
            suggest = "built_in_role"
        elif key == "teamId":
            suggest = "team_id"
        elif key == "userId":
            suggest = "user_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSourcePermissionPermission. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSourcePermissionPermission.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSourcePermissionPermission.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 permission: str,
                 built_in_role: Optional[str] = None,
                 team_id: Optional[int] = None,
                 user_id: Optional[int] = None):
        """
        :param str permission: Permission to associate with item. Options: `Query` or `Edit` (`Edit` can only be used with Grafana v9.2.3+).
        :param str built_in_role: Name of the basic role to manage permissions for. Options: `Viewer`, `Editor` or `Admin`. Can only be set from Grafana v9.2.3+. Defaults to ``.
        :param int team_id: ID of the team to manage permissions for. Defaults to `0`.
        :param int user_id: ID of the user to manage permissions for. Defaults to `0`.
        """
        pulumi.set(__self__, "permission", permission)
        if built_in_role is not None:
            pulumi.set(__self__, "built_in_role", built_in_role)
        if team_id is not None:
            pulumi.set(__self__, "team_id", team_id)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)

    @property
    @pulumi.getter
    def permission(self) -> str:
        """
        Permission to associate with item. Options: `Query` or `Edit` (`Edit` can only be used with Grafana v9.2.3+).
        """
        return pulumi.get(self, "permission")

    @property
    @pulumi.getter(name="builtInRole")
    def built_in_role(self) -> Optional[str]:
        """
        Name of the basic role to manage permissions for. Options: `Viewer`, `Editor` or `Admin`. Can only be set from Grafana v9.2.3+. Defaults to ``.
        """
        return pulumi.get(self, "built_in_role")

    @property
    @pulumi.getter(name="teamId")
    def team_id(self) -> Optional[int]:
        """
        ID of the team to manage permissions for. Defaults to `0`.
        """
        return pulumi.get(self, "team_id")

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[int]:
        """
        ID of the user to manage permissions for. Defaults to `0`.
        """
        return pulumi.get(self, "user_id")


@pulumi.output_type
class DataSourceSecureJsonData(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "accessToken":
            suggest = "access_token"
        elif key == "authToken":
            suggest = "auth_token"
        elif key == "basicAuthPassword":
            suggest = "basic_auth_password"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "privateKey":
            suggest = "private_key"
        elif key == "secretKey":
            suggest = "secret_key"
        elif key == "sigv4AccessKey":
            suggest = "sigv4_access_key"
        elif key == "sigv4SecretKey":
            suggest = "sigv4_secret_key"
        elif key == "tlsCaCert":
            suggest = "tls_ca_cert"
        elif key == "tlsClientCert":
            suggest = "tls_client_cert"
        elif key == "tlsClientKey":
            suggest = "tls_client_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSourceSecureJsonData. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSourceSecureJsonData.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSourceSecureJsonData.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_key: Optional[str] = None,
                 access_token: Optional[str] = None,
                 auth_token: Optional[str] = None,
                 basic_auth_password: Optional[str] = None,
                 client_secret: Optional[str] = None,
                 password: Optional[str] = None,
                 private_key: Optional[str] = None,
                 secret_key: Optional[str] = None,
                 sigv4_access_key: Optional[str] = None,
                 sigv4_secret_key: Optional[str] = None,
                 tls_ca_cert: Optional[str] = None,
                 tls_client_cert: Optional[str] = None,
                 tls_client_key: Optional[str] = None):
        """
        :param str access_key: (CloudWatch, Athena) The access key used to access the data source.
        :param str access_token: (Github) The access token used to access the data source.
        :param str auth_token: (Sentry) Authorization token.
        :param str basic_auth_password: (All) Password to use for basic authentication.
        :param str client_secret: (Azure Monitor) Client secret for authentication.
        :param str password: (All) Password to use for authentication.
        :param str private_key: (Stackdriver) The service account key `private_key` to use to access the data source.
        :param str secret_key: (CloudWatch, Athena) The secret key to use to access the data source.
        :param str sigv4_access_key: (Elasticsearch and Prometheus) SigV4 access key. Required when using 'keys' auth provider.
        :param str sigv4_secret_key: (Elasticsearch and Prometheus) SigV4 secret key. Required when using 'keys' auth provider.
        :param str tls_ca_cert: (All) CA cert for out going requests.
        :param str tls_client_cert: (All) TLS Client cert for outgoing requests.
        :param str tls_client_key: (All) TLS Client key for outgoing requests.
        """
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)
        if auth_token is not None:
            pulumi.set(__self__, "auth_token", auth_token)
        if basic_auth_password is not None:
            pulumi.set(__self__, "basic_auth_password", basic_auth_password)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)
        if sigv4_access_key is not None:
            pulumi.set(__self__, "sigv4_access_key", sigv4_access_key)
        if sigv4_secret_key is not None:
            pulumi.set(__self__, "sigv4_secret_key", sigv4_secret_key)
        if tls_ca_cert is not None:
            pulumi.set(__self__, "tls_ca_cert", tls_ca_cert)
        if tls_client_cert is not None:
            pulumi.set(__self__, "tls_client_cert", tls_client_cert)
        if tls_client_key is not None:
            pulumi.set(__self__, "tls_client_key", tls_client_key)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[str]:
        """
        (CloudWatch, Athena) The access key used to access the data source.
        """
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[str]:
        """
        (Github) The access token used to access the data source.
        """
        return pulumi.get(self, "access_token")

    @property
    @pulumi.getter(name="authToken")
    def auth_token(self) -> Optional[str]:
        """
        (Sentry) Authorization token.
        """
        return pulumi.get(self, "auth_token")

    @property
    @pulumi.getter(name="basicAuthPassword")
    def basic_auth_password(self) -> Optional[str]:
        """
        (All) Password to use for basic authentication.
        """
        return pulumi.get(self, "basic_auth_password")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        (Azure Monitor) Client secret for authentication.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        (All) Password to use for authentication.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[str]:
        """
        (Stackdriver) The service account key `private_key` to use to access the data source.
        """
        return pulumi.get(self, "private_key")

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[str]:
        """
        (CloudWatch, Athena) The secret key to use to access the data source.
        """
        return pulumi.get(self, "secret_key")

    @property
    @pulumi.getter(name="sigv4AccessKey")
    def sigv4_access_key(self) -> Optional[str]:
        """
        (Elasticsearch and Prometheus) SigV4 access key. Required when using 'keys' auth provider.
        """
        return pulumi.get(self, "sigv4_access_key")

    @property
    @pulumi.getter(name="sigv4SecretKey")
    def sigv4_secret_key(self) -> Optional[str]:
        """
        (Elasticsearch and Prometheus) SigV4 secret key. Required when using 'keys' auth provider.
        """
        return pulumi.get(self, "sigv4_secret_key")

    @property
    @pulumi.getter(name="tlsCaCert")
    def tls_ca_cert(self) -> Optional[str]:
        """
        (All) CA cert for out going requests.
        """
        return pulumi.get(self, "tls_ca_cert")

    @property
    @pulumi.getter(name="tlsClientCert")
    def tls_client_cert(self) -> Optional[str]:
        """
        (All) TLS Client cert for outgoing requests.
        """
        return pulumi.get(self, "tls_client_cert")

    @property
    @pulumi.getter(name="tlsClientKey")
    def tls_client_key(self) -> Optional[str]:
        """
        (All) TLS Client key for outgoing requests.
        """
        return pulumi.get(self, "tls_client_key")


@pulumi.output_type
class FolderPermissionPermission(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "teamId":
            suggest = "team_id"
        elif key == "userId":
            suggest = "user_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FolderPermissionPermission. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FolderPermissionPermission.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FolderPermissionPermission.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 permission: str,
                 role: Optional[str] = None,
                 team_id: Optional[int] = None,
                 user_id: Optional[int] = None):
        """
        :param str permission: Permission to associate with item. Must be one of `View`, `Edit`, or `Admin`.
        :param str role: Manage permissions for `Viewer` or `Editor` roles.
        :param int team_id: ID of the team to manage permissions for. Defaults to `0`.
        :param int user_id: ID of the user to manage permissions for. Defaults to `0`.
        """
        pulumi.set(__self__, "permission", permission)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if team_id is not None:
            pulumi.set(__self__, "team_id", team_id)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)

    @property
    @pulumi.getter
    def permission(self) -> str:
        """
        Permission to associate with item. Must be one of `View`, `Edit`, or `Admin`.
        """
        return pulumi.get(self, "permission")

    @property
    @pulumi.getter
    def role(self) -> Optional[str]:
        """
        Manage permissions for `Viewer` or `Editor` roles.
        """
        return pulumi.get(self, "role")

    @property
    @pulumi.getter(name="teamId")
    def team_id(self) -> Optional[int]:
        """
        ID of the team to manage permissions for. Defaults to `0`.
        """
        return pulumi.get(self, "team_id")

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[int]:
        """
        ID of the user to manage permissions for. Defaults to `0`.
        """
        return pulumi.get(self, "user_id")


@pulumi.output_type
class MuteTimingInterval(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "daysOfMonths":
            suggest = "days_of_months"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MuteTimingInterval. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MuteTimingInterval.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MuteTimingInterval.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 days_of_months: Optional[Sequence[str]] = None,
                 months: Optional[Sequence[str]] = None,
                 times: Optional[Sequence['outputs.MuteTimingIntervalTime']] = None,
                 weekdays: Optional[Sequence[str]] = None,
                 years: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] days_of_months: An inclusive range of days, 1-31, within a month, e.g. "1" or "14:16". Negative values can be used to represent days counting from the end of a month, e.g. "-1".
        :param Sequence[str] months: An inclusive range of months, either numerical or full calendar month, e.g. "1:3", "december", or "may:august".
        :param Sequence['MuteTimingIntervalTimeArgs'] times: The time ranges, represented in minutes, during which to mute in a given day.
        :param Sequence[str] weekdays: An inclusive range of weekdays, e.g. "monday" or "tuesday:thursday".
        :param Sequence[str] years: A positive inclusive range of years, e.g. "2030" or "2025:2026".
        """
        if days_of_months is not None:
            pulumi.set(__self__, "days_of_months", days_of_months)
        if months is not None:
            pulumi.set(__self__, "months", months)
        if times is not None:
            pulumi.set(__self__, "times", times)
        if weekdays is not None:
            pulumi.set(__self__, "weekdays", weekdays)
        if years is not None:
            pulumi.set(__self__, "years", years)

    @property
    @pulumi.getter(name="daysOfMonths")
    def days_of_months(self) -> Optional[Sequence[str]]:
        """
        An inclusive range of days, 1-31, within a month, e.g. "1" or "14:16". Negative values can be used to represent days counting from the end of a month, e.g. "-1".
        """
        return pulumi.get(self, "days_of_months")

    @property
    @pulumi.getter
    def months(self) -> Optional[Sequence[str]]:
        """
        An inclusive range of months, either numerical or full calendar month, e.g. "1:3", "december", or "may:august".
        """
        return pulumi.get(self, "months")

    @property
    @pulumi.getter
    def times(self) -> Optional[Sequence['outputs.MuteTimingIntervalTime']]:
        """
        The time ranges, represented in minutes, during which to mute in a given day.
        """
        return pulumi.get(self, "times")

    @property
    @pulumi.getter
    def weekdays(self) -> Optional[Sequence[str]]:
        """
        An inclusive range of weekdays, e.g. "monday" or "tuesday:thursday".
        """
        return pulumi.get(self, "weekdays")

    @property
    @pulumi.getter
    def years(self) -> Optional[Sequence[str]]:
        """
        A positive inclusive range of years, e.g. "2030" or "2025:2026".
        """
        return pulumi.get(self, "years")


@pulumi.output_type
class MuteTimingIntervalTime(dict):
    def __init__(__self__, *,
                 end: str,
                 start: str):
        pulumi.set(__self__, "end", end)
        pulumi.set(__self__, "start", start)

    @property
    @pulumi.getter
    def end(self) -> str:
        return pulumi.get(self, "end")

    @property
    @pulumi.getter
    def start(self) -> str:
        return pulumi.get(self, "start")


@pulumi.output_type
class NotificationPolicyPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contactPoint":
            suggest = "contact_point"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "continue":
            suggest = "continue_"
        elif key == "groupInterval":
            suggest = "group_interval"
        elif key == "groupWait":
            suggest = "group_wait"
        elif key == "muteTimings":
            suggest = "mute_timings"
        elif key == "repeatInterval":
            suggest = "repeat_interval"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotificationPolicyPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotificationPolicyPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotificationPolicyPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 contact_point: str,
                 group_bies: Sequence[str],
                 continue_: Optional[bool] = None,
                 group_interval: Optional[str] = None,
                 group_wait: Optional[str] = None,
                 matchers: Optional[Sequence['outputs.NotificationPolicyPolicyMatcher']] = None,
                 mute_timings: Optional[Sequence[str]] = None,
                 policies: Optional[Sequence['outputs.NotificationPolicyPolicyPolicy']] = None,
                 repeat_interval: Optional[str] = None):
        """
        :param str contact_point: The contact point to route notifications that match this rule to.
        :param Sequence[str] group_bies: A list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping.
        :param bool continue_: Whether to continue matching subsequent rules if an alert matches the current rule. Otherwise, the rule will be 'consumed' by the first policy to match it.
        :param str group_interval: Minimum time interval between two notifications for the same group. Default is 5 minutes.
        :param str group_wait: Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.
        :param Sequence['NotificationPolicyPolicyMatcherArgs'] matchers: Describes which labels this rule should match. When multiple matchers are supplied, an alert must match ALL matchers to be accepted by this policy. When no matchers are supplied, the rule will match all alert instances.
        :param Sequence[str] mute_timings: A list of mute timing names to apply to alerts that match this policy.
        :param Sequence['NotificationPolicyPolicyPolicyArgs'] policies: Routing rules for specific label sets.
        :param str repeat_interval: Minimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.
        """
        pulumi.set(__self__, "contact_point", contact_point)
        pulumi.set(__self__, "group_bies", group_bies)
        if continue_ is not None:
            pulumi.set(__self__, "continue_", continue_)
        if group_interval is not None:
            pulumi.set(__self__, "group_interval", group_interval)
        if group_wait is not None:
            pulumi.set(__self__, "group_wait", group_wait)
        if matchers is not None:
            pulumi.set(__self__, "matchers", matchers)
        if mute_timings is not None:
            pulumi.set(__self__, "mute_timings", mute_timings)
        if policies is not None:
            pulumi.set(__self__, "policies", policies)
        if repeat_interval is not None:
            pulumi.set(__self__, "repeat_interval", repeat_interval)

    @property
    @pulumi.getter(name="contactPoint")
    def contact_point(self) -> str:
        """
        The contact point to route notifications that match this rule to.
        """
        return pulumi.get(self, "contact_point")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Sequence[str]:
        """
        A list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="continue")
    def continue_(self) -> Optional[bool]:
        """
        Whether to continue matching subsequent rules if an alert matches the current rule. Otherwise, the rule will be 'consumed' by the first policy to match it.
        """
        return pulumi.get(self, "continue_")

    @property
    @pulumi.getter(name="groupInterval")
    def group_interval(self) -> Optional[str]:
        """
        Minimum time interval between two notifications for the same group. Default is 5 minutes.
        """
        return pulumi.get(self, "group_interval")

    @property
    @pulumi.getter(name="groupWait")
    def group_wait(self) -> Optional[str]:
        """
        Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.
        """
        return pulumi.get(self, "group_wait")

    @property
    @pulumi.getter
    def matchers(self) -> Optional[Sequence['outputs.NotificationPolicyPolicyMatcher']]:
        """
        Describes which labels this rule should match. When multiple matchers are supplied, an alert must match ALL matchers to be accepted by this policy. When no matchers are supplied, the rule will match all alert instances.
        """
        return pulumi.get(self, "matchers")

    @property
    @pulumi.getter(name="muteTimings")
    def mute_timings(self) -> Optional[Sequence[str]]:
        """
        A list of mute timing names to apply to alerts that match this policy.
        """
        return pulumi.get(self, "mute_timings")

    @property
    @pulumi.getter
    def policies(self) -> Optional[Sequence['outputs.NotificationPolicyPolicyPolicy']]:
        """
        Routing rules for specific label sets.
        """
        return pulumi.get(self, "policies")

    @property
    @pulumi.getter(name="repeatInterval")
    def repeat_interval(self) -> Optional[str]:
        """
        Minimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.
        """
        return pulumi.get(self, "repeat_interval")


@pulumi.output_type
class NotificationPolicyPolicyMatcher(dict):
    def __init__(__self__, *,
                 label: str,
                 match: str,
                 value: str):
        pulumi.set(__self__, "label", label)
        pulumi.set(__self__, "match", match)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def label(self) -> str:
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def match(self) -> str:
        return pulumi.get(self, "match")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class NotificationPolicyPolicyPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contactPoint":
            suggest = "contact_point"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "continue":
            suggest = "continue_"
        elif key == "groupInterval":
            suggest = "group_interval"
        elif key == "groupWait":
            suggest = "group_wait"
        elif key == "muteTimings":
            suggest = "mute_timings"
        elif key == "repeatInterval":
            suggest = "repeat_interval"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotificationPolicyPolicyPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotificationPolicyPolicyPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotificationPolicyPolicyPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 contact_point: str,
                 group_bies: Sequence[str],
                 continue_: Optional[bool] = None,
                 group_interval: Optional[str] = None,
                 group_wait: Optional[str] = None,
                 matchers: Optional[Sequence['outputs.NotificationPolicyPolicyPolicyMatcher']] = None,
                 mute_timings: Optional[Sequence[str]] = None,
                 policies: Optional[Sequence['outputs.NotificationPolicyPolicyPolicyPolicy']] = None,
                 repeat_interval: Optional[str] = None):
        """
        :param str contact_point: The contact point to route notifications that match this rule to.
        :param Sequence[str] group_bies: A list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping.
        :param bool continue_: Whether to continue matching subsequent rules if an alert matches the current rule. Otherwise, the rule will be 'consumed' by the first policy to match it.
        :param str group_interval: Minimum time interval between two notifications for the same group. Default is 5 minutes.
        :param str group_wait: Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.
        :param Sequence['NotificationPolicyPolicyPolicyMatcherArgs'] matchers: Describes which labels this rule should match. When multiple matchers are supplied, an alert must match ALL matchers to be accepted by this policy. When no matchers are supplied, the rule will match all alert instances.
        :param Sequence[str] mute_timings: A list of mute timing names to apply to alerts that match this policy.
        :param Sequence['NotificationPolicyPolicyPolicyPolicyArgs'] policies: Routing rules for specific label sets.
        :param str repeat_interval: Minimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.
        """
        pulumi.set(__self__, "contact_point", contact_point)
        pulumi.set(__self__, "group_bies", group_bies)
        if continue_ is not None:
            pulumi.set(__self__, "continue_", continue_)
        if group_interval is not None:
            pulumi.set(__self__, "group_interval", group_interval)
        if group_wait is not None:
            pulumi.set(__self__, "group_wait", group_wait)
        if matchers is not None:
            pulumi.set(__self__, "matchers", matchers)
        if mute_timings is not None:
            pulumi.set(__self__, "mute_timings", mute_timings)
        if policies is not None:
            pulumi.set(__self__, "policies", policies)
        if repeat_interval is not None:
            pulumi.set(__self__, "repeat_interval", repeat_interval)

    @property
    @pulumi.getter(name="contactPoint")
    def contact_point(self) -> str:
        """
        The contact point to route notifications that match this rule to.
        """
        return pulumi.get(self, "contact_point")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Sequence[str]:
        """
        A list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="continue")
    def continue_(self) -> Optional[bool]:
        """
        Whether to continue matching subsequent rules if an alert matches the current rule. Otherwise, the rule will be 'consumed' by the first policy to match it.
        """
        return pulumi.get(self, "continue_")

    @property
    @pulumi.getter(name="groupInterval")
    def group_interval(self) -> Optional[str]:
        """
        Minimum time interval between two notifications for the same group. Default is 5 minutes.
        """
        return pulumi.get(self, "group_interval")

    @property
    @pulumi.getter(name="groupWait")
    def group_wait(self) -> Optional[str]:
        """
        Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.
        """
        return pulumi.get(self, "group_wait")

    @property
    @pulumi.getter
    def matchers(self) -> Optional[Sequence['outputs.NotificationPolicyPolicyPolicyMatcher']]:
        """
        Describes which labels this rule should match. When multiple matchers are supplied, an alert must match ALL matchers to be accepted by this policy. When no matchers are supplied, the rule will match all alert instances.
        """
        return pulumi.get(self, "matchers")

    @property
    @pulumi.getter(name="muteTimings")
    def mute_timings(self) -> Optional[Sequence[str]]:
        """
        A list of mute timing names to apply to alerts that match this policy.
        """
        return pulumi.get(self, "mute_timings")

    @property
    @pulumi.getter
    def policies(self) -> Optional[Sequence['outputs.NotificationPolicyPolicyPolicyPolicy']]:
        """
        Routing rules for specific label sets.
        """
        return pulumi.get(self, "policies")

    @property
    @pulumi.getter(name="repeatInterval")
    def repeat_interval(self) -> Optional[str]:
        """
        Minimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.
        """
        return pulumi.get(self, "repeat_interval")


@pulumi.output_type
class NotificationPolicyPolicyPolicyMatcher(dict):
    def __init__(__self__, *,
                 label: str,
                 match: str,
                 value: str):
        pulumi.set(__self__, "label", label)
        pulumi.set(__self__, "match", match)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def label(self) -> str:
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def match(self) -> str:
        return pulumi.get(self, "match")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class NotificationPolicyPolicyPolicyPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contactPoint":
            suggest = "contact_point"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "continue":
            suggest = "continue_"
        elif key == "groupInterval":
            suggest = "group_interval"
        elif key == "groupWait":
            suggest = "group_wait"
        elif key == "muteTimings":
            suggest = "mute_timings"
        elif key == "repeatInterval":
            suggest = "repeat_interval"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotificationPolicyPolicyPolicyPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotificationPolicyPolicyPolicyPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotificationPolicyPolicyPolicyPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 contact_point: str,
                 group_bies: Sequence[str],
                 continue_: Optional[bool] = None,
                 group_interval: Optional[str] = None,
                 group_wait: Optional[str] = None,
                 matchers: Optional[Sequence['outputs.NotificationPolicyPolicyPolicyPolicyMatcher']] = None,
                 mute_timings: Optional[Sequence[str]] = None,
                 policies: Optional[Sequence['outputs.NotificationPolicyPolicyPolicyPolicyPolicy']] = None,
                 repeat_interval: Optional[str] = None):
        """
        :param str contact_point: The contact point to route notifications that match this rule to.
        :param Sequence[str] group_bies: A list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping.
        :param bool continue_: Whether to continue matching subsequent rules if an alert matches the current rule. Otherwise, the rule will be 'consumed' by the first policy to match it.
        :param str group_interval: Minimum time interval between two notifications for the same group. Default is 5 minutes.
        :param str group_wait: Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.
        :param Sequence['NotificationPolicyPolicyPolicyPolicyMatcherArgs'] matchers: Describes which labels this rule should match. When multiple matchers are supplied, an alert must match ALL matchers to be accepted by this policy. When no matchers are supplied, the rule will match all alert instances.
        :param Sequence[str] mute_timings: A list of mute timing names to apply to alerts that match this policy.
        :param Sequence['NotificationPolicyPolicyPolicyPolicyPolicyArgs'] policies: Routing rules for specific label sets.
        :param str repeat_interval: Minimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.
        """
        pulumi.set(__self__, "contact_point", contact_point)
        pulumi.set(__self__, "group_bies", group_bies)
        if continue_ is not None:
            pulumi.set(__self__, "continue_", continue_)
        if group_interval is not None:
            pulumi.set(__self__, "group_interval", group_interval)
        if group_wait is not None:
            pulumi.set(__self__, "group_wait", group_wait)
        if matchers is not None:
            pulumi.set(__self__, "matchers", matchers)
        if mute_timings is not None:
            pulumi.set(__self__, "mute_timings", mute_timings)
        if policies is not None:
            pulumi.set(__self__, "policies", policies)
        if repeat_interval is not None:
            pulumi.set(__self__, "repeat_interval", repeat_interval)

    @property
    @pulumi.getter(name="contactPoint")
    def contact_point(self) -> str:
        """
        The contact point to route notifications that match this rule to.
        """
        return pulumi.get(self, "contact_point")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Sequence[str]:
        """
        A list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="continue")
    def continue_(self) -> Optional[bool]:
        """
        Whether to continue matching subsequent rules if an alert matches the current rule. Otherwise, the rule will be 'consumed' by the first policy to match it.
        """
        return pulumi.get(self, "continue_")

    @property
    @pulumi.getter(name="groupInterval")
    def group_interval(self) -> Optional[str]:
        """
        Minimum time interval between two notifications for the same group. Default is 5 minutes.
        """
        return pulumi.get(self, "group_interval")

    @property
    @pulumi.getter(name="groupWait")
    def group_wait(self) -> Optional[str]:
        """
        Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.
        """
        return pulumi.get(self, "group_wait")

    @property
    @pulumi.getter
    def matchers(self) -> Optional[Sequence['outputs.NotificationPolicyPolicyPolicyPolicyMatcher']]:
        """
        Describes which labels this rule should match. When multiple matchers are supplied, an alert must match ALL matchers to be accepted by this policy. When no matchers are supplied, the rule will match all alert instances.
        """
        return pulumi.get(self, "matchers")

    @property
    @pulumi.getter(name="muteTimings")
    def mute_timings(self) -> Optional[Sequence[str]]:
        """
        A list of mute timing names to apply to alerts that match this policy.
        """
        return pulumi.get(self, "mute_timings")

    @property
    @pulumi.getter
    def policies(self) -> Optional[Sequence['outputs.NotificationPolicyPolicyPolicyPolicyPolicy']]:
        """
        Routing rules for specific label sets.
        """
        return pulumi.get(self, "policies")

    @property
    @pulumi.getter(name="repeatInterval")
    def repeat_interval(self) -> Optional[str]:
        """
        Minimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.
        """
        return pulumi.get(self, "repeat_interval")


@pulumi.output_type
class NotificationPolicyPolicyPolicyPolicyMatcher(dict):
    def __init__(__self__, *,
                 label: str,
                 match: str,
                 value: str):
        pulumi.set(__self__, "label", label)
        pulumi.set(__self__, "match", match)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def label(self) -> str:
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def match(self) -> str:
        return pulumi.get(self, "match")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class NotificationPolicyPolicyPolicyPolicyPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contactPoint":
            suggest = "contact_point"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "continue":
            suggest = "continue_"
        elif key == "groupInterval":
            suggest = "group_interval"
        elif key == "groupWait":
            suggest = "group_wait"
        elif key == "muteTimings":
            suggest = "mute_timings"
        elif key == "repeatInterval":
            suggest = "repeat_interval"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotificationPolicyPolicyPolicyPolicyPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotificationPolicyPolicyPolicyPolicyPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotificationPolicyPolicyPolicyPolicyPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 contact_point: str,
                 group_bies: Sequence[str],
                 continue_: Optional[bool] = None,
                 group_interval: Optional[str] = None,
                 group_wait: Optional[str] = None,
                 matchers: Optional[Sequence['outputs.NotificationPolicyPolicyPolicyPolicyPolicyMatcher']] = None,
                 mute_timings: Optional[Sequence[str]] = None,
                 repeat_interval: Optional[str] = None):
        """
        :param str contact_point: The contact point to route notifications that match this rule to.
        :param Sequence[str] group_bies: A list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping.
        :param bool continue_: Whether to continue matching subsequent rules if an alert matches the current rule. Otherwise, the rule will be 'consumed' by the first policy to match it.
        :param str group_interval: Minimum time interval between two notifications for the same group. Default is 5 minutes.
        :param str group_wait: Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.
        :param Sequence['NotificationPolicyPolicyPolicyPolicyPolicyMatcherArgs'] matchers: Describes which labels this rule should match. When multiple matchers are supplied, an alert must match ALL matchers to be accepted by this policy. When no matchers are supplied, the rule will match all alert instances.
        :param Sequence[str] mute_timings: A list of mute timing names to apply to alerts that match this policy.
        :param str repeat_interval: Minimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.
        """
        pulumi.set(__self__, "contact_point", contact_point)
        pulumi.set(__self__, "group_bies", group_bies)
        if continue_ is not None:
            pulumi.set(__self__, "continue_", continue_)
        if group_interval is not None:
            pulumi.set(__self__, "group_interval", group_interval)
        if group_wait is not None:
            pulumi.set(__self__, "group_wait", group_wait)
        if matchers is not None:
            pulumi.set(__self__, "matchers", matchers)
        if mute_timings is not None:
            pulumi.set(__self__, "mute_timings", mute_timings)
        if repeat_interval is not None:
            pulumi.set(__self__, "repeat_interval", repeat_interval)

    @property
    @pulumi.getter(name="contactPoint")
    def contact_point(self) -> str:
        """
        The contact point to route notifications that match this rule to.
        """
        return pulumi.get(self, "contact_point")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Sequence[str]:
        """
        A list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="continue")
    def continue_(self) -> Optional[bool]:
        """
        Whether to continue matching subsequent rules if an alert matches the current rule. Otherwise, the rule will be 'consumed' by the first policy to match it.
        """
        return pulumi.get(self, "continue_")

    @property
    @pulumi.getter(name="groupInterval")
    def group_interval(self) -> Optional[str]:
        """
        Minimum time interval between two notifications for the same group. Default is 5 minutes.
        """
        return pulumi.get(self, "group_interval")

    @property
    @pulumi.getter(name="groupWait")
    def group_wait(self) -> Optional[str]:
        """
        Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.
        """
        return pulumi.get(self, "group_wait")

    @property
    @pulumi.getter
    def matchers(self) -> Optional[Sequence['outputs.NotificationPolicyPolicyPolicyPolicyPolicyMatcher']]:
        """
        Describes which labels this rule should match. When multiple matchers are supplied, an alert must match ALL matchers to be accepted by this policy. When no matchers are supplied, the rule will match all alert instances.
        """
        return pulumi.get(self, "matchers")

    @property
    @pulumi.getter(name="muteTimings")
    def mute_timings(self) -> Optional[Sequence[str]]:
        """
        A list of mute timing names to apply to alerts that match this policy.
        """
        return pulumi.get(self, "mute_timings")

    @property
    @pulumi.getter(name="repeatInterval")
    def repeat_interval(self) -> Optional[str]:
        """
        Minimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.
        """
        return pulumi.get(self, "repeat_interval")


@pulumi.output_type
class NotificationPolicyPolicyPolicyPolicyPolicyMatcher(dict):
    def __init__(__self__, *,
                 label: str,
                 match: str,
                 value: str):
        pulumi.set(__self__, "label", label)
        pulumi.set(__self__, "match", match)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def label(self) -> str:
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def match(self) -> str:
        return pulumi.get(self, "match")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class OncallIntegrationDefaultRoute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "escalationChainId":
            suggest = "escalation_chain_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OncallIntegrationDefaultRoute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OncallIntegrationDefaultRoute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OncallIntegrationDefaultRoute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 escalation_chain_id: Optional[str] = None,
                 id: Optional[str] = None,
                 msteams: Optional['outputs.OncallIntegrationDefaultRouteMsteams'] = None,
                 slack: Optional['outputs.OncallIntegrationDefaultRouteSlack'] = None,
                 telegram: Optional['outputs.OncallIntegrationDefaultRouteTelegram'] = None):
        """
        :param str escalation_chain_id: The ID of the escalation chain.
        :param str id: The ID of this resource.
        :param 'OncallIntegrationDefaultRouteMsteamsArgs' msteams: MS teams-specific settings for a route.
        :param 'OncallIntegrationDefaultRouteSlackArgs' slack: Slack-specific settings for a route.
        :param 'OncallIntegrationDefaultRouteTelegramArgs' telegram: Telegram-specific settings for a route.
        """
        if escalation_chain_id is not None:
            pulumi.set(__self__, "escalation_chain_id", escalation_chain_id)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if msteams is not None:
            pulumi.set(__self__, "msteams", msteams)
        if slack is not None:
            pulumi.set(__self__, "slack", slack)
        if telegram is not None:
            pulumi.set(__self__, "telegram", telegram)

    @property
    @pulumi.getter(name="escalationChainId")
    def escalation_chain_id(self) -> Optional[str]:
        """
        The ID of the escalation chain.
        """
        return pulumi.get(self, "escalation_chain_id")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of this resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def msteams(self) -> Optional['outputs.OncallIntegrationDefaultRouteMsteams']:
        """
        MS teams-specific settings for a route.
        """
        return pulumi.get(self, "msteams")

    @property
    @pulumi.getter
    def slack(self) -> Optional['outputs.OncallIntegrationDefaultRouteSlack']:
        """
        Slack-specific settings for a route.
        """
        return pulumi.get(self, "slack")

    @property
    @pulumi.getter
    def telegram(self) -> Optional['outputs.OncallIntegrationDefaultRouteTelegram']:
        """
        Telegram-specific settings for a route.
        """
        return pulumi.get(self, "telegram")


@pulumi.output_type
class OncallIntegrationDefaultRouteMsteams(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 id: Optional[str] = None):
        """
        :param str id: The ID of this resource.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of this resource.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class OncallIntegrationDefaultRouteSlack(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "channelId":
            suggest = "channel_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OncallIntegrationDefaultRouteSlack. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OncallIntegrationDefaultRouteSlack.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OncallIntegrationDefaultRouteSlack.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 channel_id: Optional[str] = None,
                 enabled: Optional[bool] = None):
        if channel_id is not None:
            pulumi.set(__self__, "channel_id", channel_id)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="channelId")
    def channel_id(self) -> Optional[str]:
        return pulumi.get(self, "channel_id")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class OncallIntegrationDefaultRouteTelegram(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 id: Optional[str] = None):
        """
        :param str id: The ID of this resource.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of this resource.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class OncallIntegrationTemplates(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupingKey":
            suggest = "grouping_key"
        elif key == "resolveSignal":
            suggest = "resolve_signal"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OncallIntegrationTemplates. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OncallIntegrationTemplates.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OncallIntegrationTemplates.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 grouping_key: Optional[str] = None,
                 resolve_signal: Optional[str] = None,
                 slack: Optional['outputs.OncallIntegrationTemplatesSlack'] = None):
        """
        :param str grouping_key: Template for the key by which alerts are grouped.
        :param str resolve_signal: Template for sending a signal to resolve the Incident.
        :param 'OncallIntegrationTemplatesSlackArgs' slack: Templates for Slack.
        """
        if grouping_key is not None:
            pulumi.set(__self__, "grouping_key", grouping_key)
        if resolve_signal is not None:
            pulumi.set(__self__, "resolve_signal", resolve_signal)
        if slack is not None:
            pulumi.set(__self__, "slack", slack)

    @property
    @pulumi.getter(name="groupingKey")
    def grouping_key(self) -> Optional[str]:
        """
        Template for the key by which alerts are grouped.
        """
        return pulumi.get(self, "grouping_key")

    @property
    @pulumi.getter(name="resolveSignal")
    def resolve_signal(self) -> Optional[str]:
        """
        Template for sending a signal to resolve the Incident.
        """
        return pulumi.get(self, "resolve_signal")

    @property
    @pulumi.getter
    def slack(self) -> Optional['outputs.OncallIntegrationTemplatesSlack']:
        """
        Templates for Slack.
        """
        return pulumi.get(self, "slack")


@pulumi.output_type
class OncallIntegrationTemplatesSlack(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "imageUrl":
            suggest = "image_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OncallIntegrationTemplatesSlack. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OncallIntegrationTemplatesSlack.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OncallIntegrationTemplatesSlack.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 image_url: Optional[str] = None,
                 message: Optional[str] = None,
                 title: Optional[str] = None):
        if image_url is not None:
            pulumi.set(__self__, "image_url", image_url)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[str]:
        return pulumi.get(self, "image_url")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        return pulumi.get(self, "title")


@pulumi.output_type
class OncallRouteMsteams(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 id: Optional[str] = None):
        """
        :param bool enabled: Enable notification in MS teams. Defaults to `true`.
        :param str id: MS teams channel id. Alerts will be directed to this channel in Microsoft teams.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Enable notification in MS teams. Defaults to `true`.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        MS teams channel id. Alerts will be directed to this channel in Microsoft teams.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class OncallRouteSlack(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "channelId":
            suggest = "channel_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OncallRouteSlack. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OncallRouteSlack.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OncallRouteSlack.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 channel_id: Optional[str] = None,
                 enabled: Optional[bool] = None):
        """
        :param str channel_id: Slack channel id. Alerts will be directed to this channel in Slack.
        :param bool enabled: Enable notification in Slack. Defaults to `true`.
        """
        if channel_id is not None:
            pulumi.set(__self__, "channel_id", channel_id)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="channelId")
    def channel_id(self) -> Optional[str]:
        """
        Slack channel id. Alerts will be directed to this channel in Slack.
        """
        return pulumi.get(self, "channel_id")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Enable notification in Slack. Defaults to `true`.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class OncallRouteTelegram(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 id: Optional[str] = None):
        """
        :param bool enabled: Enable notification in Telegram. Defaults to `true`.
        :param str id: Telegram channel id. Alerts will be directed to this channel in Telegram.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Enable notification in Telegram. Defaults to `true`.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Telegram channel id. Alerts will be directed to this channel in Telegram.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class OncallScheduleSlack(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "channelId":
            suggest = "channel_id"
        elif key == "userGroupId":
            suggest = "user_group_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OncallScheduleSlack. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OncallScheduleSlack.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OncallScheduleSlack.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 channel_id: Optional[str] = None,
                 user_group_id: Optional[str] = None):
        """
        :param str channel_id: Slack channel id. Reminder about schedule shifts will be directed to this channel in Slack.
        :param str user_group_id: Slack user group id. Members of user group will be updated when on-call users change.
        """
        if channel_id is not None:
            pulumi.set(__self__, "channel_id", channel_id)
        if user_group_id is not None:
            pulumi.set(__self__, "user_group_id", user_group_id)

    @property
    @pulumi.getter(name="channelId")
    def channel_id(self) -> Optional[str]:
        """
        Slack channel id. Reminder about schedule shifts will be directed to this channel in Slack.
        """
        return pulumi.get(self, "channel_id")

    @property
    @pulumi.getter(name="userGroupId")
    def user_group_id(self) -> Optional[str]:
        """
        Slack user group id. Members of user group will be updated when on-call users change.
        """
        return pulumi.get(self, "user_group_id")


@pulumi.output_type
class PlaylistItem(dict):
    def __init__(__self__, *,
                 order: int,
                 title: str,
                 id: Optional[str] = None,
                 type: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str id: The ID of this resource.
        """
        pulumi.set(__self__, "order", order)
        pulumi.set(__self__, "title", title)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def order(self) -> int:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def title(self) -> str:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of this resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ReportSchedule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customInterval":
            suggest = "custom_interval"
        elif key == "endTime":
            suggest = "end_time"
        elif key == "lastDayOfMonth":
            suggest = "last_day_of_month"
        elif key == "startTime":
            suggest = "start_time"
        elif key == "workdaysOnly":
            suggest = "workdays_only"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ReportSchedule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ReportSchedule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ReportSchedule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 frequency: str,
                 custom_interval: Optional[str] = None,
                 end_time: Optional[str] = None,
                 last_day_of_month: Optional[bool] = None,
                 start_time: Optional[str] = None,
                 workdays_only: Optional[bool] = None):
        """
        :param str frequency: Frequency of the report. Allowed values: `never`, `once`, `hourly`, `daily`, `weekly`, `monthly`, `custom`.
        :param str custom_interval: Custom interval of the report.
               **Note:** This field is only available when frequency is set to `custom`.
        :param str end_time: End time of the report. If empty, the report will be sent indefinitely (according to frequency). Note that times will be saved as UTC in Grafana.
        :param bool last_day_of_month: Send the report on the last day of the month Defaults to `false`.
        :param str start_time: Start time of the report. If empty, the start date will be set to the creation time. Note that times will be saved as UTC in Grafana.
        :param bool workdays_only: Whether to send the report only on work days. Defaults to `false`.
        """
        pulumi.set(__self__, "frequency", frequency)
        if custom_interval is not None:
            pulumi.set(__self__, "custom_interval", custom_interval)
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if last_day_of_month is not None:
            pulumi.set(__self__, "last_day_of_month", last_day_of_month)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)
        if workdays_only is not None:
            pulumi.set(__self__, "workdays_only", workdays_only)

    @property
    @pulumi.getter
    def frequency(self) -> str:
        """
        Frequency of the report. Allowed values: `never`, `once`, `hourly`, `daily`, `weekly`, `monthly`, `custom`.
        """
        return pulumi.get(self, "frequency")

    @property
    @pulumi.getter(name="customInterval")
    def custom_interval(self) -> Optional[str]:
        """
        Custom interval of the report.
        **Note:** This field is only available when frequency is set to `custom`.
        """
        return pulumi.get(self, "custom_interval")

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[str]:
        """
        End time of the report. If empty, the report will be sent indefinitely (according to frequency). Note that times will be saved as UTC in Grafana.
        """
        return pulumi.get(self, "end_time")

    @property
    @pulumi.getter(name="lastDayOfMonth")
    def last_day_of_month(self) -> Optional[bool]:
        """
        Send the report on the last day of the month Defaults to `false`.
        """
        return pulumi.get(self, "last_day_of_month")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[str]:
        """
        Start time of the report. If empty, the start date will be set to the creation time. Note that times will be saved as UTC in Grafana.
        """
        return pulumi.get(self, "start_time")

    @property
    @pulumi.getter(name="workdaysOnly")
    def workdays_only(self) -> Optional[bool]:
        """
        Whether to send the report only on work days. Defaults to `false`.
        """
        return pulumi.get(self, "workdays_only")


@pulumi.output_type
class ReportTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ReportTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ReportTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ReportTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_: Optional[str] = None,
                 to: Optional[str] = None):
        """
        :param str from_: Start of the time range.
        :param str to: End of the time range.
        """
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[str]:
        """
        Start of the time range.
        """
        return pulumi.get(self, "from_")

    @property
    @pulumi.getter
    def to(self) -> Optional[str]:
        """
        End of the time range.
        """
        return pulumi.get(self, "to")


@pulumi.output_type
class RolePermission(dict):
    def __init__(__self__, *,
                 action: str,
                 scope: Optional[str] = None):
        """
        :param str action: Specific action users granted with the role will be allowed to perform (for example: `users:read`)
        :param str scope: Scope to restrict the action to a set of resources (for example: `users:*` or `roles:customrole1`)
        """
        pulumi.set(__self__, "action", action)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        Specific action users granted with the role will be allowed to perform (for example: `users:read`)
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def scope(self) -> Optional[str]:
        """
        Scope to restrict the action to a set of resources (for example: `users:*` or `roles:customrole1`)
        """
        return pulumi.get(self, "scope")


@pulumi.output_type
class RuleGroupRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "execErrState":
            suggest = "exec_err_state"
        elif key == "for":
            suggest = "for_"
        elif key == "noDataState":
            suggest = "no_data_state"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 condition: str,
                 datas: Sequence['outputs.RuleGroupRuleData'],
                 name: str,
                 annotations: Optional[Mapping[str, str]] = None,
                 exec_err_state: Optional[str] = None,
                 for_: Optional[str] = None,
                 labels: Optional[Mapping[str, str]] = None,
                 no_data_state: Optional[str] = None,
                 uid: Optional[str] = None):
        """
        :param str condition: The `ref_id` of the query node in the `data` field to use as the alert condition.
        :param Sequence['RuleGroupRuleDataArgs'] datas: A sequence of stages that describe the contents of the rule.
        :param str name: The name of the alert rule.
        :param Mapping[str, str] annotations: Key-value pairs of metadata to attach to the alert rule that may add user-defined context, but cannot be used for matching, grouping, or routing. Defaults to `map[]`.
        :param str exec_err_state: Describes what state to enter when the rule's query is invalid and the rule cannot be executed. Options are OK, Error, and Alerting. Defaults to `Alerting`.
        :param str for_: The amount of time for which the rule must be breached for the rule to be considered to be Firing. Before this time has elapsed, the rule is only considered to be Pending. Defaults to `0`.
        :param Mapping[str, str] labels: Key-value pairs to attach to the alert rule that can be used in matching, grouping, and routing. Defaults to `map[]`.
        :param str no_data_state: Describes what state to enter when the rule's query returns No Data. Options are OK, NoData, and Alerting. Defaults to `NoData`.
        :param str uid: The unique identifier of the alert rule.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "datas", datas)
        pulumi.set(__self__, "name", name)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if exec_err_state is not None:
            pulumi.set(__self__, "exec_err_state", exec_err_state)
        if for_ is not None:
            pulumi.set(__self__, "for_", for_)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if no_data_state is not None:
            pulumi.set(__self__, "no_data_state", no_data_state)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter
    def condition(self) -> str:
        """
        The `ref_id` of the query node in the `data` field to use as the alert condition.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def datas(self) -> Sequence['outputs.RuleGroupRuleData']:
        """
        A sequence of stages that describe the contents of the rule.
        """
        return pulumi.get(self, "datas")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the alert rule.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, str]]:
        """
        Key-value pairs of metadata to attach to the alert rule that may add user-defined context, but cannot be used for matching, grouping, or routing. Defaults to `map[]`.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="execErrState")
    def exec_err_state(self) -> Optional[str]:
        """
        Describes what state to enter when the rule's query is invalid and the rule cannot be executed. Options are OK, Error, and Alerting. Defaults to `Alerting`.
        """
        return pulumi.get(self, "exec_err_state")

    @property
    @pulumi.getter(name="for")
    def for_(self) -> Optional[str]:
        """
        The amount of time for which the rule must be breached for the rule to be considered to be Firing. Before this time has elapsed, the rule is only considered to be Pending. Defaults to `0`.
        """
        return pulumi.get(self, "for_")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, str]]:
        """
        Key-value pairs to attach to the alert rule that can be used in matching, grouping, and routing. Defaults to `map[]`.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="noDataState")
    def no_data_state(self) -> Optional[str]:
        """
        Describes what state to enter when the rule's query returns No Data. Options are OK, NoData, and Alerting. Defaults to `NoData`.
        """
        return pulumi.get(self, "no_data_state")

    @property
    @pulumi.getter
    def uid(self) -> Optional[str]:
        """
        The unique identifier of the alert rule.
        """
        return pulumi.get(self, "uid")


@pulumi.output_type
class RuleGroupRuleData(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "datasourceUid":
            suggest = "datasource_uid"
        elif key == "refId":
            suggest = "ref_id"
        elif key == "relativeTimeRange":
            suggest = "relative_time_range"
        elif key == "queryType":
            suggest = "query_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleData. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleData.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleData.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 datasource_uid: str,
                 model: str,
                 ref_id: str,
                 relative_time_range: 'outputs.RuleGroupRuleDataRelativeTimeRange',
                 query_type: Optional[str] = None):
        pulumi.set(__self__, "datasource_uid", datasource_uid)
        pulumi.set(__self__, "model", model)
        pulumi.set(__self__, "ref_id", ref_id)
        pulumi.set(__self__, "relative_time_range", relative_time_range)
        if query_type is not None:
            pulumi.set(__self__, "query_type", query_type)

    @property
    @pulumi.getter(name="datasourceUid")
    def datasource_uid(self) -> str:
        return pulumi.get(self, "datasource_uid")

    @property
    @pulumi.getter
    def model(self) -> str:
        return pulumi.get(self, "model")

    @property
    @pulumi.getter(name="refId")
    def ref_id(self) -> str:
        return pulumi.get(self, "ref_id")

    @property
    @pulumi.getter(name="relativeTimeRange")
    def relative_time_range(self) -> 'outputs.RuleGroupRuleDataRelativeTimeRange':
        return pulumi.get(self, "relative_time_range")

    @property
    @pulumi.getter(name="queryType")
    def query_type(self) -> Optional[str]:
        return pulumi.get(self, "query_type")


@pulumi.output_type
class RuleGroupRuleDataRelativeTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleDataRelativeTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleDataRelativeTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleDataRelativeTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_: int,
                 to: int):
        pulumi.set(__self__, "from_", from_)
        pulumi.set(__self__, "to", to)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> int:
        return pulumi.get(self, "from_")

    @property
    @pulumi.getter
    def to(self) -> int:
        return pulumi.get(self, "to")


@pulumi.output_type
class ServiceAccountPermissionPermission(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "teamId":
            suggest = "team_id"
        elif key == "userId":
            suggest = "user_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceAccountPermissionPermission. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceAccountPermissionPermission.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceAccountPermissionPermission.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 permission: str,
                 team_id: Optional[int] = None,
                 user_id: Optional[int] = None):
        """
        :param str permission: Permission to associate with item. Must be `Edit` or `Admin`.
        :param int team_id: ID of the team to manage permissions for. Specify either this or `user_id`. Defaults to `0`.
        :param int user_id: ID of the user to manage permissions for. Specify either this or `team_id`. Defaults to `0`.
        """
        pulumi.set(__self__, "permission", permission)
        if team_id is not None:
            pulumi.set(__self__, "team_id", team_id)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)

    @property
    @pulumi.getter
    def permission(self) -> str:
        """
        Permission to associate with item. Must be `Edit` or `Admin`.
        """
        return pulumi.get(self, "permission")

    @property
    @pulumi.getter(name="teamId")
    def team_id(self) -> Optional[int]:
        """
        ID of the team to manage permissions for. Specify either this or `user_id`. Defaults to `0`.
        """
        return pulumi.get(self, "team_id")

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[int]:
        """
        ID of the user to manage permissions for. Specify either this or `team_id`. Defaults to `0`.
        """
        return pulumi.get(self, "user_id")


@pulumi.output_type
class SyntheticMonitoringCheckSettings(dict):
    def __init__(__self__, *,
                 dns: Optional['outputs.SyntheticMonitoringCheckSettingsDns'] = None,
                 http: Optional['outputs.SyntheticMonitoringCheckSettingsHttp'] = None,
                 ping: Optional['outputs.SyntheticMonitoringCheckSettingsPing'] = None,
                 tcp: Optional['outputs.SyntheticMonitoringCheckSettingsTcp'] = None,
                 traceroute: Optional['outputs.SyntheticMonitoringCheckSettingsTraceroute'] = None):
        """
        :param 'SyntheticMonitoringCheckSettingsDnsArgs' dns: Settings for DNS check. The target must be a valid hostname (or IP address for `PTR` records).
        :param 'SyntheticMonitoringCheckSettingsHttpArgs' http: Settings for HTTP check. The target must be a URL (http or https).
        :param 'SyntheticMonitoringCheckSettingsPingArgs' ping: Settings for ping (ICMP) check. The target must be a valid hostname or IP address.
        :param 'SyntheticMonitoringCheckSettingsTcpArgs' tcp: Settings for TCP check. The target must be of the form `<host>:<port>`, where the host portion must be a valid hostname or IP address.
        :param 'SyntheticMonitoringCheckSettingsTracerouteArgs' traceroute: Settings for traceroute check. The target must be a valid hostname or IP address
        """
        if dns is not None:
            pulumi.set(__self__, "dns", dns)
        if http is not None:
            pulumi.set(__self__, "http", http)
        if ping is not None:
            pulumi.set(__self__, "ping", ping)
        if tcp is not None:
            pulumi.set(__self__, "tcp", tcp)
        if traceroute is not None:
            pulumi.set(__self__, "traceroute", traceroute)

    @property
    @pulumi.getter
    def dns(self) -> Optional['outputs.SyntheticMonitoringCheckSettingsDns']:
        """
        Settings for DNS check. The target must be a valid hostname (or IP address for `PTR` records).
        """
        return pulumi.get(self, "dns")

    @property
    @pulumi.getter
    def http(self) -> Optional['outputs.SyntheticMonitoringCheckSettingsHttp']:
        """
        Settings for HTTP check. The target must be a URL (http or https).
        """
        return pulumi.get(self, "http")

    @property
    @pulumi.getter
    def ping(self) -> Optional['outputs.SyntheticMonitoringCheckSettingsPing']:
        """
        Settings for ping (ICMP) check. The target must be a valid hostname or IP address.
        """
        return pulumi.get(self, "ping")

    @property
    @pulumi.getter
    def tcp(self) -> Optional['outputs.SyntheticMonitoringCheckSettingsTcp']:
        """
        Settings for TCP check. The target must be of the form `<host>:<port>`, where the host portion must be a valid hostname or IP address.
        """
        return pulumi.get(self, "tcp")

    @property
    @pulumi.getter
    def traceroute(self) -> Optional['outputs.SyntheticMonitoringCheckSettingsTraceroute']:
        """
        Settings for traceroute check. The target must be a valid hostname or IP address
        """
        return pulumi.get(self, "traceroute")


@pulumi.output_type
class SyntheticMonitoringCheckSettingsDns(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipVersion":
            suggest = "ip_version"
        elif key == "recordType":
            suggest = "record_type"
        elif key == "sourceIpAddress":
            suggest = "source_ip_address"
        elif key == "validRCodes":
            suggest = "valid_r_codes"
        elif key == "validateAdditionalRrs":
            suggest = "validate_additional_rrs"
        elif key == "validateAnswerRrs":
            suggest = "validate_answer_rrs"
        elif key == "validateAuthorityRrs":
            suggest = "validate_authority_rrs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticMonitoringCheckSettingsDns. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticMonitoringCheckSettingsDns.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticMonitoringCheckSettingsDns.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_version: Optional[str] = None,
                 port: Optional[int] = None,
                 protocol: Optional[str] = None,
                 record_type: Optional[str] = None,
                 server: Optional[str] = None,
                 source_ip_address: Optional[str] = None,
                 valid_r_codes: Optional[Sequence[str]] = None,
                 validate_additional_rrs: Optional[Sequence['outputs.SyntheticMonitoringCheckSettingsDnsValidateAdditionalRr']] = None,
                 validate_answer_rrs: Optional['outputs.SyntheticMonitoringCheckSettingsDnsValidateAnswerRrs'] = None,
                 validate_authority_rrs: Optional['outputs.SyntheticMonitoringCheckSettingsDnsValidateAuthorityRrs'] = None):
        if ip_version is not None:
            pulumi.set(__self__, "ip_version", ip_version)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if record_type is not None:
            pulumi.set(__self__, "record_type", record_type)
        if server is not None:
            pulumi.set(__self__, "server", server)
        if source_ip_address is not None:
            pulumi.set(__self__, "source_ip_address", source_ip_address)
        if valid_r_codes is not None:
            pulumi.set(__self__, "valid_r_codes", valid_r_codes)
        if validate_additional_rrs is not None:
            pulumi.set(__self__, "validate_additional_rrs", validate_additional_rrs)
        if validate_answer_rrs is not None:
            pulumi.set(__self__, "validate_answer_rrs", validate_answer_rrs)
        if validate_authority_rrs is not None:
            pulumi.set(__self__, "validate_authority_rrs", validate_authority_rrs)

    @property
    @pulumi.getter(name="ipVersion")
    def ip_version(self) -> Optional[str]:
        return pulumi.get(self, "ip_version")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="recordType")
    def record_type(self) -> Optional[str]:
        return pulumi.get(self, "record_type")

    @property
    @pulumi.getter
    def server(self) -> Optional[str]:
        return pulumi.get(self, "server")

    @property
    @pulumi.getter(name="sourceIpAddress")
    def source_ip_address(self) -> Optional[str]:
        return pulumi.get(self, "source_ip_address")

    @property
    @pulumi.getter(name="validRCodes")
    def valid_r_codes(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "valid_r_codes")

    @property
    @pulumi.getter(name="validateAdditionalRrs")
    def validate_additional_rrs(self) -> Optional[Sequence['outputs.SyntheticMonitoringCheckSettingsDnsValidateAdditionalRr']]:
        return pulumi.get(self, "validate_additional_rrs")

    @property
    @pulumi.getter(name="validateAnswerRrs")
    def validate_answer_rrs(self) -> Optional['outputs.SyntheticMonitoringCheckSettingsDnsValidateAnswerRrs']:
        return pulumi.get(self, "validate_answer_rrs")

    @property
    @pulumi.getter(name="validateAuthorityRrs")
    def validate_authority_rrs(self) -> Optional['outputs.SyntheticMonitoringCheckSettingsDnsValidateAuthorityRrs']:
        return pulumi.get(self, "validate_authority_rrs")


@pulumi.output_type
class SyntheticMonitoringCheckSettingsDnsValidateAdditionalRr(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failIfMatchesRegexps":
            suggest = "fail_if_matches_regexps"
        elif key == "failIfNotMatchesRegexps":
            suggest = "fail_if_not_matches_regexps"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticMonitoringCheckSettingsDnsValidateAdditionalRr. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticMonitoringCheckSettingsDnsValidateAdditionalRr.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticMonitoringCheckSettingsDnsValidateAdditionalRr.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fail_if_matches_regexps: Optional[Sequence[str]] = None,
                 fail_if_not_matches_regexps: Optional[Sequence[str]] = None):
        if fail_if_matches_regexps is not None:
            pulumi.set(__self__, "fail_if_matches_regexps", fail_if_matches_regexps)
        if fail_if_not_matches_regexps is not None:
            pulumi.set(__self__, "fail_if_not_matches_regexps", fail_if_not_matches_regexps)

    @property
    @pulumi.getter(name="failIfMatchesRegexps")
    def fail_if_matches_regexps(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "fail_if_matches_regexps")

    @property
    @pulumi.getter(name="failIfNotMatchesRegexps")
    def fail_if_not_matches_regexps(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "fail_if_not_matches_regexps")


@pulumi.output_type
class SyntheticMonitoringCheckSettingsDnsValidateAnswerRrs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failIfMatchesRegexps":
            suggest = "fail_if_matches_regexps"
        elif key == "failIfNotMatchesRegexps":
            suggest = "fail_if_not_matches_regexps"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticMonitoringCheckSettingsDnsValidateAnswerRrs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticMonitoringCheckSettingsDnsValidateAnswerRrs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticMonitoringCheckSettingsDnsValidateAnswerRrs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fail_if_matches_regexps: Optional[Sequence[str]] = None,
                 fail_if_not_matches_regexps: Optional[Sequence[str]] = None):
        if fail_if_matches_regexps is not None:
            pulumi.set(__self__, "fail_if_matches_regexps", fail_if_matches_regexps)
        if fail_if_not_matches_regexps is not None:
            pulumi.set(__self__, "fail_if_not_matches_regexps", fail_if_not_matches_regexps)

    @property
    @pulumi.getter(name="failIfMatchesRegexps")
    def fail_if_matches_regexps(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "fail_if_matches_regexps")

    @property
    @pulumi.getter(name="failIfNotMatchesRegexps")
    def fail_if_not_matches_regexps(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "fail_if_not_matches_regexps")


@pulumi.output_type
class SyntheticMonitoringCheckSettingsDnsValidateAuthorityRrs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failIfMatchesRegexps":
            suggest = "fail_if_matches_regexps"
        elif key == "failIfNotMatchesRegexps":
            suggest = "fail_if_not_matches_regexps"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticMonitoringCheckSettingsDnsValidateAuthorityRrs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticMonitoringCheckSettingsDnsValidateAuthorityRrs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticMonitoringCheckSettingsDnsValidateAuthorityRrs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fail_if_matches_regexps: Optional[Sequence[str]] = None,
                 fail_if_not_matches_regexps: Optional[Sequence[str]] = None):
        if fail_if_matches_regexps is not None:
            pulumi.set(__self__, "fail_if_matches_regexps", fail_if_matches_regexps)
        if fail_if_not_matches_regexps is not None:
            pulumi.set(__self__, "fail_if_not_matches_regexps", fail_if_not_matches_regexps)

    @property
    @pulumi.getter(name="failIfMatchesRegexps")
    def fail_if_matches_regexps(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "fail_if_matches_regexps")

    @property
    @pulumi.getter(name="failIfNotMatchesRegexps")
    def fail_if_not_matches_regexps(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "fail_if_not_matches_regexps")


@pulumi.output_type
class SyntheticMonitoringCheckSettingsHttp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "basicAuth":
            suggest = "basic_auth"
        elif key == "bearerToken":
            suggest = "bearer_token"
        elif key == "cacheBustingQueryParamName":
            suggest = "cache_busting_query_param_name"
        elif key == "failIfBodyMatchesRegexps":
            suggest = "fail_if_body_matches_regexps"
        elif key == "failIfBodyNotMatchesRegexps":
            suggest = "fail_if_body_not_matches_regexps"
        elif key == "failIfHeaderMatchesRegexps":
            suggest = "fail_if_header_matches_regexps"
        elif key == "failIfHeaderNotMatchesRegexps":
            suggest = "fail_if_header_not_matches_regexps"
        elif key == "failIfNotSsl":
            suggest = "fail_if_not_ssl"
        elif key == "failIfSsl":
            suggest = "fail_if_ssl"
        elif key == "ipVersion":
            suggest = "ip_version"
        elif key == "noFollowRedirects":
            suggest = "no_follow_redirects"
        elif key == "proxyUrl":
            suggest = "proxy_url"
        elif key == "tlsConfig":
            suggest = "tls_config"
        elif key == "validHttpVersions":
            suggest = "valid_http_versions"
        elif key == "validStatusCodes":
            suggest = "valid_status_codes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticMonitoringCheckSettingsHttp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticMonitoringCheckSettingsHttp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticMonitoringCheckSettingsHttp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 basic_auth: Optional['outputs.SyntheticMonitoringCheckSettingsHttpBasicAuth'] = None,
                 bearer_token: Optional[str] = None,
                 body: Optional[str] = None,
                 cache_busting_query_param_name: Optional[str] = None,
                 fail_if_body_matches_regexps: Optional[Sequence[str]] = None,
                 fail_if_body_not_matches_regexps: Optional[Sequence[str]] = None,
                 fail_if_header_matches_regexps: Optional[Sequence['outputs.SyntheticMonitoringCheckSettingsHttpFailIfHeaderMatchesRegexp']] = None,
                 fail_if_header_not_matches_regexps: Optional[Sequence['outputs.SyntheticMonitoringCheckSettingsHttpFailIfHeaderNotMatchesRegexp']] = None,
                 fail_if_not_ssl: Optional[bool] = None,
                 fail_if_ssl: Optional[bool] = None,
                 headers: Optional[Sequence[str]] = None,
                 ip_version: Optional[str] = None,
                 method: Optional[str] = None,
                 no_follow_redirects: Optional[bool] = None,
                 proxy_url: Optional[str] = None,
                 tls_config: Optional['outputs.SyntheticMonitoringCheckSettingsHttpTlsConfig'] = None,
                 valid_http_versions: Optional[Sequence[str]] = None,
                 valid_status_codes: Optional[Sequence[int]] = None):
        if basic_auth is not None:
            pulumi.set(__self__, "basic_auth", basic_auth)
        if bearer_token is not None:
            pulumi.set(__self__, "bearer_token", bearer_token)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cache_busting_query_param_name is not None:
            pulumi.set(__self__, "cache_busting_query_param_name", cache_busting_query_param_name)
        if fail_if_body_matches_regexps is not None:
            pulumi.set(__self__, "fail_if_body_matches_regexps", fail_if_body_matches_regexps)
        if fail_if_body_not_matches_regexps is not None:
            pulumi.set(__self__, "fail_if_body_not_matches_regexps", fail_if_body_not_matches_regexps)
        if fail_if_header_matches_regexps is not None:
            pulumi.set(__self__, "fail_if_header_matches_regexps", fail_if_header_matches_regexps)
        if fail_if_header_not_matches_regexps is not None:
            pulumi.set(__self__, "fail_if_header_not_matches_regexps", fail_if_header_not_matches_regexps)
        if fail_if_not_ssl is not None:
            pulumi.set(__self__, "fail_if_not_ssl", fail_if_not_ssl)
        if fail_if_ssl is not None:
            pulumi.set(__self__, "fail_if_ssl", fail_if_ssl)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ip_version is not None:
            pulumi.set(__self__, "ip_version", ip_version)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if no_follow_redirects is not None:
            pulumi.set(__self__, "no_follow_redirects", no_follow_redirects)
        if proxy_url is not None:
            pulumi.set(__self__, "proxy_url", proxy_url)
        if tls_config is not None:
            pulumi.set(__self__, "tls_config", tls_config)
        if valid_http_versions is not None:
            pulumi.set(__self__, "valid_http_versions", valid_http_versions)
        if valid_status_codes is not None:
            pulumi.set(__self__, "valid_status_codes", valid_status_codes)

    @property
    @pulumi.getter(name="basicAuth")
    def basic_auth(self) -> Optional['outputs.SyntheticMonitoringCheckSettingsHttpBasicAuth']:
        return pulumi.get(self, "basic_auth")

    @property
    @pulumi.getter(name="bearerToken")
    def bearer_token(self) -> Optional[str]:
        return pulumi.get(self, "bearer_token")

    @property
    @pulumi.getter
    def body(self) -> Optional[str]:
        return pulumi.get(self, "body")

    @property
    @pulumi.getter(name="cacheBustingQueryParamName")
    def cache_busting_query_param_name(self) -> Optional[str]:
        return pulumi.get(self, "cache_busting_query_param_name")

    @property
    @pulumi.getter(name="failIfBodyMatchesRegexps")
    def fail_if_body_matches_regexps(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "fail_if_body_matches_regexps")

    @property
    @pulumi.getter(name="failIfBodyNotMatchesRegexps")
    def fail_if_body_not_matches_regexps(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "fail_if_body_not_matches_regexps")

    @property
    @pulumi.getter(name="failIfHeaderMatchesRegexps")
    def fail_if_header_matches_regexps(self) -> Optional[Sequence['outputs.SyntheticMonitoringCheckSettingsHttpFailIfHeaderMatchesRegexp']]:
        return pulumi.get(self, "fail_if_header_matches_regexps")

    @property
    @pulumi.getter(name="failIfHeaderNotMatchesRegexps")
    def fail_if_header_not_matches_regexps(self) -> Optional[Sequence['outputs.SyntheticMonitoringCheckSettingsHttpFailIfHeaderNotMatchesRegexp']]:
        return pulumi.get(self, "fail_if_header_not_matches_regexps")

    @property
    @pulumi.getter(name="failIfNotSsl")
    def fail_if_not_ssl(self) -> Optional[bool]:
        return pulumi.get(self, "fail_if_not_ssl")

    @property
    @pulumi.getter(name="failIfSsl")
    def fail_if_ssl(self) -> Optional[bool]:
        return pulumi.get(self, "fail_if_ssl")

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="ipVersion")
    def ip_version(self) -> Optional[str]:
        return pulumi.get(self, "ip_version")

    @property
    @pulumi.getter
    def method(self) -> Optional[str]:
        return pulumi.get(self, "method")

    @property
    @pulumi.getter(name="noFollowRedirects")
    def no_follow_redirects(self) -> Optional[bool]:
        return pulumi.get(self, "no_follow_redirects")

    @property
    @pulumi.getter(name="proxyUrl")
    def proxy_url(self) -> Optional[str]:
        return pulumi.get(self, "proxy_url")

    @property
    @pulumi.getter(name="tlsConfig")
    def tls_config(self) -> Optional['outputs.SyntheticMonitoringCheckSettingsHttpTlsConfig']:
        return pulumi.get(self, "tls_config")

    @property
    @pulumi.getter(name="validHttpVersions")
    def valid_http_versions(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "valid_http_versions")

    @property
    @pulumi.getter(name="validStatusCodes")
    def valid_status_codes(self) -> Optional[Sequence[int]]:
        return pulumi.get(self, "valid_status_codes")


@pulumi.output_type
class SyntheticMonitoringCheckSettingsHttpBasicAuth(dict):
    def __init__(__self__, *,
                 password: str,
                 username: str):
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> str:
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> str:
        return pulumi.get(self, "username")


@pulumi.output_type
class SyntheticMonitoringCheckSettingsHttpFailIfHeaderMatchesRegexp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowMissing":
            suggest = "allow_missing"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticMonitoringCheckSettingsHttpFailIfHeaderMatchesRegexp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticMonitoringCheckSettingsHttpFailIfHeaderMatchesRegexp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticMonitoringCheckSettingsHttpFailIfHeaderMatchesRegexp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 header: str,
                 regexp: str,
                 allow_missing: Optional[bool] = None):
        pulumi.set(__self__, "header", header)
        pulumi.set(__self__, "regexp", regexp)
        if allow_missing is not None:
            pulumi.set(__self__, "allow_missing", allow_missing)

    @property
    @pulumi.getter
    def header(self) -> str:
        return pulumi.get(self, "header")

    @property
    @pulumi.getter
    def regexp(self) -> str:
        return pulumi.get(self, "regexp")

    @property
    @pulumi.getter(name="allowMissing")
    def allow_missing(self) -> Optional[bool]:
        return pulumi.get(self, "allow_missing")


@pulumi.output_type
class SyntheticMonitoringCheckSettingsHttpFailIfHeaderNotMatchesRegexp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowMissing":
            suggest = "allow_missing"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticMonitoringCheckSettingsHttpFailIfHeaderNotMatchesRegexp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticMonitoringCheckSettingsHttpFailIfHeaderNotMatchesRegexp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticMonitoringCheckSettingsHttpFailIfHeaderNotMatchesRegexp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 header: str,
                 regexp: str,
                 allow_missing: Optional[bool] = None):
        pulumi.set(__self__, "header", header)
        pulumi.set(__self__, "regexp", regexp)
        if allow_missing is not None:
            pulumi.set(__self__, "allow_missing", allow_missing)

    @property
    @pulumi.getter
    def header(self) -> str:
        return pulumi.get(self, "header")

    @property
    @pulumi.getter
    def regexp(self) -> str:
        return pulumi.get(self, "regexp")

    @property
    @pulumi.getter(name="allowMissing")
    def allow_missing(self) -> Optional[bool]:
        return pulumi.get(self, "allow_missing")


@pulumi.output_type
class SyntheticMonitoringCheckSettingsHttpTlsConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caCert":
            suggest = "ca_cert"
        elif key == "clientCert":
            suggest = "client_cert"
        elif key == "clientKey":
            suggest = "client_key"
        elif key == "insecureSkipVerify":
            suggest = "insecure_skip_verify"
        elif key == "serverName":
            suggest = "server_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticMonitoringCheckSettingsHttpTlsConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticMonitoringCheckSettingsHttpTlsConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticMonitoringCheckSettingsHttpTlsConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ca_cert: Optional[str] = None,
                 client_cert: Optional[str] = None,
                 client_key: Optional[str] = None,
                 insecure_skip_verify: Optional[bool] = None,
                 server_name: Optional[str] = None):
        if ca_cert is not None:
            pulumi.set(__self__, "ca_cert", ca_cert)
        if client_cert is not None:
            pulumi.set(__self__, "client_cert", client_cert)
        if client_key is not None:
            pulumi.set(__self__, "client_key", client_key)
        if insecure_skip_verify is not None:
            pulumi.set(__self__, "insecure_skip_verify", insecure_skip_verify)
        if server_name is not None:
            pulumi.set(__self__, "server_name", server_name)

    @property
    @pulumi.getter(name="caCert")
    def ca_cert(self) -> Optional[str]:
        return pulumi.get(self, "ca_cert")

    @property
    @pulumi.getter(name="clientCert")
    def client_cert(self) -> Optional[str]:
        return pulumi.get(self, "client_cert")

    @property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> Optional[str]:
        return pulumi.get(self, "client_key")

    @property
    @pulumi.getter(name="insecureSkipVerify")
    def insecure_skip_verify(self) -> Optional[bool]:
        return pulumi.get(self, "insecure_skip_verify")

    @property
    @pulumi.getter(name="serverName")
    def server_name(self) -> Optional[str]:
        return pulumi.get(self, "server_name")


@pulumi.output_type
class SyntheticMonitoringCheckSettingsPing(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dontFragment":
            suggest = "dont_fragment"
        elif key == "ipVersion":
            suggest = "ip_version"
        elif key == "payloadSize":
            suggest = "payload_size"
        elif key == "sourceIpAddress":
            suggest = "source_ip_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticMonitoringCheckSettingsPing. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticMonitoringCheckSettingsPing.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticMonitoringCheckSettingsPing.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dont_fragment: Optional[bool] = None,
                 ip_version: Optional[str] = None,
                 payload_size: Optional[int] = None,
                 source_ip_address: Optional[str] = None):
        if dont_fragment is not None:
            pulumi.set(__self__, "dont_fragment", dont_fragment)
        if ip_version is not None:
            pulumi.set(__self__, "ip_version", ip_version)
        if payload_size is not None:
            pulumi.set(__self__, "payload_size", payload_size)
        if source_ip_address is not None:
            pulumi.set(__self__, "source_ip_address", source_ip_address)

    @property
    @pulumi.getter(name="dontFragment")
    def dont_fragment(self) -> Optional[bool]:
        return pulumi.get(self, "dont_fragment")

    @property
    @pulumi.getter(name="ipVersion")
    def ip_version(self) -> Optional[str]:
        return pulumi.get(self, "ip_version")

    @property
    @pulumi.getter(name="payloadSize")
    def payload_size(self) -> Optional[int]:
        return pulumi.get(self, "payload_size")

    @property
    @pulumi.getter(name="sourceIpAddress")
    def source_ip_address(self) -> Optional[str]:
        return pulumi.get(self, "source_ip_address")


@pulumi.output_type
class SyntheticMonitoringCheckSettingsTcp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipVersion":
            suggest = "ip_version"
        elif key == "queryResponses":
            suggest = "query_responses"
        elif key == "sourceIpAddress":
            suggest = "source_ip_address"
        elif key == "tlsConfig":
            suggest = "tls_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticMonitoringCheckSettingsTcp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticMonitoringCheckSettingsTcp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticMonitoringCheckSettingsTcp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_version: Optional[str] = None,
                 query_responses: Optional[Sequence['outputs.SyntheticMonitoringCheckSettingsTcpQueryResponse']] = None,
                 source_ip_address: Optional[str] = None,
                 tls: Optional[bool] = None,
                 tls_config: Optional['outputs.SyntheticMonitoringCheckSettingsTcpTlsConfig'] = None):
        if ip_version is not None:
            pulumi.set(__self__, "ip_version", ip_version)
        if query_responses is not None:
            pulumi.set(__self__, "query_responses", query_responses)
        if source_ip_address is not None:
            pulumi.set(__self__, "source_ip_address", source_ip_address)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)
        if tls_config is not None:
            pulumi.set(__self__, "tls_config", tls_config)

    @property
    @pulumi.getter(name="ipVersion")
    def ip_version(self) -> Optional[str]:
        return pulumi.get(self, "ip_version")

    @property
    @pulumi.getter(name="queryResponses")
    def query_responses(self) -> Optional[Sequence['outputs.SyntheticMonitoringCheckSettingsTcpQueryResponse']]:
        return pulumi.get(self, "query_responses")

    @property
    @pulumi.getter(name="sourceIpAddress")
    def source_ip_address(self) -> Optional[str]:
        return pulumi.get(self, "source_ip_address")

    @property
    @pulumi.getter
    def tls(self) -> Optional[bool]:
        return pulumi.get(self, "tls")

    @property
    @pulumi.getter(name="tlsConfig")
    def tls_config(self) -> Optional['outputs.SyntheticMonitoringCheckSettingsTcpTlsConfig']:
        return pulumi.get(self, "tls_config")


@pulumi.output_type
class SyntheticMonitoringCheckSettingsTcpQueryResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "startTls":
            suggest = "start_tls"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticMonitoringCheckSettingsTcpQueryResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticMonitoringCheckSettingsTcpQueryResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticMonitoringCheckSettingsTcpQueryResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 expect: str,
                 send: str,
                 start_tls: Optional[bool] = None):
        pulumi.set(__self__, "expect", expect)
        pulumi.set(__self__, "send", send)
        if start_tls is not None:
            pulumi.set(__self__, "start_tls", start_tls)

    @property
    @pulumi.getter
    def expect(self) -> str:
        return pulumi.get(self, "expect")

    @property
    @pulumi.getter
    def send(self) -> str:
        return pulumi.get(self, "send")

    @property
    @pulumi.getter(name="startTls")
    def start_tls(self) -> Optional[bool]:
        return pulumi.get(self, "start_tls")


@pulumi.output_type
class SyntheticMonitoringCheckSettingsTcpTlsConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caCert":
            suggest = "ca_cert"
        elif key == "clientCert":
            suggest = "client_cert"
        elif key == "clientKey":
            suggest = "client_key"
        elif key == "insecureSkipVerify":
            suggest = "insecure_skip_verify"
        elif key == "serverName":
            suggest = "server_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticMonitoringCheckSettingsTcpTlsConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticMonitoringCheckSettingsTcpTlsConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticMonitoringCheckSettingsTcpTlsConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ca_cert: Optional[str] = None,
                 client_cert: Optional[str] = None,
                 client_key: Optional[str] = None,
                 insecure_skip_verify: Optional[bool] = None,
                 server_name: Optional[str] = None):
        if ca_cert is not None:
            pulumi.set(__self__, "ca_cert", ca_cert)
        if client_cert is not None:
            pulumi.set(__self__, "client_cert", client_cert)
        if client_key is not None:
            pulumi.set(__self__, "client_key", client_key)
        if insecure_skip_verify is not None:
            pulumi.set(__self__, "insecure_skip_verify", insecure_skip_verify)
        if server_name is not None:
            pulumi.set(__self__, "server_name", server_name)

    @property
    @pulumi.getter(name="caCert")
    def ca_cert(self) -> Optional[str]:
        return pulumi.get(self, "ca_cert")

    @property
    @pulumi.getter(name="clientCert")
    def client_cert(self) -> Optional[str]:
        return pulumi.get(self, "client_cert")

    @property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> Optional[str]:
        return pulumi.get(self, "client_key")

    @property
    @pulumi.getter(name="insecureSkipVerify")
    def insecure_skip_verify(self) -> Optional[bool]:
        return pulumi.get(self, "insecure_skip_verify")

    @property
    @pulumi.getter(name="serverName")
    def server_name(self) -> Optional[str]:
        return pulumi.get(self, "server_name")


@pulumi.output_type
class SyntheticMonitoringCheckSettingsTraceroute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxHops":
            suggest = "max_hops"
        elif key == "maxUnknownHops":
            suggest = "max_unknown_hops"
        elif key == "ptrLookup":
            suggest = "ptr_lookup"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticMonitoringCheckSettingsTraceroute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticMonitoringCheckSettingsTraceroute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticMonitoringCheckSettingsTraceroute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_hops: Optional[int] = None,
                 max_unknown_hops: Optional[int] = None,
                 ptr_lookup: Optional[bool] = None):
        if max_hops is not None:
            pulumi.set(__self__, "max_hops", max_hops)
        if max_unknown_hops is not None:
            pulumi.set(__self__, "max_unknown_hops", max_unknown_hops)
        if ptr_lookup is not None:
            pulumi.set(__self__, "ptr_lookup", ptr_lookup)

    @property
    @pulumi.getter(name="maxHops")
    def max_hops(self) -> Optional[int]:
        return pulumi.get(self, "max_hops")

    @property
    @pulumi.getter(name="maxUnknownHops")
    def max_unknown_hops(self) -> Optional[int]:
        return pulumi.get(self, "max_unknown_hops")

    @property
    @pulumi.getter(name="ptrLookup")
    def ptr_lookup(self) -> Optional[bool]:
        return pulumi.get(self, "ptr_lookup")


@pulumi.output_type
class GetDashboardsDashboardResult(dict):
    def __init__(__self__, *,
                 folder_title: str,
                 title: str,
                 uid: str):
        pulumi.set(__self__, "folder_title", folder_title)
        pulumi.set(__self__, "title", title)
        pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="folderTitle")
    def folder_title(self) -> str:
        return pulumi.get(self, "folder_title")

    @property
    @pulumi.getter
    def title(self) -> str:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def uid(self) -> str:
        return pulumi.get(self, "uid")


@pulumi.output_type
class GetFoldersFolderResult(dict):
    def __init__(__self__, *,
                 id: int,
                 title: str,
                 uid: str,
                 url: str):
        """
        :param int id: The ID of this resource.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "title", title)
        pulumi.set(__self__, "uid", uid)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def id(self) -> int:
        """
        The ID of this resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def title(self) -> str:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def uid(self) -> str:
        return pulumi.get(self, "uid")

    @property
    @pulumi.getter
    def url(self) -> str:
        return pulumi.get(self, "url")


