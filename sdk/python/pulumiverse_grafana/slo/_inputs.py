# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'SLOAlertingArgs',
    'SLOAlertingArgsDict',
    'SLOAlertingAdvancedOptionsArgs',
    'SLOAlertingAdvancedOptionsArgsDict',
    'SLOAlertingAnnotationArgs',
    'SLOAlertingAnnotationArgsDict',
    'SLOAlertingFastburnArgs',
    'SLOAlertingFastburnArgsDict',
    'SLOAlertingFastburnAnnotationArgs',
    'SLOAlertingFastburnAnnotationArgsDict',
    'SLOAlertingFastburnLabelArgs',
    'SLOAlertingFastburnLabelArgsDict',
    'SLOAlertingLabelArgs',
    'SLOAlertingLabelArgsDict',
    'SLOAlertingSlowburnArgs',
    'SLOAlertingSlowburnArgsDict',
    'SLOAlertingSlowburnAnnotationArgs',
    'SLOAlertingSlowburnAnnotationArgsDict',
    'SLOAlertingSlowburnLabelArgs',
    'SLOAlertingSlowburnLabelArgsDict',
    'SLODestinationDatasourceArgs',
    'SLODestinationDatasourceArgsDict',
    'SLOLabelArgs',
    'SLOLabelArgsDict',
    'SLOObjectiveArgs',
    'SLOObjectiveArgsDict',
    'SLOQueryArgs',
    'SLOQueryArgsDict',
    'SLOQueryFreeformArgs',
    'SLOQueryFreeformArgsDict',
    'SLOQueryGrafanaQueriesArgs',
    'SLOQueryGrafanaQueriesArgsDict',
    'SLOQueryRatioArgs',
    'SLOQueryRatioArgsDict',
]

MYPY = False

if not MYPY:
    class SLOAlertingArgsDict(TypedDict):
        advanced_options: NotRequired[pulumi.Input['SLOAlertingAdvancedOptionsArgsDict']]
        """
        Advanced Options for Alert Rules
        """
        annotations: NotRequired[pulumi.Input[Sequence[pulumi.Input['SLOAlertingAnnotationArgsDict']]]]
        """
        Annotations will be attached to all alerts generated by any of these rules.
        """
        fastburns: NotRequired[pulumi.Input[Sequence[pulumi.Input['SLOAlertingFastburnArgsDict']]]]
        """
        Alerting Rules generated for Fast Burn alerts
        """
        labels: NotRequired[pulumi.Input[Sequence[pulumi.Input['SLOAlertingLabelArgsDict']]]]
        """
        Labels will be attached to all alerts generated by any of these rules.
        """
        slowburns: NotRequired[pulumi.Input[Sequence[pulumi.Input['SLOAlertingSlowburnArgsDict']]]]
        """
        Alerting Rules generated for Slow Burn alerts
        """
elif False:
    SLOAlertingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SLOAlertingArgs:
    def __init__(__self__, *,
                 advanced_options: Optional[pulumi.Input['SLOAlertingAdvancedOptionsArgs']] = None,
                 annotations: Optional[pulumi.Input[Sequence[pulumi.Input['SLOAlertingAnnotationArgs']]]] = None,
                 fastburns: Optional[pulumi.Input[Sequence[pulumi.Input['SLOAlertingFastburnArgs']]]] = None,
                 labels: Optional[pulumi.Input[Sequence[pulumi.Input['SLOAlertingLabelArgs']]]] = None,
                 slowburns: Optional[pulumi.Input[Sequence[pulumi.Input['SLOAlertingSlowburnArgs']]]] = None):
        """
        :param pulumi.Input['SLOAlertingAdvancedOptionsArgs'] advanced_options: Advanced Options for Alert Rules
        :param pulumi.Input[Sequence[pulumi.Input['SLOAlertingAnnotationArgs']]] annotations: Annotations will be attached to all alerts generated by any of these rules.
        :param pulumi.Input[Sequence[pulumi.Input['SLOAlertingFastburnArgs']]] fastburns: Alerting Rules generated for Fast Burn alerts
        :param pulumi.Input[Sequence[pulumi.Input['SLOAlertingLabelArgs']]] labels: Labels will be attached to all alerts generated by any of these rules.
        :param pulumi.Input[Sequence[pulumi.Input['SLOAlertingSlowburnArgs']]] slowburns: Alerting Rules generated for Slow Burn alerts
        """
        if advanced_options is not None:
            pulumi.set(__self__, "advanced_options", advanced_options)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if fastburns is not None:
            pulumi.set(__self__, "fastburns", fastburns)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if slowburns is not None:
            pulumi.set(__self__, "slowburns", slowburns)

    @property
    @pulumi.getter(name="advancedOptions")
    def advanced_options(self) -> Optional[pulumi.Input['SLOAlertingAdvancedOptionsArgs']]:
        """
        Advanced Options for Alert Rules
        """
        return pulumi.get(self, "advanced_options")

    @advanced_options.setter
    def advanced_options(self, value: Optional[pulumi.Input['SLOAlertingAdvancedOptionsArgs']]):
        pulumi.set(self, "advanced_options", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SLOAlertingAnnotationArgs']]]]:
        """
        Annotations will be attached to all alerts generated by any of these rules.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SLOAlertingAnnotationArgs']]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def fastburns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SLOAlertingFastburnArgs']]]]:
        """
        Alerting Rules generated for Fast Burn alerts
        """
        return pulumi.get(self, "fastburns")

    @fastburns.setter
    def fastburns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SLOAlertingFastburnArgs']]]]):
        pulumi.set(self, "fastburns", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SLOAlertingLabelArgs']]]]:
        """
        Labels will be attached to all alerts generated by any of these rules.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SLOAlertingLabelArgs']]]]):
        pulumi.set(self, "labels", value)

    @property
    @pulumi.getter
    def slowburns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SLOAlertingSlowburnArgs']]]]:
        """
        Alerting Rules generated for Slow Burn alerts
        """
        return pulumi.get(self, "slowburns")

    @slowburns.setter
    def slowburns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SLOAlertingSlowburnArgs']]]]):
        pulumi.set(self, "slowburns", value)


if not MYPY:
    class SLOAlertingAdvancedOptionsArgsDict(TypedDict):
        min_failures: NotRequired[pulumi.Input[int]]
        """
        Minimum number of failed events to trigger an alert
        """
elif False:
    SLOAlertingAdvancedOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SLOAlertingAdvancedOptionsArgs:
    def __init__(__self__, *,
                 min_failures: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] min_failures: Minimum number of failed events to trigger an alert
        """
        if min_failures is not None:
            pulumi.set(__self__, "min_failures", min_failures)

    @property
    @pulumi.getter(name="minFailures")
    def min_failures(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum number of failed events to trigger an alert
        """
        return pulumi.get(self, "min_failures")

    @min_failures.setter
    def min_failures(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_failures", value)


if not MYPY:
    class SLOAlertingAnnotationArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        Key for filtering and identification
        """
        value: pulumi.Input[str]
        """
        Templatable value
        """
elif False:
    SLOAlertingAnnotationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SLOAlertingAnnotationArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: Key for filtering and identification
        :param pulumi.Input[str] value: Templatable value
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Key for filtering and identification
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Templatable value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class SLOAlertingFastburnArgsDict(TypedDict):
        annotations: NotRequired[pulumi.Input[Sequence[pulumi.Input['SLOAlertingFastburnAnnotationArgsDict']]]]
        """
        Annotations to attach only to Fast Burn alerts.
        """
        labels: NotRequired[pulumi.Input[Sequence[pulumi.Input['SLOAlertingFastburnLabelArgsDict']]]]
        """
        Labels to attach only to Fast Burn alerts.
        """
elif False:
    SLOAlertingFastburnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SLOAlertingFastburnArgs:
    def __init__(__self__, *,
                 annotations: Optional[pulumi.Input[Sequence[pulumi.Input['SLOAlertingFastburnAnnotationArgs']]]] = None,
                 labels: Optional[pulumi.Input[Sequence[pulumi.Input['SLOAlertingFastburnLabelArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['SLOAlertingFastburnAnnotationArgs']]] annotations: Annotations to attach only to Fast Burn alerts.
        :param pulumi.Input[Sequence[pulumi.Input['SLOAlertingFastburnLabelArgs']]] labels: Labels to attach only to Fast Burn alerts.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SLOAlertingFastburnAnnotationArgs']]]]:
        """
        Annotations to attach only to Fast Burn alerts.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SLOAlertingFastburnAnnotationArgs']]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SLOAlertingFastburnLabelArgs']]]]:
        """
        Labels to attach only to Fast Burn alerts.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SLOAlertingFastburnLabelArgs']]]]):
        pulumi.set(self, "labels", value)


if not MYPY:
    class SLOAlertingFastburnAnnotationArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        Key for filtering and identification
        """
        value: pulumi.Input[str]
        """
        Templatable value
        """
elif False:
    SLOAlertingFastburnAnnotationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SLOAlertingFastburnAnnotationArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: Key for filtering and identification
        :param pulumi.Input[str] value: Templatable value
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Key for filtering and identification
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Templatable value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class SLOAlertingFastburnLabelArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        Key for filtering and identification
        """
        value: pulumi.Input[str]
        """
        Templatable value
        """
elif False:
    SLOAlertingFastburnLabelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SLOAlertingFastburnLabelArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: Key for filtering and identification
        :param pulumi.Input[str] value: Templatable value
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Key for filtering and identification
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Templatable value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class SLOAlertingLabelArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        Key for filtering and identification
        """
        value: pulumi.Input[str]
        """
        Templatable value
        """
elif False:
    SLOAlertingLabelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SLOAlertingLabelArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: Key for filtering and identification
        :param pulumi.Input[str] value: Templatable value
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Key for filtering and identification
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Templatable value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class SLOAlertingSlowburnArgsDict(TypedDict):
        annotations: NotRequired[pulumi.Input[Sequence[pulumi.Input['SLOAlertingSlowburnAnnotationArgsDict']]]]
        """
        Annotations to attach only to Slow Burn alerts.
        """
        labels: NotRequired[pulumi.Input[Sequence[pulumi.Input['SLOAlertingSlowburnLabelArgsDict']]]]
        """
        Labels to attach only to Slow Burn alerts.
        """
elif False:
    SLOAlertingSlowburnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SLOAlertingSlowburnArgs:
    def __init__(__self__, *,
                 annotations: Optional[pulumi.Input[Sequence[pulumi.Input['SLOAlertingSlowburnAnnotationArgs']]]] = None,
                 labels: Optional[pulumi.Input[Sequence[pulumi.Input['SLOAlertingSlowburnLabelArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['SLOAlertingSlowburnAnnotationArgs']]] annotations: Annotations to attach only to Slow Burn alerts.
        :param pulumi.Input[Sequence[pulumi.Input['SLOAlertingSlowburnLabelArgs']]] labels: Labels to attach only to Slow Burn alerts.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SLOAlertingSlowburnAnnotationArgs']]]]:
        """
        Annotations to attach only to Slow Burn alerts.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SLOAlertingSlowburnAnnotationArgs']]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SLOAlertingSlowburnLabelArgs']]]]:
        """
        Labels to attach only to Slow Burn alerts.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SLOAlertingSlowburnLabelArgs']]]]):
        pulumi.set(self, "labels", value)


if not MYPY:
    class SLOAlertingSlowburnAnnotationArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        Key for filtering and identification
        """
        value: pulumi.Input[str]
        """
        Templatable value
        """
elif False:
    SLOAlertingSlowburnAnnotationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SLOAlertingSlowburnAnnotationArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: Key for filtering and identification
        :param pulumi.Input[str] value: Templatable value
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Key for filtering and identification
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Templatable value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class SLOAlertingSlowburnLabelArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        Key for filtering and identification
        """
        value: pulumi.Input[str]
        """
        Templatable value
        """
elif False:
    SLOAlertingSlowburnLabelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SLOAlertingSlowburnLabelArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: Key for filtering and identification
        :param pulumi.Input[str] value: Templatable value
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Key for filtering and identification
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Templatable value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class SLODestinationDatasourceArgsDict(TypedDict):
        uid: pulumi.Input[str]
        """
        UID for the Datasource
        """
elif False:
    SLODestinationDatasourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SLODestinationDatasourceArgs:
    def __init__(__self__, *,
                 uid: pulumi.Input[str]):
        """
        :param pulumi.Input[str] uid: UID for the Datasource
        """
        pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter
    def uid(self) -> pulumi.Input[str]:
        """
        UID for the Datasource
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: pulumi.Input[str]):
        pulumi.set(self, "uid", value)


if not MYPY:
    class SLOLabelArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        Key for filtering and identification
        """
        value: pulumi.Input[str]
        """
        Templatable value
        """
elif False:
    SLOLabelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SLOLabelArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: Key for filtering and identification
        :param pulumi.Input[str] value: Templatable value
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Key for filtering and identification
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Templatable value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class SLOObjectiveArgsDict(TypedDict):
        value: pulumi.Input[float]
        """
        Value between 0 and 1. If the value of the query is above the objective, the SLO is met.
        """
        window: pulumi.Input[str]
        """
        A Prometheus-parsable time duration string like 24h, 60m. This is the time window the objective is measured over.
        """
elif False:
    SLOObjectiveArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SLOObjectiveArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[float],
                 window: pulumi.Input[str]):
        """
        :param pulumi.Input[float] value: Value between 0 and 1. If the value of the query is above the objective, the SLO is met.
        :param pulumi.Input[str] window: A Prometheus-parsable time duration string like 24h, 60m. This is the time window the objective is measured over.
        """
        pulumi.set(__self__, "value", value)
        pulumi.set(__self__, "window", window)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[float]:
        """
        Value between 0 and 1. If the value of the query is above the objective, the SLO is met.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[float]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def window(self) -> pulumi.Input[str]:
        """
        A Prometheus-parsable time duration string like 24h, 60m. This is the time window the objective is measured over.
        """
        return pulumi.get(self, "window")

    @window.setter
    def window(self, value: pulumi.Input[str]):
        pulumi.set(self, "window", value)


if not MYPY:
    class SLOQueryArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        Query type must be one of: "freeform", "query", "ratio", "grafana_queries" or "threshold"
        """
        freeform: NotRequired[pulumi.Input['SLOQueryFreeformArgsDict']]
        grafana_queries: NotRequired[pulumi.Input['SLOQueryGrafanaQueriesArgsDict']]
        """
        Array for holding a set of grafana queries
        """
        ratio: NotRequired[pulumi.Input['SLOQueryRatioArgsDict']]
elif False:
    SLOQueryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SLOQueryArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 freeform: Optional[pulumi.Input['SLOQueryFreeformArgs']] = None,
                 grafana_queries: Optional[pulumi.Input['SLOQueryGrafanaQueriesArgs']] = None,
                 ratio: Optional[pulumi.Input['SLOQueryRatioArgs']] = None):
        """
        :param pulumi.Input[str] type: Query type must be one of: "freeform", "query", "ratio", "grafana_queries" or "threshold"
        :param pulumi.Input['SLOQueryGrafanaQueriesArgs'] grafana_queries: Array for holding a set of grafana queries
        """
        pulumi.set(__self__, "type", type)
        if freeform is not None:
            pulumi.set(__self__, "freeform", freeform)
        if grafana_queries is not None:
            pulumi.set(__self__, "grafana_queries", grafana_queries)
        if ratio is not None:
            pulumi.set(__self__, "ratio", ratio)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Query type must be one of: "freeform", "query", "ratio", "grafana_queries" or "threshold"
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def freeform(self) -> Optional[pulumi.Input['SLOQueryFreeformArgs']]:
        return pulumi.get(self, "freeform")

    @freeform.setter
    def freeform(self, value: Optional[pulumi.Input['SLOQueryFreeformArgs']]):
        pulumi.set(self, "freeform", value)

    @property
    @pulumi.getter(name="grafanaQueries")
    def grafana_queries(self) -> Optional[pulumi.Input['SLOQueryGrafanaQueriesArgs']]:
        """
        Array for holding a set of grafana queries
        """
        return pulumi.get(self, "grafana_queries")

    @grafana_queries.setter
    def grafana_queries(self, value: Optional[pulumi.Input['SLOQueryGrafanaQueriesArgs']]):
        pulumi.set(self, "grafana_queries", value)

    @property
    @pulumi.getter
    def ratio(self) -> Optional[pulumi.Input['SLOQueryRatioArgs']]:
        return pulumi.get(self, "ratio")

    @ratio.setter
    def ratio(self, value: Optional[pulumi.Input['SLOQueryRatioArgs']]):
        pulumi.set(self, "ratio", value)


if not MYPY:
    class SLOQueryFreeformArgsDict(TypedDict):
        query: pulumi.Input[str]
        """
        Freeform Query Field - valid promQl
        """
elif False:
    SLOQueryFreeformArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SLOQueryFreeformArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str]):
        """
        :param pulumi.Input[str] query: Freeform Query Field - valid promQl
        """
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        Freeform Query Field - valid promQl
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)


if not MYPY:
    class SLOQueryGrafanaQueriesArgsDict(TypedDict):
        grafana_queries: pulumi.Input[str]
        """
        Query Object - Array of Grafana Query JSON objects
        """
elif False:
    SLOQueryGrafanaQueriesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SLOQueryGrafanaQueriesArgs:
    def __init__(__self__, *,
                 grafana_queries: pulumi.Input[str]):
        """
        :param pulumi.Input[str] grafana_queries: Query Object - Array of Grafana Query JSON objects
        """
        pulumi.set(__self__, "grafana_queries", grafana_queries)

    @property
    @pulumi.getter(name="grafanaQueries")
    def grafana_queries(self) -> pulumi.Input[str]:
        """
        Query Object - Array of Grafana Query JSON objects
        """
        return pulumi.get(self, "grafana_queries")

    @grafana_queries.setter
    def grafana_queries(self, value: pulumi.Input[str]):
        pulumi.set(self, "grafana_queries", value)


if not MYPY:
    class SLOQueryRatioArgsDict(TypedDict):
        success_metric: pulumi.Input[str]
        """
        Counter metric for success events (numerator)
        """
        total_metric: pulumi.Input[str]
        """
        Metric for total events (denominator)
        """
        group_by_labels: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Defines Group By Labels used for per-label alerting. These appear as variables on SLO dashboards to enable filtering and aggregation. Labels must adhere to Prometheus label name schema - "^[a-zA-Z*][a-zA-Z0-9*]*$"
        """
elif False:
    SLOQueryRatioArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SLOQueryRatioArgs:
    def __init__(__self__, *,
                 success_metric: pulumi.Input[str],
                 total_metric: pulumi.Input[str],
                 group_by_labels: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] success_metric: Counter metric for success events (numerator)
        :param pulumi.Input[str] total_metric: Metric for total events (denominator)
        :param pulumi.Input[Sequence[pulumi.Input[str]]] group_by_labels: Defines Group By Labels used for per-label alerting. These appear as variables on SLO dashboards to enable filtering and aggregation. Labels must adhere to Prometheus label name schema - "^[a-zA-Z*][a-zA-Z0-9*]*$"
        """
        pulumi.set(__self__, "success_metric", success_metric)
        pulumi.set(__self__, "total_metric", total_metric)
        if group_by_labels is not None:
            pulumi.set(__self__, "group_by_labels", group_by_labels)

    @property
    @pulumi.getter(name="successMetric")
    def success_metric(self) -> pulumi.Input[str]:
        """
        Counter metric for success events (numerator)
        """
        return pulumi.get(self, "success_metric")

    @success_metric.setter
    def success_metric(self, value: pulumi.Input[str]):
        pulumi.set(self, "success_metric", value)

    @property
    @pulumi.getter(name="totalMetric")
    def total_metric(self) -> pulumi.Input[str]:
        """
        Metric for total events (denominator)
        """
        return pulumi.get(self, "total_metric")

    @total_metric.setter
    def total_metric(self, value: pulumi.Input[str]):
        pulumi.set(self, "total_metric", value)

    @property
    @pulumi.getter(name="groupByLabels")
    def group_by_labels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Defines Group By Labels used for per-label alerting. These appear as variables on SLO dashboards to enable filtering and aggregation. Labels must adhere to Prometheus label name schema - "^[a-zA-Z*][a-zA-Z0-9*]*$"
        """
        return pulumi.get(self, "group_by_labels")

    @group_by_labels.setter
    def group_by_labels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "group_by_labels", value)


