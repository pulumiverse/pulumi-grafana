# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'ScheduleCronArgs',
    'ScheduleCronArgsDict',
    'ScheduleRecurrenceRuleArgs',
    'ScheduleRecurrenceRuleArgsDict',
    'GetScheduleCronArgs',
    'GetScheduleCronArgsDict',
    'GetScheduleRecurrenceRuleArgs',
    'GetScheduleRecurrenceRuleArgsDict',
]

MYPY = False

if not MYPY:
    class ScheduleCronArgsDict(TypedDict):
        schedule: NotRequired[pulumi.Input[_builtins.str]]
        """
        A cron expression with exactly 5 entries, or an alias. The allowed aliases are: `@yearly`, `@annually`, `@monthly`, `@weekly`, `@daily`, `@hourly`.
        """
        timezone: NotRequired[pulumi.Input[_builtins.str]]
        """
        The timezone of the cron expression. For example, `UTC` or `Europe/London`.
        """
elif False:
    ScheduleCronArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduleCronArgs:
    def __init__(__self__, *,
                 schedule: Optional[pulumi.Input[_builtins.str]] = None,
                 timezone: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] schedule: A cron expression with exactly 5 entries, or an alias. The allowed aliases are: `@yearly`, `@annually`, `@monthly`, `@weekly`, `@daily`, `@hourly`.
        :param pulumi.Input[_builtins.str] timezone: The timezone of the cron expression. For example, `UTC` or `Europe/London`.
        """
        if schedule is not None:
            pulumi.set(__self__, "schedule", schedule)
        if timezone is not None:
            pulumi.set(__self__, "timezone", timezone)

    @_builtins.property
    @pulumi.getter
    def schedule(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A cron expression with exactly 5 entries, or an alias. The allowed aliases are: `@yearly`, `@annually`, `@monthly`, `@weekly`, `@daily`, `@hourly`.
        """
        return pulumi.get(self, "schedule")

    @schedule.setter
    def schedule(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schedule", value)

    @_builtins.property
    @pulumi.getter
    def timezone(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The timezone of the cron expression. For example, `UTC` or `Europe/London`.
        """
        return pulumi.get(self, "timezone")

    @timezone.setter
    def timezone(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "timezone", value)


if not MYPY:
    class ScheduleRecurrenceRuleArgsDict(TypedDict):
        bydays: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The weekdays when the 'WEEKLY' recurrence will be applied (e.g., ['MO', 'WE', 'FR']). Cannot be set for other frequencies.
        """
        count: NotRequired[pulumi.Input[_builtins.int]]
        """
        How many times the recurrence will repeat.
        """
        frequency: NotRequired[pulumi.Input[_builtins.str]]
        """
        The frequency of the schedule (HOURLY, DAILY, WEEKLY, MONTHLY, YEARLY).
        """
        interval: NotRequired[pulumi.Input[_builtins.int]]
        """
        The interval between each frequency iteration (e.g., 2 = every 2 hours for HOURLY). Defaults to 1.
        """
        until: NotRequired[pulumi.Input[_builtins.str]]
        """
        The end time for the recurrence (RFC3339 format).
        """
elif False:
    ScheduleRecurrenceRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduleRecurrenceRuleArgs:
    def __init__(__self__, *,
                 bydays: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 count: Optional[pulumi.Input[_builtins.int]] = None,
                 frequency: Optional[pulumi.Input[_builtins.str]] = None,
                 interval: Optional[pulumi.Input[_builtins.int]] = None,
                 until: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] bydays: The weekdays when the 'WEEKLY' recurrence will be applied (e.g., ['MO', 'WE', 'FR']). Cannot be set for other frequencies.
        :param pulumi.Input[_builtins.int] count: How many times the recurrence will repeat.
        :param pulumi.Input[_builtins.str] frequency: The frequency of the schedule (HOURLY, DAILY, WEEKLY, MONTHLY, YEARLY).
        :param pulumi.Input[_builtins.int] interval: The interval between each frequency iteration (e.g., 2 = every 2 hours for HOURLY). Defaults to 1.
        :param pulumi.Input[_builtins.str] until: The end time for the recurrence (RFC3339 format).
        """
        if bydays is not None:
            pulumi.set(__self__, "bydays", bydays)
        if count is not None:
            pulumi.set(__self__, "count", count)
        if frequency is not None:
            pulumi.set(__self__, "frequency", frequency)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if until is not None:
            pulumi.set(__self__, "until", until)

    @_builtins.property
    @pulumi.getter
    def bydays(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The weekdays when the 'WEEKLY' recurrence will be applied (e.g., ['MO', 'WE', 'FR']). Cannot be set for other frequencies.
        """
        return pulumi.get(self, "bydays")

    @bydays.setter
    def bydays(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "bydays", value)

    @_builtins.property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        How many times the recurrence will repeat.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "count", value)

    @_builtins.property
    @pulumi.getter
    def frequency(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The frequency of the schedule (HOURLY, DAILY, WEEKLY, MONTHLY, YEARLY).
        """
        return pulumi.get(self, "frequency")

    @frequency.setter
    def frequency(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "frequency", value)

    @_builtins.property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The interval between each frequency iteration (e.g., 2 = every 2 hours for HOURLY). Defaults to 1.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "interval", value)

    @_builtins.property
    @pulumi.getter
    def until(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The end time for the recurrence (RFC3339 format).
        """
        return pulumi.get(self, "until")

    @until.setter
    def until(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "until", value)


if not MYPY:
    class GetScheduleCronArgsDict(TypedDict):
        schedule: _builtins.str
        """
        A cron expression with exactly 5 entries, or an alias. The allowed aliases are: `@yearly`, `@annually`, `@monthly`, `@weekly`, `@daily`, `@hourly`.
        """
        timezone: _builtins.str
        """
        The timezone of the cron expression. For example, `UTC` or `Europe/London`.
        """
elif False:
    GetScheduleCronArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetScheduleCronArgs:
    def __init__(__self__, *,
                 schedule: _builtins.str,
                 timezone: _builtins.str):
        """
        :param _builtins.str schedule: A cron expression with exactly 5 entries, or an alias. The allowed aliases are: `@yearly`, `@annually`, `@monthly`, `@weekly`, `@daily`, `@hourly`.
        :param _builtins.str timezone: The timezone of the cron expression. For example, `UTC` or `Europe/London`.
        """
        pulumi.set(__self__, "schedule", schedule)
        pulumi.set(__self__, "timezone", timezone)

    @_builtins.property
    @pulumi.getter
    def schedule(self) -> _builtins.str:
        """
        A cron expression with exactly 5 entries, or an alias. The allowed aliases are: `@yearly`, `@annually`, `@monthly`, `@weekly`, `@daily`, `@hourly`.
        """
        return pulumi.get(self, "schedule")

    @schedule.setter
    def schedule(self, value: _builtins.str):
        pulumi.set(self, "schedule", value)

    @_builtins.property
    @pulumi.getter
    def timezone(self) -> _builtins.str:
        """
        The timezone of the cron expression. For example, `UTC` or `Europe/London`.
        """
        return pulumi.get(self, "timezone")

    @timezone.setter
    def timezone(self, value: _builtins.str):
        pulumi.set(self, "timezone", value)


if not MYPY:
    class GetScheduleRecurrenceRuleArgsDict(TypedDict):
        bydays: Sequence[_builtins.str]
        """
        The weekdays when the 'WEEKLY' recurrence will be applied (e.g., ['MO', 'WE', 'FR']). Cannot be set for other frequencies.
        """
        count: _builtins.int
        """
        How many times the recurrence will repeat.
        """
        frequency: _builtins.str
        """
        The frequency of the schedule (HOURLY, DAILY, WEEKLY, MONTHLY).
        """
        interval: _builtins.int
        """
        The interval between each frequency iteration (e.g., 2 = every 2 hours for HOURLY).
        """
        until: _builtins.str
        """
        The end time for the recurrence (RFC3339 format).
        """
elif False:
    GetScheduleRecurrenceRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetScheduleRecurrenceRuleArgs:
    def __init__(__self__, *,
                 bydays: Sequence[_builtins.str],
                 count: _builtins.int,
                 frequency: _builtins.str,
                 interval: _builtins.int,
                 until: _builtins.str):
        """
        :param Sequence[_builtins.str] bydays: The weekdays when the 'WEEKLY' recurrence will be applied (e.g., ['MO', 'WE', 'FR']). Cannot be set for other frequencies.
        :param _builtins.int count: How many times the recurrence will repeat.
        :param _builtins.str frequency: The frequency of the schedule (HOURLY, DAILY, WEEKLY, MONTHLY).
        :param _builtins.int interval: The interval between each frequency iteration (e.g., 2 = every 2 hours for HOURLY).
        :param _builtins.str until: The end time for the recurrence (RFC3339 format).
        """
        pulumi.set(__self__, "bydays", bydays)
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "frequency", frequency)
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "until", until)

    @_builtins.property
    @pulumi.getter
    def bydays(self) -> Sequence[_builtins.str]:
        """
        The weekdays when the 'WEEKLY' recurrence will be applied (e.g., ['MO', 'WE', 'FR']). Cannot be set for other frequencies.
        """
        return pulumi.get(self, "bydays")

    @bydays.setter
    def bydays(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "bydays", value)

    @_builtins.property
    @pulumi.getter
    def count(self) -> _builtins.int:
        """
        How many times the recurrence will repeat.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: _builtins.int):
        pulumi.set(self, "count", value)

    @_builtins.property
    @pulumi.getter
    def frequency(self) -> _builtins.str:
        """
        The frequency of the schedule (HOURLY, DAILY, WEEKLY, MONTHLY).
        """
        return pulumi.get(self, "frequency")

    @frequency.setter
    def frequency(self, value: _builtins.str):
        pulumi.set(self, "frequency", value)

    @_builtins.property
    @pulumi.getter
    def interval(self) -> _builtins.int:
        """
        The interval between each frequency iteration (e.g., 2 = every 2 hours for HOURLY).
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: _builtins.int):
        pulumi.set(self, "interval", value)

    @_builtins.property
    @pulumi.getter
    def until(self) -> _builtins.str:
        """
        The end time for the recurrence (RFC3339 format).
        """
        return pulumi.get(self, "until")

    @until.setter
    def until(self, value: _builtins.str):
        pulumi.set(self, "until", value)


