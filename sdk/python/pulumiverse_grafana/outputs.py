# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities
from . import outputs

__all__ = [
    'CloudAccessPolicyCondition',
    'CloudAccessPolicyRealm',
    'CloudAccessPolicyRealmLabelPolicy',
    'ContactPointAlertmanager',
    'ContactPointDingding',
    'ContactPointDiscord',
    'ContactPointEmail',
    'ContactPointGooglechat',
    'ContactPointKafka',
    'ContactPointLine',
    'ContactPointOncall',
    'ContactPointOpsgeny',
    'ContactPointOpsgenyResponder',
    'ContactPointPagerduty',
    'ContactPointPushover',
    'ContactPointSensugo',
    'ContactPointSlack',
    'ContactPointSn',
    'ContactPointTeam',
    'ContactPointTelegram',
    'ContactPointThreema',
    'ContactPointVictorop',
    'ContactPointWebex',
    'ContactPointWebhook',
    'ContactPointWecom',
    'DashboardPermissionPermission',
    'DataSourcePermissionPermission',
    'FolderPermissionPermission',
    'MachineLearningHolidayCustomPeriod',
    'MachineLearningOutlierDetectorAlgorithm',
    'MachineLearningOutlierDetectorAlgorithmConfig',
    'MuteTimingInterval',
    'MuteTimingIntervalTime',
    'NotificationPolicyPolicy',
    'NotificationPolicyPolicyMatcher',
    'NotificationPolicyPolicyPolicy',
    'NotificationPolicyPolicyPolicyMatcher',
    'NotificationPolicyPolicyPolicyPolicy',
    'NotificationPolicyPolicyPolicyPolicyMatcher',
    'NotificationPolicyPolicyPolicyPolicyPolicy',
    'NotificationPolicyPolicyPolicyPolicyPolicyMatcher',
    'OncallIntegrationDefaultRoute',
    'OncallIntegrationDefaultRouteMsteams',
    'OncallIntegrationDefaultRouteSlack',
    'OncallIntegrationDefaultRouteTelegram',
    'OncallIntegrationTemplates',
    'OncallIntegrationTemplatesEmail',
    'OncallIntegrationTemplatesMicrosoftTeams',
    'OncallIntegrationTemplatesMobileApp',
    'OncallIntegrationTemplatesPhoneCall',
    'OncallIntegrationTemplatesSlack',
    'OncallIntegrationTemplatesSms',
    'OncallIntegrationTemplatesTelegram',
    'OncallIntegrationTemplatesWeb',
    'OncallRouteMsteams',
    'OncallRouteSlack',
    'OncallRouteTelegram',
    'OncallScheduleSlack',
    'PlaylistItem',
    'ReportDashboard',
    'ReportDashboardTimeRange',
    'ReportSchedule',
    'RolePermission',
    'RuleGroupRule',
    'RuleGroupRuleData',
    'RuleGroupRuleDataRelativeTimeRange',
    'RuleGroupRuleNotificationSettings',
    'RuleGroupRuleRecord',
    'SLOAlerting',
    'SLOAlertingAdvancedOptions',
    'SLOAlertingAnnotation',
    'SLOAlertingFastburn',
    'SLOAlertingFastburnAnnotation',
    'SLOAlertingFastburnLabel',
    'SLOAlertingLabel',
    'SLOAlertingSlowburn',
    'SLOAlertingSlowburnAnnotation',
    'SLOAlertingSlowburnLabel',
    'SLODestinationDatasource',
    'SLOLabel',
    'SLOObjective',
    'SLOQuery',
    'SLOQueryFreeform',
    'SLOQueryGrafanaQueries',
    'SLOQueryRatio',
    'ServiceAccountPermissionPermission',
    'SsoSettingsLdapSettings',
    'SsoSettingsLdapSettingsConfig',
    'SsoSettingsLdapSettingsConfigServer',
    'SsoSettingsLdapSettingsConfigServerGroupMapping',
    'SsoSettingsOauth2Settings',
    'SsoSettingsSamlSettings',
    'SyntheticMonitoringCheckSettings',
    'SyntheticMonitoringCheckSettingsBrowser',
    'SyntheticMonitoringCheckSettingsDns',
    'SyntheticMonitoringCheckSettingsDnsValidateAdditionalRr',
    'SyntheticMonitoringCheckSettingsDnsValidateAnswerRrs',
    'SyntheticMonitoringCheckSettingsDnsValidateAuthorityRrs',
    'SyntheticMonitoringCheckSettingsGrpc',
    'SyntheticMonitoringCheckSettingsGrpcTlsConfig',
    'SyntheticMonitoringCheckSettingsHttp',
    'SyntheticMonitoringCheckSettingsHttpBasicAuth',
    'SyntheticMonitoringCheckSettingsHttpFailIfHeaderMatchesRegexp',
    'SyntheticMonitoringCheckSettingsHttpFailIfHeaderNotMatchesRegexp',
    'SyntheticMonitoringCheckSettingsHttpTlsConfig',
    'SyntheticMonitoringCheckSettingsMultihttp',
    'SyntheticMonitoringCheckSettingsMultihttpEntry',
    'SyntheticMonitoringCheckSettingsMultihttpEntryAssertion',
    'SyntheticMonitoringCheckSettingsMultihttpEntryRequest',
    'SyntheticMonitoringCheckSettingsMultihttpEntryRequestBody',
    'SyntheticMonitoringCheckSettingsMultihttpEntryRequestHeader',
    'SyntheticMonitoringCheckSettingsMultihttpEntryRequestQueryField',
    'SyntheticMonitoringCheckSettingsMultihttpEntryVariable',
    'SyntheticMonitoringCheckSettingsPing',
    'SyntheticMonitoringCheckSettingsScripted',
    'SyntheticMonitoringCheckSettingsTcp',
    'SyntheticMonitoringCheckSettingsTcpQueryResponse',
    'SyntheticMonitoringCheckSettingsTcpTlsConfig',
    'SyntheticMonitoringCheckSettingsTraceroute',
    'TeamPreferences',
    'TeamTeamSync',
    'GetDashboardsDashboardResult',
    'GetFoldersFolderResult',
    'GetLibraryPanelsPanelResult',
    'GetRolePermissionResult',
    'GetSlosSloResult',
    'GetSlosSloAlertingResult',
    'GetSlosSloAlertingAdvancedOptionsResult',
    'GetSlosSloAlertingAnnotationResult',
    'GetSlosSloAlertingFastburnResult',
    'GetSlosSloAlertingFastburnAnnotationResult',
    'GetSlosSloAlertingFastburnLabelResult',
    'GetSlosSloAlertingLabelResult',
    'GetSlosSloAlertingSlowburnResult',
    'GetSlosSloAlertingSlowburnAnnotationResult',
    'GetSlosSloAlertingSlowburnLabelResult',
    'GetSlosSloDestinationDatasourceResult',
    'GetSlosSloLabelResult',
    'GetSlosSloObjectiveResult',
    'GetSlosSloQueryResult',
    'GetSlosSloQueryFreeformResult',
    'GetSlosSloQueryGrafanaQueriesResult',
    'GetSlosSloQueryRatioResult',
    'GetTeamPreferenceResult',
    'GetTeamTeamSyncResult',
    'GetUsersUserResult',
]

@pulumi.output_type
class CloudAccessPolicyCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedSubnets":
            suggest = "allowed_subnets"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudAccessPolicyCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudAccessPolicyCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudAccessPolicyCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_subnets: Sequence[str]):
        """
        :param Sequence[str] allowed_subnets: Conditions that apply to the access policy,such as IP Allow lists.
        """
        pulumi.set(__self__, "allowed_subnets", allowed_subnets)

    @property
    @pulumi.getter(name="allowedSubnets")
    def allowed_subnets(self) -> Sequence[str]:
        """
        Conditions that apply to the access policy,such as IP Allow lists.
        """
        return pulumi.get(self, "allowed_subnets")


@pulumi.output_type
class CloudAccessPolicyRealm(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelPolicies":
            suggest = "label_policies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudAccessPolicyRealm. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudAccessPolicyRealm.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudAccessPolicyRealm.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identifier: str,
                 type: str,
                 label_policies: Optional[Sequence['outputs.CloudAccessPolicyRealmLabelPolicy']] = None):
        """
        :param str identifier: The identifier of the org or stack. For orgs, this is the slug, for stacks, this is the stack ID.
        :param str type: Whether a policy applies to a Cloud org or a specific stack. Should be one of `org` or `stack`.
        """
        pulumi.set(__self__, "identifier", identifier)
        pulumi.set(__self__, "type", type)
        if label_policies is not None:
            pulumi.set(__self__, "label_policies", label_policies)

    @property
    @pulumi.getter
    def identifier(self) -> str:
        """
        The identifier of the org or stack. For orgs, this is the slug, for stacks, this is the stack ID.
        """
        return pulumi.get(self, "identifier")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Whether a policy applies to a Cloud org or a specific stack. Should be one of `org` or `stack`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="labelPolicies")
    def label_policies(self) -> Optional[Sequence['outputs.CloudAccessPolicyRealmLabelPolicy']]:
        return pulumi.get(self, "label_policies")


@pulumi.output_type
class CloudAccessPolicyRealmLabelPolicy(dict):
    def __init__(__self__, *,
                 selector: str):
        """
        :param str selector: The label selector to match in metrics or logs query. Should be in PromQL or LogQL format.
        """
        pulumi.set(__self__, "selector", selector)

    @property
    @pulumi.getter
    def selector(self) -> str:
        """
        The label selector to match in metrics or logs query. Should be in PromQL or LogQL format.
        """
        return pulumi.get(self, "selector")


@pulumi.output_type
class ContactPointAlertmanager(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "basicAuthPassword":
            suggest = "basic_auth_password"
        elif key == "basicAuthUser":
            suggest = "basic_auth_user"
        elif key == "disableResolveMessage":
            suggest = "disable_resolve_message"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContactPointAlertmanager. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContactPointAlertmanager.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContactPointAlertmanager.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: str,
                 basic_auth_password: Optional[str] = None,
                 basic_auth_user: Optional[str] = None,
                 disable_resolve_message: Optional[bool] = None,
                 settings: Optional[Mapping[str, str]] = None,
                 uid: Optional[str] = None):
        """
        :param str url: The URL of the Alertmanager instance.
        :param str basic_auth_password: The password component of the basic auth credentials to use.
        :param str basic_auth_user: The username component of the basic auth credentials to use.
        :param bool disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param Mapping[str, str] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param str uid: The UID of the contact point.
        """
        pulumi.set(__self__, "url", url)
        if basic_auth_password is not None:
            pulumi.set(__self__, "basic_auth_password", basic_auth_password)
        if basic_auth_user is not None:
            pulumi.set(__self__, "basic_auth_user", basic_auth_user)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        The URL of the Alertmanager instance.
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter(name="basicAuthPassword")
    def basic_auth_password(self) -> Optional[str]:
        """
        The password component of the basic auth credentials to use.
        """
        return pulumi.get(self, "basic_auth_password")

    @property
    @pulumi.getter(name="basicAuthUser")
    def basic_auth_user(self) -> Optional[str]:
        """
        The username component of the basic auth credentials to use.
        """
        return pulumi.get(self, "basic_auth_user")

    @property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[bool]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @property
    @pulumi.getter
    def settings(self) -> Optional[Mapping[str, str]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @property
    @pulumi.getter
    def uid(self) -> Optional[str]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")


@pulumi.output_type
class ContactPointDingding(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disableResolveMessage":
            suggest = "disable_resolve_message"
        elif key == "messageType":
            suggest = "message_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContactPointDingding. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContactPointDingding.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContactPointDingding.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: str,
                 disable_resolve_message: Optional[bool] = None,
                 message: Optional[str] = None,
                 message_type: Optional[str] = None,
                 settings: Optional[Mapping[str, str]] = None,
                 title: Optional[str] = None,
                 uid: Optional[str] = None):
        """
        :param str url: The DingDing webhook URL.
        :param bool disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param str message: The templated content of the message.
        :param str message_type: The format of message to send - either 'link' or 'actionCard'
        :param Mapping[str, str] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param str title: The templated title of the message.
        :param str uid: The UID of the contact point.
        """
        pulumi.set(__self__, "url", url)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if message_type is not None:
            pulumi.set(__self__, "message_type", message_type)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        The DingDing webhook URL.
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[bool]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        The templated content of the message.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter(name="messageType")
    def message_type(self) -> Optional[str]:
        """
        The format of message to send - either 'link' or 'actionCard'
        """
        return pulumi.get(self, "message_type")

    @property
    @pulumi.getter
    def settings(self) -> Optional[Mapping[str, str]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The templated title of the message.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def uid(self) -> Optional[str]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")


@pulumi.output_type
class ContactPointDiscord(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "avatarUrl":
            suggest = "avatar_url"
        elif key == "disableResolveMessage":
            suggest = "disable_resolve_message"
        elif key == "useDiscordUsername":
            suggest = "use_discord_username"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContactPointDiscord. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContactPointDiscord.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContactPointDiscord.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: str,
                 avatar_url: Optional[str] = None,
                 disable_resolve_message: Optional[bool] = None,
                 message: Optional[str] = None,
                 settings: Optional[Mapping[str, str]] = None,
                 title: Optional[str] = None,
                 uid: Optional[str] = None,
                 use_discord_username: Optional[bool] = None):
        """
        :param str url: The discord webhook URL.
        :param str avatar_url: The URL of a custom avatar image to use. Defaults to ``.
        :param bool disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param str message: The templated content of the message. Defaults to ``.
        :param Mapping[str, str] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param str title: The templated content of the title.
        :param str uid: The UID of the contact point.
        :param bool use_discord_username: Whether to use the bot account's plain username instead of "Grafana." Defaults to `false`.
        """
        pulumi.set(__self__, "url", url)
        if avatar_url is not None:
            pulumi.set(__self__, "avatar_url", avatar_url)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)
        if use_discord_username is not None:
            pulumi.set(__self__, "use_discord_username", use_discord_username)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        The discord webhook URL.
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter(name="avatarUrl")
    def avatar_url(self) -> Optional[str]:
        """
        The URL of a custom avatar image to use. Defaults to ``.
        """
        return pulumi.get(self, "avatar_url")

    @property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[bool]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        The templated content of the message. Defaults to ``.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def settings(self) -> Optional[Mapping[str, str]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The templated content of the title.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def uid(self) -> Optional[str]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")

    @property
    @pulumi.getter(name="useDiscordUsername")
    def use_discord_username(self) -> Optional[bool]:
        """
        Whether to use the bot account's plain username instead of "Grafana." Defaults to `false`.
        """
        return pulumi.get(self, "use_discord_username")


@pulumi.output_type
class ContactPointEmail(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disableResolveMessage":
            suggest = "disable_resolve_message"
        elif key == "singleEmail":
            suggest = "single_email"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContactPointEmail. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContactPointEmail.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContactPointEmail.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 addresses: Sequence[str],
                 disable_resolve_message: Optional[bool] = None,
                 message: Optional[str] = None,
                 settings: Optional[Mapping[str, str]] = None,
                 single_email: Optional[bool] = None,
                 subject: Optional[str] = None,
                 uid: Optional[str] = None):
        """
        :param Sequence[str] addresses: The addresses to send emails to.
        :param bool disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param str message: The templated content of the email. Defaults to ``.
        :param Mapping[str, str] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param bool single_email: Whether to send a single email CC'ing all addresses, rather than a separate email to each address. Defaults to `false`.
        :param str subject: The templated subject line of the email. Defaults to ``.
        :param str uid: The UID of the contact point.
        """
        pulumi.set(__self__, "addresses", addresses)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if single_email is not None:
            pulumi.set(__self__, "single_email", single_email)
        if subject is not None:
            pulumi.set(__self__, "subject", subject)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter
    def addresses(self) -> Sequence[str]:
        """
        The addresses to send emails to.
        """
        return pulumi.get(self, "addresses")

    @property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[bool]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        The templated content of the email. Defaults to ``.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def settings(self) -> Optional[Mapping[str, str]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @property
    @pulumi.getter(name="singleEmail")
    def single_email(self) -> Optional[bool]:
        """
        Whether to send a single email CC'ing all addresses, rather than a separate email to each address. Defaults to `false`.
        """
        return pulumi.get(self, "single_email")

    @property
    @pulumi.getter
    def subject(self) -> Optional[str]:
        """
        The templated subject line of the email. Defaults to ``.
        """
        return pulumi.get(self, "subject")

    @property
    @pulumi.getter
    def uid(self) -> Optional[str]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")


@pulumi.output_type
class ContactPointGooglechat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disableResolveMessage":
            suggest = "disable_resolve_message"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContactPointGooglechat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContactPointGooglechat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContactPointGooglechat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: str,
                 disable_resolve_message: Optional[bool] = None,
                 message: Optional[str] = None,
                 settings: Optional[Mapping[str, str]] = None,
                 title: Optional[str] = None,
                 uid: Optional[str] = None):
        """
        :param str url: The Google Chat webhook URL.
        :param bool disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param str message: The templated content of the message.
        :param Mapping[str, str] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param str title: The templated content of the title.
        :param str uid: The UID of the contact point.
        """
        pulumi.set(__self__, "url", url)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        The Google Chat webhook URL.
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[bool]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        The templated content of the message.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def settings(self) -> Optional[Mapping[str, str]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The templated content of the title.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def uid(self) -> Optional[str]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")


@pulumi.output_type
class ContactPointKafka(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "restProxyUrl":
            suggest = "rest_proxy_url"
        elif key == "apiVersion":
            suggest = "api_version"
        elif key == "clusterId":
            suggest = "cluster_id"
        elif key == "disableResolveMessage":
            suggest = "disable_resolve_message"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContactPointKafka. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContactPointKafka.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContactPointKafka.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 rest_proxy_url: str,
                 topic: str,
                 api_version: Optional[str] = None,
                 cluster_id: Optional[str] = None,
                 description: Optional[str] = None,
                 details: Optional[str] = None,
                 disable_resolve_message: Optional[bool] = None,
                 password: Optional[str] = None,
                 settings: Optional[Mapping[str, str]] = None,
                 uid: Optional[str] = None,
                 username: Optional[str] = None):
        """
        :param str rest_proxy_url: The URL of the Kafka REST proxy to send requests to.
        :param str topic: The name of the Kafka topic to publish to.
        :param str api_version: The API version to use when contacting the Kafka REST Server. Supported: v2 (default) and v3. Defaults to `v2`.
        :param str cluster_id: The Id of cluster to use when contacting the Kafka REST Server. Required api_version to be 'v3'
        :param str description: The templated description of the Kafka message.
        :param str details: The templated details to include with the message.
        :param bool disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param str password: The password to use when making a call to the Kafka REST Proxy
        :param Mapping[str, str] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param str uid: The UID of the contact point.
        :param str username: The user name to use when making a call to the Kafka REST Proxy
        """
        pulumi.set(__self__, "rest_proxy_url", rest_proxy_url)
        pulumi.set(__self__, "topic", topic)
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if cluster_id is not None:
            pulumi.set(__self__, "cluster_id", cluster_id)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if details is not None:
            pulumi.set(__self__, "details", details)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="restProxyUrl")
    def rest_proxy_url(self) -> str:
        """
        The URL of the Kafka REST proxy to send requests to.
        """
        return pulumi.get(self, "rest_proxy_url")

    @property
    @pulumi.getter
    def topic(self) -> str:
        """
        The name of the Kafka topic to publish to.
        """
        return pulumi.get(self, "topic")

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[str]:
        """
        The API version to use when contacting the Kafka REST Server. Supported: v2 (default) and v3. Defaults to `v2`.
        """
        return pulumi.get(self, "api_version")

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> Optional[str]:
        """
        The Id of cluster to use when contacting the Kafka REST Server. Required api_version to be 'v3'
        """
        return pulumi.get(self, "cluster_id")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The templated description of the Kafka message.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def details(self) -> Optional[str]:
        """
        The templated details to include with the message.
        """
        return pulumi.get(self, "details")

    @property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[bool]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password to use when making a call to the Kafka REST Proxy
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def settings(self) -> Optional[Mapping[str, str]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @property
    @pulumi.getter
    def uid(self) -> Optional[str]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The user name to use when making a call to the Kafka REST Proxy
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ContactPointLine(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disableResolveMessage":
            suggest = "disable_resolve_message"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContactPointLine. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContactPointLine.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContactPointLine.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 token: str,
                 description: Optional[str] = None,
                 disable_resolve_message: Optional[bool] = None,
                 settings: Optional[Mapping[str, str]] = None,
                 title: Optional[str] = None,
                 uid: Optional[str] = None):
        """
        :param str token: The bearer token used to authorize the client.
        :param str description: The templated description of the message.
        :param bool disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param Mapping[str, str] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param str title: The templated title of the message.
        :param str uid: The UID of the contact point.
        """
        pulumi.set(__self__, "token", token)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter
    def token(self) -> str:
        """
        The bearer token used to authorize the client.
        """
        return pulumi.get(self, "token")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The templated description of the message.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[bool]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @property
    @pulumi.getter
    def settings(self) -> Optional[Mapping[str, str]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The templated title of the message.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def uid(self) -> Optional[str]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")


@pulumi.output_type
class ContactPointOncall(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authorizationCredentials":
            suggest = "authorization_credentials"
        elif key == "authorizationScheme":
            suggest = "authorization_scheme"
        elif key == "basicAuthPassword":
            suggest = "basic_auth_password"
        elif key == "basicAuthUser":
            suggest = "basic_auth_user"
        elif key == "disableResolveMessage":
            suggest = "disable_resolve_message"
        elif key == "httpMethod":
            suggest = "http_method"
        elif key == "maxAlerts":
            suggest = "max_alerts"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContactPointOncall. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContactPointOncall.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContactPointOncall.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: str,
                 authorization_credentials: Optional[str] = None,
                 authorization_scheme: Optional[str] = None,
                 basic_auth_password: Optional[str] = None,
                 basic_auth_user: Optional[str] = None,
                 disable_resolve_message: Optional[bool] = None,
                 http_method: Optional[str] = None,
                 max_alerts: Optional[int] = None,
                 message: Optional[str] = None,
                 settings: Optional[Mapping[str, str]] = None,
                 title: Optional[str] = None,
                 uid: Optional[str] = None):
        """
        :param str url: The URL to send webhook requests to.
        :param str authorization_credentials: Allows a custom authorization scheme - attaches an auth header with this value. Do not use in conjunction with basic auth parameters.
        :param str authorization_scheme: Allows a custom authorization scheme - attaches an auth header with this name. Do not use in conjunction with basic auth parameters.
        :param str basic_auth_password: The username to use in basic auth headers attached to the request. If omitted, basic auth will not be used.
        :param str basic_auth_user: The username to use in basic auth headers attached to the request. If omitted, basic auth will not be used.
        :param bool disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param str http_method: The HTTP method to use in the request. Defaults to `POST`.
        :param int max_alerts: The maximum number of alerts to send in a single request. This can be helpful in limiting the size of the request body. The default is 0, which indicates no limit.
        :param str message: Custom message. You can use template variables.
        :param Mapping[str, str] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param str title: Templated title of the message.
        :param str uid: The UID of the contact point.
        """
        pulumi.set(__self__, "url", url)
        if authorization_credentials is not None:
            pulumi.set(__self__, "authorization_credentials", authorization_credentials)
        if authorization_scheme is not None:
            pulumi.set(__self__, "authorization_scheme", authorization_scheme)
        if basic_auth_password is not None:
            pulumi.set(__self__, "basic_auth_password", basic_auth_password)
        if basic_auth_user is not None:
            pulumi.set(__self__, "basic_auth_user", basic_auth_user)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if http_method is not None:
            pulumi.set(__self__, "http_method", http_method)
        if max_alerts is not None:
            pulumi.set(__self__, "max_alerts", max_alerts)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        The URL to send webhook requests to.
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter(name="authorizationCredentials")
    def authorization_credentials(self) -> Optional[str]:
        """
        Allows a custom authorization scheme - attaches an auth header with this value. Do not use in conjunction with basic auth parameters.
        """
        return pulumi.get(self, "authorization_credentials")

    @property
    @pulumi.getter(name="authorizationScheme")
    def authorization_scheme(self) -> Optional[str]:
        """
        Allows a custom authorization scheme - attaches an auth header with this name. Do not use in conjunction with basic auth parameters.
        """
        return pulumi.get(self, "authorization_scheme")

    @property
    @pulumi.getter(name="basicAuthPassword")
    def basic_auth_password(self) -> Optional[str]:
        """
        The username to use in basic auth headers attached to the request. If omitted, basic auth will not be used.
        """
        return pulumi.get(self, "basic_auth_password")

    @property
    @pulumi.getter(name="basicAuthUser")
    def basic_auth_user(self) -> Optional[str]:
        """
        The username to use in basic auth headers attached to the request. If omitted, basic auth will not be used.
        """
        return pulumi.get(self, "basic_auth_user")

    @property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[bool]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @property
    @pulumi.getter(name="httpMethod")
    def http_method(self) -> Optional[str]:
        """
        The HTTP method to use in the request. Defaults to `POST`.
        """
        return pulumi.get(self, "http_method")

    @property
    @pulumi.getter(name="maxAlerts")
    def max_alerts(self) -> Optional[int]:
        """
        The maximum number of alerts to send in a single request. This can be helpful in limiting the size of the request body. The default is 0, which indicates no limit.
        """
        return pulumi.get(self, "max_alerts")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        Custom message. You can use template variables.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def settings(self) -> Optional[Mapping[str, str]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        Templated title of the message.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def uid(self) -> Optional[str]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")


@pulumi.output_type
class ContactPointOpsgeny(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"
        elif key == "autoClose":
            suggest = "auto_close"
        elif key == "disableResolveMessage":
            suggest = "disable_resolve_message"
        elif key == "overridePriority":
            suggest = "override_priority"
        elif key == "sendTagsAs":
            suggest = "send_tags_as"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContactPointOpsgeny. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContactPointOpsgeny.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContactPointOpsgeny.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: str,
                 auto_close: Optional[bool] = None,
                 description: Optional[str] = None,
                 disable_resolve_message: Optional[bool] = None,
                 message: Optional[str] = None,
                 override_priority: Optional[bool] = None,
                 responders: Optional[Sequence['outputs.ContactPointOpsgenyResponder']] = None,
                 send_tags_as: Optional[str] = None,
                 settings: Optional[Mapping[str, str]] = None,
                 uid: Optional[str] = None,
                 url: Optional[str] = None):
        """
        :param str api_key: The OpsGenie API key to use.
        :param bool auto_close: Whether to auto-close alerts in OpsGenie when they resolve in the Alertmanager.
        :param str description: A templated high-level description to use for the alert.
        :param bool disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param str message: The templated content of the message.
        :param bool override_priority: Whether to allow the alert priority to be configured via the value of the `og_priority` annotation on the alert.
        :param Sequence['ContactPointOpsgenyResponderArgs'] responders: Teams, users, escalations and schedules that the alert will be routed to send notifications. If the API Key belongs to a team integration, this field will be overwritten with the owner team. This feature is available from Grafana 10.3+.
        :param str send_tags_as: Whether to send annotations to OpsGenie as Tags, Details, or both. Supported values are `tags`, `details`, `both`, or empty to use the default behavior of Tags.
        :param Mapping[str, str] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param str uid: The UID of the contact point.
        :param str url: Allows customization of the OpsGenie API URL.
        """
        pulumi.set(__self__, "api_key", api_key)
        if auto_close is not None:
            pulumi.set(__self__, "auto_close", auto_close)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if override_priority is not None:
            pulumi.set(__self__, "override_priority", override_priority)
        if responders is not None:
            pulumi.set(__self__, "responders", responders)
        if send_tags_as is not None:
            pulumi.set(__self__, "send_tags_as", send_tags_as)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> str:
        """
        The OpsGenie API key to use.
        """
        return pulumi.get(self, "api_key")

    @property
    @pulumi.getter(name="autoClose")
    def auto_close(self) -> Optional[bool]:
        """
        Whether to auto-close alerts in OpsGenie when they resolve in the Alertmanager.
        """
        return pulumi.get(self, "auto_close")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        A templated high-level description to use for the alert.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[bool]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        The templated content of the message.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter(name="overridePriority")
    def override_priority(self) -> Optional[bool]:
        """
        Whether to allow the alert priority to be configured via the value of the `og_priority` annotation on the alert.
        """
        return pulumi.get(self, "override_priority")

    @property
    @pulumi.getter
    def responders(self) -> Optional[Sequence['outputs.ContactPointOpsgenyResponder']]:
        """
        Teams, users, escalations and schedules that the alert will be routed to send notifications. If the API Key belongs to a team integration, this field will be overwritten with the owner team. This feature is available from Grafana 10.3+.
        """
        return pulumi.get(self, "responders")

    @property
    @pulumi.getter(name="sendTagsAs")
    def send_tags_as(self) -> Optional[str]:
        """
        Whether to send annotations to OpsGenie as Tags, Details, or both. Supported values are `tags`, `details`, `both`, or empty to use the default behavior of Tags.
        """
        return pulumi.get(self, "send_tags_as")

    @property
    @pulumi.getter
    def settings(self) -> Optional[Mapping[str, str]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @property
    @pulumi.getter
    def uid(self) -> Optional[str]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        """
        Allows customization of the OpsGenie API URL.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class ContactPointOpsgenyResponder(dict):
    def __init__(__self__, *,
                 type: str,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 username: Optional[str] = None):
        """
        :param str type: Type of the responder. Supported: team, teams, user, escalation, schedule or a template that is expanded to one of these values.
        :param str id: ID of the responder. Must be specified if name and username are empty.
        :param str name: Name of the responder. Must be specified if username and id are empty.
        :param str username: User name of the responder. Must be specified if name and id are empty.
        """
        pulumi.set(__self__, "type", type)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of the responder. Supported: team, teams, user, escalation, schedule or a template that is expanded to one of these values.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        ID of the responder. Must be specified if name and username are empty.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the responder. Must be specified if username and id are empty.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        User name of the responder. Must be specified if name and id are empty.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ContactPointPagerduty(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "integrationKey":
            suggest = "integration_key"
        elif key == "class":
            suggest = "class_"
        elif key == "clientUrl":
            suggest = "client_url"
        elif key == "disableResolveMessage":
            suggest = "disable_resolve_message"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContactPointPagerduty. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContactPointPagerduty.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContactPointPagerduty.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 integration_key: str,
                 class_: Optional[str] = None,
                 client: Optional[str] = None,
                 client_url: Optional[str] = None,
                 component: Optional[str] = None,
                 details: Optional[Mapping[str, str]] = None,
                 disable_resolve_message: Optional[bool] = None,
                 group: Optional[str] = None,
                 settings: Optional[Mapping[str, str]] = None,
                 severity: Optional[str] = None,
                 source: Optional[str] = None,
                 summary: Optional[str] = None,
                 uid: Optional[str] = None,
                 url: Optional[str] = None):
        """
        :param str integration_key: The PagerDuty API key.
        :param str class_: The class or type of event, for example `ping failure`.
        :param str client: The name of the monitoring client that is triggering this event.
        :param str client_url: The URL of the monitoring client that is triggering this event.
        :param str component: The component being affected by the event.
        :param Mapping[str, str] details: A set of arbitrary key/value pairs that provide further detail about the incident.
        :param bool disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param str group: The group to which the provided component belongs to.
        :param Mapping[str, str] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param str severity: The PagerDuty event severity level. Default is `critical`.
        :param str source: The unique location of the affected system.
        :param str summary: The templated summary message of the event.
        :param str uid: The UID of the contact point.
        :param str url: The URL to send API requests to
        """
        pulumi.set(__self__, "integration_key", integration_key)
        if class_ is not None:
            pulumi.set(__self__, "class_", class_)
        if client is not None:
            pulumi.set(__self__, "client", client)
        if client_url is not None:
            pulumi.set(__self__, "client_url", client_url)
        if component is not None:
            pulumi.set(__self__, "component", component)
        if details is not None:
            pulumi.set(__self__, "details", details)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if group is not None:
            pulumi.set(__self__, "group", group)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if summary is not None:
            pulumi.set(__self__, "summary", summary)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter(name="integrationKey")
    def integration_key(self) -> str:
        """
        The PagerDuty API key.
        """
        return pulumi.get(self, "integration_key")

    @property
    @pulumi.getter(name="class")
    def class_(self) -> Optional[str]:
        """
        The class or type of event, for example `ping failure`.
        """
        return pulumi.get(self, "class_")

    @property
    @pulumi.getter
    def client(self) -> Optional[str]:
        """
        The name of the monitoring client that is triggering this event.
        """
        return pulumi.get(self, "client")

    @property
    @pulumi.getter(name="clientUrl")
    def client_url(self) -> Optional[str]:
        """
        The URL of the monitoring client that is triggering this event.
        """
        return pulumi.get(self, "client_url")

    @property
    @pulumi.getter
    def component(self) -> Optional[str]:
        """
        The component being affected by the event.
        """
        return pulumi.get(self, "component")

    @property
    @pulumi.getter
    def details(self) -> Optional[Mapping[str, str]]:
        """
        A set of arbitrary key/value pairs that provide further detail about the incident.
        """
        return pulumi.get(self, "details")

    @property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[bool]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @property
    @pulumi.getter
    def group(self) -> Optional[str]:
        """
        The group to which the provided component belongs to.
        """
        return pulumi.get(self, "group")

    @property
    @pulumi.getter
    def settings(self) -> Optional[Mapping[str, str]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @property
    @pulumi.getter
    def severity(self) -> Optional[str]:
        """
        The PagerDuty event severity level. Default is `critical`.
        """
        return pulumi.get(self, "severity")

    @property
    @pulumi.getter
    def source(self) -> Optional[str]:
        """
        The unique location of the affected system.
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def summary(self) -> Optional[str]:
        """
        The templated summary message of the event.
        """
        return pulumi.get(self, "summary")

    @property
    @pulumi.getter
    def uid(self) -> Optional[str]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        """
        The URL to send API requests to
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class ContactPointPushover(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiToken":
            suggest = "api_token"
        elif key == "userKey":
            suggest = "user_key"
        elif key == "disableResolveMessage":
            suggest = "disable_resolve_message"
        elif key == "okPriority":
            suggest = "ok_priority"
        elif key == "okSound":
            suggest = "ok_sound"
        elif key == "uploadImage":
            suggest = "upload_image"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContactPointPushover. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContactPointPushover.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContactPointPushover.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_token: str,
                 user_key: str,
                 device: Optional[str] = None,
                 disable_resolve_message: Optional[bool] = None,
                 expire: Optional[int] = None,
                 message: Optional[str] = None,
                 ok_priority: Optional[int] = None,
                 ok_sound: Optional[str] = None,
                 priority: Optional[int] = None,
                 retry: Optional[int] = None,
                 settings: Optional[Mapping[str, str]] = None,
                 sound: Optional[str] = None,
                 title: Optional[str] = None,
                 uid: Optional[str] = None,
                 upload_image: Optional[bool] = None):
        """
        :param str api_token: The Pushover API token.
        :param str user_key: The Pushover user key.
        :param str device: Comma-separated list of devices to which the event is associated.
        :param bool disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param int expire: How many seconds for which the notification will continue to be retried by Pushover.
        :param str message: The templated notification message content.
        :param int ok_priority: The priority level of the resolved event.
        :param str ok_sound: The sound associated with the resolved notification.
        :param int priority: The priority level of the event.
        :param int retry: How often, in seconds, the Pushover servers will send the same notification to the user.
        :param Mapping[str, str] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param str sound: The sound associated with the notification.
        :param str title: The templated title of the message.
        :param str uid: The UID of the contact point.
        :param bool upload_image: Whether to send images in the notification or not. Default is true. Requires Grafana to be configured to send images in notifications.
        """
        pulumi.set(__self__, "api_token", api_token)
        pulumi.set(__self__, "user_key", user_key)
        if device is not None:
            pulumi.set(__self__, "device", device)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if expire is not None:
            pulumi.set(__self__, "expire", expire)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if ok_priority is not None:
            pulumi.set(__self__, "ok_priority", ok_priority)
        if ok_sound is not None:
            pulumi.set(__self__, "ok_sound", ok_sound)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if retry is not None:
            pulumi.set(__self__, "retry", retry)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if sound is not None:
            pulumi.set(__self__, "sound", sound)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)
        if upload_image is not None:
            pulumi.set(__self__, "upload_image", upload_image)

    @property
    @pulumi.getter(name="apiToken")
    def api_token(self) -> str:
        """
        The Pushover API token.
        """
        return pulumi.get(self, "api_token")

    @property
    @pulumi.getter(name="userKey")
    def user_key(self) -> str:
        """
        The Pushover user key.
        """
        return pulumi.get(self, "user_key")

    @property
    @pulumi.getter
    def device(self) -> Optional[str]:
        """
        Comma-separated list of devices to which the event is associated.
        """
        return pulumi.get(self, "device")

    @property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[bool]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @property
    @pulumi.getter
    def expire(self) -> Optional[int]:
        """
        How many seconds for which the notification will continue to be retried by Pushover.
        """
        return pulumi.get(self, "expire")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        The templated notification message content.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter(name="okPriority")
    def ok_priority(self) -> Optional[int]:
        """
        The priority level of the resolved event.
        """
        return pulumi.get(self, "ok_priority")

    @property
    @pulumi.getter(name="okSound")
    def ok_sound(self) -> Optional[str]:
        """
        The sound associated with the resolved notification.
        """
        return pulumi.get(self, "ok_sound")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        The priority level of the event.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def retry(self) -> Optional[int]:
        """
        How often, in seconds, the Pushover servers will send the same notification to the user.
        """
        return pulumi.get(self, "retry")

    @property
    @pulumi.getter
    def settings(self) -> Optional[Mapping[str, str]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @property
    @pulumi.getter
    def sound(self) -> Optional[str]:
        """
        The sound associated with the notification.
        """
        return pulumi.get(self, "sound")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The templated title of the message.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def uid(self) -> Optional[str]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")

    @property
    @pulumi.getter(name="uploadImage")
    def upload_image(self) -> Optional[bool]:
        """
        Whether to send images in the notification or not. Default is true. Requires Grafana to be configured to send images in notifications.
        """
        return pulumi.get(self, "upload_image")


@pulumi.output_type
class ContactPointSensugo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"
        elif key == "disableResolveMessage":
            suggest = "disable_resolve_message"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContactPointSensugo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContactPointSensugo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContactPointSensugo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: str,
                 url: str,
                 check: Optional[str] = None,
                 disable_resolve_message: Optional[bool] = None,
                 entity: Optional[str] = None,
                 handler: Optional[str] = None,
                 message: Optional[str] = None,
                 namespace: Optional[str] = None,
                 settings: Optional[Mapping[str, str]] = None,
                 uid: Optional[str] = None):
        """
        :param str api_key: The SensuGo API key.
        :param str url: The SensuGo URL to send requests to.
        :param str check: The SensuGo check to which the event should be routed.
        :param bool disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param str entity: The entity being monitored.
        :param str handler: A custom handler to execute in addition to the check.
        :param str message: Templated message content describing the alert.
        :param str namespace: The namespace in which the check resides.
        :param Mapping[str, str] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param str uid: The UID of the contact point.
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "url", url)
        if check is not None:
            pulumi.set(__self__, "check", check)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if entity is not None:
            pulumi.set(__self__, "entity", entity)
        if handler is not None:
            pulumi.set(__self__, "handler", handler)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> str:
        """
        The SensuGo API key.
        """
        return pulumi.get(self, "api_key")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        The SensuGo URL to send requests to.
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter
    def check(self) -> Optional[str]:
        """
        The SensuGo check to which the event should be routed.
        """
        return pulumi.get(self, "check")

    @property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[bool]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @property
    @pulumi.getter
    def entity(self) -> Optional[str]:
        """
        The entity being monitored.
        """
        return pulumi.get(self, "entity")

    @property
    @pulumi.getter
    def handler(self) -> Optional[str]:
        """
        A custom handler to execute in addition to the check.
        """
        return pulumi.get(self, "handler")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        Templated message content describing the alert.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        The namespace in which the check resides.
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def settings(self) -> Optional[Mapping[str, str]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @property
    @pulumi.getter
    def uid(self) -> Optional[str]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")


@pulumi.output_type
class ContactPointSlack(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disableResolveMessage":
            suggest = "disable_resolve_message"
        elif key == "endpointUrl":
            suggest = "endpoint_url"
        elif key == "iconEmoji":
            suggest = "icon_emoji"
        elif key == "iconUrl":
            suggest = "icon_url"
        elif key == "mentionChannel":
            suggest = "mention_channel"
        elif key == "mentionGroups":
            suggest = "mention_groups"
        elif key == "mentionUsers":
            suggest = "mention_users"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContactPointSlack. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContactPointSlack.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContactPointSlack.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 color: Optional[str] = None,
                 disable_resolve_message: Optional[bool] = None,
                 endpoint_url: Optional[str] = None,
                 icon_emoji: Optional[str] = None,
                 icon_url: Optional[str] = None,
                 mention_channel: Optional[str] = None,
                 mention_groups: Optional[str] = None,
                 mention_users: Optional[str] = None,
                 recipient: Optional[str] = None,
                 settings: Optional[Mapping[str, str]] = None,
                 text: Optional[str] = None,
                 title: Optional[str] = None,
                 token: Optional[str] = None,
                 uid: Optional[str] = None,
                 url: Optional[str] = None,
                 username: Optional[str] = None):
        """
        :param str color: Templated color of the slack message.
        :param bool disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param str endpoint_url: Use this to override the Slack API endpoint URL to send requests to.
        :param str icon_emoji: The name of a Slack workspace emoji to use as the bot icon.
        :param str icon_url: A URL of an image to use as the bot icon.
        :param str mention_channel: Describes how to ping the slack channel that messages are being sent to. Options are `here` for an @here ping, `channel` for @channel, or empty for no ping.
        :param str mention_groups: Comma-separated list of groups to mention in the message.
        :param str mention_users: Comma-separated list of users to mention in the message.
        :param str recipient: Channel, private group, or IM channel (can be an encoded ID or a name) to send messages to.
        :param Mapping[str, str] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param str text: Templated content of the message.
        :param str title: Templated title of the message.
        :param str token: A Slack API token,for sending messages directly without the webhook method.
        :param str uid: The UID of the contact point.
        :param str url: A Slack webhook URL,for sending messages via the webhook method.
        :param str username: Username for the bot to use.
        """
        if color is not None:
            pulumi.set(__self__, "color", color)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if endpoint_url is not None:
            pulumi.set(__self__, "endpoint_url", endpoint_url)
        if icon_emoji is not None:
            pulumi.set(__self__, "icon_emoji", icon_emoji)
        if icon_url is not None:
            pulumi.set(__self__, "icon_url", icon_url)
        if mention_channel is not None:
            pulumi.set(__self__, "mention_channel", mention_channel)
        if mention_groups is not None:
            pulumi.set(__self__, "mention_groups", mention_groups)
        if mention_users is not None:
            pulumi.set(__self__, "mention_users", mention_users)
        if recipient is not None:
            pulumi.set(__self__, "recipient", recipient)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if text is not None:
            pulumi.set(__self__, "text", text)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if token is not None:
            pulumi.set(__self__, "token", token)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def color(self) -> Optional[str]:
        """
        Templated color of the slack message.
        """
        return pulumi.get(self, "color")

    @property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[bool]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @property
    @pulumi.getter(name="endpointUrl")
    def endpoint_url(self) -> Optional[str]:
        """
        Use this to override the Slack API endpoint URL to send requests to.
        """
        return pulumi.get(self, "endpoint_url")

    @property
    @pulumi.getter(name="iconEmoji")
    def icon_emoji(self) -> Optional[str]:
        """
        The name of a Slack workspace emoji to use as the bot icon.
        """
        return pulumi.get(self, "icon_emoji")

    @property
    @pulumi.getter(name="iconUrl")
    def icon_url(self) -> Optional[str]:
        """
        A URL of an image to use as the bot icon.
        """
        return pulumi.get(self, "icon_url")

    @property
    @pulumi.getter(name="mentionChannel")
    def mention_channel(self) -> Optional[str]:
        """
        Describes how to ping the slack channel that messages are being sent to. Options are `here` for an @here ping, `channel` for @channel, or empty for no ping.
        """
        return pulumi.get(self, "mention_channel")

    @property
    @pulumi.getter(name="mentionGroups")
    def mention_groups(self) -> Optional[str]:
        """
        Comma-separated list of groups to mention in the message.
        """
        return pulumi.get(self, "mention_groups")

    @property
    @pulumi.getter(name="mentionUsers")
    def mention_users(self) -> Optional[str]:
        """
        Comma-separated list of users to mention in the message.
        """
        return pulumi.get(self, "mention_users")

    @property
    @pulumi.getter
    def recipient(self) -> Optional[str]:
        """
        Channel, private group, or IM channel (can be an encoded ID or a name) to send messages to.
        """
        return pulumi.get(self, "recipient")

    @property
    @pulumi.getter
    def settings(self) -> Optional[Mapping[str, str]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @property
    @pulumi.getter
    def text(self) -> Optional[str]:
        """
        Templated content of the message.
        """
        return pulumi.get(self, "text")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        Templated title of the message.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def token(self) -> Optional[str]:
        """
        A Slack API token,for sending messages directly without the webhook method.
        """
        return pulumi.get(self, "token")

    @property
    @pulumi.getter
    def uid(self) -> Optional[str]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        """
        A Slack webhook URL,for sending messages via the webhook method.
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        Username for the bot to use.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ContactPointSn(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "assumeRoleArn":
            suggest = "assume_role_arn"
        elif key == "authProvider":
            suggest = "auth_provider"
        elif key == "disableResolveMessage":
            suggest = "disable_resolve_message"
        elif key == "externalId":
            suggest = "external_id"
        elif key == "messageFormat":
            suggest = "message_format"
        elif key == "secretKey":
            suggest = "secret_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContactPointSn. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContactPointSn.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContactPointSn.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 topic: str,
                 access_key: Optional[str] = None,
                 assume_role_arn: Optional[str] = None,
                 auth_provider: Optional[str] = None,
                 body: Optional[str] = None,
                 disable_resolve_message: Optional[bool] = None,
                 external_id: Optional[str] = None,
                 message_format: Optional[str] = None,
                 secret_key: Optional[str] = None,
                 settings: Optional[Mapping[str, str]] = None,
                 subject: Optional[str] = None,
                 uid: Optional[str] = None):
        """
        :param str topic: The Amazon SNS topic to send notifications to.
        :param str access_key: AWS access key ID used to authenticate with Amazon SNS.
        :param str assume_role_arn: The Amazon Resource Name (ARN) of the role to assume to send notifications to Amazon SNS.
        :param str auth_provider: The authentication provider to use. Valid values are `default`, `arn` and `keys`. Default is `default`. Defaults to `default`.
        :param bool disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param str external_id: The external ID to use when assuming the role.
        :param str message_format: The format of the message to send. Valid values are `text`, `body` and `json`. Default is `text`. Defaults to `text`.
        :param str secret_key: AWS secret access key used to authenticate with Amazon SNS.
        :param Mapping[str, str] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param str uid: The UID of the contact point.
        """
        pulumi.set(__self__, "topic", topic)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if assume_role_arn is not None:
            pulumi.set(__self__, "assume_role_arn", assume_role_arn)
        if auth_provider is not None:
            pulumi.set(__self__, "auth_provider", auth_provider)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)
        if message_format is not None:
            pulumi.set(__self__, "message_format", message_format)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if subject is not None:
            pulumi.set(__self__, "subject", subject)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter
    def topic(self) -> str:
        """
        The Amazon SNS topic to send notifications to.
        """
        return pulumi.get(self, "topic")

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[str]:
        """
        AWS access key ID used to authenticate with Amazon SNS.
        """
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="assumeRoleArn")
    def assume_role_arn(self) -> Optional[str]:
        """
        The Amazon Resource Name (ARN) of the role to assume to send notifications to Amazon SNS.
        """
        return pulumi.get(self, "assume_role_arn")

    @property
    @pulumi.getter(name="authProvider")
    def auth_provider(self) -> Optional[str]:
        """
        The authentication provider to use. Valid values are `default`, `arn` and `keys`. Default is `default`. Defaults to `default`.
        """
        return pulumi.get(self, "auth_provider")

    @property
    @pulumi.getter
    def body(self) -> Optional[str]:
        return pulumi.get(self, "body")

    @property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[bool]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[str]:
        """
        The external ID to use when assuming the role.
        """
        return pulumi.get(self, "external_id")

    @property
    @pulumi.getter(name="messageFormat")
    def message_format(self) -> Optional[str]:
        """
        The format of the message to send. Valid values are `text`, `body` and `json`. Default is `text`. Defaults to `text`.
        """
        return pulumi.get(self, "message_format")

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[str]:
        """
        AWS secret access key used to authenticate with Amazon SNS.
        """
        return pulumi.get(self, "secret_key")

    @property
    @pulumi.getter
    def settings(self) -> Optional[Mapping[str, str]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @property
    @pulumi.getter
    def subject(self) -> Optional[str]:
        return pulumi.get(self, "subject")

    @property
    @pulumi.getter
    def uid(self) -> Optional[str]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")


@pulumi.output_type
class ContactPointTeam(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disableResolveMessage":
            suggest = "disable_resolve_message"
        elif key == "sectionTitle":
            suggest = "section_title"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContactPointTeam. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContactPointTeam.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContactPointTeam.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: str,
                 disable_resolve_message: Optional[bool] = None,
                 message: Optional[str] = None,
                 section_title: Optional[str] = None,
                 settings: Optional[Mapping[str, str]] = None,
                 title: Optional[str] = None,
                 uid: Optional[str] = None):
        """
        :param str url: A Teams webhook URL.
        :param bool disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param str message: The templated message content to send.
        :param str section_title: The templated subtitle for each message section.
        :param Mapping[str, str] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param str title: The templated title of the message.
        :param str uid: The UID of the contact point.
        """
        pulumi.set(__self__, "url", url)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if section_title is not None:
            pulumi.set(__self__, "section_title", section_title)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        A Teams webhook URL.
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[bool]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        The templated message content to send.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter(name="sectionTitle")
    def section_title(self) -> Optional[str]:
        """
        The templated subtitle for each message section.
        """
        return pulumi.get(self, "section_title")

    @property
    @pulumi.getter
    def settings(self) -> Optional[Mapping[str, str]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The templated title of the message.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def uid(self) -> Optional[str]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")


@pulumi.output_type
class ContactPointTelegram(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "chatId":
            suggest = "chat_id"
        elif key == "disableNotifications":
            suggest = "disable_notifications"
        elif key == "disableResolveMessage":
            suggest = "disable_resolve_message"
        elif key == "disableWebPagePreview":
            suggest = "disable_web_page_preview"
        elif key == "messageThreadId":
            suggest = "message_thread_id"
        elif key == "parseMode":
            suggest = "parse_mode"
        elif key == "protectContent":
            suggest = "protect_content"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContactPointTelegram. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContactPointTelegram.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContactPointTelegram.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 chat_id: str,
                 token: str,
                 disable_notifications: Optional[bool] = None,
                 disable_resolve_message: Optional[bool] = None,
                 disable_web_page_preview: Optional[bool] = None,
                 message: Optional[str] = None,
                 message_thread_id: Optional[str] = None,
                 parse_mode: Optional[str] = None,
                 protect_content: Optional[bool] = None,
                 settings: Optional[Mapping[str, str]] = None,
                 uid: Optional[str] = None):
        """
        :param str chat_id: The chat ID to send messages to.
        :param str token: The Telegram bot token.
        :param bool disable_notifications: When set users will receive a notification with no sound.
        :param bool disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param bool disable_web_page_preview: When set it disables link previews for links in the message.
        :param str message: The templated content of the message.
        :param str message_thread_id: The ID of the message thread to send the message to.
        :param str parse_mode: Mode for parsing entities in the message text. Supported: None, Markdown, MarkdownV2, and HTML. HTML is the default.
        :param bool protect_content: When set it protects the contents of the message from forwarding and saving.
        :param Mapping[str, str] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param str uid: The UID of the contact point.
        """
        pulumi.set(__self__, "chat_id", chat_id)
        pulumi.set(__self__, "token", token)
        if disable_notifications is not None:
            pulumi.set(__self__, "disable_notifications", disable_notifications)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if disable_web_page_preview is not None:
            pulumi.set(__self__, "disable_web_page_preview", disable_web_page_preview)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if message_thread_id is not None:
            pulumi.set(__self__, "message_thread_id", message_thread_id)
        if parse_mode is not None:
            pulumi.set(__self__, "parse_mode", parse_mode)
        if protect_content is not None:
            pulumi.set(__self__, "protect_content", protect_content)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="chatId")
    def chat_id(self) -> str:
        """
        The chat ID to send messages to.
        """
        return pulumi.get(self, "chat_id")

    @property
    @pulumi.getter
    def token(self) -> str:
        """
        The Telegram bot token.
        """
        return pulumi.get(self, "token")

    @property
    @pulumi.getter(name="disableNotifications")
    def disable_notifications(self) -> Optional[bool]:
        """
        When set users will receive a notification with no sound.
        """
        return pulumi.get(self, "disable_notifications")

    @property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[bool]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @property
    @pulumi.getter(name="disableWebPagePreview")
    def disable_web_page_preview(self) -> Optional[bool]:
        """
        When set it disables link previews for links in the message.
        """
        return pulumi.get(self, "disable_web_page_preview")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        The templated content of the message.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter(name="messageThreadId")
    def message_thread_id(self) -> Optional[str]:
        """
        The ID of the message thread to send the message to.
        """
        return pulumi.get(self, "message_thread_id")

    @property
    @pulumi.getter(name="parseMode")
    def parse_mode(self) -> Optional[str]:
        """
        Mode for parsing entities in the message text. Supported: None, Markdown, MarkdownV2, and HTML. HTML is the default.
        """
        return pulumi.get(self, "parse_mode")

    @property
    @pulumi.getter(name="protectContent")
    def protect_content(self) -> Optional[bool]:
        """
        When set it protects the contents of the message from forwarding and saving.
        """
        return pulumi.get(self, "protect_content")

    @property
    @pulumi.getter
    def settings(self) -> Optional[Mapping[str, str]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @property
    @pulumi.getter
    def uid(self) -> Optional[str]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")


@pulumi.output_type
class ContactPointThreema(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiSecret":
            suggest = "api_secret"
        elif key == "gatewayId":
            suggest = "gateway_id"
        elif key == "recipientId":
            suggest = "recipient_id"
        elif key == "disableResolveMessage":
            suggest = "disable_resolve_message"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContactPointThreema. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContactPointThreema.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContactPointThreema.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_secret: str,
                 gateway_id: str,
                 recipient_id: str,
                 description: Optional[str] = None,
                 disable_resolve_message: Optional[bool] = None,
                 settings: Optional[Mapping[str, str]] = None,
                 title: Optional[str] = None,
                 uid: Optional[str] = None):
        """
        :param str api_secret: The Threema API key.
        :param str gateway_id: The Threema gateway ID.
        :param str recipient_id: The ID of the recipient of the message.
        :param str description: The templated description of the message.
        :param bool disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param Mapping[str, str] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param str title: The templated title of the message.
        :param str uid: The UID of the contact point.
        """
        pulumi.set(__self__, "api_secret", api_secret)
        pulumi.set(__self__, "gateway_id", gateway_id)
        pulumi.set(__self__, "recipient_id", recipient_id)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="apiSecret")
    def api_secret(self) -> str:
        """
        The Threema API key.
        """
        return pulumi.get(self, "api_secret")

    @property
    @pulumi.getter(name="gatewayId")
    def gateway_id(self) -> str:
        """
        The Threema gateway ID.
        """
        return pulumi.get(self, "gateway_id")

    @property
    @pulumi.getter(name="recipientId")
    def recipient_id(self) -> str:
        """
        The ID of the recipient of the message.
        """
        return pulumi.get(self, "recipient_id")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The templated description of the message.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[bool]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @property
    @pulumi.getter
    def settings(self) -> Optional[Mapping[str, str]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The templated title of the message.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def uid(self) -> Optional[str]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")


@pulumi.output_type
class ContactPointVictorop(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disableResolveMessage":
            suggest = "disable_resolve_message"
        elif key == "messageType":
            suggest = "message_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContactPointVictorop. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContactPointVictorop.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContactPointVictorop.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: str,
                 description: Optional[str] = None,
                 disable_resolve_message: Optional[bool] = None,
                 message_type: Optional[str] = None,
                 settings: Optional[Mapping[str, str]] = None,
                 title: Optional[str] = None,
                 uid: Optional[str] = None):
        """
        :param str url: The VictorOps webhook URL.
        :param str description: Templated description of the message.
        :param bool disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param str message_type: The VictorOps alert state - typically either `CRITICAL` or `RECOVERY`.
        :param Mapping[str, str] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param str title: Templated title to display.
        :param str uid: The UID of the contact point.
        """
        pulumi.set(__self__, "url", url)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if message_type is not None:
            pulumi.set(__self__, "message_type", message_type)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        The VictorOps webhook URL.
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Templated description of the message.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[bool]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @property
    @pulumi.getter(name="messageType")
    def message_type(self) -> Optional[str]:
        """
        The VictorOps alert state - typically either `CRITICAL` or `RECOVERY`.
        """
        return pulumi.get(self, "message_type")

    @property
    @pulumi.getter
    def settings(self) -> Optional[Mapping[str, str]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        Templated title to display.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def uid(self) -> Optional[str]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")


@pulumi.output_type
class ContactPointWebex(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiUrl":
            suggest = "api_url"
        elif key == "disableResolveMessage":
            suggest = "disable_resolve_message"
        elif key == "roomId":
            suggest = "room_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContactPointWebex. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContactPointWebex.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContactPointWebex.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_url: Optional[str] = None,
                 disable_resolve_message: Optional[bool] = None,
                 message: Optional[str] = None,
                 room_id: Optional[str] = None,
                 settings: Optional[Mapping[str, str]] = None,
                 token: Optional[str] = None,
                 uid: Optional[str] = None):
        """
        :param str api_url: The URL to send webhook requests to.
        :param bool disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param str message: The templated title of the message to send.
        :param str room_id: ID of the Webex Teams room where to send the messages.
        :param Mapping[str, str] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param str token: The bearer token used to authorize the client.
        :param str uid: The UID of the contact point.
        """
        if api_url is not None:
            pulumi.set(__self__, "api_url", api_url)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if room_id is not None:
            pulumi.set(__self__, "room_id", room_id)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if token is not None:
            pulumi.set(__self__, "token", token)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="apiUrl")
    def api_url(self) -> Optional[str]:
        """
        The URL to send webhook requests to.
        """
        return pulumi.get(self, "api_url")

    @property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[bool]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        The templated title of the message to send.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter(name="roomId")
    def room_id(self) -> Optional[str]:
        """
        ID of the Webex Teams room where to send the messages.
        """
        return pulumi.get(self, "room_id")

    @property
    @pulumi.getter
    def settings(self) -> Optional[Mapping[str, str]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @property
    @pulumi.getter
    def token(self) -> Optional[str]:
        """
        The bearer token used to authorize the client.
        """
        return pulumi.get(self, "token")

    @property
    @pulumi.getter
    def uid(self) -> Optional[str]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")


@pulumi.output_type
class ContactPointWebhook(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authorizationCredentials":
            suggest = "authorization_credentials"
        elif key == "authorizationScheme":
            suggest = "authorization_scheme"
        elif key == "basicAuthPassword":
            suggest = "basic_auth_password"
        elif key == "basicAuthUser":
            suggest = "basic_auth_user"
        elif key == "disableResolveMessage":
            suggest = "disable_resolve_message"
        elif key == "httpMethod":
            suggest = "http_method"
        elif key == "maxAlerts":
            suggest = "max_alerts"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContactPointWebhook. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContactPointWebhook.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContactPointWebhook.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: str,
                 authorization_credentials: Optional[str] = None,
                 authorization_scheme: Optional[str] = None,
                 basic_auth_password: Optional[str] = None,
                 basic_auth_user: Optional[str] = None,
                 disable_resolve_message: Optional[bool] = None,
                 http_method: Optional[str] = None,
                 max_alerts: Optional[int] = None,
                 message: Optional[str] = None,
                 settings: Optional[Mapping[str, str]] = None,
                 title: Optional[str] = None,
                 uid: Optional[str] = None):
        """
        :param str url: The URL to send webhook requests to.
        :param str authorization_credentials: Allows a custom authorization scheme - attaches an auth header with this value. Do not use in conjunction with basic auth parameters.
        :param str authorization_scheme: Allows a custom authorization scheme - attaches an auth header with this name. Do not use in conjunction with basic auth parameters.
        :param str basic_auth_password: The username to use in basic auth headers attached to the request. If omitted, basic auth will not be used.
        :param str basic_auth_user: The username to use in basic auth headers attached to the request. If omitted, basic auth will not be used.
        :param bool disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param str http_method: The HTTP method to use in the request. Defaults to `POST`.
        :param int max_alerts: The maximum number of alerts to send in a single request. This can be helpful in limiting the size of the request body. The default is 0, which indicates no limit.
        :param str message: Custom message. You can use template variables.
        :param Mapping[str, str] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param str title: Templated title of the message.
        :param str uid: The UID of the contact point.
        """
        pulumi.set(__self__, "url", url)
        if authorization_credentials is not None:
            pulumi.set(__self__, "authorization_credentials", authorization_credentials)
        if authorization_scheme is not None:
            pulumi.set(__self__, "authorization_scheme", authorization_scheme)
        if basic_auth_password is not None:
            pulumi.set(__self__, "basic_auth_password", basic_auth_password)
        if basic_auth_user is not None:
            pulumi.set(__self__, "basic_auth_user", basic_auth_user)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if http_method is not None:
            pulumi.set(__self__, "http_method", http_method)
        if max_alerts is not None:
            pulumi.set(__self__, "max_alerts", max_alerts)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        The URL to send webhook requests to.
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter(name="authorizationCredentials")
    def authorization_credentials(self) -> Optional[str]:
        """
        Allows a custom authorization scheme - attaches an auth header with this value. Do not use in conjunction with basic auth parameters.
        """
        return pulumi.get(self, "authorization_credentials")

    @property
    @pulumi.getter(name="authorizationScheme")
    def authorization_scheme(self) -> Optional[str]:
        """
        Allows a custom authorization scheme - attaches an auth header with this name. Do not use in conjunction with basic auth parameters.
        """
        return pulumi.get(self, "authorization_scheme")

    @property
    @pulumi.getter(name="basicAuthPassword")
    def basic_auth_password(self) -> Optional[str]:
        """
        The username to use in basic auth headers attached to the request. If omitted, basic auth will not be used.
        """
        return pulumi.get(self, "basic_auth_password")

    @property
    @pulumi.getter(name="basicAuthUser")
    def basic_auth_user(self) -> Optional[str]:
        """
        The username to use in basic auth headers attached to the request. If omitted, basic auth will not be used.
        """
        return pulumi.get(self, "basic_auth_user")

    @property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[bool]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @property
    @pulumi.getter(name="httpMethod")
    def http_method(self) -> Optional[str]:
        """
        The HTTP method to use in the request. Defaults to `POST`.
        """
        return pulumi.get(self, "http_method")

    @property
    @pulumi.getter(name="maxAlerts")
    def max_alerts(self) -> Optional[int]:
        """
        The maximum number of alerts to send in a single request. This can be helpful in limiting the size of the request body. The default is 0, which indicates no limit.
        """
        return pulumi.get(self, "max_alerts")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        Custom message. You can use template variables.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def settings(self) -> Optional[Mapping[str, str]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        Templated title of the message.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def uid(self) -> Optional[str]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")


@pulumi.output_type
class ContactPointWecom(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "agentId":
            suggest = "agent_id"
        elif key == "corpId":
            suggest = "corp_id"
        elif key == "disableResolveMessage":
            suggest = "disable_resolve_message"
        elif key == "msgType":
            suggest = "msg_type"
        elif key == "toUser":
            suggest = "to_user"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContactPointWecom. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContactPointWecom.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContactPointWecom.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 agent_id: Optional[str] = None,
                 corp_id: Optional[str] = None,
                 disable_resolve_message: Optional[bool] = None,
                 message: Optional[str] = None,
                 msg_type: Optional[str] = None,
                 secret: Optional[str] = None,
                 settings: Optional[Mapping[str, str]] = None,
                 title: Optional[str] = None,
                 to_user: Optional[str] = None,
                 uid: Optional[str] = None,
                 url: Optional[str] = None):
        """
        :param str agent_id: Agent ID added to the request payload when using APIAPP.
        :param str corp_id: Corp ID used to get token when using APIAPP.
        :param bool disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param str message: The templated content of the message to send.
        :param str msg_type: The type of them message. Supported: markdown, text. Default: text.
        :param str secret: The secret key required to obtain access token when using APIAPP. See https://work.weixin.qq.com/wework_admin/frame#apps to create APIAPP.
        :param Mapping[str, str] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param str title: The templated title of the message to send.
        :param str to_user: The ID of user that should receive the message. Multiple entries should be separated by '|'. Default: @all.
        :param str uid: The UID of the contact point.
        :param str url: The WeCom webhook URL. Required if using GroupRobot.
        """
        if agent_id is not None:
            pulumi.set(__self__, "agent_id", agent_id)
        if corp_id is not None:
            pulumi.set(__self__, "corp_id", corp_id)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if msg_type is not None:
            pulumi.set(__self__, "msg_type", msg_type)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if to_user is not None:
            pulumi.set(__self__, "to_user", to_user)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter(name="agentId")
    def agent_id(self) -> Optional[str]:
        """
        Agent ID added to the request payload when using APIAPP.
        """
        return pulumi.get(self, "agent_id")

    @property
    @pulumi.getter(name="corpId")
    def corp_id(self) -> Optional[str]:
        """
        Corp ID used to get token when using APIAPP.
        """
        return pulumi.get(self, "corp_id")

    @property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[bool]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        The templated content of the message to send.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter(name="msgType")
    def msg_type(self) -> Optional[str]:
        """
        The type of them message. Supported: markdown, text. Default: text.
        """
        return pulumi.get(self, "msg_type")

    @property
    @pulumi.getter
    def secret(self) -> Optional[str]:
        """
        The secret key required to obtain access token when using APIAPP. See https://work.weixin.qq.com/wework_admin/frame#apps to create APIAPP.
        """
        return pulumi.get(self, "secret")

    @property
    @pulumi.getter
    def settings(self) -> Optional[Mapping[str, str]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The templated title of the message to send.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="toUser")
    def to_user(self) -> Optional[str]:
        """
        The ID of user that should receive the message. Multiple entries should be separated by '|'. Default: @all.
        """
        return pulumi.get(self, "to_user")

    @property
    @pulumi.getter
    def uid(self) -> Optional[str]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        """
        The WeCom webhook URL. Required if using GroupRobot.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class DashboardPermissionPermission(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "teamId":
            suggest = "team_id"
        elif key == "userId":
            suggest = "user_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPermissionPermission. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPermissionPermission.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPermissionPermission.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 permission: str,
                 role: Optional[str] = None,
                 team_id: Optional[str] = None,
                 user_id: Optional[str] = None):
        """
        :param str permission: Permission to associate with item. Must be one of `View`, `Edit`, or `Admin`.
        :param str role: Name of the basic role to manage permissions for. Options: `Viewer`, `Editor` or `Admin`.
        :param str team_id: ID of the team to manage permissions for. Defaults to `0`.
        :param str user_id: ID of the user or service account to manage permissions for. Defaults to `0`.
        """
        pulumi.set(__self__, "permission", permission)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if team_id is not None:
            pulumi.set(__self__, "team_id", team_id)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)

    @property
    @pulumi.getter
    def permission(self) -> str:
        """
        Permission to associate with item. Must be one of `View`, `Edit`, or `Admin`.
        """
        return pulumi.get(self, "permission")

    @property
    @pulumi.getter
    def role(self) -> Optional[str]:
        """
        Name of the basic role to manage permissions for. Options: `Viewer`, `Editor` or `Admin`.
        """
        return pulumi.get(self, "role")

    @property
    @pulumi.getter(name="teamId")
    def team_id(self) -> Optional[str]:
        """
        ID of the team to manage permissions for. Defaults to `0`.
        """
        return pulumi.get(self, "team_id")

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[str]:
        """
        ID of the user or service account to manage permissions for. Defaults to `0`.
        """
        return pulumi.get(self, "user_id")


@pulumi.output_type
class DataSourcePermissionPermission(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "builtInRole":
            suggest = "built_in_role"
        elif key == "teamId":
            suggest = "team_id"
        elif key == "userId":
            suggest = "user_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSourcePermissionPermission. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSourcePermissionPermission.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSourcePermissionPermission.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 permission: str,
                 built_in_role: Optional[str] = None,
                 team_id: Optional[str] = None,
                 user_id: Optional[str] = None):
        """
        :param str permission: Permission to associate with item. Options: `Query`, `Edit` or `Admin` (`Admin` can only be used with Grafana v10.3.0+).
        :param str built_in_role: Name of the basic role to manage permissions for. Options: `Viewer`, `Editor` or `Admin`.
        :param str team_id: ID of the team to manage permissions for. Defaults to `0`.
        :param str user_id: ID of the user or service account to manage permissions for. Defaults to `0`.
        """
        pulumi.set(__self__, "permission", permission)
        if built_in_role is not None:
            pulumi.set(__self__, "built_in_role", built_in_role)
        if team_id is not None:
            pulumi.set(__self__, "team_id", team_id)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)

    @property
    @pulumi.getter
    def permission(self) -> str:
        """
        Permission to associate with item. Options: `Query`, `Edit` or `Admin` (`Admin` can only be used with Grafana v10.3.0+).
        """
        return pulumi.get(self, "permission")

    @property
    @pulumi.getter(name="builtInRole")
    def built_in_role(self) -> Optional[str]:
        """
        Name of the basic role to manage permissions for. Options: `Viewer`, `Editor` or `Admin`.
        """
        return pulumi.get(self, "built_in_role")

    @property
    @pulumi.getter(name="teamId")
    def team_id(self) -> Optional[str]:
        """
        ID of the team to manage permissions for. Defaults to `0`.
        """
        return pulumi.get(self, "team_id")

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[str]:
        """
        ID of the user or service account to manage permissions for. Defaults to `0`.
        """
        return pulumi.get(self, "user_id")


@pulumi.output_type
class FolderPermissionPermission(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "teamId":
            suggest = "team_id"
        elif key == "userId":
            suggest = "user_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FolderPermissionPermission. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FolderPermissionPermission.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FolderPermissionPermission.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 permission: str,
                 role: Optional[str] = None,
                 team_id: Optional[str] = None,
                 user_id: Optional[str] = None):
        """
        :param str permission: Permission to associate with item. Must be one of `View`, `Edit`, or `Admin`.
        :param str role: Name of the basic role to manage permissions for. Options: `Viewer`, `Editor` or `Admin`.
        :param str team_id: ID of the team to manage permissions for. Defaults to `0`.
        :param str user_id: ID of the user or service account to manage permissions for. Defaults to `0`.
        """
        pulumi.set(__self__, "permission", permission)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if team_id is not None:
            pulumi.set(__self__, "team_id", team_id)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)

    @property
    @pulumi.getter
    def permission(self) -> str:
        """
        Permission to associate with item. Must be one of `View`, `Edit`, or `Admin`.
        """
        return pulumi.get(self, "permission")

    @property
    @pulumi.getter
    def role(self) -> Optional[str]:
        """
        Name of the basic role to manage permissions for. Options: `Viewer`, `Editor` or `Admin`.
        """
        return pulumi.get(self, "role")

    @property
    @pulumi.getter(name="teamId")
    def team_id(self) -> Optional[str]:
        """
        ID of the team to manage permissions for. Defaults to `0`.
        """
        return pulumi.get(self, "team_id")

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[str]:
        """
        ID of the user or service account to manage permissions for. Defaults to `0`.
        """
        return pulumi.get(self, "user_id")


@pulumi.output_type
class MachineLearningHolidayCustomPeriod(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endTime":
            suggest = "end_time"
        elif key == "startTime":
            suggest = "start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MachineLearningHolidayCustomPeriod. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MachineLearningHolidayCustomPeriod.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MachineLearningHolidayCustomPeriod.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_time: str,
                 start_time: str,
                 name: Optional[str] = None):
        """
        :param str name: The name of the custom period.
        """
        pulumi.set(__self__, "end_time", end_time)
        pulumi.set(__self__, "start_time", start_time)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> str:
        return pulumi.get(self, "end_time")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> str:
        return pulumi.get(self, "start_time")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the custom period.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class MachineLearningOutlierDetectorAlgorithm(dict):
    def __init__(__self__, *,
                 name: str,
                 sensitivity: float,
                 config: Optional['outputs.MachineLearningOutlierDetectorAlgorithmConfig'] = None):
        """
        :param str name: The name of the algorithm to use ('mad' or 'dbscan').
        :param float sensitivity: Specify the sensitivity of the detector (in range [0,1]).
        :param 'MachineLearningOutlierDetectorAlgorithmConfigArgs' config: For DBSCAN only, specify the configuration map
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "sensitivity", sensitivity)
        if config is not None:
            pulumi.set(__self__, "config", config)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the algorithm to use ('mad' or 'dbscan').
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def sensitivity(self) -> float:
        """
        Specify the sensitivity of the detector (in range [0,1]).
        """
        return pulumi.get(self, "sensitivity")

    @property
    @pulumi.getter
    def config(self) -> Optional['outputs.MachineLearningOutlierDetectorAlgorithmConfig']:
        """
        For DBSCAN only, specify the configuration map
        """
        return pulumi.get(self, "config")


@pulumi.output_type
class MachineLearningOutlierDetectorAlgorithmConfig(dict):
    def __init__(__self__, *,
                 epsilon: float):
        """
        :param float epsilon: Specify the epsilon parameter (positive float)
        """
        pulumi.set(__self__, "epsilon", epsilon)

    @property
    @pulumi.getter
    def epsilon(self) -> float:
        """
        Specify the epsilon parameter (positive float)
        """
        return pulumi.get(self, "epsilon")


@pulumi.output_type
class MuteTimingInterval(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "daysOfMonths":
            suggest = "days_of_months"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MuteTimingInterval. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MuteTimingInterval.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MuteTimingInterval.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 days_of_months: Optional[Sequence[str]] = None,
                 location: Optional[str] = None,
                 months: Optional[Sequence[str]] = None,
                 times: Optional[Sequence['outputs.MuteTimingIntervalTime']] = None,
                 weekdays: Optional[Sequence[str]] = None,
                 years: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] days_of_months: An inclusive range of days, 1-31, within a month, e.g. "1" or "14:16". Negative values can be used to represent days counting from the end of a month, e.g. "-1".
        :param str location: Provides the time zone for the time interval. Must be a location in the IANA time zone database, e.g "America/New_York"
        :param Sequence[str] months: An inclusive range of months, either numerical or full calendar month, e.g. "1:3", "december", or "may:august".
        :param Sequence['MuteTimingIntervalTimeArgs'] times: The time ranges, represented in minutes, during which to mute in a given day.
        :param Sequence[str] weekdays: An inclusive range of weekdays, e.g. "monday" or "tuesday:thursday".
        :param Sequence[str] years: A positive inclusive range of years, e.g. "2030" or "2025:2026".
        """
        if days_of_months is not None:
            pulumi.set(__self__, "days_of_months", days_of_months)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if months is not None:
            pulumi.set(__self__, "months", months)
        if times is not None:
            pulumi.set(__self__, "times", times)
        if weekdays is not None:
            pulumi.set(__self__, "weekdays", weekdays)
        if years is not None:
            pulumi.set(__self__, "years", years)

    @property
    @pulumi.getter(name="daysOfMonths")
    def days_of_months(self) -> Optional[Sequence[str]]:
        """
        An inclusive range of days, 1-31, within a month, e.g. "1" or "14:16". Negative values can be used to represent days counting from the end of a month, e.g. "-1".
        """
        return pulumi.get(self, "days_of_months")

    @property
    @pulumi.getter
    def location(self) -> Optional[str]:
        """
        Provides the time zone for the time interval. Must be a location in the IANA time zone database, e.g "America/New_York"
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter
    def months(self) -> Optional[Sequence[str]]:
        """
        An inclusive range of months, either numerical or full calendar month, e.g. "1:3", "december", or "may:august".
        """
        return pulumi.get(self, "months")

    @property
    @pulumi.getter
    def times(self) -> Optional[Sequence['outputs.MuteTimingIntervalTime']]:
        """
        The time ranges, represented in minutes, during which to mute in a given day.
        """
        return pulumi.get(self, "times")

    @property
    @pulumi.getter
    def weekdays(self) -> Optional[Sequence[str]]:
        """
        An inclusive range of weekdays, e.g. "monday" or "tuesday:thursday".
        """
        return pulumi.get(self, "weekdays")

    @property
    @pulumi.getter
    def years(self) -> Optional[Sequence[str]]:
        """
        A positive inclusive range of years, e.g. "2030" or "2025:2026".
        """
        return pulumi.get(self, "years")


@pulumi.output_type
class MuteTimingIntervalTime(dict):
    def __init__(__self__, *,
                 end: str,
                 start: str):
        """
        :param str end: The time, in hh:mm format, of when the interval should end exclusively.
        :param str start: The time, in hh:mm format, of when the interval should begin inclusively.
        """
        pulumi.set(__self__, "end", end)
        pulumi.set(__self__, "start", start)

    @property
    @pulumi.getter
    def end(self) -> str:
        """
        The time, in hh:mm format, of when the interval should end exclusively.
        """
        return pulumi.get(self, "end")

    @property
    @pulumi.getter
    def start(self) -> str:
        """
        The time, in hh:mm format, of when the interval should begin inclusively.
        """
        return pulumi.get(self, "start")


@pulumi.output_type
class NotificationPolicyPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contactPoint":
            suggest = "contact_point"
        elif key == "continue":
            suggest = "continue_"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "groupInterval":
            suggest = "group_interval"
        elif key == "groupWait":
            suggest = "group_wait"
        elif key == "muteTimings":
            suggest = "mute_timings"
        elif key == "repeatInterval":
            suggest = "repeat_interval"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotificationPolicyPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotificationPolicyPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotificationPolicyPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 contact_point: Optional[str] = None,
                 continue_: Optional[bool] = None,
                 group_bies: Optional[Sequence[str]] = None,
                 group_interval: Optional[str] = None,
                 group_wait: Optional[str] = None,
                 matchers: Optional[Sequence['outputs.NotificationPolicyPolicyMatcher']] = None,
                 mute_timings: Optional[Sequence[str]] = None,
                 policies: Optional[Sequence['outputs.NotificationPolicyPolicyPolicy']] = None,
                 repeat_interval: Optional[str] = None):
        """
        :param str contact_point: The contact point to route notifications that match this rule to.
        :param bool continue_: Whether to continue matching subsequent rules if an alert matches the current rule. Otherwise, the rule will be 'consumed' by the first policy to match it.
        :param Sequence[str] group_bies: A list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping. Required for root policy only. If empty, the parent grouping is used.
        :param str group_interval: Minimum time interval between two notifications for the same group. Default is 5 minutes.
        :param str group_wait: Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.
        :param Sequence['NotificationPolicyPolicyMatcherArgs'] matchers: Describes which labels this rule should match. When multiple matchers are supplied, an alert must match ALL matchers to be accepted by this policy. When no matchers are supplied, the rule will match all alert instances.
        :param Sequence[str] mute_timings: A list of mute timing names to apply to alerts that match this policy.
        :param Sequence['NotificationPolicyPolicyPolicyArgs'] policies: Routing rules for specific label sets.
        :param str repeat_interval: Minimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.
        """
        if contact_point is not None:
            pulumi.set(__self__, "contact_point", contact_point)
        if continue_ is not None:
            pulumi.set(__self__, "continue_", continue_)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if group_interval is not None:
            pulumi.set(__self__, "group_interval", group_interval)
        if group_wait is not None:
            pulumi.set(__self__, "group_wait", group_wait)
        if matchers is not None:
            pulumi.set(__self__, "matchers", matchers)
        if mute_timings is not None:
            pulumi.set(__self__, "mute_timings", mute_timings)
        if policies is not None:
            pulumi.set(__self__, "policies", policies)
        if repeat_interval is not None:
            pulumi.set(__self__, "repeat_interval", repeat_interval)

    @property
    @pulumi.getter(name="contactPoint")
    def contact_point(self) -> Optional[str]:
        """
        The contact point to route notifications that match this rule to.
        """
        return pulumi.get(self, "contact_point")

    @property
    @pulumi.getter(name="continue")
    def continue_(self) -> Optional[bool]:
        """
        Whether to continue matching subsequent rules if an alert matches the current rule. Otherwise, the rule will be 'consumed' by the first policy to match it.
        """
        return pulumi.get(self, "continue_")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence[str]]:
        """
        A list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping. Required for root policy only. If empty, the parent grouping is used.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="groupInterval")
    def group_interval(self) -> Optional[str]:
        """
        Minimum time interval between two notifications for the same group. Default is 5 minutes.
        """
        return pulumi.get(self, "group_interval")

    @property
    @pulumi.getter(name="groupWait")
    def group_wait(self) -> Optional[str]:
        """
        Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.
        """
        return pulumi.get(self, "group_wait")

    @property
    @pulumi.getter
    def matchers(self) -> Optional[Sequence['outputs.NotificationPolicyPolicyMatcher']]:
        """
        Describes which labels this rule should match. When multiple matchers are supplied, an alert must match ALL matchers to be accepted by this policy. When no matchers are supplied, the rule will match all alert instances.
        """
        return pulumi.get(self, "matchers")

    @property
    @pulumi.getter(name="muteTimings")
    def mute_timings(self) -> Optional[Sequence[str]]:
        """
        A list of mute timing names to apply to alerts that match this policy.
        """
        return pulumi.get(self, "mute_timings")

    @property
    @pulumi.getter
    def policies(self) -> Optional[Sequence['outputs.NotificationPolicyPolicyPolicy']]:
        """
        Routing rules for specific label sets.
        """
        return pulumi.get(self, "policies")

    @property
    @pulumi.getter(name="repeatInterval")
    def repeat_interval(self) -> Optional[str]:
        """
        Minimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.
        """
        return pulumi.get(self, "repeat_interval")


@pulumi.output_type
class NotificationPolicyPolicyMatcher(dict):
    def __init__(__self__, *,
                 label: str,
                 match: str,
                 value: str):
        """
        :param str label: The name of the label to match against.
        :param str match: The operator to apply when matching values of the given label. Allowed operators are `=` for equality, `!=` for negated equality, `=~` for regex equality, and `!~` for negated regex equality.
        :param str value: The label value to match against.
        """
        pulumi.set(__self__, "label", label)
        pulumi.set(__self__, "match", match)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def label(self) -> str:
        """
        The name of the label to match against.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def match(self) -> str:
        """
        The operator to apply when matching values of the given label. Allowed operators are `=` for equality, `!=` for negated equality, `=~` for regex equality, and `!~` for negated regex equality.
        """
        return pulumi.get(self, "match")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The label value to match against.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class NotificationPolicyPolicyPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contactPoint":
            suggest = "contact_point"
        elif key == "continue":
            suggest = "continue_"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "groupInterval":
            suggest = "group_interval"
        elif key == "groupWait":
            suggest = "group_wait"
        elif key == "muteTimings":
            suggest = "mute_timings"
        elif key == "repeatInterval":
            suggest = "repeat_interval"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotificationPolicyPolicyPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotificationPolicyPolicyPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotificationPolicyPolicyPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 contact_point: Optional[str] = None,
                 continue_: Optional[bool] = None,
                 group_bies: Optional[Sequence[str]] = None,
                 group_interval: Optional[str] = None,
                 group_wait: Optional[str] = None,
                 matchers: Optional[Sequence['outputs.NotificationPolicyPolicyPolicyMatcher']] = None,
                 mute_timings: Optional[Sequence[str]] = None,
                 policies: Optional[Sequence['outputs.NotificationPolicyPolicyPolicyPolicy']] = None,
                 repeat_interval: Optional[str] = None):
        """
        :param str contact_point: The contact point to route notifications that match this rule to.
        :param bool continue_: Whether to continue matching subsequent rules if an alert matches the current rule. Otherwise, the rule will be 'consumed' by the first policy to match it.
        :param Sequence[str] group_bies: A list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping. Required for root policy only. If empty, the parent grouping is used.
        :param str group_interval: Minimum time interval between two notifications for the same group. Default is 5 minutes.
        :param str group_wait: Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.
        :param Sequence['NotificationPolicyPolicyPolicyMatcherArgs'] matchers: Describes which labels this rule should match. When multiple matchers are supplied, an alert must match ALL matchers to be accepted by this policy. When no matchers are supplied, the rule will match all alert instances.
        :param Sequence[str] mute_timings: A list of mute timing names to apply to alerts that match this policy.
        :param Sequence['NotificationPolicyPolicyPolicyPolicyArgs'] policies: Routing rules for specific label sets.
        :param str repeat_interval: Minimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.
        """
        if contact_point is not None:
            pulumi.set(__self__, "contact_point", contact_point)
        if continue_ is not None:
            pulumi.set(__self__, "continue_", continue_)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if group_interval is not None:
            pulumi.set(__self__, "group_interval", group_interval)
        if group_wait is not None:
            pulumi.set(__self__, "group_wait", group_wait)
        if matchers is not None:
            pulumi.set(__self__, "matchers", matchers)
        if mute_timings is not None:
            pulumi.set(__self__, "mute_timings", mute_timings)
        if policies is not None:
            pulumi.set(__self__, "policies", policies)
        if repeat_interval is not None:
            pulumi.set(__self__, "repeat_interval", repeat_interval)

    @property
    @pulumi.getter(name="contactPoint")
    def contact_point(self) -> Optional[str]:
        """
        The contact point to route notifications that match this rule to.
        """
        return pulumi.get(self, "contact_point")

    @property
    @pulumi.getter(name="continue")
    def continue_(self) -> Optional[bool]:
        """
        Whether to continue matching subsequent rules if an alert matches the current rule. Otherwise, the rule will be 'consumed' by the first policy to match it.
        """
        return pulumi.get(self, "continue_")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence[str]]:
        """
        A list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping. Required for root policy only. If empty, the parent grouping is used.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="groupInterval")
    def group_interval(self) -> Optional[str]:
        """
        Minimum time interval between two notifications for the same group. Default is 5 minutes.
        """
        return pulumi.get(self, "group_interval")

    @property
    @pulumi.getter(name="groupWait")
    def group_wait(self) -> Optional[str]:
        """
        Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.
        """
        return pulumi.get(self, "group_wait")

    @property
    @pulumi.getter
    def matchers(self) -> Optional[Sequence['outputs.NotificationPolicyPolicyPolicyMatcher']]:
        """
        Describes which labels this rule should match. When multiple matchers are supplied, an alert must match ALL matchers to be accepted by this policy. When no matchers are supplied, the rule will match all alert instances.
        """
        return pulumi.get(self, "matchers")

    @property
    @pulumi.getter(name="muteTimings")
    def mute_timings(self) -> Optional[Sequence[str]]:
        """
        A list of mute timing names to apply to alerts that match this policy.
        """
        return pulumi.get(self, "mute_timings")

    @property
    @pulumi.getter
    def policies(self) -> Optional[Sequence['outputs.NotificationPolicyPolicyPolicyPolicy']]:
        """
        Routing rules for specific label sets.
        """
        return pulumi.get(self, "policies")

    @property
    @pulumi.getter(name="repeatInterval")
    def repeat_interval(self) -> Optional[str]:
        """
        Minimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.
        """
        return pulumi.get(self, "repeat_interval")


@pulumi.output_type
class NotificationPolicyPolicyPolicyMatcher(dict):
    def __init__(__self__, *,
                 label: str,
                 match: str,
                 value: str):
        """
        :param str label: The name of the label to match against.
        :param str match: The operator to apply when matching values of the given label. Allowed operators are `=` for equality, `!=` for negated equality, `=~` for regex equality, and `!~` for negated regex equality.
        :param str value: The label value to match against.
        """
        pulumi.set(__self__, "label", label)
        pulumi.set(__self__, "match", match)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def label(self) -> str:
        """
        The name of the label to match against.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def match(self) -> str:
        """
        The operator to apply when matching values of the given label. Allowed operators are `=` for equality, `!=` for negated equality, `=~` for regex equality, and `!~` for negated regex equality.
        """
        return pulumi.get(self, "match")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The label value to match against.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class NotificationPolicyPolicyPolicyPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contactPoint":
            suggest = "contact_point"
        elif key == "continue":
            suggest = "continue_"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "groupInterval":
            suggest = "group_interval"
        elif key == "groupWait":
            suggest = "group_wait"
        elif key == "muteTimings":
            suggest = "mute_timings"
        elif key == "repeatInterval":
            suggest = "repeat_interval"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotificationPolicyPolicyPolicyPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotificationPolicyPolicyPolicyPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotificationPolicyPolicyPolicyPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 contact_point: Optional[str] = None,
                 continue_: Optional[bool] = None,
                 group_bies: Optional[Sequence[str]] = None,
                 group_interval: Optional[str] = None,
                 group_wait: Optional[str] = None,
                 matchers: Optional[Sequence['outputs.NotificationPolicyPolicyPolicyPolicyMatcher']] = None,
                 mute_timings: Optional[Sequence[str]] = None,
                 policies: Optional[Sequence['outputs.NotificationPolicyPolicyPolicyPolicyPolicy']] = None,
                 repeat_interval: Optional[str] = None):
        """
        :param str contact_point: The contact point to route notifications that match this rule to.
        :param bool continue_: Whether to continue matching subsequent rules if an alert matches the current rule. Otherwise, the rule will be 'consumed' by the first policy to match it.
        :param Sequence[str] group_bies: A list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping. Required for root policy only. If empty, the parent grouping is used.
        :param str group_interval: Minimum time interval between two notifications for the same group. Default is 5 minutes.
        :param str group_wait: Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.
        :param Sequence['NotificationPolicyPolicyPolicyPolicyMatcherArgs'] matchers: Describes which labels this rule should match. When multiple matchers are supplied, an alert must match ALL matchers to be accepted by this policy. When no matchers are supplied, the rule will match all alert instances.
        :param Sequence[str] mute_timings: A list of mute timing names to apply to alerts that match this policy.
        :param Sequence['NotificationPolicyPolicyPolicyPolicyPolicyArgs'] policies: Routing rules for specific label sets.
        :param str repeat_interval: Minimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.
        """
        if contact_point is not None:
            pulumi.set(__self__, "contact_point", contact_point)
        if continue_ is not None:
            pulumi.set(__self__, "continue_", continue_)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if group_interval is not None:
            pulumi.set(__self__, "group_interval", group_interval)
        if group_wait is not None:
            pulumi.set(__self__, "group_wait", group_wait)
        if matchers is not None:
            pulumi.set(__self__, "matchers", matchers)
        if mute_timings is not None:
            pulumi.set(__self__, "mute_timings", mute_timings)
        if policies is not None:
            pulumi.set(__self__, "policies", policies)
        if repeat_interval is not None:
            pulumi.set(__self__, "repeat_interval", repeat_interval)

    @property
    @pulumi.getter(name="contactPoint")
    def contact_point(self) -> Optional[str]:
        """
        The contact point to route notifications that match this rule to.
        """
        return pulumi.get(self, "contact_point")

    @property
    @pulumi.getter(name="continue")
    def continue_(self) -> Optional[bool]:
        """
        Whether to continue matching subsequent rules if an alert matches the current rule. Otherwise, the rule will be 'consumed' by the first policy to match it.
        """
        return pulumi.get(self, "continue_")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence[str]]:
        """
        A list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping. Required for root policy only. If empty, the parent grouping is used.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="groupInterval")
    def group_interval(self) -> Optional[str]:
        """
        Minimum time interval between two notifications for the same group. Default is 5 minutes.
        """
        return pulumi.get(self, "group_interval")

    @property
    @pulumi.getter(name="groupWait")
    def group_wait(self) -> Optional[str]:
        """
        Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.
        """
        return pulumi.get(self, "group_wait")

    @property
    @pulumi.getter
    def matchers(self) -> Optional[Sequence['outputs.NotificationPolicyPolicyPolicyPolicyMatcher']]:
        """
        Describes which labels this rule should match. When multiple matchers are supplied, an alert must match ALL matchers to be accepted by this policy. When no matchers are supplied, the rule will match all alert instances.
        """
        return pulumi.get(self, "matchers")

    @property
    @pulumi.getter(name="muteTimings")
    def mute_timings(self) -> Optional[Sequence[str]]:
        """
        A list of mute timing names to apply to alerts that match this policy.
        """
        return pulumi.get(self, "mute_timings")

    @property
    @pulumi.getter
    def policies(self) -> Optional[Sequence['outputs.NotificationPolicyPolicyPolicyPolicyPolicy']]:
        """
        Routing rules for specific label sets.
        """
        return pulumi.get(self, "policies")

    @property
    @pulumi.getter(name="repeatInterval")
    def repeat_interval(self) -> Optional[str]:
        """
        Minimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.
        """
        return pulumi.get(self, "repeat_interval")


@pulumi.output_type
class NotificationPolicyPolicyPolicyPolicyMatcher(dict):
    def __init__(__self__, *,
                 label: str,
                 match: str,
                 value: str):
        """
        :param str label: The name of the label to match against.
        :param str match: The operator to apply when matching values of the given label. Allowed operators are `=` for equality, `!=` for negated equality, `=~` for regex equality, and `!~` for negated regex equality.
        :param str value: The label value to match against.
        """
        pulumi.set(__self__, "label", label)
        pulumi.set(__self__, "match", match)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def label(self) -> str:
        """
        The name of the label to match against.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def match(self) -> str:
        """
        The operator to apply when matching values of the given label. Allowed operators are `=` for equality, `!=` for negated equality, `=~` for regex equality, and `!~` for negated regex equality.
        """
        return pulumi.get(self, "match")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The label value to match against.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class NotificationPolicyPolicyPolicyPolicyPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupBies":
            suggest = "group_bies"
        elif key == "contactPoint":
            suggest = "contact_point"
        elif key == "continue":
            suggest = "continue_"
        elif key == "groupInterval":
            suggest = "group_interval"
        elif key == "groupWait":
            suggest = "group_wait"
        elif key == "muteTimings":
            suggest = "mute_timings"
        elif key == "repeatInterval":
            suggest = "repeat_interval"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotificationPolicyPolicyPolicyPolicyPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotificationPolicyPolicyPolicyPolicyPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotificationPolicyPolicyPolicyPolicyPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 group_bies: Sequence[str],
                 contact_point: Optional[str] = None,
                 continue_: Optional[bool] = None,
                 group_interval: Optional[str] = None,
                 group_wait: Optional[str] = None,
                 matchers: Optional[Sequence['outputs.NotificationPolicyPolicyPolicyPolicyPolicyMatcher']] = None,
                 mute_timings: Optional[Sequence[str]] = None,
                 repeat_interval: Optional[str] = None):
        """
        :param Sequence[str] group_bies: A list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping. Required for root policy only. If empty, the parent grouping is used.
        :param str contact_point: The contact point to route notifications that match this rule to.
        :param bool continue_: Whether to continue matching subsequent rules if an alert matches the current rule. Otherwise, the rule will be 'consumed' by the first policy to match it.
        :param str group_interval: Minimum time interval between two notifications for the same group. Default is 5 minutes.
        :param str group_wait: Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.
        :param Sequence['NotificationPolicyPolicyPolicyPolicyPolicyMatcherArgs'] matchers: Describes which labels this rule should match. When multiple matchers are supplied, an alert must match ALL matchers to be accepted by this policy. When no matchers are supplied, the rule will match all alert instances.
        :param Sequence[str] mute_timings: A list of mute timing names to apply to alerts that match this policy.
        :param str repeat_interval: Minimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.
        """
        pulumi.set(__self__, "group_bies", group_bies)
        if contact_point is not None:
            pulumi.set(__self__, "contact_point", contact_point)
        if continue_ is not None:
            pulumi.set(__self__, "continue_", continue_)
        if group_interval is not None:
            pulumi.set(__self__, "group_interval", group_interval)
        if group_wait is not None:
            pulumi.set(__self__, "group_wait", group_wait)
        if matchers is not None:
            pulumi.set(__self__, "matchers", matchers)
        if mute_timings is not None:
            pulumi.set(__self__, "mute_timings", mute_timings)
        if repeat_interval is not None:
            pulumi.set(__self__, "repeat_interval", repeat_interval)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Sequence[str]:
        """
        A list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping. Required for root policy only. If empty, the parent grouping is used.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="contactPoint")
    def contact_point(self) -> Optional[str]:
        """
        The contact point to route notifications that match this rule to.
        """
        return pulumi.get(self, "contact_point")

    @property
    @pulumi.getter(name="continue")
    def continue_(self) -> Optional[bool]:
        """
        Whether to continue matching subsequent rules if an alert matches the current rule. Otherwise, the rule will be 'consumed' by the first policy to match it.
        """
        return pulumi.get(self, "continue_")

    @property
    @pulumi.getter(name="groupInterval")
    def group_interval(self) -> Optional[str]:
        """
        Minimum time interval between two notifications for the same group. Default is 5 minutes.
        """
        return pulumi.get(self, "group_interval")

    @property
    @pulumi.getter(name="groupWait")
    def group_wait(self) -> Optional[str]:
        """
        Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.
        """
        return pulumi.get(self, "group_wait")

    @property
    @pulumi.getter
    def matchers(self) -> Optional[Sequence['outputs.NotificationPolicyPolicyPolicyPolicyPolicyMatcher']]:
        """
        Describes which labels this rule should match. When multiple matchers are supplied, an alert must match ALL matchers to be accepted by this policy. When no matchers are supplied, the rule will match all alert instances.
        """
        return pulumi.get(self, "matchers")

    @property
    @pulumi.getter(name="muteTimings")
    def mute_timings(self) -> Optional[Sequence[str]]:
        """
        A list of mute timing names to apply to alerts that match this policy.
        """
        return pulumi.get(self, "mute_timings")

    @property
    @pulumi.getter(name="repeatInterval")
    def repeat_interval(self) -> Optional[str]:
        """
        Minimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.
        """
        return pulumi.get(self, "repeat_interval")


@pulumi.output_type
class NotificationPolicyPolicyPolicyPolicyPolicyMatcher(dict):
    def __init__(__self__, *,
                 label: str,
                 match: str,
                 value: str):
        """
        :param str label: The name of the label to match against.
        :param str match: The operator to apply when matching values of the given label. Allowed operators are `=` for equality, `!=` for negated equality, `=~` for regex equality, and `!~` for negated regex equality.
        :param str value: The label value to match against.
        """
        pulumi.set(__self__, "label", label)
        pulumi.set(__self__, "match", match)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def label(self) -> str:
        """
        The name of the label to match against.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def match(self) -> str:
        """
        The operator to apply when matching values of the given label. Allowed operators are `=` for equality, `!=` for negated equality, `=~` for regex equality, and `!~` for negated regex equality.
        """
        return pulumi.get(self, "match")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The label value to match against.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class OncallIntegrationDefaultRoute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "escalationChainId":
            suggest = "escalation_chain_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OncallIntegrationDefaultRoute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OncallIntegrationDefaultRoute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OncallIntegrationDefaultRoute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 escalation_chain_id: Optional[str] = None,
                 id: Optional[str] = None,
                 msteams: Optional['outputs.OncallIntegrationDefaultRouteMsteams'] = None,
                 slack: Optional['outputs.OncallIntegrationDefaultRouteSlack'] = None,
                 telegram: Optional['outputs.OncallIntegrationDefaultRouteTelegram'] = None):
        """
        :param str escalation_chain_id: The ID of the escalation chain.
        :param 'OncallIntegrationDefaultRouteMsteamsArgs' msteams: MS teams-specific settings for a route.
        :param 'OncallIntegrationDefaultRouteSlackArgs' slack: Slack-specific settings for a route.
        :param 'OncallIntegrationDefaultRouteTelegramArgs' telegram: Telegram-specific settings for a route.
        """
        if escalation_chain_id is not None:
            pulumi.set(__self__, "escalation_chain_id", escalation_chain_id)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if msteams is not None:
            pulumi.set(__self__, "msteams", msteams)
        if slack is not None:
            pulumi.set(__self__, "slack", slack)
        if telegram is not None:
            pulumi.set(__self__, "telegram", telegram)

    @property
    @pulumi.getter(name="escalationChainId")
    def escalation_chain_id(self) -> Optional[str]:
        """
        The ID of the escalation chain.
        """
        return pulumi.get(self, "escalation_chain_id")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def msteams(self) -> Optional['outputs.OncallIntegrationDefaultRouteMsteams']:
        """
        MS teams-specific settings for a route.
        """
        return pulumi.get(self, "msteams")

    @property
    @pulumi.getter
    def slack(self) -> Optional['outputs.OncallIntegrationDefaultRouteSlack']:
        """
        Slack-specific settings for a route.
        """
        return pulumi.get(self, "slack")

    @property
    @pulumi.getter
    def telegram(self) -> Optional['outputs.OncallIntegrationDefaultRouteTelegram']:
        """
        Telegram-specific settings for a route.
        """
        return pulumi.get(self, "telegram")


@pulumi.output_type
class OncallIntegrationDefaultRouteMsteams(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 id: Optional[str] = None):
        """
        :param bool enabled: Enable notification in MS teams. Defaults to `true`.
        :param str id: MS teams channel id. Alerts will be directed to this channel in Microsoft teams.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Enable notification in MS teams. Defaults to `true`.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        MS teams channel id. Alerts will be directed to this channel in Microsoft teams.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class OncallIntegrationDefaultRouteSlack(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "channelId":
            suggest = "channel_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OncallIntegrationDefaultRouteSlack. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OncallIntegrationDefaultRouteSlack.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OncallIntegrationDefaultRouteSlack.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 channel_id: Optional[str] = None,
                 enabled: Optional[bool] = None):
        """
        :param str channel_id: Slack channel id. Alerts will be directed to this channel in Slack.
        :param bool enabled: Enable notification in Slack. Defaults to `true`.
        """
        if channel_id is not None:
            pulumi.set(__self__, "channel_id", channel_id)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="channelId")
    def channel_id(self) -> Optional[str]:
        """
        Slack channel id. Alerts will be directed to this channel in Slack.
        """
        return pulumi.get(self, "channel_id")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Enable notification in Slack. Defaults to `true`.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class OncallIntegrationDefaultRouteTelegram(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 id: Optional[str] = None):
        """
        :param bool enabled: Enable notification in Telegram. Defaults to `true`.
        :param str id: Telegram channel id. Alerts will be directed to this channel in Telegram.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Enable notification in Telegram. Defaults to `true`.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Telegram channel id. Alerts will be directed to this channel in Telegram.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class OncallIntegrationTemplates(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acknowledgeSignal":
            suggest = "acknowledge_signal"
        elif key == "groupingKey":
            suggest = "grouping_key"
        elif key == "microsoftTeams":
            suggest = "microsoft_teams"
        elif key == "mobileApp":
            suggest = "mobile_app"
        elif key == "phoneCall":
            suggest = "phone_call"
        elif key == "resolveSignal":
            suggest = "resolve_signal"
        elif key == "sourceLink":
            suggest = "source_link"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OncallIntegrationTemplates. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OncallIntegrationTemplates.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OncallIntegrationTemplates.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 acknowledge_signal: Optional[str] = None,
                 email: Optional['outputs.OncallIntegrationTemplatesEmail'] = None,
                 grouping_key: Optional[str] = None,
                 microsoft_teams: Optional['outputs.OncallIntegrationTemplatesMicrosoftTeams'] = None,
                 mobile_app: Optional['outputs.OncallIntegrationTemplatesMobileApp'] = None,
                 phone_call: Optional['outputs.OncallIntegrationTemplatesPhoneCall'] = None,
                 resolve_signal: Optional[str] = None,
                 slack: Optional['outputs.OncallIntegrationTemplatesSlack'] = None,
                 sms: Optional['outputs.OncallIntegrationTemplatesSms'] = None,
                 source_link: Optional[str] = None,
                 telegram: Optional['outputs.OncallIntegrationTemplatesTelegram'] = None,
                 web: Optional['outputs.OncallIntegrationTemplatesWeb'] = None):
        """
        :param str acknowledge_signal: Template for sending a signal to acknowledge the Incident.
        :param 'OncallIntegrationTemplatesEmailArgs' email: Templates for Email.
        :param str grouping_key: Template for the key by which alerts are grouped.
        :param 'OncallIntegrationTemplatesMicrosoftTeamsArgs' microsoft_teams: Templates for Microsoft Teams. **NOTE**: Microsoft Teams templates are only available on Grafana Cloud.
        :param 'OncallIntegrationTemplatesMobileAppArgs' mobile_app: Templates for Mobile app push notifications.
        :param 'OncallIntegrationTemplatesPhoneCallArgs' phone_call: Templates for Phone Call.
        :param str resolve_signal: Template for sending a signal to resolve the Incident.
        :param 'OncallIntegrationTemplatesSlackArgs' slack: Templates for Slack.
        :param 'OncallIntegrationTemplatesSmsArgs' sms: Templates for SMS.
        :param str source_link: Template for a source link.
        :param 'OncallIntegrationTemplatesTelegramArgs' telegram: Templates for Telegram.
        :param 'OncallIntegrationTemplatesWebArgs' web: Templates for Web.
        """
        if acknowledge_signal is not None:
            pulumi.set(__self__, "acknowledge_signal", acknowledge_signal)
        if email is not None:
            pulumi.set(__self__, "email", email)
        if grouping_key is not None:
            pulumi.set(__self__, "grouping_key", grouping_key)
        if microsoft_teams is not None:
            pulumi.set(__self__, "microsoft_teams", microsoft_teams)
        if mobile_app is not None:
            pulumi.set(__self__, "mobile_app", mobile_app)
        if phone_call is not None:
            pulumi.set(__self__, "phone_call", phone_call)
        if resolve_signal is not None:
            pulumi.set(__self__, "resolve_signal", resolve_signal)
        if slack is not None:
            pulumi.set(__self__, "slack", slack)
        if sms is not None:
            pulumi.set(__self__, "sms", sms)
        if source_link is not None:
            pulumi.set(__self__, "source_link", source_link)
        if telegram is not None:
            pulumi.set(__self__, "telegram", telegram)
        if web is not None:
            pulumi.set(__self__, "web", web)

    @property
    @pulumi.getter(name="acknowledgeSignal")
    def acknowledge_signal(self) -> Optional[str]:
        """
        Template for sending a signal to acknowledge the Incident.
        """
        return pulumi.get(self, "acknowledge_signal")

    @property
    @pulumi.getter
    def email(self) -> Optional['outputs.OncallIntegrationTemplatesEmail']:
        """
        Templates for Email.
        """
        return pulumi.get(self, "email")

    @property
    @pulumi.getter(name="groupingKey")
    def grouping_key(self) -> Optional[str]:
        """
        Template for the key by which alerts are grouped.
        """
        return pulumi.get(self, "grouping_key")

    @property
    @pulumi.getter(name="microsoftTeams")
    def microsoft_teams(self) -> Optional['outputs.OncallIntegrationTemplatesMicrosoftTeams']:
        """
        Templates for Microsoft Teams. **NOTE**: Microsoft Teams templates are only available on Grafana Cloud.
        """
        return pulumi.get(self, "microsoft_teams")

    @property
    @pulumi.getter(name="mobileApp")
    def mobile_app(self) -> Optional['outputs.OncallIntegrationTemplatesMobileApp']:
        """
        Templates for Mobile app push notifications.
        """
        return pulumi.get(self, "mobile_app")

    @property
    @pulumi.getter(name="phoneCall")
    def phone_call(self) -> Optional['outputs.OncallIntegrationTemplatesPhoneCall']:
        """
        Templates for Phone Call.
        """
        return pulumi.get(self, "phone_call")

    @property
    @pulumi.getter(name="resolveSignal")
    def resolve_signal(self) -> Optional[str]:
        """
        Template for sending a signal to resolve the Incident.
        """
        return pulumi.get(self, "resolve_signal")

    @property
    @pulumi.getter
    def slack(self) -> Optional['outputs.OncallIntegrationTemplatesSlack']:
        """
        Templates for Slack.
        """
        return pulumi.get(self, "slack")

    @property
    @pulumi.getter
    def sms(self) -> Optional['outputs.OncallIntegrationTemplatesSms']:
        """
        Templates for SMS.
        """
        return pulumi.get(self, "sms")

    @property
    @pulumi.getter(name="sourceLink")
    def source_link(self) -> Optional[str]:
        """
        Template for a source link.
        """
        return pulumi.get(self, "source_link")

    @property
    @pulumi.getter
    def telegram(self) -> Optional['outputs.OncallIntegrationTemplatesTelegram']:
        """
        Templates for Telegram.
        """
        return pulumi.get(self, "telegram")

    @property
    @pulumi.getter
    def web(self) -> Optional['outputs.OncallIntegrationTemplatesWeb']:
        """
        Templates for Web.
        """
        return pulumi.get(self, "web")


@pulumi.output_type
class OncallIntegrationTemplatesEmail(dict):
    def __init__(__self__, *,
                 message: Optional[str] = None,
                 title: Optional[str] = None):
        """
        :param str message: Template for Alert message.
        :param str title: Template for Alert title.
        """
        if message is not None:
            pulumi.set(__self__, "message", message)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        Template for Alert message.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        Template for Alert title.
        """
        return pulumi.get(self, "title")


@pulumi.output_type
class OncallIntegrationTemplatesMicrosoftTeams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "imageUrl":
            suggest = "image_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OncallIntegrationTemplatesMicrosoftTeams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OncallIntegrationTemplatesMicrosoftTeams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OncallIntegrationTemplatesMicrosoftTeams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 image_url: Optional[str] = None,
                 message: Optional[str] = None,
                 title: Optional[str] = None):
        """
        :param str image_url: Template for Alert image url.
        :param str message: Template for Alert message.
        :param str title: Template for Alert title.
        """
        if image_url is not None:
            pulumi.set(__self__, "image_url", image_url)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[str]:
        """
        Template for Alert image url.
        """
        return pulumi.get(self, "image_url")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        Template for Alert message.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        Template for Alert title.
        """
        return pulumi.get(self, "title")


@pulumi.output_type
class OncallIntegrationTemplatesMobileApp(dict):
    def __init__(__self__, *,
                 message: Optional[str] = None,
                 title: Optional[str] = None):
        """
        :param str message: Template for Alert message.
        :param str title: Template for Alert title.
        """
        if message is not None:
            pulumi.set(__self__, "message", message)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        Template for Alert message.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        Template for Alert title.
        """
        return pulumi.get(self, "title")


@pulumi.output_type
class OncallIntegrationTemplatesPhoneCall(dict):
    def __init__(__self__, *,
                 title: Optional[str] = None):
        """
        :param str title: Template for Alert title.
        """
        if title is not None:
            pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        Template for Alert title.
        """
        return pulumi.get(self, "title")


@pulumi.output_type
class OncallIntegrationTemplatesSlack(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "imageUrl":
            suggest = "image_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OncallIntegrationTemplatesSlack. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OncallIntegrationTemplatesSlack.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OncallIntegrationTemplatesSlack.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 image_url: Optional[str] = None,
                 message: Optional[str] = None,
                 title: Optional[str] = None):
        """
        :param str image_url: Template for Alert image url.
        :param str message: Template for Alert message.
        :param str title: Template for Alert title.
        """
        if image_url is not None:
            pulumi.set(__self__, "image_url", image_url)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[str]:
        """
        Template for Alert image url.
        """
        return pulumi.get(self, "image_url")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        Template for Alert message.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        Template for Alert title.
        """
        return pulumi.get(self, "title")


@pulumi.output_type
class OncallIntegrationTemplatesSms(dict):
    def __init__(__self__, *,
                 title: Optional[str] = None):
        """
        :param str title: Template for Alert title.
        """
        if title is not None:
            pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        Template for Alert title.
        """
        return pulumi.get(self, "title")


@pulumi.output_type
class OncallIntegrationTemplatesTelegram(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "imageUrl":
            suggest = "image_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OncallIntegrationTemplatesTelegram. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OncallIntegrationTemplatesTelegram.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OncallIntegrationTemplatesTelegram.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 image_url: Optional[str] = None,
                 message: Optional[str] = None,
                 title: Optional[str] = None):
        """
        :param str image_url: Template for Alert image url.
        :param str message: Template for Alert message.
        :param str title: Template for Alert title.
        """
        if image_url is not None:
            pulumi.set(__self__, "image_url", image_url)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[str]:
        """
        Template for Alert image url.
        """
        return pulumi.get(self, "image_url")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        Template for Alert message.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        Template for Alert title.
        """
        return pulumi.get(self, "title")


@pulumi.output_type
class OncallIntegrationTemplatesWeb(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "imageUrl":
            suggest = "image_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OncallIntegrationTemplatesWeb. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OncallIntegrationTemplatesWeb.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OncallIntegrationTemplatesWeb.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 image_url: Optional[str] = None,
                 message: Optional[str] = None,
                 title: Optional[str] = None):
        """
        :param str image_url: Template for Alert image url.
        :param str message: Template for Alert message.
        :param str title: Template for Alert title.
        """
        if image_url is not None:
            pulumi.set(__self__, "image_url", image_url)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[str]:
        """
        Template for Alert image url.
        """
        return pulumi.get(self, "image_url")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        Template for Alert message.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        Template for Alert title.
        """
        return pulumi.get(self, "title")


@pulumi.output_type
class OncallRouteMsteams(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 id: Optional[str] = None):
        """
        :param bool enabled: Enable notification in MS teams. Defaults to `true`.
        :param str id: MS teams channel id. Alerts will be directed to this channel in Microsoft teams.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Enable notification in MS teams. Defaults to `true`.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        MS teams channel id. Alerts will be directed to this channel in Microsoft teams.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class OncallRouteSlack(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "channelId":
            suggest = "channel_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OncallRouteSlack. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OncallRouteSlack.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OncallRouteSlack.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 channel_id: Optional[str] = None,
                 enabled: Optional[bool] = None):
        """
        :param str channel_id: Slack channel id. Alerts will be directed to this channel in Slack.
        :param bool enabled: Enable notification in Slack. Defaults to `true`.
        """
        if channel_id is not None:
            pulumi.set(__self__, "channel_id", channel_id)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="channelId")
    def channel_id(self) -> Optional[str]:
        """
        Slack channel id. Alerts will be directed to this channel in Slack.
        """
        return pulumi.get(self, "channel_id")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Enable notification in Slack. Defaults to `true`.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class OncallRouteTelegram(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 id: Optional[str] = None):
        """
        :param bool enabled: Enable notification in Telegram. Defaults to `true`.
        :param str id: Telegram channel id. Alerts will be directed to this channel in Telegram.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Enable notification in Telegram. Defaults to `true`.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Telegram channel id. Alerts will be directed to this channel in Telegram.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class OncallScheduleSlack(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "channelId":
            suggest = "channel_id"
        elif key == "userGroupId":
            suggest = "user_group_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OncallScheduleSlack. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OncallScheduleSlack.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OncallScheduleSlack.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 channel_id: Optional[str] = None,
                 user_group_id: Optional[str] = None):
        """
        :param str channel_id: Slack channel id. Reminder about schedule shifts will be directed to this channel in Slack.
        :param str user_group_id: Slack user group id. Members of user group will be updated when on-call users change.
        """
        if channel_id is not None:
            pulumi.set(__self__, "channel_id", channel_id)
        if user_group_id is not None:
            pulumi.set(__self__, "user_group_id", user_group_id)

    @property
    @pulumi.getter(name="channelId")
    def channel_id(self) -> Optional[str]:
        """
        Slack channel id. Reminder about schedule shifts will be directed to this channel in Slack.
        """
        return pulumi.get(self, "channel_id")

    @property
    @pulumi.getter(name="userGroupId")
    def user_group_id(self) -> Optional[str]:
        """
        Slack user group id. Members of user group will be updated when on-call users change.
        """
        return pulumi.get(self, "user_group_id")


@pulumi.output_type
class PlaylistItem(dict):
    def __init__(__self__, *,
                 order: int,
                 title: str,
                 id: Optional[str] = None,
                 type: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "order", order)
        pulumi.set(__self__, "title", title)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def order(self) -> int:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def title(self) -> str:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ReportDashboard(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "reportVariables":
            suggest = "report_variables"
        elif key == "timeRange":
            suggest = "time_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ReportDashboard. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ReportDashboard.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ReportDashboard.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 uid: str,
                 report_variables: Optional[Mapping[str, str]] = None,
                 time_range: Optional['outputs.ReportDashboardTimeRange'] = None):
        """
        :param str uid: Dashboard uid.
        :param Mapping[str, str] report_variables: Add report variables to the dashboard. Values should be separated by commas.
        :param 'ReportDashboardTimeRangeArgs' time_range: Time range of the report.
        """
        pulumi.set(__self__, "uid", uid)
        if report_variables is not None:
            pulumi.set(__self__, "report_variables", report_variables)
        if time_range is not None:
            pulumi.set(__self__, "time_range", time_range)

    @property
    @pulumi.getter
    def uid(self) -> str:
        """
        Dashboard uid.
        """
        return pulumi.get(self, "uid")

    @property
    @pulumi.getter(name="reportVariables")
    def report_variables(self) -> Optional[Mapping[str, str]]:
        """
        Add report variables to the dashboard. Values should be separated by commas.
        """
        return pulumi.get(self, "report_variables")

    @property
    @pulumi.getter(name="timeRange")
    def time_range(self) -> Optional['outputs.ReportDashboardTimeRange']:
        """
        Time range of the report.
        """
        return pulumi.get(self, "time_range")


@pulumi.output_type
class ReportDashboardTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ReportDashboardTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ReportDashboardTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ReportDashboardTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_: Optional[str] = None,
                 to: Optional[str] = None):
        """
        :param str from_: Start of the time range.
        :param str to: End of the time range.
        """
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[str]:
        """
        Start of the time range.
        """
        return pulumi.get(self, "from_")

    @property
    @pulumi.getter
    def to(self) -> Optional[str]:
        """
        End of the time range.
        """
        return pulumi.get(self, "to")


@pulumi.output_type
class ReportSchedule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customInterval":
            suggest = "custom_interval"
        elif key == "endTime":
            suggest = "end_time"
        elif key == "lastDayOfMonth":
            suggest = "last_day_of_month"
        elif key == "startTime":
            suggest = "start_time"
        elif key == "workdaysOnly":
            suggest = "workdays_only"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ReportSchedule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ReportSchedule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ReportSchedule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 frequency: str,
                 custom_interval: Optional[str] = None,
                 end_time: Optional[str] = None,
                 last_day_of_month: Optional[bool] = None,
                 start_time: Optional[str] = None,
                 timezone: Optional[str] = None,
                 workdays_only: Optional[bool] = None):
        """
        :param str frequency: Frequency of the report. Allowed values: `never`, `once`, `hourly`, `daily`, `weekly`, `monthly`, `custom`.
        :param str custom_interval: Custom interval of the report.
               **Note:** This field is only available when frequency is set to `custom`.
        :param str end_time: End time of the report. If empty, the report will be sent indefinitely (according to frequency). Note that times will be saved as UTC in Grafana. Use 2006-01-02T15:04:05 format if you want to set a custom timezone
        :param bool last_day_of_month: Send the report on the last day of the month Defaults to `false`.
        :param str start_time: Start time of the report. If empty, the start date will be set to the creation time. Note that times will be saved as UTC in Grafana. Use 2006-01-02T15:04:05 format if you want to set a custom timezone
        :param str timezone: Set the report time zone. Defaults to `GMT`.
        :param bool workdays_only: Whether to send the report only on work days. Defaults to `false`.
        """
        pulumi.set(__self__, "frequency", frequency)
        if custom_interval is not None:
            pulumi.set(__self__, "custom_interval", custom_interval)
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if last_day_of_month is not None:
            pulumi.set(__self__, "last_day_of_month", last_day_of_month)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)
        if timezone is not None:
            pulumi.set(__self__, "timezone", timezone)
        if workdays_only is not None:
            pulumi.set(__self__, "workdays_only", workdays_only)

    @property
    @pulumi.getter
    def frequency(self) -> str:
        """
        Frequency of the report. Allowed values: `never`, `once`, `hourly`, `daily`, `weekly`, `monthly`, `custom`.
        """
        return pulumi.get(self, "frequency")

    @property
    @pulumi.getter(name="customInterval")
    def custom_interval(self) -> Optional[str]:
        """
        Custom interval of the report.
        **Note:** This field is only available when frequency is set to `custom`.
        """
        return pulumi.get(self, "custom_interval")

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[str]:
        """
        End time of the report. If empty, the report will be sent indefinitely (according to frequency). Note that times will be saved as UTC in Grafana. Use 2006-01-02T15:04:05 format if you want to set a custom timezone
        """
        return pulumi.get(self, "end_time")

    @property
    @pulumi.getter(name="lastDayOfMonth")
    def last_day_of_month(self) -> Optional[bool]:
        """
        Send the report on the last day of the month Defaults to `false`.
        """
        return pulumi.get(self, "last_day_of_month")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[str]:
        """
        Start time of the report. If empty, the start date will be set to the creation time. Note that times will be saved as UTC in Grafana. Use 2006-01-02T15:04:05 format if you want to set a custom timezone
        """
        return pulumi.get(self, "start_time")

    @property
    @pulumi.getter
    def timezone(self) -> Optional[str]:
        """
        Set the report time zone. Defaults to `GMT`.
        """
        return pulumi.get(self, "timezone")

    @property
    @pulumi.getter(name="workdaysOnly")
    def workdays_only(self) -> Optional[bool]:
        """
        Whether to send the report only on work days. Defaults to `false`.
        """
        return pulumi.get(self, "workdays_only")


@pulumi.output_type
class RolePermission(dict):
    def __init__(__self__, *,
                 action: str,
                 scope: Optional[str] = None):
        """
        :param str action: Specific action users granted with the role will be allowed to perform (for example: `users:read`)
        :param str scope: Scope to restrict the action to a set of resources (for example: `users:*` or `roles:customrole1`) Defaults to ``.
        """
        pulumi.set(__self__, "action", action)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        Specific action users granted with the role will be allowed to perform (for example: `users:read`)
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def scope(self) -> Optional[str]:
        """
        Scope to restrict the action to a set of resources (for example: `users:*` or `roles:customrole1`) Defaults to ``.
        """
        return pulumi.get(self, "scope")


@pulumi.output_type
class RuleGroupRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "execErrState":
            suggest = "exec_err_state"
        elif key == "for":
            suggest = "for_"
        elif key == "isPaused":
            suggest = "is_paused"
        elif key == "noDataState":
            suggest = "no_data_state"
        elif key == "notificationSettings":
            suggest = "notification_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 datas: Sequence['outputs.RuleGroupRuleData'],
                 name: str,
                 annotations: Optional[Mapping[str, str]] = None,
                 condition: Optional[str] = None,
                 exec_err_state: Optional[str] = None,
                 for_: Optional[str] = None,
                 is_paused: Optional[bool] = None,
                 labels: Optional[Mapping[str, str]] = None,
                 no_data_state: Optional[str] = None,
                 notification_settings: Optional['outputs.RuleGroupRuleNotificationSettings'] = None,
                 record: Optional['outputs.RuleGroupRuleRecord'] = None,
                 uid: Optional[str] = None):
        """
        :param Sequence['RuleGroupRuleDataArgs'] datas: A sequence of stages that describe the contents of the rule.
        :param str name: The name of the alert rule.
        :param Mapping[str, str] annotations: Key-value pairs of metadata to attach to the alert rule. They add additional information, such as a `summary` or `runbook_url`, to help identify and investigate alerts. The `dashboardUId` and `panelId` annotations, which link alerts to a panel, must be set together. Defaults to `map[]`.
        :param str condition: The `ref_id` of the query node in the `data` field to use as the alert condition.
        :param str exec_err_state: Describes what state to enter when the rule's query is invalid and the rule cannot be executed. Options are OK, Error, KeepLast, and Alerting.  Defaults to Alerting if not set.
        :param str for_: The amount of time for which the rule must be breached for the rule to be considered to be Firing. Before this time has elapsed, the rule is only considered to be Pending. Defaults to `0`.
        :param bool is_paused: Sets whether the alert should be paused or not. Defaults to `false`.
        :param Mapping[str, str] labels: Key-value pairs to attach to the alert rule that can be used in matching, grouping, and routing. Defaults to `map[]`.
        :param str no_data_state: Describes what state to enter when the rule's query returns No Data. Options are OK, NoData, KeepLast, and Alerting. Defaults to NoData if not set.
        :param 'RuleGroupRuleNotificationSettingsArgs' notification_settings: Notification settings for the rule. If specified, it overrides the notification policies. Available since Grafana 10.4, requires feature flag 'alertingSimplifiedRouting' to be enabled.
        :param 'RuleGroupRuleRecordArgs' record: Settings for a recording rule. Available since Grafana 11.2, requires feature flag 'grafanaManagedRecordingRules' to be enabled.
        :param str uid: The unique identifier of the alert rule.
        """
        pulumi.set(__self__, "datas", datas)
        pulumi.set(__self__, "name", name)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if exec_err_state is not None:
            pulumi.set(__self__, "exec_err_state", exec_err_state)
        if for_ is not None:
            pulumi.set(__self__, "for_", for_)
        if is_paused is not None:
            pulumi.set(__self__, "is_paused", is_paused)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if no_data_state is not None:
            pulumi.set(__self__, "no_data_state", no_data_state)
        if notification_settings is not None:
            pulumi.set(__self__, "notification_settings", notification_settings)
        if record is not None:
            pulumi.set(__self__, "record", record)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter
    def datas(self) -> Sequence['outputs.RuleGroupRuleData']:
        """
        A sequence of stages that describe the contents of the rule.
        """
        return pulumi.get(self, "datas")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the alert rule.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, str]]:
        """
        Key-value pairs of metadata to attach to the alert rule. They add additional information, such as a `summary` or `runbook_url`, to help identify and investigate alerts. The `dashboardUId` and `panelId` annotations, which link alerts to a panel, must be set together. Defaults to `map[]`.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def condition(self) -> Optional[str]:
        """
        The `ref_id` of the query node in the `data` field to use as the alert condition.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter(name="execErrState")
    def exec_err_state(self) -> Optional[str]:
        """
        Describes what state to enter when the rule's query is invalid and the rule cannot be executed. Options are OK, Error, KeepLast, and Alerting.  Defaults to Alerting if not set.
        """
        return pulumi.get(self, "exec_err_state")

    @property
    @pulumi.getter(name="for")
    def for_(self) -> Optional[str]:
        """
        The amount of time for which the rule must be breached for the rule to be considered to be Firing. Before this time has elapsed, the rule is only considered to be Pending. Defaults to `0`.
        """
        return pulumi.get(self, "for_")

    @property
    @pulumi.getter(name="isPaused")
    def is_paused(self) -> Optional[bool]:
        """
        Sets whether the alert should be paused or not. Defaults to `false`.
        """
        return pulumi.get(self, "is_paused")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, str]]:
        """
        Key-value pairs to attach to the alert rule that can be used in matching, grouping, and routing. Defaults to `map[]`.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="noDataState")
    def no_data_state(self) -> Optional[str]:
        """
        Describes what state to enter when the rule's query returns No Data. Options are OK, NoData, KeepLast, and Alerting. Defaults to NoData if not set.
        """
        return pulumi.get(self, "no_data_state")

    @property
    @pulumi.getter(name="notificationSettings")
    def notification_settings(self) -> Optional['outputs.RuleGroupRuleNotificationSettings']:
        """
        Notification settings for the rule. If specified, it overrides the notification policies. Available since Grafana 10.4, requires feature flag 'alertingSimplifiedRouting' to be enabled.
        """
        return pulumi.get(self, "notification_settings")

    @property
    @pulumi.getter
    def record(self) -> Optional['outputs.RuleGroupRuleRecord']:
        """
        Settings for a recording rule. Available since Grafana 11.2, requires feature flag 'grafanaManagedRecordingRules' to be enabled.
        """
        return pulumi.get(self, "record")

    @property
    @pulumi.getter
    def uid(self) -> Optional[str]:
        """
        The unique identifier of the alert rule.
        """
        return pulumi.get(self, "uid")


@pulumi.output_type
class RuleGroupRuleData(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "datasourceUid":
            suggest = "datasource_uid"
        elif key == "refId":
            suggest = "ref_id"
        elif key == "relativeTimeRange":
            suggest = "relative_time_range"
        elif key == "queryType":
            suggest = "query_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleData. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleData.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleData.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 datasource_uid: str,
                 model: str,
                 ref_id: str,
                 relative_time_range: 'outputs.RuleGroupRuleDataRelativeTimeRange',
                 query_type: Optional[str] = None):
        """
        :param str datasource_uid: The UID of the datasource being queried, or "-100" if this stage is an expression stage.
        :param str model: Custom JSON data to send to the specified datasource when querying.
        :param str ref_id: A unique string to identify this query stage within a rule.
        :param 'RuleGroupRuleDataRelativeTimeRangeArgs' relative_time_range: The time range, relative to when the query is executed, across which to query.
        :param str query_type: An optional identifier for the type of query being executed. Defaults to ``.
        """
        pulumi.set(__self__, "datasource_uid", datasource_uid)
        pulumi.set(__self__, "model", model)
        pulumi.set(__self__, "ref_id", ref_id)
        pulumi.set(__self__, "relative_time_range", relative_time_range)
        if query_type is not None:
            pulumi.set(__self__, "query_type", query_type)

    @property
    @pulumi.getter(name="datasourceUid")
    def datasource_uid(self) -> str:
        """
        The UID of the datasource being queried, or "-100" if this stage is an expression stage.
        """
        return pulumi.get(self, "datasource_uid")

    @property
    @pulumi.getter
    def model(self) -> str:
        """
        Custom JSON data to send to the specified datasource when querying.
        """
        return pulumi.get(self, "model")

    @property
    @pulumi.getter(name="refId")
    def ref_id(self) -> str:
        """
        A unique string to identify this query stage within a rule.
        """
        return pulumi.get(self, "ref_id")

    @property
    @pulumi.getter(name="relativeTimeRange")
    def relative_time_range(self) -> 'outputs.RuleGroupRuleDataRelativeTimeRange':
        """
        The time range, relative to when the query is executed, across which to query.
        """
        return pulumi.get(self, "relative_time_range")

    @property
    @pulumi.getter(name="queryType")
    def query_type(self) -> Optional[str]:
        """
        An optional identifier for the type of query being executed. Defaults to ``.
        """
        return pulumi.get(self, "query_type")


@pulumi.output_type
class RuleGroupRuleDataRelativeTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleDataRelativeTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleDataRelativeTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleDataRelativeTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_: int,
                 to: int):
        """
        :param int from_: The number of seconds in the past, relative to when the rule is evaluated, at which the time range begins.
        :param int to: The number of seconds in the past, relative to when the rule is evaluated, at which the time range ends.
        """
        pulumi.set(__self__, "from_", from_)
        pulumi.set(__self__, "to", to)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> int:
        """
        The number of seconds in the past, relative to when the rule is evaluated, at which the time range begins.
        """
        return pulumi.get(self, "from_")

    @property
    @pulumi.getter
    def to(self) -> int:
        """
        The number of seconds in the past, relative to when the rule is evaluated, at which the time range ends.
        """
        return pulumi.get(self, "to")


@pulumi.output_type
class RuleGroupRuleNotificationSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contactPoint":
            suggest = "contact_point"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "groupInterval":
            suggest = "group_interval"
        elif key == "groupWait":
            suggest = "group_wait"
        elif key == "muteTimings":
            suggest = "mute_timings"
        elif key == "repeatInterval":
            suggest = "repeat_interval"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleNotificationSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleNotificationSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleNotificationSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 contact_point: str,
                 group_bies: Optional[Sequence[str]] = None,
                 group_interval: Optional[str] = None,
                 group_wait: Optional[str] = None,
                 mute_timings: Optional[Sequence[str]] = None,
                 repeat_interval: Optional[str] = None):
        """
        :param str contact_point: The contact point to route notifications that match this rule to.
        :param Sequence[str] group_bies: A list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping. If empty, no grouping is used. If specified, requires labels 'alertname' and 'grafana_folder' to be included.
        :param str group_interval: Minimum time interval between two notifications for the same group. Default is 5 minutes.
        :param str group_wait: Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.
        :param Sequence[str] mute_timings: A list of mute timing names to apply to alerts that match this policy.
        :param str repeat_interval: Minimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.
        """
        pulumi.set(__self__, "contact_point", contact_point)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if group_interval is not None:
            pulumi.set(__self__, "group_interval", group_interval)
        if group_wait is not None:
            pulumi.set(__self__, "group_wait", group_wait)
        if mute_timings is not None:
            pulumi.set(__self__, "mute_timings", mute_timings)
        if repeat_interval is not None:
            pulumi.set(__self__, "repeat_interval", repeat_interval)

    @property
    @pulumi.getter(name="contactPoint")
    def contact_point(self) -> str:
        """
        The contact point to route notifications that match this rule to.
        """
        return pulumi.get(self, "contact_point")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence[str]]:
        """
        A list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping. If empty, no grouping is used. If specified, requires labels 'alertname' and 'grafana_folder' to be included.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="groupInterval")
    def group_interval(self) -> Optional[str]:
        """
        Minimum time interval between two notifications for the same group. Default is 5 minutes.
        """
        return pulumi.get(self, "group_interval")

    @property
    @pulumi.getter(name="groupWait")
    def group_wait(self) -> Optional[str]:
        """
        Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.
        """
        return pulumi.get(self, "group_wait")

    @property
    @pulumi.getter(name="muteTimings")
    def mute_timings(self) -> Optional[Sequence[str]]:
        """
        A list of mute timing names to apply to alerts that match this policy.
        """
        return pulumi.get(self, "mute_timings")

    @property
    @pulumi.getter(name="repeatInterval")
    def repeat_interval(self) -> Optional[str]:
        """
        Minimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.
        """
        return pulumi.get(self, "repeat_interval")


@pulumi.output_type
class RuleGroupRuleRecord(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleRecord. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleRecord.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleRecord.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_: str,
                 metric: str):
        """
        :param str from_: The ref id of the query node in the data field to use as the source of the metric.
        :param str metric: The name of the metric to write to.
        """
        pulumi.set(__self__, "from_", from_)
        pulumi.set(__self__, "metric", metric)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> str:
        """
        The ref id of the query node in the data field to use as the source of the metric.
        """
        return pulumi.get(self, "from_")

    @property
    @pulumi.getter
    def metric(self) -> str:
        """
        The name of the metric to write to.
        """
        return pulumi.get(self, "metric")


@pulumi.output_type
class SLOAlerting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "advancedOptions":
            suggest = "advanced_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SLOAlerting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SLOAlerting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SLOAlerting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 advanced_options: Optional['outputs.SLOAlertingAdvancedOptions'] = None,
                 annotations: Optional[Sequence['outputs.SLOAlertingAnnotation']] = None,
                 fastburns: Optional[Sequence['outputs.SLOAlertingFastburn']] = None,
                 labels: Optional[Sequence['outputs.SLOAlertingLabel']] = None,
                 slowburns: Optional[Sequence['outputs.SLOAlertingSlowburn']] = None):
        """
        :param 'SLOAlertingAdvancedOptionsArgs' advanced_options: Advanced Options for Alert Rules
        :param Sequence['SLOAlertingAnnotationArgs'] annotations: Annotations will be attached to all alerts generated by any of these rules.
        :param Sequence['SLOAlertingFastburnArgs'] fastburns: Alerting Rules generated for Fast Burn alerts
        :param Sequence['SLOAlertingLabelArgs'] labels: Labels will be attached to all alerts generated by any of these rules.
        :param Sequence['SLOAlertingSlowburnArgs'] slowburns: Alerting Rules generated for Slow Burn alerts
        """
        if advanced_options is not None:
            pulumi.set(__self__, "advanced_options", advanced_options)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if fastburns is not None:
            pulumi.set(__self__, "fastburns", fastburns)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if slowburns is not None:
            pulumi.set(__self__, "slowburns", slowburns)

    @property
    @pulumi.getter(name="advancedOptions")
    def advanced_options(self) -> Optional['outputs.SLOAlertingAdvancedOptions']:
        """
        Advanced Options for Alert Rules
        """
        return pulumi.get(self, "advanced_options")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence['outputs.SLOAlertingAnnotation']]:
        """
        Annotations will be attached to all alerts generated by any of these rules.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def fastburns(self) -> Optional[Sequence['outputs.SLOAlertingFastburn']]:
        """
        Alerting Rules generated for Fast Burn alerts
        """
        return pulumi.get(self, "fastburns")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Sequence['outputs.SLOAlertingLabel']]:
        """
        Labels will be attached to all alerts generated by any of these rules.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter
    def slowburns(self) -> Optional[Sequence['outputs.SLOAlertingSlowburn']]:
        """
        Alerting Rules generated for Slow Burn alerts
        """
        return pulumi.get(self, "slowburns")


@pulumi.output_type
class SLOAlertingAdvancedOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "minFailures":
            suggest = "min_failures"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SLOAlertingAdvancedOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SLOAlertingAdvancedOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SLOAlertingAdvancedOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 min_failures: Optional[int] = None):
        """
        :param int min_failures: Minimum number of failed events to trigger an alert
        """
        if min_failures is not None:
            pulumi.set(__self__, "min_failures", min_failures)

    @property
    @pulumi.getter(name="minFailures")
    def min_failures(self) -> Optional[int]:
        """
        Minimum number of failed events to trigger an alert
        """
        return pulumi.get(self, "min_failures")


@pulumi.output_type
class SLOAlertingAnnotation(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: Key for filtering and identification
        :param str value: Templatable value
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key for filtering and identification
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Templatable value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class SLOAlertingFastburn(dict):
    def __init__(__self__, *,
                 annotations: Optional[Sequence['outputs.SLOAlertingFastburnAnnotation']] = None,
                 labels: Optional[Sequence['outputs.SLOAlertingFastburnLabel']] = None):
        """
        :param Sequence['SLOAlertingFastburnAnnotationArgs'] annotations: Annotations to attach only to Fast Burn alerts.
        :param Sequence['SLOAlertingFastburnLabelArgs'] labels: Labels to attach only to Fast Burn alerts.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence['outputs.SLOAlertingFastburnAnnotation']]:
        """
        Annotations to attach only to Fast Burn alerts.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Sequence['outputs.SLOAlertingFastburnLabel']]:
        """
        Labels to attach only to Fast Burn alerts.
        """
        return pulumi.get(self, "labels")


@pulumi.output_type
class SLOAlertingFastburnAnnotation(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: Key for filtering and identification
        :param str value: Templatable value
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key for filtering and identification
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Templatable value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class SLOAlertingFastburnLabel(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: Key for filtering and identification
        :param str value: Templatable value
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key for filtering and identification
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Templatable value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class SLOAlertingLabel(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: Key for filtering and identification
        :param str value: Templatable value
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key for filtering and identification
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Templatable value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class SLOAlertingSlowburn(dict):
    def __init__(__self__, *,
                 annotations: Optional[Sequence['outputs.SLOAlertingSlowburnAnnotation']] = None,
                 labels: Optional[Sequence['outputs.SLOAlertingSlowburnLabel']] = None):
        """
        :param Sequence['SLOAlertingSlowburnAnnotationArgs'] annotations: Annotations to attach only to Slow Burn alerts.
        :param Sequence['SLOAlertingSlowburnLabelArgs'] labels: Labels to attach only to Slow Burn alerts.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence['outputs.SLOAlertingSlowburnAnnotation']]:
        """
        Annotations to attach only to Slow Burn alerts.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Sequence['outputs.SLOAlertingSlowburnLabel']]:
        """
        Labels to attach only to Slow Burn alerts.
        """
        return pulumi.get(self, "labels")


@pulumi.output_type
class SLOAlertingSlowburnAnnotation(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: Key for filtering and identification
        :param str value: Templatable value
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key for filtering and identification
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Templatable value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class SLOAlertingSlowburnLabel(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: Key for filtering and identification
        :param str value: Templatable value
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key for filtering and identification
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Templatable value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class SLODestinationDatasource(dict):
    def __init__(__self__, *,
                 uid: str):
        """
        :param str uid: UID for the Datasource
        """
        pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter
    def uid(self) -> str:
        """
        UID for the Datasource
        """
        return pulumi.get(self, "uid")


@pulumi.output_type
class SLOLabel(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: Key for filtering and identification
        :param str value: Templatable value
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key for filtering and identification
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Templatable value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class SLOObjective(dict):
    def __init__(__self__, *,
                 value: float,
                 window: str):
        """
        :param float value: Value between 0 and 1. If the value of the query is above the objective, the SLO is met.
        :param str window: A Prometheus-parsable time duration string like 24h, 60m. This is the time window the objective is measured over.
        """
        pulumi.set(__self__, "value", value)
        pulumi.set(__self__, "window", window)

    @property
    @pulumi.getter
    def value(self) -> float:
        """
        Value between 0 and 1. If the value of the query is above the objective, the SLO is met.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def window(self) -> str:
        """
        A Prometheus-parsable time duration string like 24h, 60m. This is the time window the objective is measured over.
        """
        return pulumi.get(self, "window")


@pulumi.output_type
class SLOQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "grafanaQueries":
            suggest = "grafana_queries"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SLOQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SLOQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SLOQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 freeform: Optional['outputs.SLOQueryFreeform'] = None,
                 grafana_queries: Optional['outputs.SLOQueryGrafanaQueries'] = None,
                 ratio: Optional['outputs.SLOQueryRatio'] = None):
        """
        :param str type: Query type must be one of: "freeform", "query", "ratio", "grafana_queries" or "threshold"
        :param 'SLOQueryGrafanaQueriesArgs' grafana_queries: Array for holding a set of grafana queries
        """
        pulumi.set(__self__, "type", type)
        if freeform is not None:
            pulumi.set(__self__, "freeform", freeform)
        if grafana_queries is not None:
            pulumi.set(__self__, "grafana_queries", grafana_queries)
        if ratio is not None:
            pulumi.set(__self__, "ratio", ratio)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Query type must be one of: "freeform", "query", "ratio", "grafana_queries" or "threshold"
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def freeform(self) -> Optional['outputs.SLOQueryFreeform']:
        return pulumi.get(self, "freeform")

    @property
    @pulumi.getter(name="grafanaQueries")
    def grafana_queries(self) -> Optional['outputs.SLOQueryGrafanaQueries']:
        """
        Array for holding a set of grafana queries
        """
        return pulumi.get(self, "grafana_queries")

    @property
    @pulumi.getter
    def ratio(self) -> Optional['outputs.SLOQueryRatio']:
        return pulumi.get(self, "ratio")


@pulumi.output_type
class SLOQueryFreeform(dict):
    def __init__(__self__, *,
                 query: str):
        """
        :param str query: Freeform Query Field - valid promQl
        """
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        Freeform Query Field - valid promQl
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class SLOQueryGrafanaQueries(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "grafanaQueries":
            suggest = "grafana_queries"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SLOQueryGrafanaQueries. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SLOQueryGrafanaQueries.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SLOQueryGrafanaQueries.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 grafana_queries: str):
        """
        :param str grafana_queries: Query Object - Array of Grafana Query JSON objects
        """
        pulumi.set(__self__, "grafana_queries", grafana_queries)

    @property
    @pulumi.getter(name="grafanaQueries")
    def grafana_queries(self) -> str:
        """
        Query Object - Array of Grafana Query JSON objects
        """
        return pulumi.get(self, "grafana_queries")


@pulumi.output_type
class SLOQueryRatio(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "successMetric":
            suggest = "success_metric"
        elif key == "totalMetric":
            suggest = "total_metric"
        elif key == "groupByLabels":
            suggest = "group_by_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SLOQueryRatio. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SLOQueryRatio.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SLOQueryRatio.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 success_metric: str,
                 total_metric: str,
                 group_by_labels: Optional[Sequence[str]] = None):
        """
        :param str success_metric: Counter metric for success events (numerator)
        :param str total_metric: Metric for total events (denominator)
        :param Sequence[str] group_by_labels: Defines Group By Labels used for per-label alerting. These appear as variables on SLO dashboards to enable filtering and aggregation. Labels must adhere to Prometheus label name schema - "^[a-zA-Z*][a-zA-Z0-9*]*$"
        """
        pulumi.set(__self__, "success_metric", success_metric)
        pulumi.set(__self__, "total_metric", total_metric)
        if group_by_labels is not None:
            pulumi.set(__self__, "group_by_labels", group_by_labels)

    @property
    @pulumi.getter(name="successMetric")
    def success_metric(self) -> str:
        """
        Counter metric for success events (numerator)
        """
        return pulumi.get(self, "success_metric")

    @property
    @pulumi.getter(name="totalMetric")
    def total_metric(self) -> str:
        """
        Metric for total events (denominator)
        """
        return pulumi.get(self, "total_metric")

    @property
    @pulumi.getter(name="groupByLabels")
    def group_by_labels(self) -> Optional[Sequence[str]]:
        """
        Defines Group By Labels used for per-label alerting. These appear as variables on SLO dashboards to enable filtering and aggregation. Labels must adhere to Prometheus label name schema - "^[a-zA-Z*][a-zA-Z0-9*]*$"
        """
        return pulumi.get(self, "group_by_labels")


@pulumi.output_type
class ServiceAccountPermissionPermission(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "teamId":
            suggest = "team_id"
        elif key == "userId":
            suggest = "user_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceAccountPermissionPermission. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceAccountPermissionPermission.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceAccountPermissionPermission.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 permission: str,
                 team_id: Optional[str] = None,
                 user_id: Optional[str] = None):
        """
        :param str permission: Permission to associate with item. Must be one of `View`, `Edit`, or `Admin`.
        :param str team_id: ID of the team to manage permissions for. Defaults to `0`.
        :param str user_id: ID of the user or service account to manage permissions for. Defaults to `0`.
        """
        pulumi.set(__self__, "permission", permission)
        if team_id is not None:
            pulumi.set(__self__, "team_id", team_id)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)

    @property
    @pulumi.getter
    def permission(self) -> str:
        """
        Permission to associate with item. Must be one of `View`, `Edit`, or `Admin`.
        """
        return pulumi.get(self, "permission")

    @property
    @pulumi.getter(name="teamId")
    def team_id(self) -> Optional[str]:
        """
        ID of the team to manage permissions for. Defaults to `0`.
        """
        return pulumi.get(self, "team_id")

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[str]:
        """
        ID of the user or service account to manage permissions for. Defaults to `0`.
        """
        return pulumi.get(self, "user_id")


@pulumi.output_type
class SsoSettingsLdapSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowSignUp":
            suggest = "allow_sign_up"
        elif key == "skipOrgRoleSync":
            suggest = "skip_org_role_sync"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SsoSettingsLdapSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SsoSettingsLdapSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SsoSettingsLdapSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 config: 'outputs.SsoSettingsLdapSettingsConfig',
                 allow_sign_up: Optional[bool] = None,
                 enabled: Optional[bool] = None,
                 skip_org_role_sync: Optional[bool] = None):
        """
        :param 'SsoSettingsLdapSettingsConfigArgs' config: The LDAP configuration.
        :param bool allow_sign_up: Whether to allow new Grafana user creation through LDAP login. If set to false, then only existing Grafana users can log in with LDAP.
        :param bool enabled: Define whether this configuration is enabled for LDAP. Defaults to `true`.
        :param bool skip_org_role_sync: Prevent synchronizing users organization roles from LDAP.
        """
        pulumi.set(__self__, "config", config)
        if allow_sign_up is not None:
            pulumi.set(__self__, "allow_sign_up", allow_sign_up)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if skip_org_role_sync is not None:
            pulumi.set(__self__, "skip_org_role_sync", skip_org_role_sync)

    @property
    @pulumi.getter
    def config(self) -> 'outputs.SsoSettingsLdapSettingsConfig':
        """
        The LDAP configuration.
        """
        return pulumi.get(self, "config")

    @property
    @pulumi.getter(name="allowSignUp")
    def allow_sign_up(self) -> Optional[bool]:
        """
        Whether to allow new Grafana user creation through LDAP login. If set to false, then only existing Grafana users can log in with LDAP.
        """
        return pulumi.get(self, "allow_sign_up")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Define whether this configuration is enabled for LDAP. Defaults to `true`.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="skipOrgRoleSync")
    def skip_org_role_sync(self) -> Optional[bool]:
        """
        Prevent synchronizing users organization roles from LDAP.
        """
        return pulumi.get(self, "skip_org_role_sync")


@pulumi.output_type
class SsoSettingsLdapSettingsConfig(dict):
    def __init__(__self__, *,
                 servers: Sequence['outputs.SsoSettingsLdapSettingsConfigServer']):
        """
        :param Sequence['SsoSettingsLdapSettingsConfigServerArgs'] servers: The LDAP servers configuration.
        """
        pulumi.set(__self__, "servers", servers)

    @property
    @pulumi.getter
    def servers(self) -> Sequence['outputs.SsoSettingsLdapSettingsConfigServer']:
        """
        The LDAP servers configuration.
        """
        return pulumi.get(self, "servers")


@pulumi.output_type
class SsoSettingsLdapSettingsConfigServer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "searchBaseDns":
            suggest = "search_base_dns"
        elif key == "searchFilter":
            suggest = "search_filter"
        elif key == "bindDn":
            suggest = "bind_dn"
        elif key == "bindPassword":
            suggest = "bind_password"
        elif key == "clientCert":
            suggest = "client_cert"
        elif key == "clientCertValue":
            suggest = "client_cert_value"
        elif key == "clientKey":
            suggest = "client_key"
        elif key == "clientKeyValue":
            suggest = "client_key_value"
        elif key == "groupMappings":
            suggest = "group_mappings"
        elif key == "groupSearchBaseDns":
            suggest = "group_search_base_dns"
        elif key == "groupSearchFilter":
            suggest = "group_search_filter"
        elif key == "groupSearchFilterUserAttribute":
            suggest = "group_search_filter_user_attribute"
        elif key == "minTlsVersion":
            suggest = "min_tls_version"
        elif key == "rootCaCert":
            suggest = "root_ca_cert"
        elif key == "rootCaCertValues":
            suggest = "root_ca_cert_values"
        elif key == "sslSkipVerify":
            suggest = "ssl_skip_verify"
        elif key == "startTls":
            suggest = "start_tls"
        elif key == "tlsCiphers":
            suggest = "tls_ciphers"
        elif key == "useSsl":
            suggest = "use_ssl"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SsoSettingsLdapSettingsConfigServer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SsoSettingsLdapSettingsConfigServer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SsoSettingsLdapSettingsConfigServer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host: str,
                 search_base_dns: Sequence[str],
                 search_filter: str,
                 attributes: Optional[Mapping[str, str]] = None,
                 bind_dn: Optional[str] = None,
                 bind_password: Optional[str] = None,
                 client_cert: Optional[str] = None,
                 client_cert_value: Optional[str] = None,
                 client_key: Optional[str] = None,
                 client_key_value: Optional[str] = None,
                 group_mappings: Optional[Sequence['outputs.SsoSettingsLdapSettingsConfigServerGroupMapping']] = None,
                 group_search_base_dns: Optional[Sequence[str]] = None,
                 group_search_filter: Optional[str] = None,
                 group_search_filter_user_attribute: Optional[str] = None,
                 min_tls_version: Optional[str] = None,
                 port: Optional[int] = None,
                 root_ca_cert: Optional[str] = None,
                 root_ca_cert_values: Optional[Sequence[str]] = None,
                 ssl_skip_verify: Optional[bool] = None,
                 start_tls: Optional[bool] = None,
                 timeout: Optional[int] = None,
                 tls_ciphers: Optional[Sequence[str]] = None,
                 use_ssl: Optional[bool] = None):
        """
        :param str host: The LDAP server host.
        :param Sequence[str] search_base_dns: An array of base DNs to search through.
        :param str search_filter: The user search filter, for example "(cn=%s)" or "(sAMAccountName=%s)" or "(uid=%s)".
        :param Mapping[str, str] attributes: The LDAP server attributes. The following attributes can be configured: email, member_of, name, surname, username.
        :param str bind_dn: The search user bind DN.
        :param str bind_password: The search user bind password.
        :param str client_cert: The path to the client certificate.
        :param str client_cert_value: The Base64 encoded value of the client certificate.
        :param str client_key: The path to the client private key.
        :param str client_key_value: The Base64 encoded value of the client private key.
        :param Sequence['SsoSettingsLdapSettingsConfigServerGroupMappingArgs'] group_mappings: For mapping an LDAP group to a Grafana organization and role.
        :param Sequence[str] group_search_base_dns: An array of the base DNs to search through for groups. Typically uses ou=groups.
        :param str group_search_filter: Group search filter, to retrieve the groups of which the user is a member (only set if memberOf attribute is not available).
        :param str group_search_filter_user_attribute: The %s in the search filter will be replaced with the attribute defined in this field.
        :param str min_tls_version: Minimum TLS version allowed. Accepted values are: TLS1.2, TLS1.3.
        :param int port: The LDAP server port.
        :param str root_ca_cert: The path to the root CA certificate.
        :param Sequence[str] root_ca_cert_values: The Base64 encoded values of the root CA certificates.
        :param bool ssl_skip_verify: If set to true, the SSL cert validation will be skipped.
        :param bool start_tls: If set to true, use LDAP with STARTTLS instead of LDAPS.
        :param int timeout: The timeout in seconds for connecting to the LDAP host.
        :param Sequence[str] tls_ciphers: Accepted TLS ciphers. For a complete list of supported ciphers, refer to: https://go.dev/src/crypto/tls/cipher_suites.go.
        :param bool use_ssl: Set to true if LDAP server should use an encrypted TLS connection (either with STARTTLS or LDAPS).
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "search_base_dns", search_base_dns)
        pulumi.set(__self__, "search_filter", search_filter)
        if attributes is not None:
            pulumi.set(__self__, "attributes", attributes)
        if bind_dn is not None:
            pulumi.set(__self__, "bind_dn", bind_dn)
        if bind_password is not None:
            pulumi.set(__self__, "bind_password", bind_password)
        if client_cert is not None:
            pulumi.set(__self__, "client_cert", client_cert)
        if client_cert_value is not None:
            pulumi.set(__self__, "client_cert_value", client_cert_value)
        if client_key is not None:
            pulumi.set(__self__, "client_key", client_key)
        if client_key_value is not None:
            pulumi.set(__self__, "client_key_value", client_key_value)
        if group_mappings is not None:
            pulumi.set(__self__, "group_mappings", group_mappings)
        if group_search_base_dns is not None:
            pulumi.set(__self__, "group_search_base_dns", group_search_base_dns)
        if group_search_filter is not None:
            pulumi.set(__self__, "group_search_filter", group_search_filter)
        if group_search_filter_user_attribute is not None:
            pulumi.set(__self__, "group_search_filter_user_attribute", group_search_filter_user_attribute)
        if min_tls_version is not None:
            pulumi.set(__self__, "min_tls_version", min_tls_version)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if root_ca_cert is not None:
            pulumi.set(__self__, "root_ca_cert", root_ca_cert)
        if root_ca_cert_values is not None:
            pulumi.set(__self__, "root_ca_cert_values", root_ca_cert_values)
        if ssl_skip_verify is not None:
            pulumi.set(__self__, "ssl_skip_verify", ssl_skip_verify)
        if start_tls is not None:
            pulumi.set(__self__, "start_tls", start_tls)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if tls_ciphers is not None:
            pulumi.set(__self__, "tls_ciphers", tls_ciphers)
        if use_ssl is not None:
            pulumi.set(__self__, "use_ssl", use_ssl)

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        The LDAP server host.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="searchBaseDns")
    def search_base_dns(self) -> Sequence[str]:
        """
        An array of base DNs to search through.
        """
        return pulumi.get(self, "search_base_dns")

    @property
    @pulumi.getter(name="searchFilter")
    def search_filter(self) -> str:
        """
        The user search filter, for example "(cn=%s)" or "(sAMAccountName=%s)" or "(uid=%s)".
        """
        return pulumi.get(self, "search_filter")

    @property
    @pulumi.getter
    def attributes(self) -> Optional[Mapping[str, str]]:
        """
        The LDAP server attributes. The following attributes can be configured: email, member_of, name, surname, username.
        """
        return pulumi.get(self, "attributes")

    @property
    @pulumi.getter(name="bindDn")
    def bind_dn(self) -> Optional[str]:
        """
        The search user bind DN.
        """
        return pulumi.get(self, "bind_dn")

    @property
    @pulumi.getter(name="bindPassword")
    def bind_password(self) -> Optional[str]:
        """
        The search user bind password.
        """
        return pulumi.get(self, "bind_password")

    @property
    @pulumi.getter(name="clientCert")
    def client_cert(self) -> Optional[str]:
        """
        The path to the client certificate.
        """
        return pulumi.get(self, "client_cert")

    @property
    @pulumi.getter(name="clientCertValue")
    def client_cert_value(self) -> Optional[str]:
        """
        The Base64 encoded value of the client certificate.
        """
        return pulumi.get(self, "client_cert_value")

    @property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> Optional[str]:
        """
        The path to the client private key.
        """
        return pulumi.get(self, "client_key")

    @property
    @pulumi.getter(name="clientKeyValue")
    def client_key_value(self) -> Optional[str]:
        """
        The Base64 encoded value of the client private key.
        """
        return pulumi.get(self, "client_key_value")

    @property
    @pulumi.getter(name="groupMappings")
    def group_mappings(self) -> Optional[Sequence['outputs.SsoSettingsLdapSettingsConfigServerGroupMapping']]:
        """
        For mapping an LDAP group to a Grafana organization and role.
        """
        return pulumi.get(self, "group_mappings")

    @property
    @pulumi.getter(name="groupSearchBaseDns")
    def group_search_base_dns(self) -> Optional[Sequence[str]]:
        """
        An array of the base DNs to search through for groups. Typically uses ou=groups.
        """
        return pulumi.get(self, "group_search_base_dns")

    @property
    @pulumi.getter(name="groupSearchFilter")
    def group_search_filter(self) -> Optional[str]:
        """
        Group search filter, to retrieve the groups of which the user is a member (only set if memberOf attribute is not available).
        """
        return pulumi.get(self, "group_search_filter")

    @property
    @pulumi.getter(name="groupSearchFilterUserAttribute")
    def group_search_filter_user_attribute(self) -> Optional[str]:
        """
        The %s in the search filter will be replaced with the attribute defined in this field.
        """
        return pulumi.get(self, "group_search_filter_user_attribute")

    @property
    @pulumi.getter(name="minTlsVersion")
    def min_tls_version(self) -> Optional[str]:
        """
        Minimum TLS version allowed. Accepted values are: TLS1.2, TLS1.3.
        """
        return pulumi.get(self, "min_tls_version")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The LDAP server port.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="rootCaCert")
    def root_ca_cert(self) -> Optional[str]:
        """
        The path to the root CA certificate.
        """
        return pulumi.get(self, "root_ca_cert")

    @property
    @pulumi.getter(name="rootCaCertValues")
    def root_ca_cert_values(self) -> Optional[Sequence[str]]:
        """
        The Base64 encoded values of the root CA certificates.
        """
        return pulumi.get(self, "root_ca_cert_values")

    @property
    @pulumi.getter(name="sslSkipVerify")
    def ssl_skip_verify(self) -> Optional[bool]:
        """
        If set to true, the SSL cert validation will be skipped.
        """
        return pulumi.get(self, "ssl_skip_verify")

    @property
    @pulumi.getter(name="startTls")
    def start_tls(self) -> Optional[bool]:
        """
        If set to true, use LDAP with STARTTLS instead of LDAPS.
        """
        return pulumi.get(self, "start_tls")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[int]:
        """
        The timeout in seconds for connecting to the LDAP host.
        """
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter(name="tlsCiphers")
    def tls_ciphers(self) -> Optional[Sequence[str]]:
        """
        Accepted TLS ciphers. For a complete list of supported ciphers, refer to: https://go.dev/src/crypto/tls/cipher_suites.go.
        """
        return pulumi.get(self, "tls_ciphers")

    @property
    @pulumi.getter(name="useSsl")
    def use_ssl(self) -> Optional[bool]:
        """
        Set to true if LDAP server should use an encrypted TLS connection (either with STARTTLS or LDAPS).
        """
        return pulumi.get(self, "use_ssl")


@pulumi.output_type
class SsoSettingsLdapSettingsConfigServerGroupMapping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupDn":
            suggest = "group_dn"
        elif key == "orgRole":
            suggest = "org_role"
        elif key == "grafanaAdmin":
            suggest = "grafana_admin"
        elif key == "orgId":
            suggest = "org_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SsoSettingsLdapSettingsConfigServerGroupMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SsoSettingsLdapSettingsConfigServerGroupMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SsoSettingsLdapSettingsConfigServerGroupMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 group_dn: str,
                 org_role: str,
                 grafana_admin: Optional[bool] = None,
                 org_id: Optional[int] = None):
        """
        :param str group_dn: LDAP distinguished name (DN) of LDAP group. If you want to match all (or no LDAP groups) then you can use wildcard ("*").
        :param str org_role: Assign users of group_dn the organization role Admin, Editor, or Viewer.
        :param bool grafana_admin: If set to true, it makes the user of group_dn Grafana server admin.
        :param int org_id: The Grafana organization database id.
        """
        pulumi.set(__self__, "group_dn", group_dn)
        pulumi.set(__self__, "org_role", org_role)
        if grafana_admin is not None:
            pulumi.set(__self__, "grafana_admin", grafana_admin)
        if org_id is not None:
            pulumi.set(__self__, "org_id", org_id)

    @property
    @pulumi.getter(name="groupDn")
    def group_dn(self) -> str:
        """
        LDAP distinguished name (DN) of LDAP group. If you want to match all (or no LDAP groups) then you can use wildcard ("*").
        """
        return pulumi.get(self, "group_dn")

    @property
    @pulumi.getter(name="orgRole")
    def org_role(self) -> str:
        """
        Assign users of group_dn the organization role Admin, Editor, or Viewer.
        """
        return pulumi.get(self, "org_role")

    @property
    @pulumi.getter(name="grafanaAdmin")
    def grafana_admin(self) -> Optional[bool]:
        """
        If set to true, it makes the user of group_dn Grafana server admin.
        """
        return pulumi.get(self, "grafana_admin")

    @property
    @pulumi.getter(name="orgId")
    def org_id(self) -> Optional[int]:
        """
        The Grafana organization database id.
        """
        return pulumi.get(self, "org_id")


@pulumi.output_type
class SsoSettingsOauth2Settings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "allowAssignGrafanaAdmin":
            suggest = "allow_assign_grafana_admin"
        elif key == "allowSignUp":
            suggest = "allow_sign_up"
        elif key == "allowedDomains":
            suggest = "allowed_domains"
        elif key == "allowedGroups":
            suggest = "allowed_groups"
        elif key == "allowedOrganizations":
            suggest = "allowed_organizations"
        elif key == "apiUrl":
            suggest = "api_url"
        elif key == "authStyle":
            suggest = "auth_style"
        elif key == "authUrl":
            suggest = "auth_url"
        elif key == "autoLogin":
            suggest = "auto_login"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "defineAllowedGroups":
            suggest = "define_allowed_groups"
        elif key == "defineAllowedTeamsIds":
            suggest = "define_allowed_teams_ids"
        elif key == "emailAttributeName":
            suggest = "email_attribute_name"
        elif key == "emailAttributePath":
            suggest = "email_attribute_path"
        elif key == "emptyScopes":
            suggest = "empty_scopes"
        elif key == "groupsAttributePath":
            suggest = "groups_attribute_path"
        elif key == "idTokenAttributeName":
            suggest = "id_token_attribute_name"
        elif key == "loginAttributePath":
            suggest = "login_attribute_path"
        elif key == "nameAttributePath":
            suggest = "name_attribute_path"
        elif key == "orgAttributePath":
            suggest = "org_attribute_path"
        elif key == "orgMapping":
            suggest = "org_mapping"
        elif key == "roleAttributePath":
            suggest = "role_attribute_path"
        elif key == "roleAttributeStrict":
            suggest = "role_attribute_strict"
        elif key == "signoutRedirectUrl":
            suggest = "signout_redirect_url"
        elif key == "skipOrgRoleSync":
            suggest = "skip_org_role_sync"
        elif key == "teamIds":
            suggest = "team_ids"
        elif key == "teamIdsAttributePath":
            suggest = "team_ids_attribute_path"
        elif key == "teamsUrl":
            suggest = "teams_url"
        elif key == "tlsClientCa":
            suggest = "tls_client_ca"
        elif key == "tlsClientCert":
            suggest = "tls_client_cert"
        elif key == "tlsClientKey":
            suggest = "tls_client_key"
        elif key == "tlsSkipVerifyInsecure":
            suggest = "tls_skip_verify_insecure"
        elif key == "tokenUrl":
            suggest = "token_url"
        elif key == "usePkce":
            suggest = "use_pkce"
        elif key == "useRefreshToken":
            suggest = "use_refresh_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SsoSettingsOauth2Settings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SsoSettingsOauth2Settings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SsoSettingsOauth2Settings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 allow_assign_grafana_admin: Optional[bool] = None,
                 allow_sign_up: Optional[bool] = None,
                 allowed_domains: Optional[str] = None,
                 allowed_groups: Optional[str] = None,
                 allowed_organizations: Optional[str] = None,
                 api_url: Optional[str] = None,
                 auth_style: Optional[str] = None,
                 auth_url: Optional[str] = None,
                 auto_login: Optional[bool] = None,
                 client_secret: Optional[str] = None,
                 custom: Optional[Mapping[str, str]] = None,
                 define_allowed_groups: Optional[bool] = None,
                 define_allowed_teams_ids: Optional[bool] = None,
                 email_attribute_name: Optional[str] = None,
                 email_attribute_path: Optional[str] = None,
                 empty_scopes: Optional[bool] = None,
                 enabled: Optional[bool] = None,
                 groups_attribute_path: Optional[str] = None,
                 id_token_attribute_name: Optional[str] = None,
                 login_attribute_path: Optional[str] = None,
                 name: Optional[str] = None,
                 name_attribute_path: Optional[str] = None,
                 org_attribute_path: Optional[str] = None,
                 org_mapping: Optional[str] = None,
                 role_attribute_path: Optional[str] = None,
                 role_attribute_strict: Optional[bool] = None,
                 scopes: Optional[str] = None,
                 signout_redirect_url: Optional[str] = None,
                 skip_org_role_sync: Optional[bool] = None,
                 team_ids: Optional[str] = None,
                 team_ids_attribute_path: Optional[str] = None,
                 teams_url: Optional[str] = None,
                 tls_client_ca: Optional[str] = None,
                 tls_client_cert: Optional[str] = None,
                 tls_client_key: Optional[str] = None,
                 tls_skip_verify_insecure: Optional[bool] = None,
                 token_url: Optional[str] = None,
                 use_pkce: Optional[bool] = None,
                 use_refresh_token: Optional[bool] = None):
        """
        :param str client_id: The client Id of your OAuth2 app.
        :param bool allow_assign_grafana_admin: If enabled, it will automatically sync the Grafana server administrator role.
        :param bool allow_sign_up: If not enabled, only existing Grafana users can log in using OAuth.
        :param str allowed_domains: List of comma- or space-separated domains. The user should belong to at least one domain to log in.
        :param str allowed_groups: List of comma- or space-separated groups. The user should be a member of at least one group to log in. For Generic OAuth, if you configure allowed*groups, you must also configure groups*attribute_path.
        :param str allowed_organizations: List of comma- or space-separated organizations. The user should be a member of at least one organization to log in.
        :param str api_url: The user information endpoint of your OAuth2 provider. Required for okta and generic_oauth providers.
        :param str auth_style: It determines how client*id and client*secret are sent to Oauth2 provider. Possible values are AutoDetect, InParams, InHeader. Default is AutoDetect.
        :param str auth_url: The authorization endpoint of your OAuth2 provider. Required for azuread, okta and generic_oauth providers.
        :param bool auto_login: Log in automatically, skipping the login screen.
        :param str client_secret: The client secret of your OAuth2 app.
        :param Mapping[str, str] custom: Custom fields to configure for OAuth2 such as the [force*use*graph_api](https://grafana.com/docs/grafana/latest/setup-grafana/configure-security/configure-authentication/azuread/#force-fetching-groups-from-microsoft-graph-api) field.
        :param bool define_allowed_groups: Define allowed groups.
        :param bool define_allowed_teams_ids: Define allowed teams ids.
        :param str email_attribute_name: Name of the key to use for user email lookup within the attributes map of OAuth2 ID token. Only applicable to Generic OAuth.
        :param str email_attribute_path: JMESPath expression to use for user email lookup from the user information. Only applicable to Generic OAuth.
        :param bool empty_scopes: If enabled, no scopes will be sent to the OAuth2 provider.
        :param bool enabled: Define whether this configuration is enabled for the specified provider. Defaults to `true`.
        :param str groups_attribute_path: JMESPath expression to use for user group lookup. If you configure allowed*groups, you must also configure groups*attribute_path.
        :param str id_token_attribute_name: The name of the key used to extract the ID token from the returned OAuth2 token. Only applicable to Generic OAuth.
        :param str login_attribute_path: JMESPath expression to use for user login lookup from the user ID token. Only applicable to Generic OAuth.
        :param str name: Helpful if you use more than one identity providers or SSO protocols.
        :param str name_attribute_path: JMESPath expression to use for user name lookup from the user ID token. This name will be used as the users display name. Only applicable to Generic OAuth.
        :param str org_attribute_path: JMESPath expression to use for the organization mapping lookup from the user ID token. The extracted list will be used for the organization mapping (to match "Organization" in the "org_mapping"). Only applicable to Generic OAuth and Okta.
        :param str org_mapping: List of comma- or space-separated Organization:OrgIdOrOrgName:Role mappings. Organization can be * meaning All users. Role is optional and can have the following values: None, Viewer, Editor or Admin.
        :param str role_attribute_path: JMESPath expression to use for Grafana role lookup.
        :param bool role_attribute_strict: If enabled, denies user login if the Grafana role cannot be extracted using Role attribute path.
        :param str scopes: List of comma- or space-separated OAuth2 scopes.
        :param str signout_redirect_url: The URL to redirect the user to after signing out from Grafana.
        :param bool skip_org_role_sync: Prevent synchronizing users organization roles from your IdP.
        :param str team_ids: String list of Team Ids. If set, the user must be a member of one of the given teams to log in. If you configure team*ids, you must also configure teams*url and team*ids*attribute_path.
        :param str team_ids_attribute_path: The JMESPath expression to use for Grafana Team Id lookup within the results returned by the teams_url endpoint. Only applicable to Generic OAuth.
        :param str teams_url: The URL used to query for Team Ids. If not set, the default value is /teams. If you configure teams*url, you must also configure team*ids*attribute*path. Only applicable to Generic OAuth.
        :param str tls_client_ca: The path to the trusted certificate authority list. Is not applicable on Grafana Cloud.
        :param str tls_client_cert: The path to the certificate. Is not applicable on Grafana Cloud.
        :param str tls_client_key: The path to the key. Is not applicable on Grafana Cloud.
        :param bool tls_skip_verify_insecure: If enabled, the client accepts any certificate presented by the server and any host name in that certificate. You should only use this for testing, because this mode leaves SSL/TLS susceptible to man-in-the-middle attacks.
        :param str token_url: The token endpoint of your OAuth2 provider. Required for azuread, okta and generic_oauth providers.
        :param bool use_pkce: If enabled, Grafana will use Proof Key for Code Exchange (PKCE) with the OAuth2 Authorization Code Grant.
        :param bool use_refresh_token: If enabled, Grafana will fetch a new access token using the refresh token provided by the OAuth2 provider.
        """
        pulumi.set(__self__, "client_id", client_id)
        if allow_assign_grafana_admin is not None:
            pulumi.set(__self__, "allow_assign_grafana_admin", allow_assign_grafana_admin)
        if allow_sign_up is not None:
            pulumi.set(__self__, "allow_sign_up", allow_sign_up)
        if allowed_domains is not None:
            pulumi.set(__self__, "allowed_domains", allowed_domains)
        if allowed_groups is not None:
            pulumi.set(__self__, "allowed_groups", allowed_groups)
        if allowed_organizations is not None:
            pulumi.set(__self__, "allowed_organizations", allowed_organizations)
        if api_url is not None:
            pulumi.set(__self__, "api_url", api_url)
        if auth_style is not None:
            pulumi.set(__self__, "auth_style", auth_style)
        if auth_url is not None:
            pulumi.set(__self__, "auth_url", auth_url)
        if auto_login is not None:
            pulumi.set(__self__, "auto_login", auto_login)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if custom is not None:
            pulumi.set(__self__, "custom", custom)
        if define_allowed_groups is not None:
            pulumi.set(__self__, "define_allowed_groups", define_allowed_groups)
        if define_allowed_teams_ids is not None:
            pulumi.set(__self__, "define_allowed_teams_ids", define_allowed_teams_ids)
        if email_attribute_name is not None:
            pulumi.set(__self__, "email_attribute_name", email_attribute_name)
        if email_attribute_path is not None:
            pulumi.set(__self__, "email_attribute_path", email_attribute_path)
        if empty_scopes is not None:
            pulumi.set(__self__, "empty_scopes", empty_scopes)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if groups_attribute_path is not None:
            pulumi.set(__self__, "groups_attribute_path", groups_attribute_path)
        if id_token_attribute_name is not None:
            pulumi.set(__self__, "id_token_attribute_name", id_token_attribute_name)
        if login_attribute_path is not None:
            pulumi.set(__self__, "login_attribute_path", login_attribute_path)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if name_attribute_path is not None:
            pulumi.set(__self__, "name_attribute_path", name_attribute_path)
        if org_attribute_path is not None:
            pulumi.set(__self__, "org_attribute_path", org_attribute_path)
        if org_mapping is not None:
            pulumi.set(__self__, "org_mapping", org_mapping)
        if role_attribute_path is not None:
            pulumi.set(__self__, "role_attribute_path", role_attribute_path)
        if role_attribute_strict is not None:
            pulumi.set(__self__, "role_attribute_strict", role_attribute_strict)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if signout_redirect_url is not None:
            pulumi.set(__self__, "signout_redirect_url", signout_redirect_url)
        if skip_org_role_sync is not None:
            pulumi.set(__self__, "skip_org_role_sync", skip_org_role_sync)
        if team_ids is not None:
            pulumi.set(__self__, "team_ids", team_ids)
        if team_ids_attribute_path is not None:
            pulumi.set(__self__, "team_ids_attribute_path", team_ids_attribute_path)
        if teams_url is not None:
            pulumi.set(__self__, "teams_url", teams_url)
        if tls_client_ca is not None:
            pulumi.set(__self__, "tls_client_ca", tls_client_ca)
        if tls_client_cert is not None:
            pulumi.set(__self__, "tls_client_cert", tls_client_cert)
        if tls_client_key is not None:
            pulumi.set(__self__, "tls_client_key", tls_client_key)
        if tls_skip_verify_insecure is not None:
            pulumi.set(__self__, "tls_skip_verify_insecure", tls_skip_verify_insecure)
        if token_url is not None:
            pulumi.set(__self__, "token_url", token_url)
        if use_pkce is not None:
            pulumi.set(__self__, "use_pkce", use_pkce)
        if use_refresh_token is not None:
            pulumi.set(__self__, "use_refresh_token", use_refresh_token)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The client Id of your OAuth2 app.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="allowAssignGrafanaAdmin")
    def allow_assign_grafana_admin(self) -> Optional[bool]:
        """
        If enabled, it will automatically sync the Grafana server administrator role.
        """
        return pulumi.get(self, "allow_assign_grafana_admin")

    @property
    @pulumi.getter(name="allowSignUp")
    def allow_sign_up(self) -> Optional[bool]:
        """
        If not enabled, only existing Grafana users can log in using OAuth.
        """
        return pulumi.get(self, "allow_sign_up")

    @property
    @pulumi.getter(name="allowedDomains")
    def allowed_domains(self) -> Optional[str]:
        """
        List of comma- or space-separated domains. The user should belong to at least one domain to log in.
        """
        return pulumi.get(self, "allowed_domains")

    @property
    @pulumi.getter(name="allowedGroups")
    def allowed_groups(self) -> Optional[str]:
        """
        List of comma- or space-separated groups. The user should be a member of at least one group to log in. For Generic OAuth, if you configure allowed*groups, you must also configure groups*attribute_path.
        """
        return pulumi.get(self, "allowed_groups")

    @property
    @pulumi.getter(name="allowedOrganizations")
    def allowed_organizations(self) -> Optional[str]:
        """
        List of comma- or space-separated organizations. The user should be a member of at least one organization to log in.
        """
        return pulumi.get(self, "allowed_organizations")

    @property
    @pulumi.getter(name="apiUrl")
    def api_url(self) -> Optional[str]:
        """
        The user information endpoint of your OAuth2 provider. Required for okta and generic_oauth providers.
        """
        return pulumi.get(self, "api_url")

    @property
    @pulumi.getter(name="authStyle")
    def auth_style(self) -> Optional[str]:
        """
        It determines how client*id and client*secret are sent to Oauth2 provider. Possible values are AutoDetect, InParams, InHeader. Default is AutoDetect.
        """
        return pulumi.get(self, "auth_style")

    @property
    @pulumi.getter(name="authUrl")
    def auth_url(self) -> Optional[str]:
        """
        The authorization endpoint of your OAuth2 provider. Required for azuread, okta and generic_oauth providers.
        """
        return pulumi.get(self, "auth_url")

    @property
    @pulumi.getter(name="autoLogin")
    def auto_login(self) -> Optional[bool]:
        """
        Log in automatically, skipping the login screen.
        """
        return pulumi.get(self, "auto_login")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The client secret of your OAuth2 app.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter
    def custom(self) -> Optional[Mapping[str, str]]:
        """
        Custom fields to configure for OAuth2 such as the [force*use*graph_api](https://grafana.com/docs/grafana/latest/setup-grafana/configure-security/configure-authentication/azuread/#force-fetching-groups-from-microsoft-graph-api) field.
        """
        return pulumi.get(self, "custom")

    @property
    @pulumi.getter(name="defineAllowedGroups")
    def define_allowed_groups(self) -> Optional[bool]:
        """
        Define allowed groups.
        """
        return pulumi.get(self, "define_allowed_groups")

    @property
    @pulumi.getter(name="defineAllowedTeamsIds")
    def define_allowed_teams_ids(self) -> Optional[bool]:
        """
        Define allowed teams ids.
        """
        return pulumi.get(self, "define_allowed_teams_ids")

    @property
    @pulumi.getter(name="emailAttributeName")
    def email_attribute_name(self) -> Optional[str]:
        """
        Name of the key to use for user email lookup within the attributes map of OAuth2 ID token. Only applicable to Generic OAuth.
        """
        return pulumi.get(self, "email_attribute_name")

    @property
    @pulumi.getter(name="emailAttributePath")
    def email_attribute_path(self) -> Optional[str]:
        """
        JMESPath expression to use for user email lookup from the user information. Only applicable to Generic OAuth.
        """
        return pulumi.get(self, "email_attribute_path")

    @property
    @pulumi.getter(name="emptyScopes")
    def empty_scopes(self) -> Optional[bool]:
        """
        If enabled, no scopes will be sent to the OAuth2 provider.
        """
        return pulumi.get(self, "empty_scopes")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Define whether this configuration is enabled for the specified provider. Defaults to `true`.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="groupsAttributePath")
    def groups_attribute_path(self) -> Optional[str]:
        """
        JMESPath expression to use for user group lookup. If you configure allowed*groups, you must also configure groups*attribute_path.
        """
        return pulumi.get(self, "groups_attribute_path")

    @property
    @pulumi.getter(name="idTokenAttributeName")
    def id_token_attribute_name(self) -> Optional[str]:
        """
        The name of the key used to extract the ID token from the returned OAuth2 token. Only applicable to Generic OAuth.
        """
        return pulumi.get(self, "id_token_attribute_name")

    @property
    @pulumi.getter(name="loginAttributePath")
    def login_attribute_path(self) -> Optional[str]:
        """
        JMESPath expression to use for user login lookup from the user ID token. Only applicable to Generic OAuth.
        """
        return pulumi.get(self, "login_attribute_path")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Helpful if you use more than one identity providers or SSO protocols.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="nameAttributePath")
    def name_attribute_path(self) -> Optional[str]:
        """
        JMESPath expression to use for user name lookup from the user ID token. This name will be used as the users display name. Only applicable to Generic OAuth.
        """
        return pulumi.get(self, "name_attribute_path")

    @property
    @pulumi.getter(name="orgAttributePath")
    def org_attribute_path(self) -> Optional[str]:
        """
        JMESPath expression to use for the organization mapping lookup from the user ID token. The extracted list will be used for the organization mapping (to match "Organization" in the "org_mapping"). Only applicable to Generic OAuth and Okta.
        """
        return pulumi.get(self, "org_attribute_path")

    @property
    @pulumi.getter(name="orgMapping")
    def org_mapping(self) -> Optional[str]:
        """
        List of comma- or space-separated Organization:OrgIdOrOrgName:Role mappings. Organization can be * meaning All users. Role is optional and can have the following values: None, Viewer, Editor or Admin.
        """
        return pulumi.get(self, "org_mapping")

    @property
    @pulumi.getter(name="roleAttributePath")
    def role_attribute_path(self) -> Optional[str]:
        """
        JMESPath expression to use for Grafana role lookup.
        """
        return pulumi.get(self, "role_attribute_path")

    @property
    @pulumi.getter(name="roleAttributeStrict")
    def role_attribute_strict(self) -> Optional[bool]:
        """
        If enabled, denies user login if the Grafana role cannot be extracted using Role attribute path.
        """
        return pulumi.get(self, "role_attribute_strict")

    @property
    @pulumi.getter
    def scopes(self) -> Optional[str]:
        """
        List of comma- or space-separated OAuth2 scopes.
        """
        return pulumi.get(self, "scopes")

    @property
    @pulumi.getter(name="signoutRedirectUrl")
    def signout_redirect_url(self) -> Optional[str]:
        """
        The URL to redirect the user to after signing out from Grafana.
        """
        return pulumi.get(self, "signout_redirect_url")

    @property
    @pulumi.getter(name="skipOrgRoleSync")
    def skip_org_role_sync(self) -> Optional[bool]:
        """
        Prevent synchronizing users organization roles from your IdP.
        """
        return pulumi.get(self, "skip_org_role_sync")

    @property
    @pulumi.getter(name="teamIds")
    def team_ids(self) -> Optional[str]:
        """
        String list of Team Ids. If set, the user must be a member of one of the given teams to log in. If you configure team*ids, you must also configure teams*url and team*ids*attribute_path.
        """
        return pulumi.get(self, "team_ids")

    @property
    @pulumi.getter(name="teamIdsAttributePath")
    def team_ids_attribute_path(self) -> Optional[str]:
        """
        The JMESPath expression to use for Grafana Team Id lookup within the results returned by the teams_url endpoint. Only applicable to Generic OAuth.
        """
        return pulumi.get(self, "team_ids_attribute_path")

    @property
    @pulumi.getter(name="teamsUrl")
    def teams_url(self) -> Optional[str]:
        """
        The URL used to query for Team Ids. If not set, the default value is /teams. If you configure teams*url, you must also configure team*ids*attribute*path. Only applicable to Generic OAuth.
        """
        return pulumi.get(self, "teams_url")

    @property
    @pulumi.getter(name="tlsClientCa")
    def tls_client_ca(self) -> Optional[str]:
        """
        The path to the trusted certificate authority list. Is not applicable on Grafana Cloud.
        """
        return pulumi.get(self, "tls_client_ca")

    @property
    @pulumi.getter(name="tlsClientCert")
    def tls_client_cert(self) -> Optional[str]:
        """
        The path to the certificate. Is not applicable on Grafana Cloud.
        """
        return pulumi.get(self, "tls_client_cert")

    @property
    @pulumi.getter(name="tlsClientKey")
    def tls_client_key(self) -> Optional[str]:
        """
        The path to the key. Is not applicable on Grafana Cloud.
        """
        return pulumi.get(self, "tls_client_key")

    @property
    @pulumi.getter(name="tlsSkipVerifyInsecure")
    def tls_skip_verify_insecure(self) -> Optional[bool]:
        """
        If enabled, the client accepts any certificate presented by the server and any host name in that certificate. You should only use this for testing, because this mode leaves SSL/TLS susceptible to man-in-the-middle attacks.
        """
        return pulumi.get(self, "tls_skip_verify_insecure")

    @property
    @pulumi.getter(name="tokenUrl")
    def token_url(self) -> Optional[str]:
        """
        The token endpoint of your OAuth2 provider. Required for azuread, okta and generic_oauth providers.
        """
        return pulumi.get(self, "token_url")

    @property
    @pulumi.getter(name="usePkce")
    def use_pkce(self) -> Optional[bool]:
        """
        If enabled, Grafana will use Proof Key for Code Exchange (PKCE) with the OAuth2 Authorization Code Grant.
        """
        return pulumi.get(self, "use_pkce")

    @property
    @pulumi.getter(name="useRefreshToken")
    def use_refresh_token(self) -> Optional[bool]:
        """
        If enabled, Grafana will fetch a new access token using the refresh token provided by the OAuth2 provider.
        """
        return pulumi.get(self, "use_refresh_token")


@pulumi.output_type
class SsoSettingsSamlSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowIdpInitiated":
            suggest = "allow_idp_initiated"
        elif key == "allowSignUp":
            suggest = "allow_sign_up"
        elif key == "allowedOrganizations":
            suggest = "allowed_organizations"
        elif key == "assertionAttributeEmail":
            suggest = "assertion_attribute_email"
        elif key == "assertionAttributeGroups":
            suggest = "assertion_attribute_groups"
        elif key == "assertionAttributeLogin":
            suggest = "assertion_attribute_login"
        elif key == "assertionAttributeName":
            suggest = "assertion_attribute_name"
        elif key == "assertionAttributeOrg":
            suggest = "assertion_attribute_org"
        elif key == "assertionAttributeRole":
            suggest = "assertion_attribute_role"
        elif key == "autoLogin":
            suggest = "auto_login"
        elif key == "certificatePath":
            suggest = "certificate_path"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "entityId":
            suggest = "entity_id"
        elif key == "forceUseGraphApi":
            suggest = "force_use_graph_api"
        elif key == "idpMetadata":
            suggest = "idp_metadata"
        elif key == "idpMetadataPath":
            suggest = "idp_metadata_path"
        elif key == "idpMetadataUrl":
            suggest = "idp_metadata_url"
        elif key == "maxIssueDelay":
            suggest = "max_issue_delay"
        elif key == "metadataValidDuration":
            suggest = "metadata_valid_duration"
        elif key == "nameIdFormat":
            suggest = "name_id_format"
        elif key == "orgMapping":
            suggest = "org_mapping"
        elif key == "privateKey":
            suggest = "private_key"
        elif key == "privateKeyPath":
            suggest = "private_key_path"
        elif key == "relayState":
            suggest = "relay_state"
        elif key == "roleValuesAdmin":
            suggest = "role_values_admin"
        elif key == "roleValuesEditor":
            suggest = "role_values_editor"
        elif key == "roleValuesGrafanaAdmin":
            suggest = "role_values_grafana_admin"
        elif key == "roleValuesNone":
            suggest = "role_values_none"
        elif key == "roleValuesViewer":
            suggest = "role_values_viewer"
        elif key == "signatureAlgorithm":
            suggest = "signature_algorithm"
        elif key == "singleLogout":
            suggest = "single_logout"
        elif key == "skipOrgRoleSync":
            suggest = "skip_org_role_sync"
        elif key == "tokenUrl":
            suggest = "token_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SsoSettingsSamlSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SsoSettingsSamlSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SsoSettingsSamlSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_idp_initiated: Optional[bool] = None,
                 allow_sign_up: Optional[bool] = None,
                 allowed_organizations: Optional[str] = None,
                 assertion_attribute_email: Optional[str] = None,
                 assertion_attribute_groups: Optional[str] = None,
                 assertion_attribute_login: Optional[str] = None,
                 assertion_attribute_name: Optional[str] = None,
                 assertion_attribute_org: Optional[str] = None,
                 assertion_attribute_role: Optional[str] = None,
                 auto_login: Optional[bool] = None,
                 certificate: Optional[str] = None,
                 certificate_path: Optional[str] = None,
                 client_id: Optional[str] = None,
                 client_secret: Optional[str] = None,
                 enabled: Optional[bool] = None,
                 entity_id: Optional[str] = None,
                 force_use_graph_api: Optional[bool] = None,
                 idp_metadata: Optional[str] = None,
                 idp_metadata_path: Optional[str] = None,
                 idp_metadata_url: Optional[str] = None,
                 max_issue_delay: Optional[str] = None,
                 metadata_valid_duration: Optional[str] = None,
                 name: Optional[str] = None,
                 name_id_format: Optional[str] = None,
                 org_mapping: Optional[str] = None,
                 private_key: Optional[str] = None,
                 private_key_path: Optional[str] = None,
                 relay_state: Optional[str] = None,
                 role_values_admin: Optional[str] = None,
                 role_values_editor: Optional[str] = None,
                 role_values_grafana_admin: Optional[str] = None,
                 role_values_none: Optional[str] = None,
                 role_values_viewer: Optional[str] = None,
                 signature_algorithm: Optional[str] = None,
                 single_logout: Optional[bool] = None,
                 skip_org_role_sync: Optional[bool] = None,
                 token_url: Optional[str] = None):
        """
        :param bool allow_idp_initiated: Whether SAML IdP-initiated login is allowed.
        :param bool allow_sign_up: Whether to allow new Grafana user creation through SAML login. If set to false, then only existing Grafana users can log in with SAML.
        :param str allowed_organizations: List of comma- or space-separated organizations. User should be a member of at least one organization to log in.
        :param str assertion_attribute_email: Friendly name or name of the attribute within the SAML assertion to use as the user email.
        :param str assertion_attribute_groups: Friendly name or name of the attribute within the SAML assertion to use as the user groups.
        :param str assertion_attribute_login: Friendly name or name of the attribute within the SAML assertion to use as the user login handle.
        :param str assertion_attribute_name: Friendly name or name of the attribute within the SAML assertion to use as the user name. Alternatively, this can be a template with variables that match the names of attributes within the SAML assertion.
        :param str assertion_attribute_org: Friendly name or name of the attribute within the SAML assertion to use as the user organization.
        :param str assertion_attribute_role: Friendly name or name of the attribute within the SAML assertion to use as the user roles.
        :param bool auto_login: Whether SAML auto login is enabled.
        :param str certificate: Base64-encoded string for the SP X.509 certificate.
        :param str certificate_path: Path for the SP X.509 certificate.
        :param str client_id: The client Id of your OAuth2 app.
        :param str client_secret: The client secret of your OAuth2 app.
        :param bool enabled: Define whether this configuration is enabled for SAML. Defaults to `true`.
        :param str entity_id: The entity ID is a globally unique identifier for the service provider. It is used to identify the service provider to the identity provider. Defaults to the URL of the Grafana instance if not set.
        :param bool force_use_graph_api: If enabled, Grafana will fetch groups from Microsoft Graph API instead of using the groups claim from the ID token.
        :param str idp_metadata: Base64-encoded string for the IdP SAML metadata XML.
        :param str idp_metadata_path: Path for the IdP SAML metadata XML.
        :param str idp_metadata_url: URL for the IdP SAML metadata XML.
        :param str max_issue_delay: Duration, since the IdP issued a response and the SP is allowed to process it. For example: 90s, 1h.
        :param str metadata_valid_duration: Duration, for how long the SP metadata is valid. For example: 48h, 5d.
        :param str name: Name used to refer to the SAML authentication.
        :param str name_id_format: The Name ID Format to request within the SAML assertion. Defaults to urn:oasis:names:tc:SAML:2.0:nameid-format:transient
        :param str org_mapping: List of comma- or space-separated Organization:OrgId:Role mappings. Organization can be * meaning All users. Role is optional and can have the following values: Viewer, Editor or Admin.
        :param str private_key: Base64-encoded string for the SP private key.
        :param str private_key_path: Path for the SP private key.
        :param str relay_state: Relay state for IdP-initiated login. Should match relay state configured in IdP.
        :param str role_values_admin: List of comma- or space-separated roles which will be mapped into the Admin role.
        :param str role_values_editor: List of comma- or space-separated roles which will be mapped into the Editor role.
        :param str role_values_grafana_admin: List of comma- or space-separated roles which will be mapped into the Grafana Admin (Super Admin) role.
        :param str role_values_none: List of comma- or space-separated roles which will be mapped into the None role.
        :param str role_values_viewer: List of comma- or space-separated roles which will be mapped into the Viewer role.
        :param str signature_algorithm: Signature algorithm used for signing requests to the IdP. Supported values are rsa-sha1, rsa-sha256, rsa-sha512.
        :param bool single_logout: Whether SAML Single Logout is enabled.
        :param bool skip_org_role_sync: Prevent synchronizing users organization roles from your IdP.
        :param str token_url: The token endpoint of your OAuth2 provider. Required for Azure AD providers.
        """
        if allow_idp_initiated is not None:
            pulumi.set(__self__, "allow_idp_initiated", allow_idp_initiated)
        if allow_sign_up is not None:
            pulumi.set(__self__, "allow_sign_up", allow_sign_up)
        if allowed_organizations is not None:
            pulumi.set(__self__, "allowed_organizations", allowed_organizations)
        if assertion_attribute_email is not None:
            pulumi.set(__self__, "assertion_attribute_email", assertion_attribute_email)
        if assertion_attribute_groups is not None:
            pulumi.set(__self__, "assertion_attribute_groups", assertion_attribute_groups)
        if assertion_attribute_login is not None:
            pulumi.set(__self__, "assertion_attribute_login", assertion_attribute_login)
        if assertion_attribute_name is not None:
            pulumi.set(__self__, "assertion_attribute_name", assertion_attribute_name)
        if assertion_attribute_org is not None:
            pulumi.set(__self__, "assertion_attribute_org", assertion_attribute_org)
        if assertion_attribute_role is not None:
            pulumi.set(__self__, "assertion_attribute_role", assertion_attribute_role)
        if auto_login is not None:
            pulumi.set(__self__, "auto_login", auto_login)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if certificate_path is not None:
            pulumi.set(__self__, "certificate_path", certificate_path)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if entity_id is not None:
            pulumi.set(__self__, "entity_id", entity_id)
        if force_use_graph_api is not None:
            pulumi.set(__self__, "force_use_graph_api", force_use_graph_api)
        if idp_metadata is not None:
            pulumi.set(__self__, "idp_metadata", idp_metadata)
        if idp_metadata_path is not None:
            pulumi.set(__self__, "idp_metadata_path", idp_metadata_path)
        if idp_metadata_url is not None:
            pulumi.set(__self__, "idp_metadata_url", idp_metadata_url)
        if max_issue_delay is not None:
            pulumi.set(__self__, "max_issue_delay", max_issue_delay)
        if metadata_valid_duration is not None:
            pulumi.set(__self__, "metadata_valid_duration", metadata_valid_duration)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if name_id_format is not None:
            pulumi.set(__self__, "name_id_format", name_id_format)
        if org_mapping is not None:
            pulumi.set(__self__, "org_mapping", org_mapping)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if private_key_path is not None:
            pulumi.set(__self__, "private_key_path", private_key_path)
        if relay_state is not None:
            pulumi.set(__self__, "relay_state", relay_state)
        if role_values_admin is not None:
            pulumi.set(__self__, "role_values_admin", role_values_admin)
        if role_values_editor is not None:
            pulumi.set(__self__, "role_values_editor", role_values_editor)
        if role_values_grafana_admin is not None:
            pulumi.set(__self__, "role_values_grafana_admin", role_values_grafana_admin)
        if role_values_none is not None:
            pulumi.set(__self__, "role_values_none", role_values_none)
        if role_values_viewer is not None:
            pulumi.set(__self__, "role_values_viewer", role_values_viewer)
        if signature_algorithm is not None:
            pulumi.set(__self__, "signature_algorithm", signature_algorithm)
        if single_logout is not None:
            pulumi.set(__self__, "single_logout", single_logout)
        if skip_org_role_sync is not None:
            pulumi.set(__self__, "skip_org_role_sync", skip_org_role_sync)
        if token_url is not None:
            pulumi.set(__self__, "token_url", token_url)

    @property
    @pulumi.getter(name="allowIdpInitiated")
    def allow_idp_initiated(self) -> Optional[bool]:
        """
        Whether SAML IdP-initiated login is allowed.
        """
        return pulumi.get(self, "allow_idp_initiated")

    @property
    @pulumi.getter(name="allowSignUp")
    def allow_sign_up(self) -> Optional[bool]:
        """
        Whether to allow new Grafana user creation through SAML login. If set to false, then only existing Grafana users can log in with SAML.
        """
        return pulumi.get(self, "allow_sign_up")

    @property
    @pulumi.getter(name="allowedOrganizations")
    def allowed_organizations(self) -> Optional[str]:
        """
        List of comma- or space-separated organizations. User should be a member of at least one organization to log in.
        """
        return pulumi.get(self, "allowed_organizations")

    @property
    @pulumi.getter(name="assertionAttributeEmail")
    def assertion_attribute_email(self) -> Optional[str]:
        """
        Friendly name or name of the attribute within the SAML assertion to use as the user email.
        """
        return pulumi.get(self, "assertion_attribute_email")

    @property
    @pulumi.getter(name="assertionAttributeGroups")
    def assertion_attribute_groups(self) -> Optional[str]:
        """
        Friendly name or name of the attribute within the SAML assertion to use as the user groups.
        """
        return pulumi.get(self, "assertion_attribute_groups")

    @property
    @pulumi.getter(name="assertionAttributeLogin")
    def assertion_attribute_login(self) -> Optional[str]:
        """
        Friendly name or name of the attribute within the SAML assertion to use as the user login handle.
        """
        return pulumi.get(self, "assertion_attribute_login")

    @property
    @pulumi.getter(name="assertionAttributeName")
    def assertion_attribute_name(self) -> Optional[str]:
        """
        Friendly name or name of the attribute within the SAML assertion to use as the user name. Alternatively, this can be a template with variables that match the names of attributes within the SAML assertion.
        """
        return pulumi.get(self, "assertion_attribute_name")

    @property
    @pulumi.getter(name="assertionAttributeOrg")
    def assertion_attribute_org(self) -> Optional[str]:
        """
        Friendly name or name of the attribute within the SAML assertion to use as the user organization.
        """
        return pulumi.get(self, "assertion_attribute_org")

    @property
    @pulumi.getter(name="assertionAttributeRole")
    def assertion_attribute_role(self) -> Optional[str]:
        """
        Friendly name or name of the attribute within the SAML assertion to use as the user roles.
        """
        return pulumi.get(self, "assertion_attribute_role")

    @property
    @pulumi.getter(name="autoLogin")
    def auto_login(self) -> Optional[bool]:
        """
        Whether SAML auto login is enabled.
        """
        return pulumi.get(self, "auto_login")

    @property
    @pulumi.getter
    def certificate(self) -> Optional[str]:
        """
        Base64-encoded string for the SP X.509 certificate.
        """
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="certificatePath")
    def certificate_path(self) -> Optional[str]:
        """
        Path for the SP X.509 certificate.
        """
        return pulumi.get(self, "certificate_path")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        """
        The client Id of your OAuth2 app.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The client secret of your OAuth2 app.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Define whether this configuration is enabled for SAML. Defaults to `true`.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="entityId")
    def entity_id(self) -> Optional[str]:
        """
        The entity ID is a globally unique identifier for the service provider. It is used to identify the service provider to the identity provider. Defaults to the URL of the Grafana instance if not set.
        """
        return pulumi.get(self, "entity_id")

    @property
    @pulumi.getter(name="forceUseGraphApi")
    def force_use_graph_api(self) -> Optional[bool]:
        """
        If enabled, Grafana will fetch groups from Microsoft Graph API instead of using the groups claim from the ID token.
        """
        return pulumi.get(self, "force_use_graph_api")

    @property
    @pulumi.getter(name="idpMetadata")
    def idp_metadata(self) -> Optional[str]:
        """
        Base64-encoded string for the IdP SAML metadata XML.
        """
        return pulumi.get(self, "idp_metadata")

    @property
    @pulumi.getter(name="idpMetadataPath")
    def idp_metadata_path(self) -> Optional[str]:
        """
        Path for the IdP SAML metadata XML.
        """
        return pulumi.get(self, "idp_metadata_path")

    @property
    @pulumi.getter(name="idpMetadataUrl")
    def idp_metadata_url(self) -> Optional[str]:
        """
        URL for the IdP SAML metadata XML.
        """
        return pulumi.get(self, "idp_metadata_url")

    @property
    @pulumi.getter(name="maxIssueDelay")
    def max_issue_delay(self) -> Optional[str]:
        """
        Duration, since the IdP issued a response and the SP is allowed to process it. For example: 90s, 1h.
        """
        return pulumi.get(self, "max_issue_delay")

    @property
    @pulumi.getter(name="metadataValidDuration")
    def metadata_valid_duration(self) -> Optional[str]:
        """
        Duration, for how long the SP metadata is valid. For example: 48h, 5d.
        """
        return pulumi.get(self, "metadata_valid_duration")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name used to refer to the SAML authentication.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="nameIdFormat")
    def name_id_format(self) -> Optional[str]:
        """
        The Name ID Format to request within the SAML assertion. Defaults to urn:oasis:names:tc:SAML:2.0:nameid-format:transient
        """
        return pulumi.get(self, "name_id_format")

    @property
    @pulumi.getter(name="orgMapping")
    def org_mapping(self) -> Optional[str]:
        """
        List of comma- or space-separated Organization:OrgId:Role mappings. Organization can be * meaning All users. Role is optional and can have the following values: Viewer, Editor or Admin.
        """
        return pulumi.get(self, "org_mapping")

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[str]:
        """
        Base64-encoded string for the SP private key.
        """
        return pulumi.get(self, "private_key")

    @property
    @pulumi.getter(name="privateKeyPath")
    def private_key_path(self) -> Optional[str]:
        """
        Path for the SP private key.
        """
        return pulumi.get(self, "private_key_path")

    @property
    @pulumi.getter(name="relayState")
    def relay_state(self) -> Optional[str]:
        """
        Relay state for IdP-initiated login. Should match relay state configured in IdP.
        """
        return pulumi.get(self, "relay_state")

    @property
    @pulumi.getter(name="roleValuesAdmin")
    def role_values_admin(self) -> Optional[str]:
        """
        List of comma- or space-separated roles which will be mapped into the Admin role.
        """
        return pulumi.get(self, "role_values_admin")

    @property
    @pulumi.getter(name="roleValuesEditor")
    def role_values_editor(self) -> Optional[str]:
        """
        List of comma- or space-separated roles which will be mapped into the Editor role.
        """
        return pulumi.get(self, "role_values_editor")

    @property
    @pulumi.getter(name="roleValuesGrafanaAdmin")
    def role_values_grafana_admin(self) -> Optional[str]:
        """
        List of comma- or space-separated roles which will be mapped into the Grafana Admin (Super Admin) role.
        """
        return pulumi.get(self, "role_values_grafana_admin")

    @property
    @pulumi.getter(name="roleValuesNone")
    def role_values_none(self) -> Optional[str]:
        """
        List of comma- or space-separated roles which will be mapped into the None role.
        """
        return pulumi.get(self, "role_values_none")

    @property
    @pulumi.getter(name="roleValuesViewer")
    def role_values_viewer(self) -> Optional[str]:
        """
        List of comma- or space-separated roles which will be mapped into the Viewer role.
        """
        return pulumi.get(self, "role_values_viewer")

    @property
    @pulumi.getter(name="signatureAlgorithm")
    def signature_algorithm(self) -> Optional[str]:
        """
        Signature algorithm used for signing requests to the IdP. Supported values are rsa-sha1, rsa-sha256, rsa-sha512.
        """
        return pulumi.get(self, "signature_algorithm")

    @property
    @pulumi.getter(name="singleLogout")
    def single_logout(self) -> Optional[bool]:
        """
        Whether SAML Single Logout is enabled.
        """
        return pulumi.get(self, "single_logout")

    @property
    @pulumi.getter(name="skipOrgRoleSync")
    def skip_org_role_sync(self) -> Optional[bool]:
        """
        Prevent synchronizing users organization roles from your IdP.
        """
        return pulumi.get(self, "skip_org_role_sync")

    @property
    @pulumi.getter(name="tokenUrl")
    def token_url(self) -> Optional[str]:
        """
        The token endpoint of your OAuth2 provider. Required for Azure AD providers.
        """
        return pulumi.get(self, "token_url")


@pulumi.output_type
class SyntheticMonitoringCheckSettings(dict):
    def __init__(__self__, *,
                 browser: Optional['outputs.SyntheticMonitoringCheckSettingsBrowser'] = None,
                 dns: Optional['outputs.SyntheticMonitoringCheckSettingsDns'] = None,
                 grpc: Optional['outputs.SyntheticMonitoringCheckSettingsGrpc'] = None,
                 http: Optional['outputs.SyntheticMonitoringCheckSettingsHttp'] = None,
                 multihttp: Optional['outputs.SyntheticMonitoringCheckSettingsMultihttp'] = None,
                 ping: Optional['outputs.SyntheticMonitoringCheckSettingsPing'] = None,
                 scripted: Optional['outputs.SyntheticMonitoringCheckSettingsScripted'] = None,
                 tcp: Optional['outputs.SyntheticMonitoringCheckSettingsTcp'] = None,
                 traceroute: Optional['outputs.SyntheticMonitoringCheckSettingsTraceroute'] = None):
        """
        :param 'SyntheticMonitoringCheckSettingsBrowserArgs' browser: Settings for browser check. See https://grafana.com/docs/grafana-cloud/testing/synthetic-monitoring/create-checks/checks/k6-browser/.
        :param 'SyntheticMonitoringCheckSettingsDnsArgs' dns: Settings for DNS check. The target must be a valid hostname (or IP address for `PTR` records).
        :param 'SyntheticMonitoringCheckSettingsGrpcArgs' grpc: Settings for gRPC Health check. The target must be of the form `<host>:<port>`, where the host portion must be a valid hostname or IP address.
        :param 'SyntheticMonitoringCheckSettingsHttpArgs' http: Settings for HTTP check. The target must be a URL (http or https).
        :param 'SyntheticMonitoringCheckSettingsMultihttpArgs' multihttp: Settings for MultiHTTP check. The target must be a URL (http or https)
        :param 'SyntheticMonitoringCheckSettingsPingArgs' ping: Settings for ping (ICMP) check. The target must be a valid hostname or IP address.
        :param 'SyntheticMonitoringCheckSettingsScriptedArgs' scripted: Settings for scripted check. See https://grafana.com/docs/grafana-cloud/testing/synthetic-monitoring/create-checks/checks/k6/.
        :param 'SyntheticMonitoringCheckSettingsTcpArgs' tcp: Settings for TCP check. The target must be of the form `<host>:<port>`, where the host portion must be a valid hostname or IP address.
        :param 'SyntheticMonitoringCheckSettingsTracerouteArgs' traceroute: Settings for traceroute check. The target must be a valid hostname or IP address
        """
        if browser is not None:
            pulumi.set(__self__, "browser", browser)
        if dns is not None:
            pulumi.set(__self__, "dns", dns)
        if grpc is not None:
            pulumi.set(__self__, "grpc", grpc)
        if http is not None:
            pulumi.set(__self__, "http", http)
        if multihttp is not None:
            pulumi.set(__self__, "multihttp", multihttp)
        if ping is not None:
            pulumi.set(__self__, "ping", ping)
        if scripted is not None:
            pulumi.set(__self__, "scripted", scripted)
        if tcp is not None:
            pulumi.set(__self__, "tcp", tcp)
        if traceroute is not None:
            pulumi.set(__self__, "traceroute", traceroute)

    @property
    @pulumi.getter
    def browser(self) -> Optional['outputs.SyntheticMonitoringCheckSettingsBrowser']:
        """
        Settings for browser check. See https://grafana.com/docs/grafana-cloud/testing/synthetic-monitoring/create-checks/checks/k6-browser/.
        """
        return pulumi.get(self, "browser")

    @property
    @pulumi.getter
    def dns(self) -> Optional['outputs.SyntheticMonitoringCheckSettingsDns']:
        """
        Settings for DNS check. The target must be a valid hostname (or IP address for `PTR` records).
        """
        return pulumi.get(self, "dns")

    @property
    @pulumi.getter
    def grpc(self) -> Optional['outputs.SyntheticMonitoringCheckSettingsGrpc']:
        """
        Settings for gRPC Health check. The target must be of the form `<host>:<port>`, where the host portion must be a valid hostname or IP address.
        """
        return pulumi.get(self, "grpc")

    @property
    @pulumi.getter
    def http(self) -> Optional['outputs.SyntheticMonitoringCheckSettingsHttp']:
        """
        Settings for HTTP check. The target must be a URL (http or https).
        """
        return pulumi.get(self, "http")

    @property
    @pulumi.getter
    def multihttp(self) -> Optional['outputs.SyntheticMonitoringCheckSettingsMultihttp']:
        """
        Settings for MultiHTTP check. The target must be a URL (http or https)
        """
        return pulumi.get(self, "multihttp")

    @property
    @pulumi.getter
    def ping(self) -> Optional['outputs.SyntheticMonitoringCheckSettingsPing']:
        """
        Settings for ping (ICMP) check. The target must be a valid hostname or IP address.
        """
        return pulumi.get(self, "ping")

    @property
    @pulumi.getter
    def scripted(self) -> Optional['outputs.SyntheticMonitoringCheckSettingsScripted']:
        """
        Settings for scripted check. See https://grafana.com/docs/grafana-cloud/testing/synthetic-monitoring/create-checks/checks/k6/.
        """
        return pulumi.get(self, "scripted")

    @property
    @pulumi.getter
    def tcp(self) -> Optional['outputs.SyntheticMonitoringCheckSettingsTcp']:
        """
        Settings for TCP check. The target must be of the form `<host>:<port>`, where the host portion must be a valid hostname or IP address.
        """
        return pulumi.get(self, "tcp")

    @property
    @pulumi.getter
    def traceroute(self) -> Optional['outputs.SyntheticMonitoringCheckSettingsTraceroute']:
        """
        Settings for traceroute check. The target must be a valid hostname or IP address
        """
        return pulumi.get(self, "traceroute")


@pulumi.output_type
class SyntheticMonitoringCheckSettingsBrowser(dict):
    def __init__(__self__, *,
                 script: str):
        pulumi.set(__self__, "script", script)

    @property
    @pulumi.getter
    def script(self) -> str:
        return pulumi.get(self, "script")


@pulumi.output_type
class SyntheticMonitoringCheckSettingsDns(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipVersion":
            suggest = "ip_version"
        elif key == "recordType":
            suggest = "record_type"
        elif key == "sourceIpAddress":
            suggest = "source_ip_address"
        elif key == "validRCodes":
            suggest = "valid_r_codes"
        elif key == "validateAdditionalRrs":
            suggest = "validate_additional_rrs"
        elif key == "validateAnswerRrs":
            suggest = "validate_answer_rrs"
        elif key == "validateAuthorityRrs":
            suggest = "validate_authority_rrs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticMonitoringCheckSettingsDns. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticMonitoringCheckSettingsDns.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticMonitoringCheckSettingsDns.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_version: Optional[str] = None,
                 port: Optional[int] = None,
                 protocol: Optional[str] = None,
                 record_type: Optional[str] = None,
                 server: Optional[str] = None,
                 source_ip_address: Optional[str] = None,
                 valid_r_codes: Optional[Sequence[str]] = None,
                 validate_additional_rrs: Optional[Sequence['outputs.SyntheticMonitoringCheckSettingsDnsValidateAdditionalRr']] = None,
                 validate_answer_rrs: Optional['outputs.SyntheticMonitoringCheckSettingsDnsValidateAnswerRrs'] = None,
                 validate_authority_rrs: Optional['outputs.SyntheticMonitoringCheckSettingsDnsValidateAuthorityRrs'] = None):
        """
        :param str ip_version: Options are `V4`, `V6`, `Any`. Specifies whether the corresponding check will be performed using IPv4 or IPv6. The `Any` value indicates that IPv6 should be used, falling back to IPv4 if that's not available. Defaults to `V4`.
        :param int port: Port to target. Defaults to `53`.
        :param str protocol: `TCP` or `UDP`. Defaults to `UDP`.
        :param str record_type: One of `ANY`, `A`, `AAAA`, `CNAME`, `MX`, `NS`, `PTR`, `SOA`, `SRV`, `TXT`. Defaults to `A`.
        :param str server: DNS server address to target. Defaults to `8.8.8.8`.
        :param str source_ip_address: Source IP address.
        :param Sequence[str] valid_r_codes: List of valid response codes. Options include `NOERROR`, `BADALG`, `BADMODE`, `BADKEY`, `BADCOOKIE`, `BADNAME`, `BADSIG`, `BADTIME`, `BADTRUNC`, `BADVERS`, `FORMERR`, `NOTIMP`, `NOTAUTH`, `NOTZONE`, `NXDOMAIN`, `NXRRSET`, `REFUSED`, `SERVFAIL`, `YXDOMAIN`, `YXRRSET`.
        :param Sequence['SyntheticMonitoringCheckSettingsDnsValidateAdditionalRrArgs'] validate_additional_rrs: Validate additional matches.
        :param 'SyntheticMonitoringCheckSettingsDnsValidateAnswerRrsArgs' validate_answer_rrs: Validate response answer.
        :param 'SyntheticMonitoringCheckSettingsDnsValidateAuthorityRrsArgs' validate_authority_rrs: Validate response authority.
        """
        if ip_version is not None:
            pulumi.set(__self__, "ip_version", ip_version)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if record_type is not None:
            pulumi.set(__self__, "record_type", record_type)
        if server is not None:
            pulumi.set(__self__, "server", server)
        if source_ip_address is not None:
            pulumi.set(__self__, "source_ip_address", source_ip_address)
        if valid_r_codes is not None:
            pulumi.set(__self__, "valid_r_codes", valid_r_codes)
        if validate_additional_rrs is not None:
            pulumi.set(__self__, "validate_additional_rrs", validate_additional_rrs)
        if validate_answer_rrs is not None:
            pulumi.set(__self__, "validate_answer_rrs", validate_answer_rrs)
        if validate_authority_rrs is not None:
            pulumi.set(__self__, "validate_authority_rrs", validate_authority_rrs)

    @property
    @pulumi.getter(name="ipVersion")
    def ip_version(self) -> Optional[str]:
        """
        Options are `V4`, `V6`, `Any`. Specifies whether the corresponding check will be performed using IPv4 or IPv6. The `Any` value indicates that IPv6 should be used, falling back to IPv4 if that's not available. Defaults to `V4`.
        """
        return pulumi.get(self, "ip_version")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Port to target. Defaults to `53`.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        """
        `TCP` or `UDP`. Defaults to `UDP`.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="recordType")
    def record_type(self) -> Optional[str]:
        """
        One of `ANY`, `A`, `AAAA`, `CNAME`, `MX`, `NS`, `PTR`, `SOA`, `SRV`, `TXT`. Defaults to `A`.
        """
        return pulumi.get(self, "record_type")

    @property
    @pulumi.getter
    def server(self) -> Optional[str]:
        """
        DNS server address to target. Defaults to `8.8.8.8`.
        """
        return pulumi.get(self, "server")

    @property
    @pulumi.getter(name="sourceIpAddress")
    def source_ip_address(self) -> Optional[str]:
        """
        Source IP address.
        """
        return pulumi.get(self, "source_ip_address")

    @property
    @pulumi.getter(name="validRCodes")
    def valid_r_codes(self) -> Optional[Sequence[str]]:
        """
        List of valid response codes. Options include `NOERROR`, `BADALG`, `BADMODE`, `BADKEY`, `BADCOOKIE`, `BADNAME`, `BADSIG`, `BADTIME`, `BADTRUNC`, `BADVERS`, `FORMERR`, `NOTIMP`, `NOTAUTH`, `NOTZONE`, `NXDOMAIN`, `NXRRSET`, `REFUSED`, `SERVFAIL`, `YXDOMAIN`, `YXRRSET`.
        """
        return pulumi.get(self, "valid_r_codes")

    @property
    @pulumi.getter(name="validateAdditionalRrs")
    def validate_additional_rrs(self) -> Optional[Sequence['outputs.SyntheticMonitoringCheckSettingsDnsValidateAdditionalRr']]:
        """
        Validate additional matches.
        """
        return pulumi.get(self, "validate_additional_rrs")

    @property
    @pulumi.getter(name="validateAnswerRrs")
    def validate_answer_rrs(self) -> Optional['outputs.SyntheticMonitoringCheckSettingsDnsValidateAnswerRrs']:
        """
        Validate response answer.
        """
        return pulumi.get(self, "validate_answer_rrs")

    @property
    @pulumi.getter(name="validateAuthorityRrs")
    def validate_authority_rrs(self) -> Optional['outputs.SyntheticMonitoringCheckSettingsDnsValidateAuthorityRrs']:
        """
        Validate response authority.
        """
        return pulumi.get(self, "validate_authority_rrs")


@pulumi.output_type
class SyntheticMonitoringCheckSettingsDnsValidateAdditionalRr(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failIfMatchesRegexps":
            suggest = "fail_if_matches_regexps"
        elif key == "failIfNotMatchesRegexps":
            suggest = "fail_if_not_matches_regexps"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticMonitoringCheckSettingsDnsValidateAdditionalRr. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticMonitoringCheckSettingsDnsValidateAdditionalRr.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticMonitoringCheckSettingsDnsValidateAdditionalRr.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fail_if_matches_regexps: Optional[Sequence[str]] = None,
                 fail_if_not_matches_regexps: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] fail_if_matches_regexps: Fail if value matches regex.
        :param Sequence[str] fail_if_not_matches_regexps: Fail if value does not match regex.
        """
        if fail_if_matches_regexps is not None:
            pulumi.set(__self__, "fail_if_matches_regexps", fail_if_matches_regexps)
        if fail_if_not_matches_regexps is not None:
            pulumi.set(__self__, "fail_if_not_matches_regexps", fail_if_not_matches_regexps)

    @property
    @pulumi.getter(name="failIfMatchesRegexps")
    def fail_if_matches_regexps(self) -> Optional[Sequence[str]]:
        """
        Fail if value matches regex.
        """
        return pulumi.get(self, "fail_if_matches_regexps")

    @property
    @pulumi.getter(name="failIfNotMatchesRegexps")
    def fail_if_not_matches_regexps(self) -> Optional[Sequence[str]]:
        """
        Fail if value does not match regex.
        """
        return pulumi.get(self, "fail_if_not_matches_regexps")


@pulumi.output_type
class SyntheticMonitoringCheckSettingsDnsValidateAnswerRrs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failIfMatchesRegexps":
            suggest = "fail_if_matches_regexps"
        elif key == "failIfNotMatchesRegexps":
            suggest = "fail_if_not_matches_regexps"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticMonitoringCheckSettingsDnsValidateAnswerRrs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticMonitoringCheckSettingsDnsValidateAnswerRrs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticMonitoringCheckSettingsDnsValidateAnswerRrs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fail_if_matches_regexps: Optional[Sequence[str]] = None,
                 fail_if_not_matches_regexps: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] fail_if_matches_regexps: Fail if value matches regex.
        :param Sequence[str] fail_if_not_matches_regexps: Fail if value does not match regex.
        """
        if fail_if_matches_regexps is not None:
            pulumi.set(__self__, "fail_if_matches_regexps", fail_if_matches_regexps)
        if fail_if_not_matches_regexps is not None:
            pulumi.set(__self__, "fail_if_not_matches_regexps", fail_if_not_matches_regexps)

    @property
    @pulumi.getter(name="failIfMatchesRegexps")
    def fail_if_matches_regexps(self) -> Optional[Sequence[str]]:
        """
        Fail if value matches regex.
        """
        return pulumi.get(self, "fail_if_matches_regexps")

    @property
    @pulumi.getter(name="failIfNotMatchesRegexps")
    def fail_if_not_matches_regexps(self) -> Optional[Sequence[str]]:
        """
        Fail if value does not match regex.
        """
        return pulumi.get(self, "fail_if_not_matches_regexps")


@pulumi.output_type
class SyntheticMonitoringCheckSettingsDnsValidateAuthorityRrs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failIfMatchesRegexps":
            suggest = "fail_if_matches_regexps"
        elif key == "failIfNotMatchesRegexps":
            suggest = "fail_if_not_matches_regexps"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticMonitoringCheckSettingsDnsValidateAuthorityRrs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticMonitoringCheckSettingsDnsValidateAuthorityRrs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticMonitoringCheckSettingsDnsValidateAuthorityRrs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fail_if_matches_regexps: Optional[Sequence[str]] = None,
                 fail_if_not_matches_regexps: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] fail_if_matches_regexps: Fail if value matches regex.
        :param Sequence[str] fail_if_not_matches_regexps: Fail if value does not match regex.
        """
        if fail_if_matches_regexps is not None:
            pulumi.set(__self__, "fail_if_matches_regexps", fail_if_matches_regexps)
        if fail_if_not_matches_regexps is not None:
            pulumi.set(__self__, "fail_if_not_matches_regexps", fail_if_not_matches_regexps)

    @property
    @pulumi.getter(name="failIfMatchesRegexps")
    def fail_if_matches_regexps(self) -> Optional[Sequence[str]]:
        """
        Fail if value matches regex.
        """
        return pulumi.get(self, "fail_if_matches_regexps")

    @property
    @pulumi.getter(name="failIfNotMatchesRegexps")
    def fail_if_not_matches_regexps(self) -> Optional[Sequence[str]]:
        """
        Fail if value does not match regex.
        """
        return pulumi.get(self, "fail_if_not_matches_regexps")


@pulumi.output_type
class SyntheticMonitoringCheckSettingsGrpc(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipVersion":
            suggest = "ip_version"
        elif key == "tlsConfig":
            suggest = "tls_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticMonitoringCheckSettingsGrpc. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticMonitoringCheckSettingsGrpc.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticMonitoringCheckSettingsGrpc.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_version: Optional[str] = None,
                 service: Optional[str] = None,
                 tls: Optional[bool] = None,
                 tls_config: Optional['outputs.SyntheticMonitoringCheckSettingsGrpcTlsConfig'] = None):
        """
        :param str ip_version: Options are `V4`, `V6`, `Any`. Specifies whether the corresponding check will be performed using IPv4 or IPv6. The `Any` value indicates that IPv6 should be used, falling back to IPv4 if that's not available. Defaults to `V4`.
        :param str service: gRPC service.
        :param bool tls: Whether or not TLS is used when the connection is initiated. Defaults to `false`.
        :param 'SyntheticMonitoringCheckSettingsGrpcTlsConfigArgs' tls_config: TLS config.
        """
        if ip_version is not None:
            pulumi.set(__self__, "ip_version", ip_version)
        if service is not None:
            pulumi.set(__self__, "service", service)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)
        if tls_config is not None:
            pulumi.set(__self__, "tls_config", tls_config)

    @property
    @pulumi.getter(name="ipVersion")
    def ip_version(self) -> Optional[str]:
        """
        Options are `V4`, `V6`, `Any`. Specifies whether the corresponding check will be performed using IPv4 or IPv6. The `Any` value indicates that IPv6 should be used, falling back to IPv4 if that's not available. Defaults to `V4`.
        """
        return pulumi.get(self, "ip_version")

    @property
    @pulumi.getter
    def service(self) -> Optional[str]:
        """
        gRPC service.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def tls(self) -> Optional[bool]:
        """
        Whether or not TLS is used when the connection is initiated. Defaults to `false`.
        """
        return pulumi.get(self, "tls")

    @property
    @pulumi.getter(name="tlsConfig")
    def tls_config(self) -> Optional['outputs.SyntheticMonitoringCheckSettingsGrpcTlsConfig']:
        """
        TLS config.
        """
        return pulumi.get(self, "tls_config")


@pulumi.output_type
class SyntheticMonitoringCheckSettingsGrpcTlsConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caCert":
            suggest = "ca_cert"
        elif key == "clientCert":
            suggest = "client_cert"
        elif key == "clientKey":
            suggest = "client_key"
        elif key == "insecureSkipVerify":
            suggest = "insecure_skip_verify"
        elif key == "serverName":
            suggest = "server_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticMonitoringCheckSettingsGrpcTlsConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticMonitoringCheckSettingsGrpcTlsConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticMonitoringCheckSettingsGrpcTlsConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ca_cert: Optional[str] = None,
                 client_cert: Optional[str] = None,
                 client_key: Optional[str] = None,
                 insecure_skip_verify: Optional[bool] = None,
                 server_name: Optional[str] = None):
        """
        :param str ca_cert: CA certificate in PEM format.
        :param str client_cert: Client certificate in PEM format.
        :param str client_key: Client key in PEM format.
        :param bool insecure_skip_verify: Disable target certificate validation. Defaults to `false`.
        :param str server_name: Used to verify the hostname for the targets.
        """
        if ca_cert is not None:
            pulumi.set(__self__, "ca_cert", ca_cert)
        if client_cert is not None:
            pulumi.set(__self__, "client_cert", client_cert)
        if client_key is not None:
            pulumi.set(__self__, "client_key", client_key)
        if insecure_skip_verify is not None:
            pulumi.set(__self__, "insecure_skip_verify", insecure_skip_verify)
        if server_name is not None:
            pulumi.set(__self__, "server_name", server_name)

    @property
    @pulumi.getter(name="caCert")
    def ca_cert(self) -> Optional[str]:
        """
        CA certificate in PEM format.
        """
        return pulumi.get(self, "ca_cert")

    @property
    @pulumi.getter(name="clientCert")
    def client_cert(self) -> Optional[str]:
        """
        Client certificate in PEM format.
        """
        return pulumi.get(self, "client_cert")

    @property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> Optional[str]:
        """
        Client key in PEM format.
        """
        return pulumi.get(self, "client_key")

    @property
    @pulumi.getter(name="insecureSkipVerify")
    def insecure_skip_verify(self) -> Optional[bool]:
        """
        Disable target certificate validation. Defaults to `false`.
        """
        return pulumi.get(self, "insecure_skip_verify")

    @property
    @pulumi.getter(name="serverName")
    def server_name(self) -> Optional[str]:
        """
        Used to verify the hostname for the targets.
        """
        return pulumi.get(self, "server_name")


@pulumi.output_type
class SyntheticMonitoringCheckSettingsHttp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "basicAuth":
            suggest = "basic_auth"
        elif key == "bearerToken":
            suggest = "bearer_token"
        elif key == "cacheBustingQueryParamName":
            suggest = "cache_busting_query_param_name"
        elif key == "failIfBodyMatchesRegexps":
            suggest = "fail_if_body_matches_regexps"
        elif key == "failIfBodyNotMatchesRegexps":
            suggest = "fail_if_body_not_matches_regexps"
        elif key == "failIfHeaderMatchesRegexps":
            suggest = "fail_if_header_matches_regexps"
        elif key == "failIfHeaderNotMatchesRegexps":
            suggest = "fail_if_header_not_matches_regexps"
        elif key == "failIfNotSsl":
            suggest = "fail_if_not_ssl"
        elif key == "failIfSsl":
            suggest = "fail_if_ssl"
        elif key == "ipVersion":
            suggest = "ip_version"
        elif key == "noFollowRedirects":
            suggest = "no_follow_redirects"
        elif key == "proxyConnectHeaders":
            suggest = "proxy_connect_headers"
        elif key == "proxyUrl":
            suggest = "proxy_url"
        elif key == "tlsConfig":
            suggest = "tls_config"
        elif key == "validHttpVersions":
            suggest = "valid_http_versions"
        elif key == "validStatusCodes":
            suggest = "valid_status_codes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticMonitoringCheckSettingsHttp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticMonitoringCheckSettingsHttp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticMonitoringCheckSettingsHttp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 basic_auth: Optional['outputs.SyntheticMonitoringCheckSettingsHttpBasicAuth'] = None,
                 bearer_token: Optional[str] = None,
                 body: Optional[str] = None,
                 cache_busting_query_param_name: Optional[str] = None,
                 compression: Optional[str] = None,
                 fail_if_body_matches_regexps: Optional[Sequence[str]] = None,
                 fail_if_body_not_matches_regexps: Optional[Sequence[str]] = None,
                 fail_if_header_matches_regexps: Optional[Sequence['outputs.SyntheticMonitoringCheckSettingsHttpFailIfHeaderMatchesRegexp']] = None,
                 fail_if_header_not_matches_regexps: Optional[Sequence['outputs.SyntheticMonitoringCheckSettingsHttpFailIfHeaderNotMatchesRegexp']] = None,
                 fail_if_not_ssl: Optional[bool] = None,
                 fail_if_ssl: Optional[bool] = None,
                 headers: Optional[Sequence[str]] = None,
                 ip_version: Optional[str] = None,
                 method: Optional[str] = None,
                 no_follow_redirects: Optional[bool] = None,
                 proxy_connect_headers: Optional[Sequence[str]] = None,
                 proxy_url: Optional[str] = None,
                 tls_config: Optional['outputs.SyntheticMonitoringCheckSettingsHttpTlsConfig'] = None,
                 valid_http_versions: Optional[Sequence[str]] = None,
                 valid_status_codes: Optional[Sequence[int]] = None):
        """
        :param 'SyntheticMonitoringCheckSettingsHttpBasicAuthArgs' basic_auth: Basic auth settings.
        :param str bearer_token: Token for use with bearer authorization header.
        :param str body: The body of the HTTP request used in probe.
        :param str cache_busting_query_param_name: The name of the query parameter used to prevent the server from using a cached response. Each probe will assign a random value to this parameter each time a request is made.
        :param str compression: Check fails if the response body is not compressed using this compression algorithm. One of `none`, `identity`, `br`, `gzip`, `deflate`.
        :param Sequence[str] fail_if_body_matches_regexps: List of regexes. If any match the response body, the check will fail.
        :param Sequence[str] fail_if_body_not_matches_regexps: List of regexes. If any do not match the response body, the check will fail.
        :param Sequence['SyntheticMonitoringCheckSettingsHttpFailIfHeaderMatchesRegexpArgs'] fail_if_header_matches_regexps: Check fails if headers match.
        :param Sequence['SyntheticMonitoringCheckSettingsHttpFailIfHeaderNotMatchesRegexpArgs'] fail_if_header_not_matches_regexps: Check fails if headers do not match.
        :param bool fail_if_not_ssl: Fail if SSL is not present. Defaults to `false`.
        :param bool fail_if_ssl: Fail if SSL is present. Defaults to `false`.
        :param Sequence[str] headers: The HTTP headers set for the probe.
        :param str ip_version: Options are `V4`, `V6`, `Any`. Specifies whether the corresponding check will be performed using IPv4 or IPv6. The `Any` value indicates that IPv6 should be used, falling back to IPv4 if that's not available. Defaults to `V4`.
        :param str method: Request method. One of `GET`, `CONNECT`, `DELETE`, `HEAD`, `OPTIONS`, `POST`, `PUT`, `TRACE` Defaults to `GET`.
        :param bool no_follow_redirects: Do not follow redirects. Defaults to `false`.
        :param Sequence[str] proxy_connect_headers: The HTTP headers sent to the proxy URL
        :param str proxy_url: Proxy URL.
        :param 'SyntheticMonitoringCheckSettingsHttpTlsConfigArgs' tls_config: TLS config.
        :param Sequence[str] valid_http_versions: List of valid HTTP versions. Options include `HTTP/1.0`, `HTTP/1.1`, `HTTP/2.0`
        :param Sequence[int] valid_status_codes: Accepted status codes. If unset, defaults to 2xx.
        """
        if basic_auth is not None:
            pulumi.set(__self__, "basic_auth", basic_auth)
        if bearer_token is not None:
            pulumi.set(__self__, "bearer_token", bearer_token)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cache_busting_query_param_name is not None:
            pulumi.set(__self__, "cache_busting_query_param_name", cache_busting_query_param_name)
        if compression is not None:
            pulumi.set(__self__, "compression", compression)
        if fail_if_body_matches_regexps is not None:
            pulumi.set(__self__, "fail_if_body_matches_regexps", fail_if_body_matches_regexps)
        if fail_if_body_not_matches_regexps is not None:
            pulumi.set(__self__, "fail_if_body_not_matches_regexps", fail_if_body_not_matches_regexps)
        if fail_if_header_matches_regexps is not None:
            pulumi.set(__self__, "fail_if_header_matches_regexps", fail_if_header_matches_regexps)
        if fail_if_header_not_matches_regexps is not None:
            pulumi.set(__self__, "fail_if_header_not_matches_regexps", fail_if_header_not_matches_regexps)
        if fail_if_not_ssl is not None:
            pulumi.set(__self__, "fail_if_not_ssl", fail_if_not_ssl)
        if fail_if_ssl is not None:
            pulumi.set(__self__, "fail_if_ssl", fail_if_ssl)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ip_version is not None:
            pulumi.set(__self__, "ip_version", ip_version)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if no_follow_redirects is not None:
            pulumi.set(__self__, "no_follow_redirects", no_follow_redirects)
        if proxy_connect_headers is not None:
            pulumi.set(__self__, "proxy_connect_headers", proxy_connect_headers)
        if proxy_url is not None:
            pulumi.set(__self__, "proxy_url", proxy_url)
        if tls_config is not None:
            pulumi.set(__self__, "tls_config", tls_config)
        if valid_http_versions is not None:
            pulumi.set(__self__, "valid_http_versions", valid_http_versions)
        if valid_status_codes is not None:
            pulumi.set(__self__, "valid_status_codes", valid_status_codes)

    @property
    @pulumi.getter(name="basicAuth")
    def basic_auth(self) -> Optional['outputs.SyntheticMonitoringCheckSettingsHttpBasicAuth']:
        """
        Basic auth settings.
        """
        return pulumi.get(self, "basic_auth")

    @property
    @pulumi.getter(name="bearerToken")
    def bearer_token(self) -> Optional[str]:
        """
        Token for use with bearer authorization header.
        """
        return pulumi.get(self, "bearer_token")

    @property
    @pulumi.getter
    def body(self) -> Optional[str]:
        """
        The body of the HTTP request used in probe.
        """
        return pulumi.get(self, "body")

    @property
    @pulumi.getter(name="cacheBustingQueryParamName")
    def cache_busting_query_param_name(self) -> Optional[str]:
        """
        The name of the query parameter used to prevent the server from using a cached response. Each probe will assign a random value to this parameter each time a request is made.
        """
        return pulumi.get(self, "cache_busting_query_param_name")

    @property
    @pulumi.getter
    def compression(self) -> Optional[str]:
        """
        Check fails if the response body is not compressed using this compression algorithm. One of `none`, `identity`, `br`, `gzip`, `deflate`.
        """
        return pulumi.get(self, "compression")

    @property
    @pulumi.getter(name="failIfBodyMatchesRegexps")
    def fail_if_body_matches_regexps(self) -> Optional[Sequence[str]]:
        """
        List of regexes. If any match the response body, the check will fail.
        """
        return pulumi.get(self, "fail_if_body_matches_regexps")

    @property
    @pulumi.getter(name="failIfBodyNotMatchesRegexps")
    def fail_if_body_not_matches_regexps(self) -> Optional[Sequence[str]]:
        """
        List of regexes. If any do not match the response body, the check will fail.
        """
        return pulumi.get(self, "fail_if_body_not_matches_regexps")

    @property
    @pulumi.getter(name="failIfHeaderMatchesRegexps")
    def fail_if_header_matches_regexps(self) -> Optional[Sequence['outputs.SyntheticMonitoringCheckSettingsHttpFailIfHeaderMatchesRegexp']]:
        """
        Check fails if headers match.
        """
        return pulumi.get(self, "fail_if_header_matches_regexps")

    @property
    @pulumi.getter(name="failIfHeaderNotMatchesRegexps")
    def fail_if_header_not_matches_regexps(self) -> Optional[Sequence['outputs.SyntheticMonitoringCheckSettingsHttpFailIfHeaderNotMatchesRegexp']]:
        """
        Check fails if headers do not match.
        """
        return pulumi.get(self, "fail_if_header_not_matches_regexps")

    @property
    @pulumi.getter(name="failIfNotSsl")
    def fail_if_not_ssl(self) -> Optional[bool]:
        """
        Fail if SSL is not present. Defaults to `false`.
        """
        return pulumi.get(self, "fail_if_not_ssl")

    @property
    @pulumi.getter(name="failIfSsl")
    def fail_if_ssl(self) -> Optional[bool]:
        """
        Fail if SSL is present. Defaults to `false`.
        """
        return pulumi.get(self, "fail_if_ssl")

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence[str]]:
        """
        The HTTP headers set for the probe.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="ipVersion")
    def ip_version(self) -> Optional[str]:
        """
        Options are `V4`, `V6`, `Any`. Specifies whether the corresponding check will be performed using IPv4 or IPv6. The `Any` value indicates that IPv6 should be used, falling back to IPv4 if that's not available. Defaults to `V4`.
        """
        return pulumi.get(self, "ip_version")

    @property
    @pulumi.getter
    def method(self) -> Optional[str]:
        """
        Request method. One of `GET`, `CONNECT`, `DELETE`, `HEAD`, `OPTIONS`, `POST`, `PUT`, `TRACE` Defaults to `GET`.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter(name="noFollowRedirects")
    def no_follow_redirects(self) -> Optional[bool]:
        """
        Do not follow redirects. Defaults to `false`.
        """
        return pulumi.get(self, "no_follow_redirects")

    @property
    @pulumi.getter(name="proxyConnectHeaders")
    def proxy_connect_headers(self) -> Optional[Sequence[str]]:
        """
        The HTTP headers sent to the proxy URL
        """
        return pulumi.get(self, "proxy_connect_headers")

    @property
    @pulumi.getter(name="proxyUrl")
    def proxy_url(self) -> Optional[str]:
        """
        Proxy URL.
        """
        return pulumi.get(self, "proxy_url")

    @property
    @pulumi.getter(name="tlsConfig")
    def tls_config(self) -> Optional['outputs.SyntheticMonitoringCheckSettingsHttpTlsConfig']:
        """
        TLS config.
        """
        return pulumi.get(self, "tls_config")

    @property
    @pulumi.getter(name="validHttpVersions")
    def valid_http_versions(self) -> Optional[Sequence[str]]:
        """
        List of valid HTTP versions. Options include `HTTP/1.0`, `HTTP/1.1`, `HTTP/2.0`
        """
        return pulumi.get(self, "valid_http_versions")

    @property
    @pulumi.getter(name="validStatusCodes")
    def valid_status_codes(self) -> Optional[Sequence[int]]:
        """
        Accepted status codes. If unset, defaults to 2xx.
        """
        return pulumi.get(self, "valid_status_codes")


@pulumi.output_type
class SyntheticMonitoringCheckSettingsHttpBasicAuth(dict):
    def __init__(__self__, *,
                 password: str,
                 username: str):
        """
        :param str password: Basic auth password.
        :param str username: Basic auth username.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        Basic auth password.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        Basic auth username.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class SyntheticMonitoringCheckSettingsHttpFailIfHeaderMatchesRegexp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowMissing":
            suggest = "allow_missing"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticMonitoringCheckSettingsHttpFailIfHeaderMatchesRegexp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticMonitoringCheckSettingsHttpFailIfHeaderMatchesRegexp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticMonitoringCheckSettingsHttpFailIfHeaderMatchesRegexp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 header: str,
                 regexp: str,
                 allow_missing: Optional[bool] = None):
        """
        :param str header: Header name.
        :param str regexp: Regex that header value should match.
        :param bool allow_missing: Allow header to be missing from responses. Defaults to `false`.
        """
        pulumi.set(__self__, "header", header)
        pulumi.set(__self__, "regexp", regexp)
        if allow_missing is not None:
            pulumi.set(__self__, "allow_missing", allow_missing)

    @property
    @pulumi.getter
    def header(self) -> str:
        """
        Header name.
        """
        return pulumi.get(self, "header")

    @property
    @pulumi.getter
    def regexp(self) -> str:
        """
        Regex that header value should match.
        """
        return pulumi.get(self, "regexp")

    @property
    @pulumi.getter(name="allowMissing")
    def allow_missing(self) -> Optional[bool]:
        """
        Allow header to be missing from responses. Defaults to `false`.
        """
        return pulumi.get(self, "allow_missing")


@pulumi.output_type
class SyntheticMonitoringCheckSettingsHttpFailIfHeaderNotMatchesRegexp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowMissing":
            suggest = "allow_missing"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticMonitoringCheckSettingsHttpFailIfHeaderNotMatchesRegexp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticMonitoringCheckSettingsHttpFailIfHeaderNotMatchesRegexp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticMonitoringCheckSettingsHttpFailIfHeaderNotMatchesRegexp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 header: str,
                 regexp: str,
                 allow_missing: Optional[bool] = None):
        """
        :param str header: Header name.
        :param str regexp: Regex that header value should match.
        :param bool allow_missing: Allow header to be missing from responses. Defaults to `false`.
        """
        pulumi.set(__self__, "header", header)
        pulumi.set(__self__, "regexp", regexp)
        if allow_missing is not None:
            pulumi.set(__self__, "allow_missing", allow_missing)

    @property
    @pulumi.getter
    def header(self) -> str:
        """
        Header name.
        """
        return pulumi.get(self, "header")

    @property
    @pulumi.getter
    def regexp(self) -> str:
        """
        Regex that header value should match.
        """
        return pulumi.get(self, "regexp")

    @property
    @pulumi.getter(name="allowMissing")
    def allow_missing(self) -> Optional[bool]:
        """
        Allow header to be missing from responses. Defaults to `false`.
        """
        return pulumi.get(self, "allow_missing")


@pulumi.output_type
class SyntheticMonitoringCheckSettingsHttpTlsConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caCert":
            suggest = "ca_cert"
        elif key == "clientCert":
            suggest = "client_cert"
        elif key == "clientKey":
            suggest = "client_key"
        elif key == "insecureSkipVerify":
            suggest = "insecure_skip_verify"
        elif key == "serverName":
            suggest = "server_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticMonitoringCheckSettingsHttpTlsConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticMonitoringCheckSettingsHttpTlsConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticMonitoringCheckSettingsHttpTlsConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ca_cert: Optional[str] = None,
                 client_cert: Optional[str] = None,
                 client_key: Optional[str] = None,
                 insecure_skip_verify: Optional[bool] = None,
                 server_name: Optional[str] = None):
        """
        :param str ca_cert: CA certificate in PEM format.
        :param str client_cert: Client certificate in PEM format.
        :param str client_key: Client key in PEM format.
        :param bool insecure_skip_verify: Disable target certificate validation. Defaults to `false`.
        :param str server_name: Used to verify the hostname for the targets.
        """
        if ca_cert is not None:
            pulumi.set(__self__, "ca_cert", ca_cert)
        if client_cert is not None:
            pulumi.set(__self__, "client_cert", client_cert)
        if client_key is not None:
            pulumi.set(__self__, "client_key", client_key)
        if insecure_skip_verify is not None:
            pulumi.set(__self__, "insecure_skip_verify", insecure_skip_verify)
        if server_name is not None:
            pulumi.set(__self__, "server_name", server_name)

    @property
    @pulumi.getter(name="caCert")
    def ca_cert(self) -> Optional[str]:
        """
        CA certificate in PEM format.
        """
        return pulumi.get(self, "ca_cert")

    @property
    @pulumi.getter(name="clientCert")
    def client_cert(self) -> Optional[str]:
        """
        Client certificate in PEM format.
        """
        return pulumi.get(self, "client_cert")

    @property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> Optional[str]:
        """
        Client key in PEM format.
        """
        return pulumi.get(self, "client_key")

    @property
    @pulumi.getter(name="insecureSkipVerify")
    def insecure_skip_verify(self) -> Optional[bool]:
        """
        Disable target certificate validation. Defaults to `false`.
        """
        return pulumi.get(self, "insecure_skip_verify")

    @property
    @pulumi.getter(name="serverName")
    def server_name(self) -> Optional[str]:
        """
        Used to verify the hostname for the targets.
        """
        return pulumi.get(self, "server_name")


@pulumi.output_type
class SyntheticMonitoringCheckSettingsMultihttp(dict):
    def __init__(__self__, *,
                 entries: Optional[Sequence['outputs.SyntheticMonitoringCheckSettingsMultihttpEntry']] = None):
        if entries is not None:
            pulumi.set(__self__, "entries", entries)

    @property
    @pulumi.getter
    def entries(self) -> Optional[Sequence['outputs.SyntheticMonitoringCheckSettingsMultihttpEntry']]:
        return pulumi.get(self, "entries")


@pulumi.output_type
class SyntheticMonitoringCheckSettingsMultihttpEntry(dict):
    def __init__(__self__, *,
                 assertions: Optional[Sequence['outputs.SyntheticMonitoringCheckSettingsMultihttpEntryAssertion']] = None,
                 request: Optional['outputs.SyntheticMonitoringCheckSettingsMultihttpEntryRequest'] = None,
                 variables: Optional[Sequence['outputs.SyntheticMonitoringCheckSettingsMultihttpEntryVariable']] = None):
        """
        :param Sequence['SyntheticMonitoringCheckSettingsMultihttpEntryAssertionArgs'] assertions: Assertions to make on the request response
        :param 'SyntheticMonitoringCheckSettingsMultihttpEntryRequestArgs' request: An individual MultiHTTP request
        :param Sequence['SyntheticMonitoringCheckSettingsMultihttpEntryVariableArgs'] variables: Variables to extract from the request response
        """
        if assertions is not None:
            pulumi.set(__self__, "assertions", assertions)
        if request is not None:
            pulumi.set(__self__, "request", request)
        if variables is not None:
            pulumi.set(__self__, "variables", variables)

    @property
    @pulumi.getter
    def assertions(self) -> Optional[Sequence['outputs.SyntheticMonitoringCheckSettingsMultihttpEntryAssertion']]:
        """
        Assertions to make on the request response
        """
        return pulumi.get(self, "assertions")

    @property
    @pulumi.getter
    def request(self) -> Optional['outputs.SyntheticMonitoringCheckSettingsMultihttpEntryRequest']:
        """
        An individual MultiHTTP request
        """
        return pulumi.get(self, "request")

    @property
    @pulumi.getter
    def variables(self) -> Optional[Sequence['outputs.SyntheticMonitoringCheckSettingsMultihttpEntryVariable']]:
        """
        Variables to extract from the request response
        """
        return pulumi.get(self, "variables")


@pulumi.output_type
class SyntheticMonitoringCheckSettingsMultihttpEntryAssertion(dict):
    def __init__(__self__, *,
                 type: str,
                 condition: Optional[str] = None,
                 expression: Optional[str] = None,
                 subject: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str type: The type of assertion to make: TEXT, JSON*PATH*VALUE, JSON*PATH*ASSERTION, REGEX_ASSERTION
        :param str condition: The condition of the assertion: NOT*CONTAINS, EQUALS, STARTS*WITH, ENDS*WITH, TYPE*OF, CONTAINS
        :param str expression: The expression of the assertion. Should start with $.
        :param str subject: The subject of the assertion: RESPONSE*HEADERS, HTTP*STATUS*CODE, RESPONSE*BODY
        :param str value: The value of the assertion
        """
        pulumi.set(__self__, "type", type)
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if subject is not None:
            pulumi.set(__self__, "subject", subject)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of assertion to make: TEXT, JSON*PATH*VALUE, JSON*PATH*ASSERTION, REGEX_ASSERTION
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def condition(self) -> Optional[str]:
        """
        The condition of the assertion: NOT*CONTAINS, EQUALS, STARTS*WITH, ENDS*WITH, TYPE*OF, CONTAINS
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def expression(self) -> Optional[str]:
        """
        The expression of the assertion. Should start with $.
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def subject(self) -> Optional[str]:
        """
        The subject of the assertion: RESPONSE*HEADERS, HTTP*STATUS*CODE, RESPONSE*BODY
        """
        return pulumi.get(self, "subject")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value of the assertion
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class SyntheticMonitoringCheckSettingsMultihttpEntryRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "queryFields":
            suggest = "query_fields"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticMonitoringCheckSettingsMultihttpEntryRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticMonitoringCheckSettingsMultihttpEntryRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticMonitoringCheckSettingsMultihttpEntryRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 method: str,
                 url: str,
                 bodies: Optional[Sequence['outputs.SyntheticMonitoringCheckSettingsMultihttpEntryRequestBody']] = None,
                 headers: Optional[Sequence['outputs.SyntheticMonitoringCheckSettingsMultihttpEntryRequestHeader']] = None,
                 query_fields: Optional[Sequence['outputs.SyntheticMonitoringCheckSettingsMultihttpEntryRequestQueryField']] = None):
        """
        :param str method: The HTTP method to use
        :param str url: The URL for the request
        :param Sequence['SyntheticMonitoringCheckSettingsMultihttpEntryRequestBodyArgs'] bodies: The body of the HTTP request used in probe.
        :param Sequence['SyntheticMonitoringCheckSettingsMultihttpEntryRequestHeaderArgs'] headers: The headers to send with the request
        :param Sequence['SyntheticMonitoringCheckSettingsMultihttpEntryRequestQueryFieldArgs'] query_fields: Query fields to send with the request
        """
        pulumi.set(__self__, "method", method)
        pulumi.set(__self__, "url", url)
        if bodies is not None:
            pulumi.set(__self__, "bodies", bodies)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if query_fields is not None:
            pulumi.set(__self__, "query_fields", query_fields)

    @property
    @pulumi.getter
    def method(self) -> str:
        """
        The HTTP method to use
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        The URL for the request
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter
    def bodies(self) -> Optional[Sequence['outputs.SyntheticMonitoringCheckSettingsMultihttpEntryRequestBody']]:
        """
        The body of the HTTP request used in probe.
        """
        return pulumi.get(self, "bodies")

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.SyntheticMonitoringCheckSettingsMultihttpEntryRequestHeader']]:
        """
        The headers to send with the request
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="queryFields")
    def query_fields(self) -> Optional[Sequence['outputs.SyntheticMonitoringCheckSettingsMultihttpEntryRequestQueryField']]:
        """
        Query fields to send with the request
        """
        return pulumi.get(self, "query_fields")


@pulumi.output_type
class SyntheticMonitoringCheckSettingsMultihttpEntryRequestBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contentEncoding":
            suggest = "content_encoding"
        elif key == "contentType":
            suggest = "content_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticMonitoringCheckSettingsMultihttpEntryRequestBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticMonitoringCheckSettingsMultihttpEntryRequestBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticMonitoringCheckSettingsMultihttpEntryRequestBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 content_encoding: Optional[str] = None,
                 content_type: Optional[str] = None,
                 payload: Optional[str] = None):
        """
        :param str content_encoding: The content encoding of the body
        :param str content_type: The content type of the body
        :param str payload: The body payload
        """
        if content_encoding is not None:
            pulumi.set(__self__, "content_encoding", content_encoding)
        if content_type is not None:
            pulumi.set(__self__, "content_type", content_type)
        if payload is not None:
            pulumi.set(__self__, "payload", payload)

    @property
    @pulumi.getter(name="contentEncoding")
    def content_encoding(self) -> Optional[str]:
        """
        The content encoding of the body
        """
        return pulumi.get(self, "content_encoding")

    @property
    @pulumi.getter(name="contentType")
    def content_type(self) -> Optional[str]:
        """
        The content type of the body
        """
        return pulumi.get(self, "content_type")

    @property
    @pulumi.getter
    def payload(self) -> Optional[str]:
        """
        The body payload
        """
        return pulumi.get(self, "payload")


@pulumi.output_type
class SyntheticMonitoringCheckSettingsMultihttpEntryRequestHeader(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: Name of the header to send
        :param str value: Value of the header to send
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the header to send
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value of the header to send
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class SyntheticMonitoringCheckSettingsMultihttpEntryRequestQueryField(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: Name of the query field to send
        :param str value: Value of the query field to send
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the query field to send
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value of the query field to send
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class SyntheticMonitoringCheckSettingsMultihttpEntryVariable(dict):
    def __init__(__self__, *,
                 type: str,
                 attribute: Optional[str] = None,
                 expression: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str type: The method of finding the variable value to extract. JSON*PATH, REGEX, CSS*SELECTOR
        :param str attribute: The attribute to use when finding the variable value. Only used when type is CSS_SELECTOR
        :param str expression: The expression to when finding the variable. Should start with $. Only use when type is JSON_PATH or REGEX
        :param str name: The name of the variable to extract
        """
        pulumi.set(__self__, "type", type)
        if attribute is not None:
            pulumi.set(__self__, "attribute", attribute)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The method of finding the variable value to extract. JSON*PATH, REGEX, CSS*SELECTOR
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def attribute(self) -> Optional[str]:
        """
        The attribute to use when finding the variable value. Only used when type is CSS_SELECTOR
        """
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter
    def expression(self) -> Optional[str]:
        """
        The expression to when finding the variable. Should start with $. Only use when type is JSON_PATH or REGEX
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the variable to extract
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class SyntheticMonitoringCheckSettingsPing(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dontFragment":
            suggest = "dont_fragment"
        elif key == "ipVersion":
            suggest = "ip_version"
        elif key == "payloadSize":
            suggest = "payload_size"
        elif key == "sourceIpAddress":
            suggest = "source_ip_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticMonitoringCheckSettingsPing. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticMonitoringCheckSettingsPing.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticMonitoringCheckSettingsPing.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dont_fragment: Optional[bool] = None,
                 ip_version: Optional[str] = None,
                 payload_size: Optional[int] = None,
                 source_ip_address: Optional[str] = None):
        """
        :param bool dont_fragment: Set the DF-bit in the IP-header. Only works with ipV4. Defaults to `false`.
        :param str ip_version: Options are `V4`, `V6`, `Any`. Specifies whether the corresponding check will be performed using IPv4 or IPv6. The `Any` value indicates that IPv6 should be used, falling back to IPv4 if that's not available. Defaults to `V4`.
        :param int payload_size: Payload size. Defaults to `0`.
        :param str source_ip_address: Source IP address.
        """
        if dont_fragment is not None:
            pulumi.set(__self__, "dont_fragment", dont_fragment)
        if ip_version is not None:
            pulumi.set(__self__, "ip_version", ip_version)
        if payload_size is not None:
            pulumi.set(__self__, "payload_size", payload_size)
        if source_ip_address is not None:
            pulumi.set(__self__, "source_ip_address", source_ip_address)

    @property
    @pulumi.getter(name="dontFragment")
    def dont_fragment(self) -> Optional[bool]:
        """
        Set the DF-bit in the IP-header. Only works with ipV4. Defaults to `false`.
        """
        return pulumi.get(self, "dont_fragment")

    @property
    @pulumi.getter(name="ipVersion")
    def ip_version(self) -> Optional[str]:
        """
        Options are `V4`, `V6`, `Any`. Specifies whether the corresponding check will be performed using IPv4 or IPv6. The `Any` value indicates that IPv6 should be used, falling back to IPv4 if that's not available. Defaults to `V4`.
        """
        return pulumi.get(self, "ip_version")

    @property
    @pulumi.getter(name="payloadSize")
    def payload_size(self) -> Optional[int]:
        """
        Payload size. Defaults to `0`.
        """
        return pulumi.get(self, "payload_size")

    @property
    @pulumi.getter(name="sourceIpAddress")
    def source_ip_address(self) -> Optional[str]:
        """
        Source IP address.
        """
        return pulumi.get(self, "source_ip_address")


@pulumi.output_type
class SyntheticMonitoringCheckSettingsScripted(dict):
    def __init__(__self__, *,
                 script: str):
        pulumi.set(__self__, "script", script)

    @property
    @pulumi.getter
    def script(self) -> str:
        return pulumi.get(self, "script")


@pulumi.output_type
class SyntheticMonitoringCheckSettingsTcp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipVersion":
            suggest = "ip_version"
        elif key == "queryResponses":
            suggest = "query_responses"
        elif key == "sourceIpAddress":
            suggest = "source_ip_address"
        elif key == "tlsConfig":
            suggest = "tls_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticMonitoringCheckSettingsTcp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticMonitoringCheckSettingsTcp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticMonitoringCheckSettingsTcp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_version: Optional[str] = None,
                 query_responses: Optional[Sequence['outputs.SyntheticMonitoringCheckSettingsTcpQueryResponse']] = None,
                 source_ip_address: Optional[str] = None,
                 tls: Optional[bool] = None,
                 tls_config: Optional['outputs.SyntheticMonitoringCheckSettingsTcpTlsConfig'] = None):
        """
        :param str ip_version: Options are `V4`, `V6`, `Any`. Specifies whether the corresponding check will be performed using IPv4 or IPv6. The `Any` value indicates that IPv6 should be used, falling back to IPv4 if that's not available. Defaults to `V4`.
        :param Sequence['SyntheticMonitoringCheckSettingsTcpQueryResponseArgs'] query_responses: The query sent in the TCP probe and the expected associated response.
        :param str source_ip_address: Source IP address.
        :param bool tls: Whether or not TLS is used when the connection is initiated. Defaults to `false`.
        :param 'SyntheticMonitoringCheckSettingsTcpTlsConfigArgs' tls_config: TLS config.
        """
        if ip_version is not None:
            pulumi.set(__self__, "ip_version", ip_version)
        if query_responses is not None:
            pulumi.set(__self__, "query_responses", query_responses)
        if source_ip_address is not None:
            pulumi.set(__self__, "source_ip_address", source_ip_address)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)
        if tls_config is not None:
            pulumi.set(__self__, "tls_config", tls_config)

    @property
    @pulumi.getter(name="ipVersion")
    def ip_version(self) -> Optional[str]:
        """
        Options are `V4`, `V6`, `Any`. Specifies whether the corresponding check will be performed using IPv4 or IPv6. The `Any` value indicates that IPv6 should be used, falling back to IPv4 if that's not available. Defaults to `V4`.
        """
        return pulumi.get(self, "ip_version")

    @property
    @pulumi.getter(name="queryResponses")
    def query_responses(self) -> Optional[Sequence['outputs.SyntheticMonitoringCheckSettingsTcpQueryResponse']]:
        """
        The query sent in the TCP probe and the expected associated response.
        """
        return pulumi.get(self, "query_responses")

    @property
    @pulumi.getter(name="sourceIpAddress")
    def source_ip_address(self) -> Optional[str]:
        """
        Source IP address.
        """
        return pulumi.get(self, "source_ip_address")

    @property
    @pulumi.getter
    def tls(self) -> Optional[bool]:
        """
        Whether or not TLS is used when the connection is initiated. Defaults to `false`.
        """
        return pulumi.get(self, "tls")

    @property
    @pulumi.getter(name="tlsConfig")
    def tls_config(self) -> Optional['outputs.SyntheticMonitoringCheckSettingsTcpTlsConfig']:
        """
        TLS config.
        """
        return pulumi.get(self, "tls_config")


@pulumi.output_type
class SyntheticMonitoringCheckSettingsTcpQueryResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "startTls":
            suggest = "start_tls"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticMonitoringCheckSettingsTcpQueryResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticMonitoringCheckSettingsTcpQueryResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticMonitoringCheckSettingsTcpQueryResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 expect: str,
                 send: str,
                 start_tls: Optional[bool] = None):
        """
        :param str expect: Response to expect.
        :param str send: Data to send.
        :param bool start_tls: Upgrade TCP connection to TLS. Defaults to `false`.
        """
        pulumi.set(__self__, "expect", expect)
        pulumi.set(__self__, "send", send)
        if start_tls is not None:
            pulumi.set(__self__, "start_tls", start_tls)

    @property
    @pulumi.getter
    def expect(self) -> str:
        """
        Response to expect.
        """
        return pulumi.get(self, "expect")

    @property
    @pulumi.getter
    def send(self) -> str:
        """
        Data to send.
        """
        return pulumi.get(self, "send")

    @property
    @pulumi.getter(name="startTls")
    def start_tls(self) -> Optional[bool]:
        """
        Upgrade TCP connection to TLS. Defaults to `false`.
        """
        return pulumi.get(self, "start_tls")


@pulumi.output_type
class SyntheticMonitoringCheckSettingsTcpTlsConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caCert":
            suggest = "ca_cert"
        elif key == "clientCert":
            suggest = "client_cert"
        elif key == "clientKey":
            suggest = "client_key"
        elif key == "insecureSkipVerify":
            suggest = "insecure_skip_verify"
        elif key == "serverName":
            suggest = "server_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticMonitoringCheckSettingsTcpTlsConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticMonitoringCheckSettingsTcpTlsConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticMonitoringCheckSettingsTcpTlsConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ca_cert: Optional[str] = None,
                 client_cert: Optional[str] = None,
                 client_key: Optional[str] = None,
                 insecure_skip_verify: Optional[bool] = None,
                 server_name: Optional[str] = None):
        """
        :param str ca_cert: CA certificate in PEM format.
        :param str client_cert: Client certificate in PEM format.
        :param str client_key: Client key in PEM format.
        :param bool insecure_skip_verify: Disable target certificate validation. Defaults to `false`.
        :param str server_name: Used to verify the hostname for the targets.
        """
        if ca_cert is not None:
            pulumi.set(__self__, "ca_cert", ca_cert)
        if client_cert is not None:
            pulumi.set(__self__, "client_cert", client_cert)
        if client_key is not None:
            pulumi.set(__self__, "client_key", client_key)
        if insecure_skip_verify is not None:
            pulumi.set(__self__, "insecure_skip_verify", insecure_skip_verify)
        if server_name is not None:
            pulumi.set(__self__, "server_name", server_name)

    @property
    @pulumi.getter(name="caCert")
    def ca_cert(self) -> Optional[str]:
        """
        CA certificate in PEM format.
        """
        return pulumi.get(self, "ca_cert")

    @property
    @pulumi.getter(name="clientCert")
    def client_cert(self) -> Optional[str]:
        """
        Client certificate in PEM format.
        """
        return pulumi.get(self, "client_cert")

    @property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> Optional[str]:
        """
        Client key in PEM format.
        """
        return pulumi.get(self, "client_key")

    @property
    @pulumi.getter(name="insecureSkipVerify")
    def insecure_skip_verify(self) -> Optional[bool]:
        """
        Disable target certificate validation. Defaults to `false`.
        """
        return pulumi.get(self, "insecure_skip_verify")

    @property
    @pulumi.getter(name="serverName")
    def server_name(self) -> Optional[str]:
        """
        Used to verify the hostname for the targets.
        """
        return pulumi.get(self, "server_name")


@pulumi.output_type
class SyntheticMonitoringCheckSettingsTraceroute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxHops":
            suggest = "max_hops"
        elif key == "maxUnknownHops":
            suggest = "max_unknown_hops"
        elif key == "ptrLookup":
            suggest = "ptr_lookup"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticMonitoringCheckSettingsTraceroute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticMonitoringCheckSettingsTraceroute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticMonitoringCheckSettingsTraceroute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_hops: Optional[int] = None,
                 max_unknown_hops: Optional[int] = None,
                 ptr_lookup: Optional[bool] = None):
        """
        :param int max_hops: Maximum TTL for the trace Defaults to `64`.
        :param int max_unknown_hops: Maximum number of hosts to travers that give no response Defaults to `15`.
        :param bool ptr_lookup: Reverse lookup hostnames from IP addresses Defaults to `true`.
        """
        if max_hops is not None:
            pulumi.set(__self__, "max_hops", max_hops)
        if max_unknown_hops is not None:
            pulumi.set(__self__, "max_unknown_hops", max_unknown_hops)
        if ptr_lookup is not None:
            pulumi.set(__self__, "ptr_lookup", ptr_lookup)

    @property
    @pulumi.getter(name="maxHops")
    def max_hops(self) -> Optional[int]:
        """
        Maximum TTL for the trace Defaults to `64`.
        """
        return pulumi.get(self, "max_hops")

    @property
    @pulumi.getter(name="maxUnknownHops")
    def max_unknown_hops(self) -> Optional[int]:
        """
        Maximum number of hosts to travers that give no response Defaults to `15`.
        """
        return pulumi.get(self, "max_unknown_hops")

    @property
    @pulumi.getter(name="ptrLookup")
    def ptr_lookup(self) -> Optional[bool]:
        """
        Reverse lookup hostnames from IP addresses Defaults to `true`.
        """
        return pulumi.get(self, "ptr_lookup")


@pulumi.output_type
class TeamPreferences(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "homeDashboardUid":
            suggest = "home_dashboard_uid"
        elif key == "weekStart":
            suggest = "week_start"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TeamPreferences. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TeamPreferences.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TeamPreferences.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 home_dashboard_uid: Optional[str] = None,
                 theme: Optional[str] = None,
                 timezone: Optional[str] = None,
                 week_start: Optional[str] = None):
        """
        :param str home_dashboard_uid: The UID of the dashboard to display when a team member logs in.
        :param str theme: The default theme for this team. Available themes are `light`, `dark`, `system`, or an empty string for the default theme.
        :param str timezone: The default timezone for this team. Available values are `utc`, `browser`, or an empty string for the default.
        :param str week_start: The default week start day for this team. Available values are `sunday`, `monday`, `saturday`, or an empty string for the default.
        """
        if home_dashboard_uid is not None:
            pulumi.set(__self__, "home_dashboard_uid", home_dashboard_uid)
        if theme is not None:
            pulumi.set(__self__, "theme", theme)
        if timezone is not None:
            pulumi.set(__self__, "timezone", timezone)
        if week_start is not None:
            pulumi.set(__self__, "week_start", week_start)

    @property
    @pulumi.getter(name="homeDashboardUid")
    def home_dashboard_uid(self) -> Optional[str]:
        """
        The UID of the dashboard to display when a team member logs in.
        """
        return pulumi.get(self, "home_dashboard_uid")

    @property
    @pulumi.getter
    def theme(self) -> Optional[str]:
        """
        The default theme for this team. Available themes are `light`, `dark`, `system`, or an empty string for the default theme.
        """
        return pulumi.get(self, "theme")

    @property
    @pulumi.getter
    def timezone(self) -> Optional[str]:
        """
        The default timezone for this team. Available values are `utc`, `browser`, or an empty string for the default.
        """
        return pulumi.get(self, "timezone")

    @property
    @pulumi.getter(name="weekStart")
    def week_start(self) -> Optional[str]:
        """
        The default week start day for this team. Available values are `sunday`, `monday`, `saturday`, or an empty string for the default.
        """
        return pulumi.get(self, "week_start")


@pulumi.output_type
class TeamTeamSync(dict):
    def __init__(__self__, *,
                 groups: Optional[Sequence[str]] = None):
        if groups is not None:
            pulumi.set(__self__, "groups", groups)

    @property
    @pulumi.getter
    def groups(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "groups")


@pulumi.output_type
class GetDashboardsDashboardResult(dict):
    def __init__(__self__, *,
                 folder_title: str,
                 title: str,
                 uid: str):
        pulumi.set(__self__, "folder_title", folder_title)
        pulumi.set(__self__, "title", title)
        pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="folderTitle")
    def folder_title(self) -> str:
        return pulumi.get(self, "folder_title")

    @property
    @pulumi.getter
    def title(self) -> str:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def uid(self) -> str:
        return pulumi.get(self, "uid")


@pulumi.output_type
class GetFoldersFolderResult(dict):
    def __init__(__self__, *,
                 id: int,
                 title: str,
                 uid: str,
                 url: str):
        """
        :param int id: The folder ID.
        :param str title: The folder title.
        :param str uid: The folder's unique identifier.
        :param str url: The folder's URL
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "title", title)
        pulumi.set(__self__, "uid", uid)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def id(self) -> int:
        """
        The folder ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def title(self) -> str:
        """
        The folder title.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def uid(self) -> str:
        """
        The folder's unique identifier.
        """
        return pulumi.get(self, "uid")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        The folder's URL
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class GetLibraryPanelsPanelResult(dict):
    def __init__(__self__, *,
                 description: str,
                 folder_uid: str,
                 model_json: str,
                 name: str,
                 uid: str):
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "folder_uid", folder_uid)
        pulumi.set(__self__, "model_json", model_json)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter
    def description(self) -> str:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="folderUid")
    def folder_uid(self) -> str:
        return pulumi.get(self, "folder_uid")

    @property
    @pulumi.getter(name="modelJson")
    def model_json(self) -> str:
        return pulumi.get(self, "model_json")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def uid(self) -> str:
        return pulumi.get(self, "uid")


@pulumi.output_type
class GetRolePermissionResult(dict):
    def __init__(__self__, *,
                 action: str,
                 scope: Optional[str] = None):
        """
        :param str action: Specific action users granted with the role will be allowed to perform (for example: `users:read`)
        :param str scope: Scope to restrict the action to a set of resources (for example: `users:*` or `roles:customrole1`)
        """
        pulumi.set(__self__, "action", action)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        Specific action users granted with the role will be allowed to perform (for example: `users:read`)
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def scope(self) -> Optional[str]:
        """
        Scope to restrict the action to a set of resources (for example: `users:*` or `roles:customrole1`)
        """
        return pulumi.get(self, "scope")


@pulumi.output_type
class GetSlosSloResult(dict):
    def __init__(__self__, *,
                 alertings: Sequence['outputs.GetSlosSloAlertingResult'],
                 description: str,
                 destination_datasources: Sequence['outputs.GetSlosSloDestinationDatasourceResult'],
                 folder_uid: str,
                 labels: Sequence['outputs.GetSlosSloLabelResult'],
                 name: str,
                 objectives: Sequence['outputs.GetSlosSloObjectiveResult'],
                 queries: Sequence['outputs.GetSlosSloQueryResult'],
                 search_expression: str,
                 uuid: str):
        """
        :param Sequence['GetSlosSloAlertingArgs'] alertings: Configures the alerting rules that will be generated for each
               				time window associated with the SLO. Grafana SLOs can generate
               				alerts when the short-term error budget burn is very high, the
               				long-term error budget burn rate is high, or when the remaining
               				error budget is below a certain threshold. Annotations and Labels support templating.
        :param str description: Description is a free-text field that can provide more context to an SLO.
        :param Sequence['GetSlosSloDestinationDatasourceArgs'] destination_datasources: Destination Datasource sets the datasource defined for an SLO
        :param str folder_uid: UID for the SLO folder
        :param Sequence['GetSlosSloLabelArgs'] labels: Additional labels that will be attached to all metrics generated from the query. These labels are useful for grouping SLOs in dashboard views that you create by hand. Labels must adhere to Prometheus label name schema - "^[a-zA-Z_][a-zA-Z0-9_]*$"
        :param str name: Name should be a short description of your indicator. Consider names like "API Availability"
        :param Sequence['GetSlosSloObjectiveArgs'] objectives: Over each rolling time window, the remaining error budget will be calculated, and separate alerts can be generated for each time window based on the SLO burn rate or remaining error budget.
        :param Sequence['GetSlosSloQueryArgs'] queries: Query describes the indicator that will be measured against the objective. Freeform Query types are currently supported.
        :param str search_expression: The name of a search expression in Grafana Asserts. This is used in the SLO UI to open the Asserts RCA workbench and in alerts to link to the RCA workbench.
        :param str uuid: A unique, random identifier. This value will also be the name of the resource stored in the API server. This value is read-only.
        """
        pulumi.set(__self__, "alertings", alertings)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "destination_datasources", destination_datasources)
        pulumi.set(__self__, "folder_uid", folder_uid)
        pulumi.set(__self__, "labels", labels)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "objectives", objectives)
        pulumi.set(__self__, "queries", queries)
        pulumi.set(__self__, "search_expression", search_expression)
        pulumi.set(__self__, "uuid", uuid)

    @property
    @pulumi.getter
    def alertings(self) -> Sequence['outputs.GetSlosSloAlertingResult']:
        """
        Configures the alerting rules that will be generated for each
        				time window associated with the SLO. Grafana SLOs can generate
        				alerts when the short-term error budget burn is very high, the
        				long-term error budget burn rate is high, or when the remaining
        				error budget is below a certain threshold. Annotations and Labels support templating.
        """
        return pulumi.get(self, "alertings")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Description is a free-text field that can provide more context to an SLO.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="destinationDatasources")
    def destination_datasources(self) -> Sequence['outputs.GetSlosSloDestinationDatasourceResult']:
        """
        Destination Datasource sets the datasource defined for an SLO
        """
        return pulumi.get(self, "destination_datasources")

    @property
    @pulumi.getter(name="folderUid")
    def folder_uid(self) -> str:
        """
        UID for the SLO folder
        """
        return pulumi.get(self, "folder_uid")

    @property
    @pulumi.getter
    def labels(self) -> Sequence['outputs.GetSlosSloLabelResult']:
        """
        Additional labels that will be attached to all metrics generated from the query. These labels are useful for grouping SLOs in dashboard views that you create by hand. Labels must adhere to Prometheus label name schema - "^[a-zA-Z_][a-zA-Z0-9_]*$"
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name should be a short description of your indicator. Consider names like "API Availability"
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def objectives(self) -> Sequence['outputs.GetSlosSloObjectiveResult']:
        """
        Over each rolling time window, the remaining error budget will be calculated, and separate alerts can be generated for each time window based on the SLO burn rate or remaining error budget.
        """
        return pulumi.get(self, "objectives")

    @property
    @pulumi.getter
    def queries(self) -> Sequence['outputs.GetSlosSloQueryResult']:
        """
        Query describes the indicator that will be measured against the objective. Freeform Query types are currently supported.
        """
        return pulumi.get(self, "queries")

    @property
    @pulumi.getter(name="searchExpression")
    def search_expression(self) -> str:
        """
        The name of a search expression in Grafana Asserts. This is used in the SLO UI to open the Asserts RCA workbench and in alerts to link to the RCA workbench.
        """
        return pulumi.get(self, "search_expression")

    @property
    @pulumi.getter
    def uuid(self) -> str:
        """
        A unique, random identifier. This value will also be the name of the resource stored in the API server. This value is read-only.
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class GetSlosSloAlertingResult(dict):
    def __init__(__self__, *,
                 advanced_options: Optional['outputs.GetSlosSloAlertingAdvancedOptionsResult'] = None,
                 annotations: Optional[Sequence['outputs.GetSlosSloAlertingAnnotationResult']] = None,
                 fastburn: Optional['outputs.GetSlosSloAlertingFastburnResult'] = None,
                 labels: Optional[Sequence['outputs.GetSlosSloAlertingLabelResult']] = None,
                 slowburn: Optional['outputs.GetSlosSloAlertingSlowburnResult'] = None):
        """
        :param 'GetSlosSloAlertingAdvancedOptionsArgs' advanced_options: Advanced Options for Alert Rules
        :param Sequence['GetSlosSloAlertingAnnotationArgs'] annotations: Annotations will be attached to all alerts generated by any of these rules.
        :param 'GetSlosSloAlertingFastburnArgs' fastburn: Alerting Rules generated for Fast Burn alerts
        :param Sequence['GetSlosSloAlertingLabelArgs'] labels: Labels will be attached to all alerts generated by any of these rules.
        :param 'GetSlosSloAlertingSlowburnArgs' slowburn: Alerting Rules generated for Slow Burn alerts
        """
        if advanced_options is not None:
            pulumi.set(__self__, "advanced_options", advanced_options)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if fastburn is not None:
            pulumi.set(__self__, "fastburn", fastburn)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if slowburn is not None:
            pulumi.set(__self__, "slowburn", slowburn)

    @property
    @pulumi.getter(name="advancedOptions")
    def advanced_options(self) -> Optional['outputs.GetSlosSloAlertingAdvancedOptionsResult']:
        """
        Advanced Options for Alert Rules
        """
        return pulumi.get(self, "advanced_options")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence['outputs.GetSlosSloAlertingAnnotationResult']]:
        """
        Annotations will be attached to all alerts generated by any of these rules.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def fastburn(self) -> Optional['outputs.GetSlosSloAlertingFastburnResult']:
        """
        Alerting Rules generated for Fast Burn alerts
        """
        return pulumi.get(self, "fastburn")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Sequence['outputs.GetSlosSloAlertingLabelResult']]:
        """
        Labels will be attached to all alerts generated by any of these rules.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter
    def slowburn(self) -> Optional['outputs.GetSlosSloAlertingSlowburnResult']:
        """
        Alerting Rules generated for Slow Burn alerts
        """
        return pulumi.get(self, "slowburn")


@pulumi.output_type
class GetSlosSloAlertingAdvancedOptionsResult(dict):
    def __init__(__self__, *,
                 min_failures: Optional[int] = None):
        """
        :param int min_failures: Minimum number of failed events to trigger an alert
        """
        if min_failures is not None:
            pulumi.set(__self__, "min_failures", min_failures)

    @property
    @pulumi.getter(name="minFailures")
    def min_failures(self) -> Optional[int]:
        """
        Minimum number of failed events to trigger an alert
        """
        return pulumi.get(self, "min_failures")


@pulumi.output_type
class GetSlosSloAlertingAnnotationResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: Key for filtering and identification
        :param str value: Templatable value
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key for filtering and identification
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Templatable value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetSlosSloAlertingFastburnResult(dict):
    def __init__(__self__, *,
                 annotations: Optional[Sequence['outputs.GetSlosSloAlertingFastburnAnnotationResult']] = None,
                 labels: Optional[Sequence['outputs.GetSlosSloAlertingFastburnLabelResult']] = None):
        """
        :param Sequence['GetSlosSloAlertingFastburnAnnotationArgs'] annotations: Annotations to attach only to Fast Burn alerts.
        :param Sequence['GetSlosSloAlertingFastburnLabelArgs'] labels: Labels to attach only to Fast Burn alerts.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence['outputs.GetSlosSloAlertingFastburnAnnotationResult']]:
        """
        Annotations to attach only to Fast Burn alerts.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Sequence['outputs.GetSlosSloAlertingFastburnLabelResult']]:
        """
        Labels to attach only to Fast Burn alerts.
        """
        return pulumi.get(self, "labels")


@pulumi.output_type
class GetSlosSloAlertingFastburnAnnotationResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: Key for filtering and identification
        :param str value: Templatable value
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key for filtering and identification
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Templatable value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetSlosSloAlertingFastburnLabelResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: Key for filtering and identification
        :param str value: Templatable value
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key for filtering and identification
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Templatable value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetSlosSloAlertingLabelResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: Key for filtering and identification
        :param str value: Templatable value
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key for filtering and identification
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Templatable value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetSlosSloAlertingSlowburnResult(dict):
    def __init__(__self__, *,
                 annotations: Optional[Sequence['outputs.GetSlosSloAlertingSlowburnAnnotationResult']] = None,
                 labels: Optional[Sequence['outputs.GetSlosSloAlertingSlowburnLabelResult']] = None):
        """
        :param Sequence['GetSlosSloAlertingSlowburnAnnotationArgs'] annotations: Annotations to attach only to Slow Burn alerts.
        :param Sequence['GetSlosSloAlertingSlowburnLabelArgs'] labels: Labels to attach only to Slow Burn alerts.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence['outputs.GetSlosSloAlertingSlowburnAnnotationResult']]:
        """
        Annotations to attach only to Slow Burn alerts.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Sequence['outputs.GetSlosSloAlertingSlowburnLabelResult']]:
        """
        Labels to attach only to Slow Burn alerts.
        """
        return pulumi.get(self, "labels")


@pulumi.output_type
class GetSlosSloAlertingSlowburnAnnotationResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: Key for filtering and identification
        :param str value: Templatable value
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key for filtering and identification
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Templatable value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetSlosSloAlertingSlowburnLabelResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: Key for filtering and identification
        :param str value: Templatable value
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key for filtering and identification
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Templatable value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetSlosSloDestinationDatasourceResult(dict):
    def __init__(__self__, *,
                 uid: str):
        """
        :param str uid: UID for the Datasource
        """
        pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter
    def uid(self) -> str:
        """
        UID for the Datasource
        """
        return pulumi.get(self, "uid")


@pulumi.output_type
class GetSlosSloLabelResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: Key for filtering and identification
        :param str value: Templatable value
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key for filtering and identification
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Templatable value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetSlosSloObjectiveResult(dict):
    def __init__(__self__, *,
                 value: float,
                 window: str):
        """
        :param float value: Value between 0 and 1. If the value of the query is above the objective, the SLO is met.
        :param str window: A Prometheus-parsable time duration string like 24h, 60m. This is the time window the objective is measured over.
        """
        pulumi.set(__self__, "value", value)
        pulumi.set(__self__, "window", window)

    @property
    @pulumi.getter
    def value(self) -> float:
        """
        Value between 0 and 1. If the value of the query is above the objective, the SLO is met.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def window(self) -> str:
        """
        A Prometheus-parsable time duration string like 24h, 60m. This is the time window the objective is measured over.
        """
        return pulumi.get(self, "window")


@pulumi.output_type
class GetSlosSloQueryResult(dict):
    def __init__(__self__, *,
                 type: str,
                 freeform: Optional['outputs.GetSlosSloQueryFreeformResult'] = None,
                 grafana_queries: Optional['outputs.GetSlosSloQueryGrafanaQueriesResult'] = None,
                 ratio: Optional['outputs.GetSlosSloQueryRatioResult'] = None):
        """
        :param str type: Query type must be one of: "freeform", "query", "ratio", "grafana_queries" or "threshold"
        :param 'GetSlosSloQueryGrafanaQueriesArgs' grafana_queries: Array for holding a set of grafana queries
        """
        pulumi.set(__self__, "type", type)
        if freeform is not None:
            pulumi.set(__self__, "freeform", freeform)
        if grafana_queries is not None:
            pulumi.set(__self__, "grafana_queries", grafana_queries)
        if ratio is not None:
            pulumi.set(__self__, "ratio", ratio)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Query type must be one of: "freeform", "query", "ratio", "grafana_queries" or "threshold"
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def freeform(self) -> Optional['outputs.GetSlosSloQueryFreeformResult']:
        return pulumi.get(self, "freeform")

    @property
    @pulumi.getter(name="grafanaQueries")
    def grafana_queries(self) -> Optional['outputs.GetSlosSloQueryGrafanaQueriesResult']:
        """
        Array for holding a set of grafana queries
        """
        return pulumi.get(self, "grafana_queries")

    @property
    @pulumi.getter
    def ratio(self) -> Optional['outputs.GetSlosSloQueryRatioResult']:
        return pulumi.get(self, "ratio")


@pulumi.output_type
class GetSlosSloQueryFreeformResult(dict):
    def __init__(__self__, *,
                 query: str):
        """
        :param str query: Freeform Query Field - valid promQl
        """
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        Freeform Query Field - valid promQl
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class GetSlosSloQueryGrafanaQueriesResult(dict):
    def __init__(__self__, *,
                 grafana_queries: str):
        """
        :param str grafana_queries: Query Object - Array of Grafana Query JSON objects
        """
        pulumi.set(__self__, "grafana_queries", grafana_queries)

    @property
    @pulumi.getter(name="grafanaQueries")
    def grafana_queries(self) -> str:
        """
        Query Object - Array of Grafana Query JSON objects
        """
        return pulumi.get(self, "grafana_queries")


@pulumi.output_type
class GetSlosSloQueryRatioResult(dict):
    def __init__(__self__, *,
                 success_metric: str,
                 total_metric: str,
                 group_by_labels: Optional[Sequence[str]] = None):
        """
        :param str success_metric: Counter metric for success events (numerator)
        :param str total_metric: Metric for total events (denominator)
        :param Sequence[str] group_by_labels: Defines Group By Labels used for per-label alerting. These appear as variables on SLO dashboards to enable filtering and aggregation. Labels must adhere to Prometheus label name schema - "^[a-zA-Z_][a-zA-Z0-9_]*$"
        """
        pulumi.set(__self__, "success_metric", success_metric)
        pulumi.set(__self__, "total_metric", total_metric)
        if group_by_labels is not None:
            pulumi.set(__self__, "group_by_labels", group_by_labels)

    @property
    @pulumi.getter(name="successMetric")
    def success_metric(self) -> str:
        """
        Counter metric for success events (numerator)
        """
        return pulumi.get(self, "success_metric")

    @property
    @pulumi.getter(name="totalMetric")
    def total_metric(self) -> str:
        """
        Metric for total events (denominator)
        """
        return pulumi.get(self, "total_metric")

    @property
    @pulumi.getter(name="groupByLabels")
    def group_by_labels(self) -> Optional[Sequence[str]]:
        """
        Defines Group By Labels used for per-label alerting. These appear as variables on SLO dashboards to enable filtering and aggregation. Labels must adhere to Prometheus label name schema - "^[a-zA-Z_][a-zA-Z0-9_]*$"
        """
        return pulumi.get(self, "group_by_labels")


@pulumi.output_type
class GetTeamPreferenceResult(dict):
    def __init__(__self__, *,
                 home_dashboard_uid: Optional[str] = None,
                 theme: Optional[str] = None,
                 timezone: Optional[str] = None,
                 week_start: Optional[str] = None):
        """
        :param str home_dashboard_uid: The UID of the dashboard to display when a team member logs in.
        :param str theme: The default theme for this team. Available themes are `light`, `dark`, `system`, or an empty string for the default theme.
        :param str timezone: The default timezone for this team. Available values are `utc`, `browser`, or an empty string for the default.
        :param str week_start: The default week start day for this team. Available values are `sunday`, `monday`, `saturday`, or an empty string for the default.
        """
        if home_dashboard_uid is not None:
            pulumi.set(__self__, "home_dashboard_uid", home_dashboard_uid)
        if theme is not None:
            pulumi.set(__self__, "theme", theme)
        if timezone is not None:
            pulumi.set(__self__, "timezone", timezone)
        if week_start is not None:
            pulumi.set(__self__, "week_start", week_start)

    @property
    @pulumi.getter(name="homeDashboardUid")
    def home_dashboard_uid(self) -> Optional[str]:
        """
        The UID of the dashboard to display when a team member logs in.
        """
        return pulumi.get(self, "home_dashboard_uid")

    @property
    @pulumi.getter
    def theme(self) -> Optional[str]:
        """
        The default theme for this team. Available themes are `light`, `dark`, `system`, or an empty string for the default theme.
        """
        return pulumi.get(self, "theme")

    @property
    @pulumi.getter
    def timezone(self) -> Optional[str]:
        """
        The default timezone for this team. Available values are `utc`, `browser`, or an empty string for the default.
        """
        return pulumi.get(self, "timezone")

    @property
    @pulumi.getter(name="weekStart")
    def week_start(self) -> Optional[str]:
        """
        The default week start day for this team. Available values are `sunday`, `monday`, `saturday`, or an empty string for the default.
        """
        return pulumi.get(self, "week_start")


@pulumi.output_type
class GetTeamTeamSyncResult(dict):
    def __init__(__self__, *,
                 groups: Optional[Sequence[str]] = None):
        if groups is not None:
            pulumi.set(__self__, "groups", groups)

    @property
    @pulumi.getter
    def groups(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "groups")


@pulumi.output_type
class GetUsersUserResult(dict):
    def __init__(__self__, *,
                 email: str,
                 id: int,
                 is_admin: bool,
                 login: str,
                 name: str):
        """
        :param str email: The user's email.
        :param int id: The user ID.
        :param bool is_admin: Whether the user is admin or not.
        :param str login: The user's login.
        :param str name: The user's name.
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "is_admin", is_admin)
        pulumi.set(__self__, "login", login)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def email(self) -> str:
        """
        The user's email.
        """
        return pulumi.get(self, "email")

    @property
    @pulumi.getter
    def id(self) -> int:
        """
        The user ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isAdmin")
    def is_admin(self) -> bool:
        """
        Whether the user is admin or not.
        """
        return pulumi.get(self, "is_admin")

    @property
    @pulumi.getter
    def login(self) -> str:
        """
        The user's login.
        """
        return pulumi.get(self, "login")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The user's name.
        """
        return pulumi.get(self, "name")


