# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'AlertEnrichmentMetadata',
    'AlertEnrichmentOptions',
    'AlertEnrichmentSpec',
    'AlertEnrichmentSpecAnnotationMatcher',
    'AlertEnrichmentSpecLabelMatcher',
    'AlertEnrichmentSpecStep',
    'AlertEnrichmentSpecStepAsserts',
    'AlertEnrichmentSpecStepAssign',
    'AlertEnrichmentSpecStepAssistantInvestigations',
    'AlertEnrichmentSpecStepConditional',
    'AlertEnrichmentSpecStepConditionalElse',
    'AlertEnrichmentSpecStepConditionalElseStep',
    'AlertEnrichmentSpecStepConditionalElseStepAsserts',
    'AlertEnrichmentSpecStepConditionalElseStepAssign',
    'AlertEnrichmentSpecStepConditionalElseStepAssistantInvestigations',
    'AlertEnrichmentSpecStepConditionalElseStepDataSource',
    'AlertEnrichmentSpecStepConditionalElseStepDataSourceLogsQuery',
    'AlertEnrichmentSpecStepConditionalElseStepDataSourceRawQuery',
    'AlertEnrichmentSpecStepConditionalElseStepExplain',
    'AlertEnrichmentSpecStepConditionalElseStepExternal',
    'AlertEnrichmentSpecStepConditionalElseStepSift',
    'AlertEnrichmentSpecStepConditionalIf',
    'AlertEnrichmentSpecStepConditionalIfAnnotationMatcher',
    'AlertEnrichmentSpecStepConditionalIfDataSourceCondition',
    'AlertEnrichmentSpecStepConditionalIfLabelMatcher',
    'AlertEnrichmentSpecStepConditionalThen',
    'AlertEnrichmentSpecStepConditionalThenStep',
    'AlertEnrichmentSpecStepConditionalThenStepAsserts',
    'AlertEnrichmentSpecStepConditionalThenStepAssign',
    'AlertEnrichmentSpecStepConditionalThenStepAssistantInvestigations',
    'AlertEnrichmentSpecStepConditionalThenStepDataSource',
    'AlertEnrichmentSpecStepConditionalThenStepDataSourceLogsQuery',
    'AlertEnrichmentSpecStepConditionalThenStepDataSourceRawQuery',
    'AlertEnrichmentSpecStepConditionalThenStepExplain',
    'AlertEnrichmentSpecStepConditionalThenStepExternal',
    'AlertEnrichmentSpecStepConditionalThenStepSift',
    'AlertEnrichmentSpecStepDataSource',
    'AlertEnrichmentSpecStepDataSourceLogsQuery',
    'AlertEnrichmentSpecStepDataSourceRawQuery',
    'AlertEnrichmentSpecStepExplain',
    'AlertEnrichmentSpecStepExternal',
    'AlertEnrichmentSpecStepSift',
    'AlertRuleV0Alpha1Metadata',
    'AlertRuleV0Alpha1Options',
    'AlertRuleV0Alpha1Spec',
    'AlertRuleV0Alpha1SpecNotificationSettings',
    'AlertRuleV0Alpha1SpecTrigger',
    'ContactPointAlertmanager',
    'ContactPointDingding',
    'ContactPointDiscord',
    'ContactPointEmail',
    'ContactPointGooglechat',
    'ContactPointKafka',
    'ContactPointLine',
    'ContactPointOncall',
    'ContactPointOpsgeny',
    'ContactPointOpsgenyResponder',
    'ContactPointPagerduty',
    'ContactPointPushover',
    'ContactPointSensugo',
    'ContactPointSlack',
    'ContactPointSn',
    'ContactPointTeam',
    'ContactPointTelegram',
    'ContactPointThreema',
    'ContactPointVictorop',
    'ContactPointWebex',
    'ContactPointWebhook',
    'ContactPointWebhookHmacConfig',
    'ContactPointWebhookHttpConfig',
    'ContactPointWebhookHttpConfigOauth2',
    'ContactPointWebhookHttpConfigOauth2ProxyConfig',
    'ContactPointWebhookHttpConfigOauth2TlsConfig',
    'ContactPointWebhookPayload',
    'ContactPointWecom',
    'MuteTimingInterval',
    'MuteTimingIntervalTime',
    'NotificationPolicyPolicy',
    'NotificationPolicyPolicyMatcher',
    'NotificationPolicyPolicyPolicy',
    'NotificationPolicyPolicyPolicyMatcher',
    'NotificationPolicyPolicyPolicyPolicy',
    'NotificationPolicyPolicyPolicyPolicyMatcher',
    'NotificationPolicyPolicyPolicyPolicyPolicy',
    'NotificationPolicyPolicyPolicyPolicyPolicyMatcher',
    'RecordingRuleV0Alpha1Metadata',
    'RecordingRuleV0Alpha1Options',
    'RecordingRuleV0Alpha1Spec',
    'RecordingRuleV0Alpha1SpecTrigger',
    'RuleGroupRule',
    'RuleGroupRuleData',
    'RuleGroupRuleDataRelativeTimeRange',
    'RuleGroupRuleNotificationSettings',
    'RuleGroupRuleRecord',
]

@pulumi.output_type
class AlertEnrichmentMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "folderUid":
            suggest = "folder_uid"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertEnrichmentMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertEnrichmentMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertEnrichmentMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 uid: _builtins.str,
                 annotations: Optional[Mapping[str, _builtins.str]] = None,
                 folder_uid: Optional[_builtins.str] = None,
                 url: Optional[_builtins.str] = None,
                 uuid: Optional[_builtins.str] = None,
                 version: Optional[_builtins.str] = None):
        """
        :param _builtins.str uid: The unique identifier of the resource.
        :param Mapping[str, _builtins.str] annotations: Annotations of the resource.
        :param _builtins.str folder_uid: The UID of the folder to save the resource in.
        :param _builtins.str url: The full URL of the resource.
        :param _builtins.str uuid: The globally unique identifier of a resource, used by the API for tracking.
        :param _builtins.str version: The version of the resource.
        """
        pulumi.set(__self__, "uid", uid)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if folder_uid is not None:
            pulumi.set(__self__, "folder_uid", folder_uid)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def uid(self) -> _builtins.str:
        """
        The unique identifier of the resource.
        """
        return pulumi.get(self, "uid")

    @_builtins.property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Annotations of the resource.
        """
        return pulumi.get(self, "annotations")

    @_builtins.property
    @pulumi.getter(name="folderUid")
    def folder_uid(self) -> Optional[_builtins.str]:
        """
        The UID of the folder to save the resource in.
        """
        return pulumi.get(self, "folder_uid")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        The full URL of the resource.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        The globally unique identifier of a resource, used by the API for tracking.
        """
        return pulumi.get(self, "uuid")

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[_builtins.str]:
        """
        The version of the resource.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class AlertEnrichmentOptions(dict):
    def __init__(__self__, *,
                 overwrite: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool overwrite: Set to true if you want to overwrite existing resource with newer version, same resource title in folder or same resource uid.
        """
        if overwrite is not None:
            pulumi.set(__self__, "overwrite", overwrite)

    @_builtins.property
    @pulumi.getter
    def overwrite(self) -> Optional[_builtins.bool]:
        """
        Set to true if you want to overwrite existing resource with newer version, same resource title in folder or same resource uid.
        """
        return pulumi.get(self, "overwrite")


@pulumi.output_type
class AlertEnrichmentSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertRuleUids":
            suggest = "alert_rule_uids"
        elif key == "annotationMatchers":
            suggest = "annotation_matchers"
        elif key == "disableProvenance":
            suggest = "disable_provenance"
        elif key == "labelMatchers":
            suggest = "label_matchers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertEnrichmentSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertEnrichmentSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertEnrichmentSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 title: _builtins.str,
                 alert_rule_uids: Optional[Sequence[_builtins.str]] = None,
                 annotation_matchers: Optional[Sequence['outputs.AlertEnrichmentSpecAnnotationMatcher']] = None,
                 description: Optional[_builtins.str] = None,
                 disable_provenance: Optional[_builtins.bool] = None,
                 label_matchers: Optional[Sequence['outputs.AlertEnrichmentSpecLabelMatcher']] = None,
                 receivers: Optional[Sequence[_builtins.str]] = None,
                 steps: Optional[Sequence['outputs.AlertEnrichmentSpecStep']] = None):
        """
        :param _builtins.str title: The title of the alert enrichment.
        :param Sequence[_builtins.str] alert_rule_uids: UIDs of alert rules this enrichment applies to. If empty, applies to all alert rules.
        :param Sequence['AlertEnrichmentSpecAnnotationMatcherArgs'] annotation_matchers: Annotation matchers that an alert must satisfy for this enrichment to apply. Each matcher is an object with: 'type' (string, one of: =, !=, =~, !~), 'name' (string, annotation key to match), 'value' (string, annotation value to compare against, supports regex for =~/!~ operators).
        :param _builtins.str description: Description of the alert enrichment.
        :param Sequence['AlertEnrichmentSpecLabelMatcherArgs'] label_matchers: Label matchers that an alert must satisfy for this enrichment to apply. Each matcher is an object with: 'type' (string, one of: =, !=, =~, !~), 'name' (string, label key to match), 'value' (string, label value to compare against, supports regex for =~/!~ operators).
        :param Sequence[_builtins.str] receivers: Receiver names to match. If empty, applies to all receivers.
        :param Sequence['AlertEnrichmentSpecStepArgs'] steps: Enrichment step. Can be repeated multiple times to define a sequence of steps. Each step must contain exactly one enrichment block.
        """
        pulumi.set(__self__, "title", title)
        if alert_rule_uids is not None:
            pulumi.set(__self__, "alert_rule_uids", alert_rule_uids)
        if annotation_matchers is not None:
            pulumi.set(__self__, "annotation_matchers", annotation_matchers)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disable_provenance is not None:
            pulumi.set(__self__, "disable_provenance", disable_provenance)
        if label_matchers is not None:
            pulumi.set(__self__, "label_matchers", label_matchers)
        if receivers is not None:
            pulumi.set(__self__, "receivers", receivers)
        if steps is not None:
            pulumi.set(__self__, "steps", steps)

    @_builtins.property
    @pulumi.getter
    def title(self) -> _builtins.str:
        """
        The title of the alert enrichment.
        """
        return pulumi.get(self, "title")

    @_builtins.property
    @pulumi.getter(name="alertRuleUids")
    def alert_rule_uids(self) -> Optional[Sequence[_builtins.str]]:
        """
        UIDs of alert rules this enrichment applies to. If empty, applies to all alert rules.
        """
        return pulumi.get(self, "alert_rule_uids")

    @_builtins.property
    @pulumi.getter(name="annotationMatchers")
    def annotation_matchers(self) -> Optional[Sequence['outputs.AlertEnrichmentSpecAnnotationMatcher']]:
        """
        Annotation matchers that an alert must satisfy for this enrichment to apply. Each matcher is an object with: 'type' (string, one of: =, !=, =~, !~), 'name' (string, annotation key to match), 'value' (string, annotation value to compare against, supports regex for =~/!~ operators).
        """
        return pulumi.get(self, "annotation_matchers")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Description of the alert enrichment.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="disableProvenance")
    def disable_provenance(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "disable_provenance")

    @_builtins.property
    @pulumi.getter(name="labelMatchers")
    def label_matchers(self) -> Optional[Sequence['outputs.AlertEnrichmentSpecLabelMatcher']]:
        """
        Label matchers that an alert must satisfy for this enrichment to apply. Each matcher is an object with: 'type' (string, one of: =, !=, =~, !~), 'name' (string, label key to match), 'value' (string, label value to compare against, supports regex for =~/!~ operators).
        """
        return pulumi.get(self, "label_matchers")

    @_builtins.property
    @pulumi.getter
    def receivers(self) -> Optional[Sequence[_builtins.str]]:
        """
        Receiver names to match. If empty, applies to all receivers.
        """
        return pulumi.get(self, "receivers")

    @_builtins.property
    @pulumi.getter
    def steps(self) -> Optional[Sequence['outputs.AlertEnrichmentSpecStep']]:
        """
        Enrichment step. Can be repeated multiple times to define a sequence of steps. Each step must contain exactly one enrichment block.
        """
        return pulumi.get(self, "steps")


@pulumi.output_type
class AlertEnrichmentSpecAnnotationMatcher(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 type: _builtins.str,
                 value: _builtins.str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")


@pulumi.output_type
class AlertEnrichmentSpecLabelMatcher(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 type: _builtins.str,
                 value: _builtins.str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")


@pulumi.output_type
class AlertEnrichmentSpecStep(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "assistantInvestigations":
            suggest = "assistant_investigations"
        elif key == "dataSource":
            suggest = "data_source"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertEnrichmentSpecStep. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertEnrichmentSpecStep.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertEnrichmentSpecStep.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 asserts: Optional['outputs.AlertEnrichmentSpecStepAsserts'] = None,
                 assign: Optional['outputs.AlertEnrichmentSpecStepAssign'] = None,
                 assistant_investigations: Optional['outputs.AlertEnrichmentSpecStepAssistantInvestigations'] = None,
                 conditional: Optional['outputs.AlertEnrichmentSpecStepConditional'] = None,
                 data_source: Optional['outputs.AlertEnrichmentSpecStepDataSource'] = None,
                 explain: Optional['outputs.AlertEnrichmentSpecStepExplain'] = None,
                 external: Optional['outputs.AlertEnrichmentSpecStepExternal'] = None,
                 sift: Optional['outputs.AlertEnrichmentSpecStepSift'] = None):
        """
        :param 'AlertEnrichmentSpecStepAssertsArgs' asserts: Integrate with Grafana Asserts for enrichment.
        :param 'AlertEnrichmentSpecStepAssignArgs' assign: Assign annotations to an alert.
        :param 'AlertEnrichmentSpecStepAssistantInvestigationsArgs' assistant_investigations: Use AI assistant to investigate alerts and add insights.
        :param 'AlertEnrichmentSpecStepConditionalArgs' conditional: Conditional step with if/then/else.
        :param 'AlertEnrichmentSpecStepDataSourceArgs' data_source: Query Grafana data sources and add results to alerts.
        :param 'AlertEnrichmentSpecStepExplainArgs' explain: Generate AI explanation and store in an annotation.
        :param 'AlertEnrichmentSpecStepExternalArgs' external: Call an external HTTP service for enrichment.
        :param 'AlertEnrichmentSpecStepSiftArgs' sift: Analyze alerts for patterns and insights.
        """
        if asserts is not None:
            pulumi.set(__self__, "asserts", asserts)
        if assign is not None:
            pulumi.set(__self__, "assign", assign)
        if assistant_investigations is not None:
            pulumi.set(__self__, "assistant_investigations", assistant_investigations)
        if conditional is not None:
            pulumi.set(__self__, "conditional", conditional)
        if data_source is not None:
            pulumi.set(__self__, "data_source", data_source)
        if explain is not None:
            pulumi.set(__self__, "explain", explain)
        if external is not None:
            pulumi.set(__self__, "external", external)
        if sift is not None:
            pulumi.set(__self__, "sift", sift)

    @_builtins.property
    @pulumi.getter
    def asserts(self) -> Optional['outputs.AlertEnrichmentSpecStepAsserts']:
        """
        Integrate with Grafana Asserts for enrichment.
        """
        return pulumi.get(self, "asserts")

    @_builtins.property
    @pulumi.getter
    def assign(self) -> Optional['outputs.AlertEnrichmentSpecStepAssign']:
        """
        Assign annotations to an alert.
        """
        return pulumi.get(self, "assign")

    @_builtins.property
    @pulumi.getter(name="assistantInvestigations")
    def assistant_investigations(self) -> Optional['outputs.AlertEnrichmentSpecStepAssistantInvestigations']:
        """
        Use AI assistant to investigate alerts and add insights.
        """
        return pulumi.get(self, "assistant_investigations")

    @_builtins.property
    @pulumi.getter
    def conditional(self) -> Optional['outputs.AlertEnrichmentSpecStepConditional']:
        """
        Conditional step with if/then/else.
        """
        return pulumi.get(self, "conditional")

    @_builtins.property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> Optional['outputs.AlertEnrichmentSpecStepDataSource']:
        """
        Query Grafana data sources and add results to alerts.
        """
        return pulumi.get(self, "data_source")

    @_builtins.property
    @pulumi.getter
    def explain(self) -> Optional['outputs.AlertEnrichmentSpecStepExplain']:
        """
        Generate AI explanation and store in an annotation.
        """
        return pulumi.get(self, "explain")

    @_builtins.property
    @pulumi.getter
    def external(self) -> Optional['outputs.AlertEnrichmentSpecStepExternal']:
        """
        Call an external HTTP service for enrichment.
        """
        return pulumi.get(self, "external")

    @_builtins.property
    @pulumi.getter
    def sift(self) -> Optional['outputs.AlertEnrichmentSpecStepSift']:
        """
        Analyze alerts for patterns and insights.
        """
        return pulumi.get(self, "sift")


@pulumi.output_type
class AlertEnrichmentSpecStepAsserts(dict):
    def __init__(__self__, *,
                 timeout: Optional[_builtins.str] = None):
        """
        :param _builtins.str timeout: Maximum execution time (e.g., '30s', '1m')
        """
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.str]:
        """
        Maximum execution time (e.g., '30s', '1m')
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class AlertEnrichmentSpecStepAssign(dict):
    def __init__(__self__, *,
                 annotations: Optional[Mapping[str, _builtins.str]] = None,
                 timeout: Optional[_builtins.str] = None):
        """
        :param Mapping[str, _builtins.str] annotations: Map of annotation names to values to set on matching alerts.
        :param _builtins.str timeout: Maximum execution time (e.g., '30s', '1m')
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Map of annotation names to values to set on matching alerts.
        """
        return pulumi.get(self, "annotations")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.str]:
        """
        Maximum execution time (e.g., '30s', '1m')
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class AlertEnrichmentSpecStepAssistantInvestigations(dict):
    def __init__(__self__, *,
                 timeout: Optional[_builtins.str] = None):
        """
        :param _builtins.str timeout: Maximum execution time (e.g., '30s', '1m')
        """
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.str]:
        """
        Maximum execution time (e.g., '30s', '1m')
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class AlertEnrichmentSpecStepConditional(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "else":
            suggest = "else_"
        elif key == "if":
            suggest = "if_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertEnrichmentSpecStepConditional. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertEnrichmentSpecStepConditional.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertEnrichmentSpecStepConditional.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 else_: Optional['outputs.AlertEnrichmentSpecStepConditionalElse'] = None,
                 if_: Optional['outputs.AlertEnrichmentSpecStepConditionalIf'] = None,
                 then: Optional['outputs.AlertEnrichmentSpecStepConditionalThen'] = None,
                 timeout: Optional[_builtins.str] = None):
        """
        :param 'AlertEnrichmentSpecStepConditionalElseArgs' else_: Steps when condition is false.
        :param 'AlertEnrichmentSpecStepConditionalIfArgs' if_: Condition to evaluate.
        :param 'AlertEnrichmentSpecStepConditionalThenArgs' then: Steps when condition is true.
        :param _builtins.str timeout: Maximum execution time (e.g., '30s', '1m')
        """
        if else_ is not None:
            pulumi.set(__self__, "else_", else_)
        if if_ is not None:
            pulumi.set(__self__, "if_", if_)
        if then is not None:
            pulumi.set(__self__, "then", then)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter(name="else")
    def else_(self) -> Optional['outputs.AlertEnrichmentSpecStepConditionalElse']:
        """
        Steps when condition is false.
        """
        return pulumi.get(self, "else_")

    @_builtins.property
    @pulumi.getter(name="if")
    def if_(self) -> Optional['outputs.AlertEnrichmentSpecStepConditionalIf']:
        """
        Condition to evaluate.
        """
        return pulumi.get(self, "if_")

    @_builtins.property
    @pulumi.getter
    def then(self) -> Optional['outputs.AlertEnrichmentSpecStepConditionalThen']:
        """
        Steps when condition is true.
        """
        return pulumi.get(self, "then")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.str]:
        """
        Maximum execution time (e.g., '30s', '1m')
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class AlertEnrichmentSpecStepConditionalElse(dict):
    def __init__(__self__, *,
                 steps: Optional[Sequence['outputs.AlertEnrichmentSpecStepConditionalElseStep']] = None):
        if steps is not None:
            pulumi.set(__self__, "steps", steps)

    @_builtins.property
    @pulumi.getter
    def steps(self) -> Optional[Sequence['outputs.AlertEnrichmentSpecStepConditionalElseStep']]:
        return pulumi.get(self, "steps")


@pulumi.output_type
class AlertEnrichmentSpecStepConditionalElseStep(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "assistantInvestigations":
            suggest = "assistant_investigations"
        elif key == "dataSource":
            suggest = "data_source"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertEnrichmentSpecStepConditionalElseStep. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertEnrichmentSpecStepConditionalElseStep.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertEnrichmentSpecStepConditionalElseStep.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 asserts: Optional['outputs.AlertEnrichmentSpecStepConditionalElseStepAsserts'] = None,
                 assign: Optional['outputs.AlertEnrichmentSpecStepConditionalElseStepAssign'] = None,
                 assistant_investigations: Optional['outputs.AlertEnrichmentSpecStepConditionalElseStepAssistantInvestigations'] = None,
                 data_source: Optional['outputs.AlertEnrichmentSpecStepConditionalElseStepDataSource'] = None,
                 explain: Optional['outputs.AlertEnrichmentSpecStepConditionalElseStepExplain'] = None,
                 external: Optional['outputs.AlertEnrichmentSpecStepConditionalElseStepExternal'] = None,
                 sift: Optional['outputs.AlertEnrichmentSpecStepConditionalElseStepSift'] = None):
        """
        :param 'AlertEnrichmentSpecStepConditionalElseStepAssertsArgs' asserts: Integrate with Grafana Asserts for enrichment.
        :param 'AlertEnrichmentSpecStepConditionalElseStepAssignArgs' assign: Assign annotations to an alert.
        :param 'AlertEnrichmentSpecStepConditionalElseStepAssistantInvestigationsArgs' assistant_investigations: Use AI assistant to investigate alerts and add insights.
        :param 'AlertEnrichmentSpecStepConditionalElseStepDataSourceArgs' data_source: Query Grafana data sources and add results to alerts.
        :param 'AlertEnrichmentSpecStepConditionalElseStepExplainArgs' explain: Generate AI explanation and store in an annotation.
        :param 'AlertEnrichmentSpecStepConditionalElseStepExternalArgs' external: Call an external HTTP service for enrichment.
        :param 'AlertEnrichmentSpecStepConditionalElseStepSiftArgs' sift: Analyze alerts for patterns and insights.
        """
        if asserts is not None:
            pulumi.set(__self__, "asserts", asserts)
        if assign is not None:
            pulumi.set(__self__, "assign", assign)
        if assistant_investigations is not None:
            pulumi.set(__self__, "assistant_investigations", assistant_investigations)
        if data_source is not None:
            pulumi.set(__self__, "data_source", data_source)
        if explain is not None:
            pulumi.set(__self__, "explain", explain)
        if external is not None:
            pulumi.set(__self__, "external", external)
        if sift is not None:
            pulumi.set(__self__, "sift", sift)

    @_builtins.property
    @pulumi.getter
    def asserts(self) -> Optional['outputs.AlertEnrichmentSpecStepConditionalElseStepAsserts']:
        """
        Integrate with Grafana Asserts for enrichment.
        """
        return pulumi.get(self, "asserts")

    @_builtins.property
    @pulumi.getter
    def assign(self) -> Optional['outputs.AlertEnrichmentSpecStepConditionalElseStepAssign']:
        """
        Assign annotations to an alert.
        """
        return pulumi.get(self, "assign")

    @_builtins.property
    @pulumi.getter(name="assistantInvestigations")
    def assistant_investigations(self) -> Optional['outputs.AlertEnrichmentSpecStepConditionalElseStepAssistantInvestigations']:
        """
        Use AI assistant to investigate alerts and add insights.
        """
        return pulumi.get(self, "assistant_investigations")

    @_builtins.property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> Optional['outputs.AlertEnrichmentSpecStepConditionalElseStepDataSource']:
        """
        Query Grafana data sources and add results to alerts.
        """
        return pulumi.get(self, "data_source")

    @_builtins.property
    @pulumi.getter
    def explain(self) -> Optional['outputs.AlertEnrichmentSpecStepConditionalElseStepExplain']:
        """
        Generate AI explanation and store in an annotation.
        """
        return pulumi.get(self, "explain")

    @_builtins.property
    @pulumi.getter
    def external(self) -> Optional['outputs.AlertEnrichmentSpecStepConditionalElseStepExternal']:
        """
        Call an external HTTP service for enrichment.
        """
        return pulumi.get(self, "external")

    @_builtins.property
    @pulumi.getter
    def sift(self) -> Optional['outputs.AlertEnrichmentSpecStepConditionalElseStepSift']:
        """
        Analyze alerts for patterns and insights.
        """
        return pulumi.get(self, "sift")


@pulumi.output_type
class AlertEnrichmentSpecStepConditionalElseStepAsserts(dict):
    def __init__(__self__, *,
                 timeout: Optional[_builtins.str] = None):
        """
        :param _builtins.str timeout: Maximum execution time (e.g., '30s', '1m')
        """
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.str]:
        """
        Maximum execution time (e.g., '30s', '1m')
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class AlertEnrichmentSpecStepConditionalElseStepAssign(dict):
    def __init__(__self__, *,
                 annotations: Optional[Mapping[str, _builtins.str]] = None,
                 timeout: Optional[_builtins.str] = None):
        """
        :param Mapping[str, _builtins.str] annotations: Map of annotation names to values to set on matching alerts.
        :param _builtins.str timeout: Maximum execution time (e.g., '30s', '1m')
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Map of annotation names to values to set on matching alerts.
        """
        return pulumi.get(self, "annotations")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.str]:
        """
        Maximum execution time (e.g., '30s', '1m')
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class AlertEnrichmentSpecStepConditionalElseStepAssistantInvestigations(dict):
    def __init__(__self__, *,
                 timeout: Optional[_builtins.str] = None):
        """
        :param _builtins.str timeout: Maximum execution time (e.g., '30s', '1m')
        """
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.str]:
        """
        Maximum execution time (e.g., '30s', '1m')
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class AlertEnrichmentSpecStepConditionalElseStepDataSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logsQuery":
            suggest = "logs_query"
        elif key == "rawQuery":
            suggest = "raw_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertEnrichmentSpecStepConditionalElseStepDataSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertEnrichmentSpecStepConditionalElseStepDataSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertEnrichmentSpecStepConditionalElseStepDataSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 logs_query: Optional['outputs.AlertEnrichmentSpecStepConditionalElseStepDataSourceLogsQuery'] = None,
                 raw_query: Optional['outputs.AlertEnrichmentSpecStepConditionalElseStepDataSourceRawQuery'] = None,
                 timeout: Optional[_builtins.str] = None):
        """
        :param 'AlertEnrichmentSpecStepConditionalElseStepDataSourceLogsQueryArgs' logs_query: Logs query configuration for querying log data sources.
        :param 'AlertEnrichmentSpecStepConditionalElseStepDataSourceRawQueryArgs' raw_query: Raw query configuration for advanced data source queries.
        :param _builtins.str timeout: Maximum execution time (e.g., '30s', '1m')
        """
        if logs_query is not None:
            pulumi.set(__self__, "logs_query", logs_query)
        if raw_query is not None:
            pulumi.set(__self__, "raw_query", raw_query)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter(name="logsQuery")
    def logs_query(self) -> Optional['outputs.AlertEnrichmentSpecStepConditionalElseStepDataSourceLogsQuery']:
        """
        Logs query configuration for querying log data sources.
        """
        return pulumi.get(self, "logs_query")

    @_builtins.property
    @pulumi.getter(name="rawQuery")
    def raw_query(self) -> Optional['outputs.AlertEnrichmentSpecStepConditionalElseStepDataSourceRawQuery']:
        """
        Raw query configuration for advanced data source queries.
        """
        return pulumi.get(self, "raw_query")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.str]:
        """
        Maximum execution time (e.g., '30s', '1m')
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class AlertEnrichmentSpecStepConditionalElseStepDataSourceLogsQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSourceType":
            suggest = "data_source_type"
        elif key == "dataSourceUid":
            suggest = "data_source_uid"
        elif key == "maxLines":
            suggest = "max_lines"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertEnrichmentSpecStepConditionalElseStepDataSourceLogsQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertEnrichmentSpecStepConditionalElseStepDataSourceLogsQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertEnrichmentSpecStepConditionalElseStepDataSourceLogsQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source_type: Optional[_builtins.str] = None,
                 data_source_uid: Optional[_builtins.str] = None,
                 expr: Optional[_builtins.str] = None,
                 max_lines: Optional[_builtins.int] = None):
        """
        :param _builtins.str data_source_type: Data source type (e.g., 'loki').
        :param _builtins.str data_source_uid: UID of the data source to query.
        :param _builtins.str expr: Log query expression to execute.
        :param _builtins.int max_lines: Maximum number of log lines to include. Defaults to 3.
        """
        if data_source_type is not None:
            pulumi.set(__self__, "data_source_type", data_source_type)
        if data_source_uid is not None:
            pulumi.set(__self__, "data_source_uid", data_source_uid)
        if expr is not None:
            pulumi.set(__self__, "expr", expr)
        if max_lines is not None:
            pulumi.set(__self__, "max_lines", max_lines)

    @_builtins.property
    @pulumi.getter(name="dataSourceType")
    def data_source_type(self) -> Optional[_builtins.str]:
        """
        Data source type (e.g., 'loki').
        """
        return pulumi.get(self, "data_source_type")

    @_builtins.property
    @pulumi.getter(name="dataSourceUid")
    def data_source_uid(self) -> Optional[_builtins.str]:
        """
        UID of the data source to query.
        """
        return pulumi.get(self, "data_source_uid")

    @_builtins.property
    @pulumi.getter
    def expr(self) -> Optional[_builtins.str]:
        """
        Log query expression to execute.
        """
        return pulumi.get(self, "expr")

    @_builtins.property
    @pulumi.getter(name="maxLines")
    def max_lines(self) -> Optional[_builtins.int]:
        """
        Maximum number of log lines to include. Defaults to 3.
        """
        return pulumi.get(self, "max_lines")


@pulumi.output_type
class AlertEnrichmentSpecStepConditionalElseStepDataSourceRawQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "refId":
            suggest = "ref_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertEnrichmentSpecStepConditionalElseStepDataSourceRawQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertEnrichmentSpecStepConditionalElseStepDataSourceRawQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertEnrichmentSpecStepConditionalElseStepDataSourceRawQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ref_id: Optional[_builtins.str] = None,
                 request: Optional[_builtins.str] = None):
        """
        :param _builtins.str ref_id: Reference ID for correlating queries.
        :param _builtins.str request: Raw request payload for the data source query.
        """
        if ref_id is not None:
            pulumi.set(__self__, "ref_id", ref_id)
        if request is not None:
            pulumi.set(__self__, "request", request)

    @_builtins.property
    @pulumi.getter(name="refId")
    def ref_id(self) -> Optional[_builtins.str]:
        """
        Reference ID for correlating queries.
        """
        return pulumi.get(self, "ref_id")

    @_builtins.property
    @pulumi.getter
    def request(self) -> Optional[_builtins.str]:
        """
        Raw request payload for the data source query.
        """
        return pulumi.get(self, "request")


@pulumi.output_type
class AlertEnrichmentSpecStepConditionalElseStepExplain(dict):
    def __init__(__self__, *,
                 annotation: Optional[_builtins.str] = None,
                 timeout: Optional[_builtins.str] = None):
        """
        :param _builtins.str annotation: Annotation name to set the explanation in. Defaults to 'ai_explanation'.
        :param _builtins.str timeout: Maximum execution time (e.g., '30s', '1m')
        """
        if annotation is not None:
            pulumi.set(__self__, "annotation", annotation)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def annotation(self) -> Optional[_builtins.str]:
        """
        Annotation name to set the explanation in. Defaults to 'ai_explanation'.
        """
        return pulumi.get(self, "annotation")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.str]:
        """
        Maximum execution time (e.g., '30s', '1m')
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class AlertEnrichmentSpecStepConditionalElseStepExternal(dict):
    def __init__(__self__, *,
                 timeout: Optional[_builtins.str] = None,
                 url: Optional[_builtins.str] = None):
        """
        :param _builtins.str timeout: Maximum execution time (e.g., '30s', '1m')
        :param _builtins.str url: HTTP endpoint URL to call for enrichment
        """
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.str]:
        """
        Maximum execution time (e.g., '30s', '1m')
        """
        return pulumi.get(self, "timeout")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        HTTP endpoint URL to call for enrichment
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class AlertEnrichmentSpecStepConditionalElseStepSift(dict):
    def __init__(__self__, *,
                 timeout: Optional[_builtins.str] = None):
        """
        :param _builtins.str timeout: Maximum execution time (e.g., '30s', '1m')
        """
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.str]:
        """
        Maximum execution time (e.g., '30s', '1m')
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class AlertEnrichmentSpecStepConditionalIf(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "annotationMatchers":
            suggest = "annotation_matchers"
        elif key == "dataSourceCondition":
            suggest = "data_source_condition"
        elif key == "labelMatchers":
            suggest = "label_matchers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertEnrichmentSpecStepConditionalIf. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertEnrichmentSpecStepConditionalIf.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertEnrichmentSpecStepConditionalIf.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 annotation_matchers: Optional[Sequence['outputs.AlertEnrichmentSpecStepConditionalIfAnnotationMatcher']] = None,
                 data_source_condition: Optional['outputs.AlertEnrichmentSpecStepConditionalIfDataSourceCondition'] = None,
                 label_matchers: Optional[Sequence['outputs.AlertEnrichmentSpecStepConditionalIfLabelMatcher']] = None):
        """
        :param Sequence['AlertEnrichmentSpecStepConditionalIfAnnotationMatcherArgs'] annotation_matchers: Annotation matchers for the condition.
        :param 'AlertEnrichmentSpecStepConditionalIfDataSourceConditionArgs' data_source_condition: Data source condition.
        :param Sequence['AlertEnrichmentSpecStepConditionalIfLabelMatcherArgs'] label_matchers: Label matchers for the condition.
        """
        if annotation_matchers is not None:
            pulumi.set(__self__, "annotation_matchers", annotation_matchers)
        if data_source_condition is not None:
            pulumi.set(__self__, "data_source_condition", data_source_condition)
        if label_matchers is not None:
            pulumi.set(__self__, "label_matchers", label_matchers)

    @_builtins.property
    @pulumi.getter(name="annotationMatchers")
    def annotation_matchers(self) -> Optional[Sequence['outputs.AlertEnrichmentSpecStepConditionalIfAnnotationMatcher']]:
        """
        Annotation matchers for the condition.
        """
        return pulumi.get(self, "annotation_matchers")

    @_builtins.property
    @pulumi.getter(name="dataSourceCondition")
    def data_source_condition(self) -> Optional['outputs.AlertEnrichmentSpecStepConditionalIfDataSourceCondition']:
        """
        Data source condition.
        """
        return pulumi.get(self, "data_source_condition")

    @_builtins.property
    @pulumi.getter(name="labelMatchers")
    def label_matchers(self) -> Optional[Sequence['outputs.AlertEnrichmentSpecStepConditionalIfLabelMatcher']]:
        """
        Label matchers for the condition.
        """
        return pulumi.get(self, "label_matchers")


@pulumi.output_type
class AlertEnrichmentSpecStepConditionalIfAnnotationMatcher(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 type: _builtins.str,
                 value: _builtins.str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")


@pulumi.output_type
class AlertEnrichmentSpecStepConditionalIfDataSourceCondition(dict):
    def __init__(__self__, *,
                 request: Optional[_builtins.str] = None):
        """
        :param _builtins.str request: Data source request payload.
        """
        if request is not None:
            pulumi.set(__self__, "request", request)

    @_builtins.property
    @pulumi.getter
    def request(self) -> Optional[_builtins.str]:
        """
        Data source request payload.
        """
        return pulumi.get(self, "request")


@pulumi.output_type
class AlertEnrichmentSpecStepConditionalIfLabelMatcher(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 type: _builtins.str,
                 value: _builtins.str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")


@pulumi.output_type
class AlertEnrichmentSpecStepConditionalThen(dict):
    def __init__(__self__, *,
                 steps: Optional[Sequence['outputs.AlertEnrichmentSpecStepConditionalThenStep']] = None):
        if steps is not None:
            pulumi.set(__self__, "steps", steps)

    @_builtins.property
    @pulumi.getter
    def steps(self) -> Optional[Sequence['outputs.AlertEnrichmentSpecStepConditionalThenStep']]:
        return pulumi.get(self, "steps")


@pulumi.output_type
class AlertEnrichmentSpecStepConditionalThenStep(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "assistantInvestigations":
            suggest = "assistant_investigations"
        elif key == "dataSource":
            suggest = "data_source"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertEnrichmentSpecStepConditionalThenStep. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertEnrichmentSpecStepConditionalThenStep.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertEnrichmentSpecStepConditionalThenStep.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 asserts: Optional['outputs.AlertEnrichmentSpecStepConditionalThenStepAsserts'] = None,
                 assign: Optional['outputs.AlertEnrichmentSpecStepConditionalThenStepAssign'] = None,
                 assistant_investigations: Optional['outputs.AlertEnrichmentSpecStepConditionalThenStepAssistantInvestigations'] = None,
                 data_source: Optional['outputs.AlertEnrichmentSpecStepConditionalThenStepDataSource'] = None,
                 explain: Optional['outputs.AlertEnrichmentSpecStepConditionalThenStepExplain'] = None,
                 external: Optional['outputs.AlertEnrichmentSpecStepConditionalThenStepExternal'] = None,
                 sift: Optional['outputs.AlertEnrichmentSpecStepConditionalThenStepSift'] = None):
        """
        :param 'AlertEnrichmentSpecStepConditionalThenStepAssertsArgs' asserts: Integrate with Grafana Asserts for enrichment.
        :param 'AlertEnrichmentSpecStepConditionalThenStepAssignArgs' assign: Assign annotations to an alert.
        :param 'AlertEnrichmentSpecStepConditionalThenStepAssistantInvestigationsArgs' assistant_investigations: Use AI assistant to investigate alerts and add insights.
        :param 'AlertEnrichmentSpecStepConditionalThenStepDataSourceArgs' data_source: Query Grafana data sources and add results to alerts.
        :param 'AlertEnrichmentSpecStepConditionalThenStepExplainArgs' explain: Generate AI explanation and store in an annotation.
        :param 'AlertEnrichmentSpecStepConditionalThenStepExternalArgs' external: Call an external HTTP service for enrichment.
        :param 'AlertEnrichmentSpecStepConditionalThenStepSiftArgs' sift: Analyze alerts for patterns and insights.
        """
        if asserts is not None:
            pulumi.set(__self__, "asserts", asserts)
        if assign is not None:
            pulumi.set(__self__, "assign", assign)
        if assistant_investigations is not None:
            pulumi.set(__self__, "assistant_investigations", assistant_investigations)
        if data_source is not None:
            pulumi.set(__self__, "data_source", data_source)
        if explain is not None:
            pulumi.set(__self__, "explain", explain)
        if external is not None:
            pulumi.set(__self__, "external", external)
        if sift is not None:
            pulumi.set(__self__, "sift", sift)

    @_builtins.property
    @pulumi.getter
    def asserts(self) -> Optional['outputs.AlertEnrichmentSpecStepConditionalThenStepAsserts']:
        """
        Integrate with Grafana Asserts for enrichment.
        """
        return pulumi.get(self, "asserts")

    @_builtins.property
    @pulumi.getter
    def assign(self) -> Optional['outputs.AlertEnrichmentSpecStepConditionalThenStepAssign']:
        """
        Assign annotations to an alert.
        """
        return pulumi.get(self, "assign")

    @_builtins.property
    @pulumi.getter(name="assistantInvestigations")
    def assistant_investigations(self) -> Optional['outputs.AlertEnrichmentSpecStepConditionalThenStepAssistantInvestigations']:
        """
        Use AI assistant to investigate alerts and add insights.
        """
        return pulumi.get(self, "assistant_investigations")

    @_builtins.property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> Optional['outputs.AlertEnrichmentSpecStepConditionalThenStepDataSource']:
        """
        Query Grafana data sources and add results to alerts.
        """
        return pulumi.get(self, "data_source")

    @_builtins.property
    @pulumi.getter
    def explain(self) -> Optional['outputs.AlertEnrichmentSpecStepConditionalThenStepExplain']:
        """
        Generate AI explanation and store in an annotation.
        """
        return pulumi.get(self, "explain")

    @_builtins.property
    @pulumi.getter
    def external(self) -> Optional['outputs.AlertEnrichmentSpecStepConditionalThenStepExternal']:
        """
        Call an external HTTP service for enrichment.
        """
        return pulumi.get(self, "external")

    @_builtins.property
    @pulumi.getter
    def sift(self) -> Optional['outputs.AlertEnrichmentSpecStepConditionalThenStepSift']:
        """
        Analyze alerts for patterns and insights.
        """
        return pulumi.get(self, "sift")


@pulumi.output_type
class AlertEnrichmentSpecStepConditionalThenStepAsserts(dict):
    def __init__(__self__, *,
                 timeout: Optional[_builtins.str] = None):
        """
        :param _builtins.str timeout: Maximum execution time (e.g., '30s', '1m')
        """
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.str]:
        """
        Maximum execution time (e.g., '30s', '1m')
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class AlertEnrichmentSpecStepConditionalThenStepAssign(dict):
    def __init__(__self__, *,
                 annotations: Optional[Mapping[str, _builtins.str]] = None,
                 timeout: Optional[_builtins.str] = None):
        """
        :param Mapping[str, _builtins.str] annotations: Map of annotation names to values to set on matching alerts.
        :param _builtins.str timeout: Maximum execution time (e.g., '30s', '1m')
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Map of annotation names to values to set on matching alerts.
        """
        return pulumi.get(self, "annotations")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.str]:
        """
        Maximum execution time (e.g., '30s', '1m')
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class AlertEnrichmentSpecStepConditionalThenStepAssistantInvestigations(dict):
    def __init__(__self__, *,
                 timeout: Optional[_builtins.str] = None):
        """
        :param _builtins.str timeout: Maximum execution time (e.g., '30s', '1m')
        """
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.str]:
        """
        Maximum execution time (e.g., '30s', '1m')
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class AlertEnrichmentSpecStepConditionalThenStepDataSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logsQuery":
            suggest = "logs_query"
        elif key == "rawQuery":
            suggest = "raw_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertEnrichmentSpecStepConditionalThenStepDataSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertEnrichmentSpecStepConditionalThenStepDataSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertEnrichmentSpecStepConditionalThenStepDataSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 logs_query: Optional['outputs.AlertEnrichmentSpecStepConditionalThenStepDataSourceLogsQuery'] = None,
                 raw_query: Optional['outputs.AlertEnrichmentSpecStepConditionalThenStepDataSourceRawQuery'] = None,
                 timeout: Optional[_builtins.str] = None):
        """
        :param 'AlertEnrichmentSpecStepConditionalThenStepDataSourceLogsQueryArgs' logs_query: Logs query configuration for querying log data sources.
        :param 'AlertEnrichmentSpecStepConditionalThenStepDataSourceRawQueryArgs' raw_query: Raw query configuration for advanced data source queries.
        :param _builtins.str timeout: Maximum execution time (e.g., '30s', '1m')
        """
        if logs_query is not None:
            pulumi.set(__self__, "logs_query", logs_query)
        if raw_query is not None:
            pulumi.set(__self__, "raw_query", raw_query)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter(name="logsQuery")
    def logs_query(self) -> Optional['outputs.AlertEnrichmentSpecStepConditionalThenStepDataSourceLogsQuery']:
        """
        Logs query configuration for querying log data sources.
        """
        return pulumi.get(self, "logs_query")

    @_builtins.property
    @pulumi.getter(name="rawQuery")
    def raw_query(self) -> Optional['outputs.AlertEnrichmentSpecStepConditionalThenStepDataSourceRawQuery']:
        """
        Raw query configuration for advanced data source queries.
        """
        return pulumi.get(self, "raw_query")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.str]:
        """
        Maximum execution time (e.g., '30s', '1m')
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class AlertEnrichmentSpecStepConditionalThenStepDataSourceLogsQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSourceType":
            suggest = "data_source_type"
        elif key == "dataSourceUid":
            suggest = "data_source_uid"
        elif key == "maxLines":
            suggest = "max_lines"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertEnrichmentSpecStepConditionalThenStepDataSourceLogsQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertEnrichmentSpecStepConditionalThenStepDataSourceLogsQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertEnrichmentSpecStepConditionalThenStepDataSourceLogsQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source_type: Optional[_builtins.str] = None,
                 data_source_uid: Optional[_builtins.str] = None,
                 expr: Optional[_builtins.str] = None,
                 max_lines: Optional[_builtins.int] = None):
        """
        :param _builtins.str data_source_type: Data source type (e.g., 'loki').
        :param _builtins.str data_source_uid: UID of the data source to query.
        :param _builtins.str expr: Log query expression to execute.
        :param _builtins.int max_lines: Maximum number of log lines to include. Defaults to 3.
        """
        if data_source_type is not None:
            pulumi.set(__self__, "data_source_type", data_source_type)
        if data_source_uid is not None:
            pulumi.set(__self__, "data_source_uid", data_source_uid)
        if expr is not None:
            pulumi.set(__self__, "expr", expr)
        if max_lines is not None:
            pulumi.set(__self__, "max_lines", max_lines)

    @_builtins.property
    @pulumi.getter(name="dataSourceType")
    def data_source_type(self) -> Optional[_builtins.str]:
        """
        Data source type (e.g., 'loki').
        """
        return pulumi.get(self, "data_source_type")

    @_builtins.property
    @pulumi.getter(name="dataSourceUid")
    def data_source_uid(self) -> Optional[_builtins.str]:
        """
        UID of the data source to query.
        """
        return pulumi.get(self, "data_source_uid")

    @_builtins.property
    @pulumi.getter
    def expr(self) -> Optional[_builtins.str]:
        """
        Log query expression to execute.
        """
        return pulumi.get(self, "expr")

    @_builtins.property
    @pulumi.getter(name="maxLines")
    def max_lines(self) -> Optional[_builtins.int]:
        """
        Maximum number of log lines to include. Defaults to 3.
        """
        return pulumi.get(self, "max_lines")


@pulumi.output_type
class AlertEnrichmentSpecStepConditionalThenStepDataSourceRawQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "refId":
            suggest = "ref_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertEnrichmentSpecStepConditionalThenStepDataSourceRawQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertEnrichmentSpecStepConditionalThenStepDataSourceRawQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertEnrichmentSpecStepConditionalThenStepDataSourceRawQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ref_id: Optional[_builtins.str] = None,
                 request: Optional[_builtins.str] = None):
        """
        :param _builtins.str ref_id: Reference ID for correlating queries.
        :param _builtins.str request: Raw request payload for the data source query.
        """
        if ref_id is not None:
            pulumi.set(__self__, "ref_id", ref_id)
        if request is not None:
            pulumi.set(__self__, "request", request)

    @_builtins.property
    @pulumi.getter(name="refId")
    def ref_id(self) -> Optional[_builtins.str]:
        """
        Reference ID for correlating queries.
        """
        return pulumi.get(self, "ref_id")

    @_builtins.property
    @pulumi.getter
    def request(self) -> Optional[_builtins.str]:
        """
        Raw request payload for the data source query.
        """
        return pulumi.get(self, "request")


@pulumi.output_type
class AlertEnrichmentSpecStepConditionalThenStepExplain(dict):
    def __init__(__self__, *,
                 annotation: Optional[_builtins.str] = None,
                 timeout: Optional[_builtins.str] = None):
        """
        :param _builtins.str annotation: Annotation name to set the explanation in. Defaults to 'ai_explanation'.
        :param _builtins.str timeout: Maximum execution time (e.g., '30s', '1m')
        """
        if annotation is not None:
            pulumi.set(__self__, "annotation", annotation)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def annotation(self) -> Optional[_builtins.str]:
        """
        Annotation name to set the explanation in. Defaults to 'ai_explanation'.
        """
        return pulumi.get(self, "annotation")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.str]:
        """
        Maximum execution time (e.g., '30s', '1m')
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class AlertEnrichmentSpecStepConditionalThenStepExternal(dict):
    def __init__(__self__, *,
                 timeout: Optional[_builtins.str] = None,
                 url: Optional[_builtins.str] = None):
        """
        :param _builtins.str timeout: Maximum execution time (e.g., '30s', '1m')
        :param _builtins.str url: HTTP endpoint URL to call for enrichment
        """
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.str]:
        """
        Maximum execution time (e.g., '30s', '1m')
        """
        return pulumi.get(self, "timeout")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        HTTP endpoint URL to call for enrichment
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class AlertEnrichmentSpecStepConditionalThenStepSift(dict):
    def __init__(__self__, *,
                 timeout: Optional[_builtins.str] = None):
        """
        :param _builtins.str timeout: Maximum execution time (e.g., '30s', '1m')
        """
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.str]:
        """
        Maximum execution time (e.g., '30s', '1m')
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class AlertEnrichmentSpecStepDataSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logsQuery":
            suggest = "logs_query"
        elif key == "rawQuery":
            suggest = "raw_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertEnrichmentSpecStepDataSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertEnrichmentSpecStepDataSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertEnrichmentSpecStepDataSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 logs_query: Optional['outputs.AlertEnrichmentSpecStepDataSourceLogsQuery'] = None,
                 raw_query: Optional['outputs.AlertEnrichmentSpecStepDataSourceRawQuery'] = None,
                 timeout: Optional[_builtins.str] = None):
        """
        :param 'AlertEnrichmentSpecStepDataSourceLogsQueryArgs' logs_query: Logs query configuration for querying log data sources.
        :param 'AlertEnrichmentSpecStepDataSourceRawQueryArgs' raw_query: Raw query configuration for advanced data source queries.
        :param _builtins.str timeout: Maximum execution time (e.g., '30s', '1m')
        """
        if logs_query is not None:
            pulumi.set(__self__, "logs_query", logs_query)
        if raw_query is not None:
            pulumi.set(__self__, "raw_query", raw_query)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter(name="logsQuery")
    def logs_query(self) -> Optional['outputs.AlertEnrichmentSpecStepDataSourceLogsQuery']:
        """
        Logs query configuration for querying log data sources.
        """
        return pulumi.get(self, "logs_query")

    @_builtins.property
    @pulumi.getter(name="rawQuery")
    def raw_query(self) -> Optional['outputs.AlertEnrichmentSpecStepDataSourceRawQuery']:
        """
        Raw query configuration for advanced data source queries.
        """
        return pulumi.get(self, "raw_query")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.str]:
        """
        Maximum execution time (e.g., '30s', '1m')
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class AlertEnrichmentSpecStepDataSourceLogsQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSourceType":
            suggest = "data_source_type"
        elif key == "dataSourceUid":
            suggest = "data_source_uid"
        elif key == "maxLines":
            suggest = "max_lines"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertEnrichmentSpecStepDataSourceLogsQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertEnrichmentSpecStepDataSourceLogsQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertEnrichmentSpecStepDataSourceLogsQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source_type: Optional[_builtins.str] = None,
                 data_source_uid: Optional[_builtins.str] = None,
                 expr: Optional[_builtins.str] = None,
                 max_lines: Optional[_builtins.int] = None):
        """
        :param _builtins.str data_source_type: Data source type (e.g., 'loki').
        :param _builtins.str data_source_uid: UID of the data source to query.
        :param _builtins.str expr: Log query expression to execute.
        :param _builtins.int max_lines: Maximum number of log lines to include. Defaults to 3.
        """
        if data_source_type is not None:
            pulumi.set(__self__, "data_source_type", data_source_type)
        if data_source_uid is not None:
            pulumi.set(__self__, "data_source_uid", data_source_uid)
        if expr is not None:
            pulumi.set(__self__, "expr", expr)
        if max_lines is not None:
            pulumi.set(__self__, "max_lines", max_lines)

    @_builtins.property
    @pulumi.getter(name="dataSourceType")
    def data_source_type(self) -> Optional[_builtins.str]:
        """
        Data source type (e.g., 'loki').
        """
        return pulumi.get(self, "data_source_type")

    @_builtins.property
    @pulumi.getter(name="dataSourceUid")
    def data_source_uid(self) -> Optional[_builtins.str]:
        """
        UID of the data source to query.
        """
        return pulumi.get(self, "data_source_uid")

    @_builtins.property
    @pulumi.getter
    def expr(self) -> Optional[_builtins.str]:
        """
        Log query expression to execute.
        """
        return pulumi.get(self, "expr")

    @_builtins.property
    @pulumi.getter(name="maxLines")
    def max_lines(self) -> Optional[_builtins.int]:
        """
        Maximum number of log lines to include. Defaults to 3.
        """
        return pulumi.get(self, "max_lines")


@pulumi.output_type
class AlertEnrichmentSpecStepDataSourceRawQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "refId":
            suggest = "ref_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertEnrichmentSpecStepDataSourceRawQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertEnrichmentSpecStepDataSourceRawQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertEnrichmentSpecStepDataSourceRawQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ref_id: Optional[_builtins.str] = None,
                 request: Optional[_builtins.str] = None):
        """
        :param _builtins.str ref_id: Reference ID for correlating queries.
        :param _builtins.str request: Raw request payload for the data source query.
        """
        if ref_id is not None:
            pulumi.set(__self__, "ref_id", ref_id)
        if request is not None:
            pulumi.set(__self__, "request", request)

    @_builtins.property
    @pulumi.getter(name="refId")
    def ref_id(self) -> Optional[_builtins.str]:
        """
        Reference ID for correlating queries.
        """
        return pulumi.get(self, "ref_id")

    @_builtins.property
    @pulumi.getter
    def request(self) -> Optional[_builtins.str]:
        """
        Raw request payload for the data source query.
        """
        return pulumi.get(self, "request")


@pulumi.output_type
class AlertEnrichmentSpecStepExplain(dict):
    def __init__(__self__, *,
                 annotation: Optional[_builtins.str] = None,
                 timeout: Optional[_builtins.str] = None):
        """
        :param _builtins.str annotation: Annotation name to set the explanation in. Defaults to 'ai_explanation'.
        :param _builtins.str timeout: Maximum execution time (e.g., '30s', '1m')
        """
        if annotation is not None:
            pulumi.set(__self__, "annotation", annotation)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def annotation(self) -> Optional[_builtins.str]:
        """
        Annotation name to set the explanation in. Defaults to 'ai_explanation'.
        """
        return pulumi.get(self, "annotation")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.str]:
        """
        Maximum execution time (e.g., '30s', '1m')
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class AlertEnrichmentSpecStepExternal(dict):
    def __init__(__self__, *,
                 timeout: Optional[_builtins.str] = None,
                 url: Optional[_builtins.str] = None):
        """
        :param _builtins.str timeout: Maximum execution time (e.g., '30s', '1m')
        :param _builtins.str url: HTTP endpoint URL to call for enrichment
        """
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.str]:
        """
        Maximum execution time (e.g., '30s', '1m')
        """
        return pulumi.get(self, "timeout")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        HTTP endpoint URL to call for enrichment
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class AlertEnrichmentSpecStepSift(dict):
    def __init__(__self__, *,
                 timeout: Optional[_builtins.str] = None):
        """
        :param _builtins.str timeout: Maximum execution time (e.g., '30s', '1m')
        """
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.str]:
        """
        Maximum execution time (e.g., '30s', '1m')
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class AlertRuleV0Alpha1Metadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "folderUid":
            suggest = "folder_uid"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertRuleV0Alpha1Metadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertRuleV0Alpha1Metadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertRuleV0Alpha1Metadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 uid: _builtins.str,
                 annotations: Optional[Mapping[str, _builtins.str]] = None,
                 folder_uid: Optional[_builtins.str] = None,
                 url: Optional[_builtins.str] = None,
                 uuid: Optional[_builtins.str] = None,
                 version: Optional[_builtins.str] = None):
        """
        :param _builtins.str uid: The unique identifier of the resource.
        :param Mapping[str, _builtins.str] annotations: Annotations of the resource.
        :param _builtins.str folder_uid: The UID of the folder to save the resource in.
        :param _builtins.str url: The full URL of the resource.
        :param _builtins.str uuid: The globally unique identifier of a resource, used by the API for tracking.
        :param _builtins.str version: The version of the resource.
        """
        pulumi.set(__self__, "uid", uid)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if folder_uid is not None:
            pulumi.set(__self__, "folder_uid", folder_uid)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def uid(self) -> _builtins.str:
        """
        The unique identifier of the resource.
        """
        return pulumi.get(self, "uid")

    @_builtins.property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Annotations of the resource.
        """
        return pulumi.get(self, "annotations")

    @_builtins.property
    @pulumi.getter(name="folderUid")
    def folder_uid(self) -> Optional[_builtins.str]:
        """
        The UID of the folder to save the resource in.
        """
        return pulumi.get(self, "folder_uid")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        The full URL of the resource.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        The globally unique identifier of a resource, used by the API for tracking.
        """
        return pulumi.get(self, "uuid")

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[_builtins.str]:
        """
        The version of the resource.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class AlertRuleV0Alpha1Options(dict):
    def __init__(__self__, *,
                 overwrite: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool overwrite: Set to true if you want to overwrite existing resource with newer version, same resource title in folder or same resource uid.
        """
        if overwrite is not None:
            pulumi.set(__self__, "overwrite", overwrite)

    @_builtins.property
    @pulumi.getter
    def overwrite(self) -> Optional[_builtins.bool]:
        """
        Set to true if you want to overwrite existing resource with newer version, same resource title in folder or same resource uid.
        """
        return pulumi.get(self, "overwrite")


@pulumi.output_type
class AlertRuleV0Alpha1Spec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "execErrState":
            suggest = "exec_err_state"
        elif key == "noDataState":
            suggest = "no_data_state"
        elif key == "for":
            suggest = "for_"
        elif key == "keepFiringFor":
            suggest = "keep_firing_for"
        elif key == "missingSeriesEvalsToResolve":
            suggest = "missing_series_evals_to_resolve"
        elif key == "notificationSettings":
            suggest = "notification_settings"
        elif key == "panelRef":
            suggest = "panel_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertRuleV0Alpha1Spec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertRuleV0Alpha1Spec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertRuleV0Alpha1Spec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exec_err_state: _builtins.str,
                 expressions: Mapping[str, _builtins.str],
                 no_data_state: _builtins.str,
                 title: _builtins.str,
                 annotations: Optional[Mapping[str, _builtins.str]] = None,
                 for_: Optional[_builtins.str] = None,
                 keep_firing_for: Optional[_builtins.str] = None,
                 labels: Optional[Mapping[str, _builtins.str]] = None,
                 missing_series_evals_to_resolve: Optional[_builtins.int] = None,
                 notification_settings: Optional['outputs.AlertRuleV0Alpha1SpecNotificationSettings'] = None,
                 panel_ref: Optional[Any] = None,
                 paused: Optional[_builtins.bool] = None,
                 trigger: Optional['outputs.AlertRuleV0Alpha1SpecTrigger'] = None):
        """
        :param _builtins.str exec_err_state: Describes what state to enter when the rule's query is invalid and the rule cannot be executed. Options are OK, Error, KeepLast, and Alerting.
        :param Mapping[str, _builtins.str] expressions: A sequence of stages that describe the contents of the rule. Each value is a JSON string representing an expression object.
        :param _builtins.str no_data_state: Describes what state to enter when the rule's query returns No Data. Options are OK, NoData, KeepLast, and Alerting.
        :param _builtins.str title: The title of the alert rule.
        :param Mapping[str, _builtins.str] annotations: Key-value pairs of metadata to attach to the alert rule. They add additional information, such as a `summary` or `runbook_url`, to help identify and investigate alerts.
        :param _builtins.str for_: The amount of time for which the rule must be breached for the rule to be considered to be Firing. Before this time has elapsed, the rule is only considered to be Pending.
        :param _builtins.str keep_firing_for: The amount of time for which the rule will considered to be Recovering after initially Firing. Before this time has elapsed, the rule will continue to fire once it's been triggered.
        :param Mapping[str, _builtins.str] labels: Key-value pairs to attach to the alert rule that can be used in matching, grouping, and routing.
        :param _builtins.int missing_series_evals_to_resolve: The number of missing series evaluations that must occur before the rule is considered to be resolved.
        :param 'AlertRuleV0Alpha1SpecNotificationSettingsArgs' notification_settings: Notification settings for the rule. If specified, it overrides the notification policies.
        :param Any panel_ref: Reference to a panel that this alert rule is associated with. Should be an object with 'dashboard*uid' (string) and 'panel*id' (number) fields.
        :param _builtins.bool paused: Sets whether the rule should be paused or not.
        :param 'AlertRuleV0Alpha1SpecTriggerArgs' trigger: The trigger configuration for the alert rule.
        """
        pulumi.set(__self__, "exec_err_state", exec_err_state)
        pulumi.set(__self__, "expressions", expressions)
        pulumi.set(__self__, "no_data_state", no_data_state)
        pulumi.set(__self__, "title", title)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if for_ is not None:
            pulumi.set(__self__, "for_", for_)
        if keep_firing_for is not None:
            pulumi.set(__self__, "keep_firing_for", keep_firing_for)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if missing_series_evals_to_resolve is not None:
            pulumi.set(__self__, "missing_series_evals_to_resolve", missing_series_evals_to_resolve)
        if notification_settings is not None:
            pulumi.set(__self__, "notification_settings", notification_settings)
        if panel_ref is not None:
            pulumi.set(__self__, "panel_ref", panel_ref)
        if paused is not None:
            pulumi.set(__self__, "paused", paused)
        if trigger is not None:
            pulumi.set(__self__, "trigger", trigger)

    @_builtins.property
    @pulumi.getter(name="execErrState")
    def exec_err_state(self) -> _builtins.str:
        """
        Describes what state to enter when the rule's query is invalid and the rule cannot be executed. Options are OK, Error, KeepLast, and Alerting.
        """
        return pulumi.get(self, "exec_err_state")

    @_builtins.property
    @pulumi.getter
    def expressions(self) -> Mapping[str, _builtins.str]:
        """
        A sequence of stages that describe the contents of the rule. Each value is a JSON string representing an expression object.
        """
        return pulumi.get(self, "expressions")

    @_builtins.property
    @pulumi.getter(name="noDataState")
    def no_data_state(self) -> _builtins.str:
        """
        Describes what state to enter when the rule's query returns No Data. Options are OK, NoData, KeepLast, and Alerting.
        """
        return pulumi.get(self, "no_data_state")

    @_builtins.property
    @pulumi.getter
    def title(self) -> _builtins.str:
        """
        The title of the alert rule.
        """
        return pulumi.get(self, "title")

    @_builtins.property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Key-value pairs of metadata to attach to the alert rule. They add additional information, such as a `summary` or `runbook_url`, to help identify and investigate alerts.
        """
        return pulumi.get(self, "annotations")

    @_builtins.property
    @pulumi.getter(name="for")
    def for_(self) -> Optional[_builtins.str]:
        """
        The amount of time for which the rule must be breached for the rule to be considered to be Firing. Before this time has elapsed, the rule is only considered to be Pending.
        """
        return pulumi.get(self, "for_")

    @_builtins.property
    @pulumi.getter(name="keepFiringFor")
    def keep_firing_for(self) -> Optional[_builtins.str]:
        """
        The amount of time for which the rule will considered to be Recovering after initially Firing. Before this time has elapsed, the rule will continue to fire once it's been triggered.
        """
        return pulumi.get(self, "keep_firing_for")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Key-value pairs to attach to the alert rule that can be used in matching, grouping, and routing.
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter(name="missingSeriesEvalsToResolve")
    def missing_series_evals_to_resolve(self) -> Optional[_builtins.int]:
        """
        The number of missing series evaluations that must occur before the rule is considered to be resolved.
        """
        return pulumi.get(self, "missing_series_evals_to_resolve")

    @_builtins.property
    @pulumi.getter(name="notificationSettings")
    def notification_settings(self) -> Optional['outputs.AlertRuleV0Alpha1SpecNotificationSettings']:
        """
        Notification settings for the rule. If specified, it overrides the notification policies.
        """
        return pulumi.get(self, "notification_settings")

    @_builtins.property
    @pulumi.getter(name="panelRef")
    def panel_ref(self) -> Optional[Any]:
        """
        Reference to a panel that this alert rule is associated with. Should be an object with 'dashboard*uid' (string) and 'panel*id' (number) fields.
        """
        return pulumi.get(self, "panel_ref")

    @_builtins.property
    @pulumi.getter
    def paused(self) -> Optional[_builtins.bool]:
        """
        Sets whether the rule should be paused or not.
        """
        return pulumi.get(self, "paused")

    @_builtins.property
    @pulumi.getter
    def trigger(self) -> Optional['outputs.AlertRuleV0Alpha1SpecTrigger']:
        """
        The trigger configuration for the alert rule.
        """
        return pulumi.get(self, "trigger")


@pulumi.output_type
class AlertRuleV0Alpha1SpecNotificationSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contactPoint":
            suggest = "contact_point"
        elif key == "activeTimings":
            suggest = "active_timings"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "groupInterval":
            suggest = "group_interval"
        elif key == "groupWait":
            suggest = "group_wait"
        elif key == "muteTimings":
            suggest = "mute_timings"
        elif key == "repeatInterval":
            suggest = "repeat_interval"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertRuleV0Alpha1SpecNotificationSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertRuleV0Alpha1SpecNotificationSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertRuleV0Alpha1SpecNotificationSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 contact_point: _builtins.str,
                 active_timings: Optional[Sequence[_builtins.str]] = None,
                 group_bies: Optional[Sequence[_builtins.str]] = None,
                 group_interval: Optional[_builtins.str] = None,
                 group_wait: Optional[_builtins.str] = None,
                 mute_timings: Optional[Sequence[_builtins.str]] = None,
                 repeat_interval: Optional[_builtins.str] = None):
        """
        :param _builtins.str contact_point: The contact point to route notifications that match this rule to.
        :param Sequence[_builtins.str] active_timings: A list of time interval names to apply to alerts that match this policy to suppress them unless they are sent at the specified time.
        :param Sequence[_builtins.str] group_bies: A list of alert labels to group alerts into notifications by.
        :param _builtins.str group_interval: Minimum time interval between two notifications for the same group.
        :param _builtins.str group_wait: Time to wait to buffer alerts of the same group before sending a notification.
        :param Sequence[_builtins.str] mute_timings: A list of mute timing names to apply to alerts that match this policy.
        :param _builtins.str repeat_interval: Minimum time interval for re-sending a notification if an alert is still firing.
        """
        pulumi.set(__self__, "contact_point", contact_point)
        if active_timings is not None:
            pulumi.set(__self__, "active_timings", active_timings)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if group_interval is not None:
            pulumi.set(__self__, "group_interval", group_interval)
        if group_wait is not None:
            pulumi.set(__self__, "group_wait", group_wait)
        if mute_timings is not None:
            pulumi.set(__self__, "mute_timings", mute_timings)
        if repeat_interval is not None:
            pulumi.set(__self__, "repeat_interval", repeat_interval)

    @_builtins.property
    @pulumi.getter(name="contactPoint")
    def contact_point(self) -> _builtins.str:
        """
        The contact point to route notifications that match this rule to.
        """
        return pulumi.get(self, "contact_point")

    @_builtins.property
    @pulumi.getter(name="activeTimings")
    def active_timings(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of time interval names to apply to alerts that match this policy to suppress them unless they are sent at the specified time.
        """
        return pulumi.get(self, "active_timings")

    @_builtins.property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of alert labels to group alerts into notifications by.
        """
        return pulumi.get(self, "group_bies")

    @_builtins.property
    @pulumi.getter(name="groupInterval")
    def group_interval(self) -> Optional[_builtins.str]:
        """
        Minimum time interval between two notifications for the same group.
        """
        return pulumi.get(self, "group_interval")

    @_builtins.property
    @pulumi.getter(name="groupWait")
    def group_wait(self) -> Optional[_builtins.str]:
        """
        Time to wait to buffer alerts of the same group before sending a notification.
        """
        return pulumi.get(self, "group_wait")

    @_builtins.property
    @pulumi.getter(name="muteTimings")
    def mute_timings(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of mute timing names to apply to alerts that match this policy.
        """
        return pulumi.get(self, "mute_timings")

    @_builtins.property
    @pulumi.getter(name="repeatInterval")
    def repeat_interval(self) -> Optional[_builtins.str]:
        """
        Minimum time interval for re-sending a notification if an alert is still firing.
        """
        return pulumi.get(self, "repeat_interval")


@pulumi.output_type
class AlertRuleV0Alpha1SpecTrigger(dict):
    def __init__(__self__, *,
                 interval: _builtins.str):
        """
        :param _builtins.str interval: The interval at which the alert rule should be evaluated.
        """
        pulumi.set(__self__, "interval", interval)

    @_builtins.property
    @pulumi.getter
    def interval(self) -> _builtins.str:
        """
        The interval at which the alert rule should be evaluated.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class ContactPointAlertmanager(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "basicAuthPassword":
            suggest = "basic_auth_password"
        elif key == "basicAuthUser":
            suggest = "basic_auth_user"
        elif key == "disableResolveMessage":
            suggest = "disable_resolve_message"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContactPointAlertmanager. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContactPointAlertmanager.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContactPointAlertmanager.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: _builtins.str,
                 basic_auth_password: Optional[_builtins.str] = None,
                 basic_auth_user: Optional[_builtins.str] = None,
                 disable_resolve_message: Optional[_builtins.bool] = None,
                 settings: Optional[Mapping[str, _builtins.str]] = None,
                 uid: Optional[_builtins.str] = None):
        """
        :param _builtins.str url: The URL of the Alertmanager instance.
        :param _builtins.str basic_auth_password: The password component of the basic auth credentials to use.
        :param _builtins.str basic_auth_user: The username component of the basic auth credentials to use.
        :param _builtins.bool disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param Mapping[str, _builtins.str] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param _builtins.str uid: The UID of the contact point.
        """
        pulumi.set(__self__, "url", url)
        if basic_auth_password is not None:
            pulumi.set(__self__, "basic_auth_password", basic_auth_password)
        if basic_auth_user is not None:
            pulumi.set(__self__, "basic_auth_user", basic_auth_user)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        The URL of the Alertmanager instance.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="basicAuthPassword")
    def basic_auth_password(self) -> Optional[_builtins.str]:
        """
        The password component of the basic auth credentials to use.
        """
        return pulumi.get(self, "basic_auth_password")

    @_builtins.property
    @pulumi.getter(name="basicAuthUser")
    def basic_auth_user(self) -> Optional[_builtins.str]:
        """
        The username component of the basic auth credentials to use.
        """
        return pulumi.get(self, "basic_auth_user")

    @_builtins.property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[_builtins.bool]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @_builtins.property
    @pulumi.getter
    def settings(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @_builtins.property
    @pulumi.getter
    def uid(self) -> Optional[_builtins.str]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")


@pulumi.output_type
class ContactPointDingding(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disableResolveMessage":
            suggest = "disable_resolve_message"
        elif key == "messageType":
            suggest = "message_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContactPointDingding. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContactPointDingding.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContactPointDingding.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: _builtins.str,
                 disable_resolve_message: Optional[_builtins.bool] = None,
                 message: Optional[_builtins.str] = None,
                 message_type: Optional[_builtins.str] = None,
                 settings: Optional[Mapping[str, _builtins.str]] = None,
                 title: Optional[_builtins.str] = None,
                 uid: Optional[_builtins.str] = None):
        """
        :param _builtins.str url: The DingDing webhook URL.
        :param _builtins.bool disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param _builtins.str message: The templated content of the message.
        :param _builtins.str message_type: The format of message to send - either 'link' or 'actionCard'
        :param Mapping[str, _builtins.str] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param _builtins.str title: The templated title of the message.
        :param _builtins.str uid: The UID of the contact point.
        """
        pulumi.set(__self__, "url", url)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if message_type is not None:
            pulumi.set(__self__, "message_type", message_type)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        The DingDing webhook URL.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[_builtins.bool]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[_builtins.str]:
        """
        The templated content of the message.
        """
        return pulumi.get(self, "message")

    @_builtins.property
    @pulumi.getter(name="messageType")
    def message_type(self) -> Optional[_builtins.str]:
        """
        The format of message to send - either 'link' or 'actionCard'
        """
        return pulumi.get(self, "message_type")

    @_builtins.property
    @pulumi.getter
    def settings(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @_builtins.property
    @pulumi.getter
    def title(self) -> Optional[_builtins.str]:
        """
        The templated title of the message.
        """
        return pulumi.get(self, "title")

    @_builtins.property
    @pulumi.getter
    def uid(self) -> Optional[_builtins.str]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")


@pulumi.output_type
class ContactPointDiscord(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "avatarUrl":
            suggest = "avatar_url"
        elif key == "disableResolveMessage":
            suggest = "disable_resolve_message"
        elif key == "useDiscordUsername":
            suggest = "use_discord_username"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContactPointDiscord. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContactPointDiscord.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContactPointDiscord.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: _builtins.str,
                 avatar_url: Optional[_builtins.str] = None,
                 disable_resolve_message: Optional[_builtins.bool] = None,
                 message: Optional[_builtins.str] = None,
                 settings: Optional[Mapping[str, _builtins.str]] = None,
                 title: Optional[_builtins.str] = None,
                 uid: Optional[_builtins.str] = None,
                 use_discord_username: Optional[_builtins.bool] = None):
        """
        :param _builtins.str url: The discord webhook URL.
        :param _builtins.str avatar_url: The URL of a custom avatar image to use. Defaults to ``.
        :param _builtins.bool disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param _builtins.str message: The templated content of the message. Defaults to ``.
        :param Mapping[str, _builtins.str] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param _builtins.str title: The templated content of the title.
        :param _builtins.str uid: The UID of the contact point.
        :param _builtins.bool use_discord_username: Whether to use the bot account's plain username instead of "Grafana." Defaults to `false`.
        """
        pulumi.set(__self__, "url", url)
        if avatar_url is not None:
            pulumi.set(__self__, "avatar_url", avatar_url)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)
        if use_discord_username is not None:
            pulumi.set(__self__, "use_discord_username", use_discord_username)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        The discord webhook URL.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="avatarUrl")
    def avatar_url(self) -> Optional[_builtins.str]:
        """
        The URL of a custom avatar image to use. Defaults to ``.
        """
        return pulumi.get(self, "avatar_url")

    @_builtins.property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[_builtins.bool]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[_builtins.str]:
        """
        The templated content of the message. Defaults to ``.
        """
        return pulumi.get(self, "message")

    @_builtins.property
    @pulumi.getter
    def settings(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @_builtins.property
    @pulumi.getter
    def title(self) -> Optional[_builtins.str]:
        """
        The templated content of the title.
        """
        return pulumi.get(self, "title")

    @_builtins.property
    @pulumi.getter
    def uid(self) -> Optional[_builtins.str]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")

    @_builtins.property
    @pulumi.getter(name="useDiscordUsername")
    def use_discord_username(self) -> Optional[_builtins.bool]:
        """
        Whether to use the bot account's plain username instead of "Grafana." Defaults to `false`.
        """
        return pulumi.get(self, "use_discord_username")


@pulumi.output_type
class ContactPointEmail(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disableResolveMessage":
            suggest = "disable_resolve_message"
        elif key == "singleEmail":
            suggest = "single_email"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContactPointEmail. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContactPointEmail.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContactPointEmail.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 addresses: Sequence[_builtins.str],
                 disable_resolve_message: Optional[_builtins.bool] = None,
                 message: Optional[_builtins.str] = None,
                 settings: Optional[Mapping[str, _builtins.str]] = None,
                 single_email: Optional[_builtins.bool] = None,
                 subject: Optional[_builtins.str] = None,
                 uid: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] addresses: The addresses to send emails to.
        :param _builtins.bool disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param _builtins.str message: The templated content of the email. Defaults to ``.
        :param Mapping[str, _builtins.str] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param _builtins.bool single_email: Whether to send a single email CC'ing all addresses, rather than a separate email to each address. Defaults to `false`.
        :param _builtins.str subject: The templated subject line of the email. Defaults to ``.
        :param _builtins.str uid: The UID of the contact point.
        """
        pulumi.set(__self__, "addresses", addresses)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if single_email is not None:
            pulumi.set(__self__, "single_email", single_email)
        if subject is not None:
            pulumi.set(__self__, "subject", subject)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @_builtins.property
    @pulumi.getter
    def addresses(self) -> Sequence[_builtins.str]:
        """
        The addresses to send emails to.
        """
        return pulumi.get(self, "addresses")

    @_builtins.property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[_builtins.bool]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[_builtins.str]:
        """
        The templated content of the email. Defaults to ``.
        """
        return pulumi.get(self, "message")

    @_builtins.property
    @pulumi.getter
    def settings(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @_builtins.property
    @pulumi.getter(name="singleEmail")
    def single_email(self) -> Optional[_builtins.bool]:
        """
        Whether to send a single email CC'ing all addresses, rather than a separate email to each address. Defaults to `false`.
        """
        return pulumi.get(self, "single_email")

    @_builtins.property
    @pulumi.getter
    def subject(self) -> Optional[_builtins.str]:
        """
        The templated subject line of the email. Defaults to ``.
        """
        return pulumi.get(self, "subject")

    @_builtins.property
    @pulumi.getter
    def uid(self) -> Optional[_builtins.str]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")


@pulumi.output_type
class ContactPointGooglechat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disableResolveMessage":
            suggest = "disable_resolve_message"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContactPointGooglechat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContactPointGooglechat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContactPointGooglechat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: _builtins.str,
                 disable_resolve_message: Optional[_builtins.bool] = None,
                 message: Optional[_builtins.str] = None,
                 settings: Optional[Mapping[str, _builtins.str]] = None,
                 title: Optional[_builtins.str] = None,
                 uid: Optional[_builtins.str] = None):
        """
        :param _builtins.str url: The Google Chat webhook URL.
        :param _builtins.bool disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param _builtins.str message: The templated content of the message.
        :param Mapping[str, _builtins.str] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param _builtins.str title: The templated content of the title.
        :param _builtins.str uid: The UID of the contact point.
        """
        pulumi.set(__self__, "url", url)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        The Google Chat webhook URL.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[_builtins.bool]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[_builtins.str]:
        """
        The templated content of the message.
        """
        return pulumi.get(self, "message")

    @_builtins.property
    @pulumi.getter
    def settings(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @_builtins.property
    @pulumi.getter
    def title(self) -> Optional[_builtins.str]:
        """
        The templated content of the title.
        """
        return pulumi.get(self, "title")

    @_builtins.property
    @pulumi.getter
    def uid(self) -> Optional[_builtins.str]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")


@pulumi.output_type
class ContactPointKafka(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "restProxyUrl":
            suggest = "rest_proxy_url"
        elif key == "apiVersion":
            suggest = "api_version"
        elif key == "clusterId":
            suggest = "cluster_id"
        elif key == "disableResolveMessage":
            suggest = "disable_resolve_message"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContactPointKafka. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContactPointKafka.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContactPointKafka.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 rest_proxy_url: _builtins.str,
                 topic: _builtins.str,
                 api_version: Optional[_builtins.str] = None,
                 cluster_id: Optional[_builtins.str] = None,
                 description: Optional[_builtins.str] = None,
                 details: Optional[_builtins.str] = None,
                 disable_resolve_message: Optional[_builtins.bool] = None,
                 password: Optional[_builtins.str] = None,
                 settings: Optional[Mapping[str, _builtins.str]] = None,
                 uid: Optional[_builtins.str] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str rest_proxy_url: The URL of the Kafka REST proxy to send requests to.
        :param _builtins.str topic: The name of the Kafka topic to publish to.
        :param _builtins.str api_version: The API version to use when contacting the Kafka REST Server. Supported: v2 (default) and v3. Defaults to `v2`.
        :param _builtins.str cluster_id: The Id of cluster to use when contacting the Kafka REST Server. Required api_version to be 'v3'
        :param _builtins.str description: The templated description of the Kafka message.
        :param _builtins.str details: The templated details to include with the message.
        :param _builtins.bool disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param _builtins.str password: The password to use when making a call to the Kafka REST Proxy
        :param Mapping[str, _builtins.str] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param _builtins.str uid: The UID of the contact point.
        :param _builtins.str username: The user name to use when making a call to the Kafka REST Proxy
        """
        pulumi.set(__self__, "rest_proxy_url", rest_proxy_url)
        pulumi.set(__self__, "topic", topic)
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if cluster_id is not None:
            pulumi.set(__self__, "cluster_id", cluster_id)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if details is not None:
            pulumi.set(__self__, "details", details)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="restProxyUrl")
    def rest_proxy_url(self) -> _builtins.str:
        """
        The URL of the Kafka REST proxy to send requests to.
        """
        return pulumi.get(self, "rest_proxy_url")

    @_builtins.property
    @pulumi.getter
    def topic(self) -> _builtins.str:
        """
        The name of the Kafka topic to publish to.
        """
        return pulumi.get(self, "topic")

    @_builtins.property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[_builtins.str]:
        """
        The API version to use when contacting the Kafka REST Server. Supported: v2 (default) and v3. Defaults to `v2`.
        """
        return pulumi.get(self, "api_version")

    @_builtins.property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> Optional[_builtins.str]:
        """
        The Id of cluster to use when contacting the Kafka REST Server. Required api_version to be 'v3'
        """
        return pulumi.get(self, "cluster_id")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        The templated description of the Kafka message.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def details(self) -> Optional[_builtins.str]:
        """
        The templated details to include with the message.
        """
        return pulumi.get(self, "details")

    @_builtins.property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[_builtins.bool]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to use when making a call to the Kafka REST Proxy
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def settings(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @_builtins.property
    @pulumi.getter
    def uid(self) -> Optional[_builtins.str]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The user name to use when making a call to the Kafka REST Proxy
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ContactPointLine(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disableResolveMessage":
            suggest = "disable_resolve_message"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContactPointLine. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContactPointLine.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContactPointLine.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 token: _builtins.str,
                 description: Optional[_builtins.str] = None,
                 disable_resolve_message: Optional[_builtins.bool] = None,
                 settings: Optional[Mapping[str, _builtins.str]] = None,
                 title: Optional[_builtins.str] = None,
                 uid: Optional[_builtins.str] = None):
        """
        :param _builtins.str token: The bearer token used to authorize the client.
        :param _builtins.str description: The templated description of the message.
        :param _builtins.bool disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param Mapping[str, _builtins.str] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param _builtins.str title: The templated title of the message.
        :param _builtins.str uid: The UID of the contact point.
        """
        pulumi.set(__self__, "token", token)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @_builtins.property
    @pulumi.getter
    def token(self) -> _builtins.str:
        """
        The bearer token used to authorize the client.
        """
        return pulumi.get(self, "token")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        The templated description of the message.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[_builtins.bool]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @_builtins.property
    @pulumi.getter
    def settings(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @_builtins.property
    @pulumi.getter
    def title(self) -> Optional[_builtins.str]:
        """
        The templated title of the message.
        """
        return pulumi.get(self, "title")

    @_builtins.property
    @pulumi.getter
    def uid(self) -> Optional[_builtins.str]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")


@pulumi.output_type
class ContactPointOncall(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authorizationCredentials":
            suggest = "authorization_credentials"
        elif key == "authorizationScheme":
            suggest = "authorization_scheme"
        elif key == "basicAuthPassword":
            suggest = "basic_auth_password"
        elif key == "basicAuthUser":
            suggest = "basic_auth_user"
        elif key == "disableResolveMessage":
            suggest = "disable_resolve_message"
        elif key == "httpMethod":
            suggest = "http_method"
        elif key == "maxAlerts":
            suggest = "max_alerts"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContactPointOncall. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContactPointOncall.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContactPointOncall.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: _builtins.str,
                 authorization_credentials: Optional[_builtins.str] = None,
                 authorization_scheme: Optional[_builtins.str] = None,
                 basic_auth_password: Optional[_builtins.str] = None,
                 basic_auth_user: Optional[_builtins.str] = None,
                 disable_resolve_message: Optional[_builtins.bool] = None,
                 http_method: Optional[_builtins.str] = None,
                 max_alerts: Optional[_builtins.int] = None,
                 message: Optional[_builtins.str] = None,
                 settings: Optional[Mapping[str, _builtins.str]] = None,
                 title: Optional[_builtins.str] = None,
                 uid: Optional[_builtins.str] = None):
        """
        :param _builtins.str url: The URL to send webhook requests to.
        :param _builtins.str authorization_credentials: Allows a custom authorization scheme - attaches an auth header with this value. Do not use in conjunction with basic auth parameters.
        :param _builtins.str authorization_scheme: Allows a custom authorization scheme - attaches an auth header with this name. Do not use in conjunction with basic auth parameters.
        :param _builtins.str basic_auth_password: The username to use in basic auth headers attached to the request. If omitted, basic auth will not be used.
        :param _builtins.str basic_auth_user: The username to use in basic auth headers attached to the request. If omitted, basic auth will not be used.
        :param _builtins.bool disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param _builtins.str http_method: The HTTP method to use in the request. Defaults to `POST`.
        :param _builtins.int max_alerts: The maximum number of alerts to send in a single request. This can be helpful in limiting the size of the request body. The default is 0, which indicates no limit.
        :param _builtins.str message: Custom message. You can use template variables.
        :param Mapping[str, _builtins.str] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param _builtins.str title: Templated title of the message.
        :param _builtins.str uid: The UID of the contact point.
        """
        pulumi.set(__self__, "url", url)
        if authorization_credentials is not None:
            pulumi.set(__self__, "authorization_credentials", authorization_credentials)
        if authorization_scheme is not None:
            pulumi.set(__self__, "authorization_scheme", authorization_scheme)
        if basic_auth_password is not None:
            pulumi.set(__self__, "basic_auth_password", basic_auth_password)
        if basic_auth_user is not None:
            pulumi.set(__self__, "basic_auth_user", basic_auth_user)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if http_method is not None:
            pulumi.set(__self__, "http_method", http_method)
        if max_alerts is not None:
            pulumi.set(__self__, "max_alerts", max_alerts)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        The URL to send webhook requests to.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="authorizationCredentials")
    def authorization_credentials(self) -> Optional[_builtins.str]:
        """
        Allows a custom authorization scheme - attaches an auth header with this value. Do not use in conjunction with basic auth parameters.
        """
        return pulumi.get(self, "authorization_credentials")

    @_builtins.property
    @pulumi.getter(name="authorizationScheme")
    def authorization_scheme(self) -> Optional[_builtins.str]:
        """
        Allows a custom authorization scheme - attaches an auth header with this name. Do not use in conjunction with basic auth parameters.
        """
        return pulumi.get(self, "authorization_scheme")

    @_builtins.property
    @pulumi.getter(name="basicAuthPassword")
    def basic_auth_password(self) -> Optional[_builtins.str]:
        """
        The username to use in basic auth headers attached to the request. If omitted, basic auth will not be used.
        """
        return pulumi.get(self, "basic_auth_password")

    @_builtins.property
    @pulumi.getter(name="basicAuthUser")
    def basic_auth_user(self) -> Optional[_builtins.str]:
        """
        The username to use in basic auth headers attached to the request. If omitted, basic auth will not be used.
        """
        return pulumi.get(self, "basic_auth_user")

    @_builtins.property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[_builtins.bool]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @_builtins.property
    @pulumi.getter(name="httpMethod")
    def http_method(self) -> Optional[_builtins.str]:
        """
        The HTTP method to use in the request. Defaults to `POST`.
        """
        return pulumi.get(self, "http_method")

    @_builtins.property
    @pulumi.getter(name="maxAlerts")
    def max_alerts(self) -> Optional[_builtins.int]:
        """
        The maximum number of alerts to send in a single request. This can be helpful in limiting the size of the request body. The default is 0, which indicates no limit.
        """
        return pulumi.get(self, "max_alerts")

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[_builtins.str]:
        """
        Custom message. You can use template variables.
        """
        return pulumi.get(self, "message")

    @_builtins.property
    @pulumi.getter
    def settings(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @_builtins.property
    @pulumi.getter
    def title(self) -> Optional[_builtins.str]:
        """
        Templated title of the message.
        """
        return pulumi.get(self, "title")

    @_builtins.property
    @pulumi.getter
    def uid(self) -> Optional[_builtins.str]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")


@pulumi.output_type
class ContactPointOpsgeny(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"
        elif key == "autoClose":
            suggest = "auto_close"
        elif key == "disableResolveMessage":
            suggest = "disable_resolve_message"
        elif key == "overridePriority":
            suggest = "override_priority"
        elif key == "sendTagsAs":
            suggest = "send_tags_as"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContactPointOpsgeny. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContactPointOpsgeny.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContactPointOpsgeny.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: _builtins.str,
                 auto_close: Optional[_builtins.bool] = None,
                 description: Optional[_builtins.str] = None,
                 disable_resolve_message: Optional[_builtins.bool] = None,
                 message: Optional[_builtins.str] = None,
                 override_priority: Optional[_builtins.bool] = None,
                 responders: Optional[Sequence['outputs.ContactPointOpsgenyResponder']] = None,
                 send_tags_as: Optional[_builtins.str] = None,
                 settings: Optional[Mapping[str, _builtins.str]] = None,
                 uid: Optional[_builtins.str] = None,
                 url: Optional[_builtins.str] = None):
        """
        :param _builtins.str api_key: The OpsGenie API key to use.
        :param _builtins.bool auto_close: Whether to auto-close alerts in OpsGenie when they resolve in the Alertmanager.
        :param _builtins.str description: A templated high-level description to use for the alert.
        :param _builtins.bool disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param _builtins.str message: The templated content of the message.
        :param _builtins.bool override_priority: Whether to allow the alert priority to be configured via the value of the `og_priority` annotation on the alert.
        :param Sequence['ContactPointOpsgenyResponderArgs'] responders: Teams, users, escalations and schedules that the alert will be routed to send notifications. If the API Key belongs to a team integration, this field will be overwritten with the owner team. This feature is available from Grafana 10.3+.
        :param _builtins.str send_tags_as: Whether to send annotations to OpsGenie as Tags, Details, or both. Supported values are `tags`, `details`, `both`, or empty to use the default behavior of Tags.
        :param Mapping[str, _builtins.str] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param _builtins.str uid: The UID of the contact point.
        :param _builtins.str url: Allows customization of the OpsGenie API URL.
        """
        pulumi.set(__self__, "api_key", api_key)
        if auto_close is not None:
            pulumi.set(__self__, "auto_close", auto_close)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if override_priority is not None:
            pulumi.set(__self__, "override_priority", override_priority)
        if responders is not None:
            pulumi.set(__self__, "responders", responders)
        if send_tags_as is not None:
            pulumi.set(__self__, "send_tags_as", send_tags_as)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> _builtins.str:
        """
        The OpsGenie API key to use.
        """
        return pulumi.get(self, "api_key")

    @_builtins.property
    @pulumi.getter(name="autoClose")
    def auto_close(self) -> Optional[_builtins.bool]:
        """
        Whether to auto-close alerts in OpsGenie when they resolve in the Alertmanager.
        """
        return pulumi.get(self, "auto_close")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        A templated high-level description to use for the alert.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[_builtins.bool]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[_builtins.str]:
        """
        The templated content of the message.
        """
        return pulumi.get(self, "message")

    @_builtins.property
    @pulumi.getter(name="overridePriority")
    def override_priority(self) -> Optional[_builtins.bool]:
        """
        Whether to allow the alert priority to be configured via the value of the `og_priority` annotation on the alert.
        """
        return pulumi.get(self, "override_priority")

    @_builtins.property
    @pulumi.getter
    def responders(self) -> Optional[Sequence['outputs.ContactPointOpsgenyResponder']]:
        """
        Teams, users, escalations and schedules that the alert will be routed to send notifications. If the API Key belongs to a team integration, this field will be overwritten with the owner team. This feature is available from Grafana 10.3+.
        """
        return pulumi.get(self, "responders")

    @_builtins.property
    @pulumi.getter(name="sendTagsAs")
    def send_tags_as(self) -> Optional[_builtins.str]:
        """
        Whether to send annotations to OpsGenie as Tags, Details, or both. Supported values are `tags`, `details`, `both`, or empty to use the default behavior of Tags.
        """
        return pulumi.get(self, "send_tags_as")

    @_builtins.property
    @pulumi.getter
    def settings(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @_builtins.property
    @pulumi.getter
    def uid(self) -> Optional[_builtins.str]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        Allows customization of the OpsGenie API URL.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class ContactPointOpsgenyResponder(dict):
    def __init__(__self__, *,
                 type: _builtins.str,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str type: Type of the responder. Supported: team, teams, user, escalation, schedule or a template that is expanded to one of these values.
        :param _builtins.str id: ID of the responder. Must be specified if name and username are empty.
        :param _builtins.str name: Name of the responder. Must be specified if username and id are empty.
        :param _builtins.str username: User name of the responder. Must be specified if name and id are empty.
        """
        pulumi.set(__self__, "type", type)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type of the responder. Supported: team, teams, user, escalation, schedule or a template that is expanded to one of these values.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        ID of the responder. Must be specified if name and username are empty.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the responder. Must be specified if username and id are empty.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        User name of the responder. Must be specified if name and id are empty.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ContactPointPagerduty(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "integrationKey":
            suggest = "integration_key"
        elif key == "class":
            suggest = "class_"
        elif key == "clientUrl":
            suggest = "client_url"
        elif key == "disableResolveMessage":
            suggest = "disable_resolve_message"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContactPointPagerduty. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContactPointPagerduty.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContactPointPagerduty.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 integration_key: _builtins.str,
                 class_: Optional[_builtins.str] = None,
                 client: Optional[_builtins.str] = None,
                 client_url: Optional[_builtins.str] = None,
                 component: Optional[_builtins.str] = None,
                 details: Optional[Mapping[str, _builtins.str]] = None,
                 disable_resolve_message: Optional[_builtins.bool] = None,
                 group: Optional[_builtins.str] = None,
                 settings: Optional[Mapping[str, _builtins.str]] = None,
                 severity: Optional[_builtins.str] = None,
                 source: Optional[_builtins.str] = None,
                 summary: Optional[_builtins.str] = None,
                 uid: Optional[_builtins.str] = None,
                 url: Optional[_builtins.str] = None):
        """
        :param _builtins.str integration_key: The PagerDuty API key.
        :param _builtins.str class_: The class or type of event, for example `ping failure`.
        :param _builtins.str client: The name of the monitoring client that is triggering this event.
        :param _builtins.str client_url: The URL of the monitoring client that is triggering this event.
        :param _builtins.str component: The component being affected by the event.
        :param Mapping[str, _builtins.str] details: A set of arbitrary key/value pairs that provide further detail about the incident.
        :param _builtins.bool disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param _builtins.str group: The group to which the provided component belongs to.
        :param Mapping[str, _builtins.str] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param _builtins.str severity: The PagerDuty event severity level. Default is `critical`.
        :param _builtins.str source: The unique location of the affected system.
        :param _builtins.str summary: The templated summary message of the event.
        :param _builtins.str uid: The UID of the contact point.
        :param _builtins.str url: The URL to send API requests to
        """
        pulumi.set(__self__, "integration_key", integration_key)
        if class_ is not None:
            pulumi.set(__self__, "class_", class_)
        if client is not None:
            pulumi.set(__self__, "client", client)
        if client_url is not None:
            pulumi.set(__self__, "client_url", client_url)
        if component is not None:
            pulumi.set(__self__, "component", component)
        if details is not None:
            pulumi.set(__self__, "details", details)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if group is not None:
            pulumi.set(__self__, "group", group)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if summary is not None:
            pulumi.set(__self__, "summary", summary)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter(name="integrationKey")
    def integration_key(self) -> _builtins.str:
        """
        The PagerDuty API key.
        """
        return pulumi.get(self, "integration_key")

    @_builtins.property
    @pulumi.getter(name="class")
    def class_(self) -> Optional[_builtins.str]:
        """
        The class or type of event, for example `ping failure`.
        """
        return pulumi.get(self, "class_")

    @_builtins.property
    @pulumi.getter
    def client(self) -> Optional[_builtins.str]:
        """
        The name of the monitoring client that is triggering this event.
        """
        return pulumi.get(self, "client")

    @_builtins.property
    @pulumi.getter(name="clientUrl")
    def client_url(self) -> Optional[_builtins.str]:
        """
        The URL of the monitoring client that is triggering this event.
        """
        return pulumi.get(self, "client_url")

    @_builtins.property
    @pulumi.getter
    def component(self) -> Optional[_builtins.str]:
        """
        The component being affected by the event.
        """
        return pulumi.get(self, "component")

    @_builtins.property
    @pulumi.getter
    def details(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        A set of arbitrary key/value pairs that provide further detail about the incident.
        """
        return pulumi.get(self, "details")

    @_builtins.property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[_builtins.bool]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @_builtins.property
    @pulumi.getter
    def group(self) -> Optional[_builtins.str]:
        """
        The group to which the provided component belongs to.
        """
        return pulumi.get(self, "group")

    @_builtins.property
    @pulumi.getter
    def settings(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @_builtins.property
    @pulumi.getter
    def severity(self) -> Optional[_builtins.str]:
        """
        The PagerDuty event severity level. Default is `critical`.
        """
        return pulumi.get(self, "severity")

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[_builtins.str]:
        """
        The unique location of the affected system.
        """
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter
    def summary(self) -> Optional[_builtins.str]:
        """
        The templated summary message of the event.
        """
        return pulumi.get(self, "summary")

    @_builtins.property
    @pulumi.getter
    def uid(self) -> Optional[_builtins.str]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        The URL to send API requests to
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class ContactPointPushover(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiToken":
            suggest = "api_token"
        elif key == "userKey":
            suggest = "user_key"
        elif key == "disableResolveMessage":
            suggest = "disable_resolve_message"
        elif key == "okPriority":
            suggest = "ok_priority"
        elif key == "okSound":
            suggest = "ok_sound"
        elif key == "uploadImage":
            suggest = "upload_image"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContactPointPushover. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContactPointPushover.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContactPointPushover.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_token: _builtins.str,
                 user_key: _builtins.str,
                 device: Optional[_builtins.str] = None,
                 disable_resolve_message: Optional[_builtins.bool] = None,
                 expire: Optional[_builtins.int] = None,
                 message: Optional[_builtins.str] = None,
                 ok_priority: Optional[_builtins.int] = None,
                 ok_sound: Optional[_builtins.str] = None,
                 priority: Optional[_builtins.int] = None,
                 retry: Optional[_builtins.int] = None,
                 settings: Optional[Mapping[str, _builtins.str]] = None,
                 sound: Optional[_builtins.str] = None,
                 title: Optional[_builtins.str] = None,
                 uid: Optional[_builtins.str] = None,
                 upload_image: Optional[_builtins.bool] = None):
        """
        :param _builtins.str api_token: The Pushover API token.
        :param _builtins.str user_key: The Pushover user key.
        :param _builtins.str device: Comma-separated list of devices to which the event is associated.
        :param _builtins.bool disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param _builtins.int expire: How many seconds for which the notification will continue to be retried by Pushover.
        :param _builtins.str message: The templated notification message content.
        :param _builtins.int ok_priority: The priority level of the resolved event.
        :param _builtins.str ok_sound: The sound associated with the resolved notification.
        :param _builtins.int priority: The priority level of the event.
        :param _builtins.int retry: How often, in seconds, the Pushover servers will send the same notification to the user.
        :param Mapping[str, _builtins.str] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param _builtins.str sound: The sound associated with the notification.
        :param _builtins.str title: The templated title of the message.
        :param _builtins.str uid: The UID of the contact point.
        :param _builtins.bool upload_image: Whether to send images in the notification or not. Default is true. Requires Grafana to be configured to send images in notifications.
        """
        pulumi.set(__self__, "api_token", api_token)
        pulumi.set(__self__, "user_key", user_key)
        if device is not None:
            pulumi.set(__self__, "device", device)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if expire is not None:
            pulumi.set(__self__, "expire", expire)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if ok_priority is not None:
            pulumi.set(__self__, "ok_priority", ok_priority)
        if ok_sound is not None:
            pulumi.set(__self__, "ok_sound", ok_sound)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if retry is not None:
            pulumi.set(__self__, "retry", retry)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if sound is not None:
            pulumi.set(__self__, "sound", sound)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)
        if upload_image is not None:
            pulumi.set(__self__, "upload_image", upload_image)

    @_builtins.property
    @pulumi.getter(name="apiToken")
    def api_token(self) -> _builtins.str:
        """
        The Pushover API token.
        """
        return pulumi.get(self, "api_token")

    @_builtins.property
    @pulumi.getter(name="userKey")
    def user_key(self) -> _builtins.str:
        """
        The Pushover user key.
        """
        return pulumi.get(self, "user_key")

    @_builtins.property
    @pulumi.getter
    def device(self) -> Optional[_builtins.str]:
        """
        Comma-separated list of devices to which the event is associated.
        """
        return pulumi.get(self, "device")

    @_builtins.property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[_builtins.bool]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @_builtins.property
    @pulumi.getter
    def expire(self) -> Optional[_builtins.int]:
        """
        How many seconds for which the notification will continue to be retried by Pushover.
        """
        return pulumi.get(self, "expire")

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[_builtins.str]:
        """
        The templated notification message content.
        """
        return pulumi.get(self, "message")

    @_builtins.property
    @pulumi.getter(name="okPriority")
    def ok_priority(self) -> Optional[_builtins.int]:
        """
        The priority level of the resolved event.
        """
        return pulumi.get(self, "ok_priority")

    @_builtins.property
    @pulumi.getter(name="okSound")
    def ok_sound(self) -> Optional[_builtins.str]:
        """
        The sound associated with the resolved notification.
        """
        return pulumi.get(self, "ok_sound")

    @_builtins.property
    @pulumi.getter
    def priority(self) -> Optional[_builtins.int]:
        """
        The priority level of the event.
        """
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter
    def retry(self) -> Optional[_builtins.int]:
        """
        How often, in seconds, the Pushover servers will send the same notification to the user.
        """
        return pulumi.get(self, "retry")

    @_builtins.property
    @pulumi.getter
    def settings(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @_builtins.property
    @pulumi.getter
    def sound(self) -> Optional[_builtins.str]:
        """
        The sound associated with the notification.
        """
        return pulumi.get(self, "sound")

    @_builtins.property
    @pulumi.getter
    def title(self) -> Optional[_builtins.str]:
        """
        The templated title of the message.
        """
        return pulumi.get(self, "title")

    @_builtins.property
    @pulumi.getter
    def uid(self) -> Optional[_builtins.str]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")

    @_builtins.property
    @pulumi.getter(name="uploadImage")
    def upload_image(self) -> Optional[_builtins.bool]:
        """
        Whether to send images in the notification or not. Default is true. Requires Grafana to be configured to send images in notifications.
        """
        return pulumi.get(self, "upload_image")


@pulumi.output_type
class ContactPointSensugo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"
        elif key == "disableResolveMessage":
            suggest = "disable_resolve_message"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContactPointSensugo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContactPointSensugo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContactPointSensugo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: _builtins.str,
                 url: _builtins.str,
                 check: Optional[_builtins.str] = None,
                 disable_resolve_message: Optional[_builtins.bool] = None,
                 entity: Optional[_builtins.str] = None,
                 handler: Optional[_builtins.str] = None,
                 message: Optional[_builtins.str] = None,
                 namespace: Optional[_builtins.str] = None,
                 settings: Optional[Mapping[str, _builtins.str]] = None,
                 uid: Optional[_builtins.str] = None):
        """
        :param _builtins.str api_key: The SensuGo API key.
        :param _builtins.str url: The SensuGo URL to send requests to.
        :param _builtins.str check: The SensuGo check to which the event should be routed.
        :param _builtins.bool disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param _builtins.str entity: The entity being monitored.
        :param _builtins.str handler: A custom handler to execute in addition to the check.
        :param _builtins.str message: Templated message content describing the alert.
        :param _builtins.str namespace: The namespace in which the check resides.
        :param Mapping[str, _builtins.str] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param _builtins.str uid: The UID of the contact point.
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "url", url)
        if check is not None:
            pulumi.set(__self__, "check", check)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if entity is not None:
            pulumi.set(__self__, "entity", entity)
        if handler is not None:
            pulumi.set(__self__, "handler", handler)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> _builtins.str:
        """
        The SensuGo API key.
        """
        return pulumi.get(self, "api_key")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        The SensuGo URL to send requests to.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter
    def check(self) -> Optional[_builtins.str]:
        """
        The SensuGo check to which the event should be routed.
        """
        return pulumi.get(self, "check")

    @_builtins.property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[_builtins.bool]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @_builtins.property
    @pulumi.getter
    def entity(self) -> Optional[_builtins.str]:
        """
        The entity being monitored.
        """
        return pulumi.get(self, "entity")

    @_builtins.property
    @pulumi.getter
    def handler(self) -> Optional[_builtins.str]:
        """
        A custom handler to execute in addition to the check.
        """
        return pulumi.get(self, "handler")

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[_builtins.str]:
        """
        Templated message content describing the alert.
        """
        return pulumi.get(self, "message")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[_builtins.str]:
        """
        The namespace in which the check resides.
        """
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter
    def settings(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @_builtins.property
    @pulumi.getter
    def uid(self) -> Optional[_builtins.str]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")


@pulumi.output_type
class ContactPointSlack(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disableResolveMessage":
            suggest = "disable_resolve_message"
        elif key == "endpointUrl":
            suggest = "endpoint_url"
        elif key == "iconEmoji":
            suggest = "icon_emoji"
        elif key == "iconUrl":
            suggest = "icon_url"
        elif key == "mentionChannel":
            suggest = "mention_channel"
        elif key == "mentionGroups":
            suggest = "mention_groups"
        elif key == "mentionUsers":
            suggest = "mention_users"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContactPointSlack. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContactPointSlack.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContactPointSlack.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 color: Optional[_builtins.str] = None,
                 disable_resolve_message: Optional[_builtins.bool] = None,
                 endpoint_url: Optional[_builtins.str] = None,
                 icon_emoji: Optional[_builtins.str] = None,
                 icon_url: Optional[_builtins.str] = None,
                 mention_channel: Optional[_builtins.str] = None,
                 mention_groups: Optional[_builtins.str] = None,
                 mention_users: Optional[_builtins.str] = None,
                 recipient: Optional[_builtins.str] = None,
                 settings: Optional[Mapping[str, _builtins.str]] = None,
                 text: Optional[_builtins.str] = None,
                 title: Optional[_builtins.str] = None,
                 token: Optional[_builtins.str] = None,
                 uid: Optional[_builtins.str] = None,
                 url: Optional[_builtins.str] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str color: Templated color of the slack message.
        :param _builtins.bool disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param _builtins.str endpoint_url: Use this to override the Slack API endpoint URL to send requests to.
        :param _builtins.str icon_emoji: The name of a Slack workspace emoji to use as the bot icon.
        :param _builtins.str icon_url: A URL of an image to use as the bot icon.
        :param _builtins.str mention_channel: Describes how to ping the slack channel that messages are being sent to. Options are `here` for an @here ping, `channel` for @channel, or empty for no ping.
        :param _builtins.str mention_groups: Comma-separated list of groups to mention in the message.
        :param _builtins.str mention_users: Comma-separated list of users to mention in the message.
        :param _builtins.str recipient: Channel, private group, or IM channel (can be an encoded ID or a name) to send messages to.
        :param Mapping[str, _builtins.str] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param _builtins.str text: Templated content of the message.
        :param _builtins.str title: Templated title of the message.
        :param _builtins.str token: A Slack API token,for sending messages directly without the webhook method.
        :param _builtins.str uid: The UID of the contact point.
        :param _builtins.str url: A Slack webhook URL,for sending messages via the webhook method.
        :param _builtins.str username: Username for the bot to use.
        """
        if color is not None:
            pulumi.set(__self__, "color", color)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if endpoint_url is not None:
            pulumi.set(__self__, "endpoint_url", endpoint_url)
        if icon_emoji is not None:
            pulumi.set(__self__, "icon_emoji", icon_emoji)
        if icon_url is not None:
            pulumi.set(__self__, "icon_url", icon_url)
        if mention_channel is not None:
            pulumi.set(__self__, "mention_channel", mention_channel)
        if mention_groups is not None:
            pulumi.set(__self__, "mention_groups", mention_groups)
        if mention_users is not None:
            pulumi.set(__self__, "mention_users", mention_users)
        if recipient is not None:
            pulumi.set(__self__, "recipient", recipient)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if text is not None:
            pulumi.set(__self__, "text", text)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if token is not None:
            pulumi.set(__self__, "token", token)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def color(self) -> Optional[_builtins.str]:
        """
        Templated color of the slack message.
        """
        return pulumi.get(self, "color")

    @_builtins.property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[_builtins.bool]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @_builtins.property
    @pulumi.getter(name="endpointUrl")
    def endpoint_url(self) -> Optional[_builtins.str]:
        """
        Use this to override the Slack API endpoint URL to send requests to.
        """
        return pulumi.get(self, "endpoint_url")

    @_builtins.property
    @pulumi.getter(name="iconEmoji")
    def icon_emoji(self) -> Optional[_builtins.str]:
        """
        The name of a Slack workspace emoji to use as the bot icon.
        """
        return pulumi.get(self, "icon_emoji")

    @_builtins.property
    @pulumi.getter(name="iconUrl")
    def icon_url(self) -> Optional[_builtins.str]:
        """
        A URL of an image to use as the bot icon.
        """
        return pulumi.get(self, "icon_url")

    @_builtins.property
    @pulumi.getter(name="mentionChannel")
    def mention_channel(self) -> Optional[_builtins.str]:
        """
        Describes how to ping the slack channel that messages are being sent to. Options are `here` for an @here ping, `channel` for @channel, or empty for no ping.
        """
        return pulumi.get(self, "mention_channel")

    @_builtins.property
    @pulumi.getter(name="mentionGroups")
    def mention_groups(self) -> Optional[_builtins.str]:
        """
        Comma-separated list of groups to mention in the message.
        """
        return pulumi.get(self, "mention_groups")

    @_builtins.property
    @pulumi.getter(name="mentionUsers")
    def mention_users(self) -> Optional[_builtins.str]:
        """
        Comma-separated list of users to mention in the message.
        """
        return pulumi.get(self, "mention_users")

    @_builtins.property
    @pulumi.getter
    def recipient(self) -> Optional[_builtins.str]:
        """
        Channel, private group, or IM channel (can be an encoded ID or a name) to send messages to.
        """
        return pulumi.get(self, "recipient")

    @_builtins.property
    @pulumi.getter
    def settings(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[_builtins.str]:
        """
        Templated content of the message.
        """
        return pulumi.get(self, "text")

    @_builtins.property
    @pulumi.getter
    def title(self) -> Optional[_builtins.str]:
        """
        Templated title of the message.
        """
        return pulumi.get(self, "title")

    @_builtins.property
    @pulumi.getter
    def token(self) -> Optional[_builtins.str]:
        """
        A Slack API token,for sending messages directly without the webhook method.
        """
        return pulumi.get(self, "token")

    @_builtins.property
    @pulumi.getter
    def uid(self) -> Optional[_builtins.str]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        A Slack webhook URL,for sending messages via the webhook method.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        Username for the bot to use.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ContactPointSn(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "assumeRoleArn":
            suggest = "assume_role_arn"
        elif key == "authProvider":
            suggest = "auth_provider"
        elif key == "disableResolveMessage":
            suggest = "disable_resolve_message"
        elif key == "externalId":
            suggest = "external_id"
        elif key == "messageFormat":
            suggest = "message_format"
        elif key == "secretKey":
            suggest = "secret_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContactPointSn. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContactPointSn.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContactPointSn.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 topic: _builtins.str,
                 access_key: Optional[_builtins.str] = None,
                 assume_role_arn: Optional[_builtins.str] = None,
                 auth_provider: Optional[_builtins.str] = None,
                 body: Optional[_builtins.str] = None,
                 disable_resolve_message: Optional[_builtins.bool] = None,
                 external_id: Optional[_builtins.str] = None,
                 message_format: Optional[_builtins.str] = None,
                 secret_key: Optional[_builtins.str] = None,
                 settings: Optional[Mapping[str, _builtins.str]] = None,
                 subject: Optional[_builtins.str] = None,
                 uid: Optional[_builtins.str] = None):
        """
        :param _builtins.str topic: The Amazon SNS topic to send notifications to.
        :param _builtins.str access_key: AWS access key ID used to authenticate with Amazon SNS.
        :param _builtins.str assume_role_arn: The Amazon Resource Name (ARN) of the role to assume to send notifications to Amazon SNS.
        :param _builtins.str auth_provider: The authentication provider to use. Valid values are `default`, `arn` and `keys`. Default is `default`. Defaults to `default`.
        :param _builtins.bool disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param _builtins.str external_id: The external ID to use when assuming the role.
        :param _builtins.str message_format: The format of the message to send. Valid values are `text`, `body` and `json`. Default is `text`. Defaults to `text`.
        :param _builtins.str secret_key: AWS secret access key used to authenticate with Amazon SNS.
        :param Mapping[str, _builtins.str] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param _builtins.str uid: The UID of the contact point.
        """
        pulumi.set(__self__, "topic", topic)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if assume_role_arn is not None:
            pulumi.set(__self__, "assume_role_arn", assume_role_arn)
        if auth_provider is not None:
            pulumi.set(__self__, "auth_provider", auth_provider)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)
        if message_format is not None:
            pulumi.set(__self__, "message_format", message_format)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if subject is not None:
            pulumi.set(__self__, "subject", subject)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @_builtins.property
    @pulumi.getter
    def topic(self) -> _builtins.str:
        """
        The Amazon SNS topic to send notifications to.
        """
        return pulumi.get(self, "topic")

    @_builtins.property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[_builtins.str]:
        """
        AWS access key ID used to authenticate with Amazon SNS.
        """
        return pulumi.get(self, "access_key")

    @_builtins.property
    @pulumi.getter(name="assumeRoleArn")
    def assume_role_arn(self) -> Optional[_builtins.str]:
        """
        The Amazon Resource Name (ARN) of the role to assume to send notifications to Amazon SNS.
        """
        return pulumi.get(self, "assume_role_arn")

    @_builtins.property
    @pulumi.getter(name="authProvider")
    def auth_provider(self) -> Optional[_builtins.str]:
        """
        The authentication provider to use. Valid values are `default`, `arn` and `keys`. Default is `default`. Defaults to `default`.
        """
        return pulumi.get(self, "auth_provider")

    @_builtins.property
    @pulumi.getter
    def body(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "body")

    @_builtins.property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[_builtins.bool]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @_builtins.property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[_builtins.str]:
        """
        The external ID to use when assuming the role.
        """
        return pulumi.get(self, "external_id")

    @_builtins.property
    @pulumi.getter(name="messageFormat")
    def message_format(self) -> Optional[_builtins.str]:
        """
        The format of the message to send. Valid values are `text`, `body` and `json`. Default is `text`. Defaults to `text`.
        """
        return pulumi.get(self, "message_format")

    @_builtins.property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[_builtins.str]:
        """
        AWS secret access key used to authenticate with Amazon SNS.
        """
        return pulumi.get(self, "secret_key")

    @_builtins.property
    @pulumi.getter
    def settings(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @_builtins.property
    @pulumi.getter
    def subject(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "subject")

    @_builtins.property
    @pulumi.getter
    def uid(self) -> Optional[_builtins.str]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")


@pulumi.output_type
class ContactPointTeam(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disableResolveMessage":
            suggest = "disable_resolve_message"
        elif key == "sectionTitle":
            suggest = "section_title"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContactPointTeam. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContactPointTeam.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContactPointTeam.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: _builtins.str,
                 disable_resolve_message: Optional[_builtins.bool] = None,
                 message: Optional[_builtins.str] = None,
                 section_title: Optional[_builtins.str] = None,
                 settings: Optional[Mapping[str, _builtins.str]] = None,
                 title: Optional[_builtins.str] = None,
                 uid: Optional[_builtins.str] = None):
        """
        :param _builtins.str url: A Teams webhook URL.
        :param _builtins.bool disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param _builtins.str message: The templated message content to send.
        :param _builtins.str section_title: The templated subtitle for each message section.
        :param Mapping[str, _builtins.str] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param _builtins.str title: The templated title of the message.
        :param _builtins.str uid: The UID of the contact point.
        """
        pulumi.set(__self__, "url", url)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if section_title is not None:
            pulumi.set(__self__, "section_title", section_title)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        A Teams webhook URL.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[_builtins.bool]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[_builtins.str]:
        """
        The templated message content to send.
        """
        return pulumi.get(self, "message")

    @_builtins.property
    @pulumi.getter(name="sectionTitle")
    def section_title(self) -> Optional[_builtins.str]:
        """
        The templated subtitle for each message section.
        """
        return pulumi.get(self, "section_title")

    @_builtins.property
    @pulumi.getter
    def settings(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @_builtins.property
    @pulumi.getter
    def title(self) -> Optional[_builtins.str]:
        """
        The templated title of the message.
        """
        return pulumi.get(self, "title")

    @_builtins.property
    @pulumi.getter
    def uid(self) -> Optional[_builtins.str]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")


@pulumi.output_type
class ContactPointTelegram(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "chatId":
            suggest = "chat_id"
        elif key == "disableNotifications":
            suggest = "disable_notifications"
        elif key == "disableResolveMessage":
            suggest = "disable_resolve_message"
        elif key == "disableWebPagePreview":
            suggest = "disable_web_page_preview"
        elif key == "messageThreadId":
            suggest = "message_thread_id"
        elif key == "parseMode":
            suggest = "parse_mode"
        elif key == "protectContent":
            suggest = "protect_content"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContactPointTelegram. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContactPointTelegram.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContactPointTelegram.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 chat_id: _builtins.str,
                 token: _builtins.str,
                 disable_notifications: Optional[_builtins.bool] = None,
                 disable_resolve_message: Optional[_builtins.bool] = None,
                 disable_web_page_preview: Optional[_builtins.bool] = None,
                 message: Optional[_builtins.str] = None,
                 message_thread_id: Optional[_builtins.str] = None,
                 parse_mode: Optional[_builtins.str] = None,
                 protect_content: Optional[_builtins.bool] = None,
                 settings: Optional[Mapping[str, _builtins.str]] = None,
                 uid: Optional[_builtins.str] = None):
        """
        :param _builtins.str chat_id: The chat ID to send messages to.
        :param _builtins.str token: The Telegram bot token.
        :param _builtins.bool disable_notifications: When set users will receive a notification with no sound.
        :param _builtins.bool disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param _builtins.bool disable_web_page_preview: When set it disables link previews for links in the message.
        :param _builtins.str message: The templated content of the message.
        :param _builtins.str message_thread_id: The ID of the message thread to send the message to.
        :param _builtins.str parse_mode: Mode for parsing entities in the message text. Supported: None, Markdown, MarkdownV2, and HTML. HTML is the default.
        :param _builtins.bool protect_content: When set it protects the contents of the message from forwarding and saving.
        :param Mapping[str, _builtins.str] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param _builtins.str uid: The UID of the contact point.
        """
        pulumi.set(__self__, "chat_id", chat_id)
        pulumi.set(__self__, "token", token)
        if disable_notifications is not None:
            pulumi.set(__self__, "disable_notifications", disable_notifications)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if disable_web_page_preview is not None:
            pulumi.set(__self__, "disable_web_page_preview", disable_web_page_preview)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if message_thread_id is not None:
            pulumi.set(__self__, "message_thread_id", message_thread_id)
        if parse_mode is not None:
            pulumi.set(__self__, "parse_mode", parse_mode)
        if protect_content is not None:
            pulumi.set(__self__, "protect_content", protect_content)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @_builtins.property
    @pulumi.getter(name="chatId")
    def chat_id(self) -> _builtins.str:
        """
        The chat ID to send messages to.
        """
        return pulumi.get(self, "chat_id")

    @_builtins.property
    @pulumi.getter
    def token(self) -> _builtins.str:
        """
        The Telegram bot token.
        """
        return pulumi.get(self, "token")

    @_builtins.property
    @pulumi.getter(name="disableNotifications")
    def disable_notifications(self) -> Optional[_builtins.bool]:
        """
        When set users will receive a notification with no sound.
        """
        return pulumi.get(self, "disable_notifications")

    @_builtins.property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[_builtins.bool]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @_builtins.property
    @pulumi.getter(name="disableWebPagePreview")
    def disable_web_page_preview(self) -> Optional[_builtins.bool]:
        """
        When set it disables link previews for links in the message.
        """
        return pulumi.get(self, "disable_web_page_preview")

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[_builtins.str]:
        """
        The templated content of the message.
        """
        return pulumi.get(self, "message")

    @_builtins.property
    @pulumi.getter(name="messageThreadId")
    def message_thread_id(self) -> Optional[_builtins.str]:
        """
        The ID of the message thread to send the message to.
        """
        return pulumi.get(self, "message_thread_id")

    @_builtins.property
    @pulumi.getter(name="parseMode")
    def parse_mode(self) -> Optional[_builtins.str]:
        """
        Mode for parsing entities in the message text. Supported: None, Markdown, MarkdownV2, and HTML. HTML is the default.
        """
        return pulumi.get(self, "parse_mode")

    @_builtins.property
    @pulumi.getter(name="protectContent")
    def protect_content(self) -> Optional[_builtins.bool]:
        """
        When set it protects the contents of the message from forwarding and saving.
        """
        return pulumi.get(self, "protect_content")

    @_builtins.property
    @pulumi.getter
    def settings(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @_builtins.property
    @pulumi.getter
    def uid(self) -> Optional[_builtins.str]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")


@pulumi.output_type
class ContactPointThreema(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiSecret":
            suggest = "api_secret"
        elif key == "gatewayId":
            suggest = "gateway_id"
        elif key == "recipientId":
            suggest = "recipient_id"
        elif key == "disableResolveMessage":
            suggest = "disable_resolve_message"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContactPointThreema. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContactPointThreema.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContactPointThreema.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_secret: _builtins.str,
                 gateway_id: _builtins.str,
                 recipient_id: _builtins.str,
                 description: Optional[_builtins.str] = None,
                 disable_resolve_message: Optional[_builtins.bool] = None,
                 settings: Optional[Mapping[str, _builtins.str]] = None,
                 title: Optional[_builtins.str] = None,
                 uid: Optional[_builtins.str] = None):
        """
        :param _builtins.str api_secret: The Threema API key.
        :param _builtins.str gateway_id: The Threema gateway ID.
        :param _builtins.str recipient_id: The ID of the recipient of the message.
        :param _builtins.str description: The templated description of the message.
        :param _builtins.bool disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param Mapping[str, _builtins.str] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param _builtins.str title: The templated title of the message.
        :param _builtins.str uid: The UID of the contact point.
        """
        pulumi.set(__self__, "api_secret", api_secret)
        pulumi.set(__self__, "gateway_id", gateway_id)
        pulumi.set(__self__, "recipient_id", recipient_id)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @_builtins.property
    @pulumi.getter(name="apiSecret")
    def api_secret(self) -> _builtins.str:
        """
        The Threema API key.
        """
        return pulumi.get(self, "api_secret")

    @_builtins.property
    @pulumi.getter(name="gatewayId")
    def gateway_id(self) -> _builtins.str:
        """
        The Threema gateway ID.
        """
        return pulumi.get(self, "gateway_id")

    @_builtins.property
    @pulumi.getter(name="recipientId")
    def recipient_id(self) -> _builtins.str:
        """
        The ID of the recipient of the message.
        """
        return pulumi.get(self, "recipient_id")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        The templated description of the message.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[_builtins.bool]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @_builtins.property
    @pulumi.getter
    def settings(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @_builtins.property
    @pulumi.getter
    def title(self) -> Optional[_builtins.str]:
        """
        The templated title of the message.
        """
        return pulumi.get(self, "title")

    @_builtins.property
    @pulumi.getter
    def uid(self) -> Optional[_builtins.str]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")


@pulumi.output_type
class ContactPointVictorop(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disableResolveMessage":
            suggest = "disable_resolve_message"
        elif key == "messageType":
            suggest = "message_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContactPointVictorop. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContactPointVictorop.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContactPointVictorop.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: _builtins.str,
                 description: Optional[_builtins.str] = None,
                 disable_resolve_message: Optional[_builtins.bool] = None,
                 message_type: Optional[_builtins.str] = None,
                 settings: Optional[Mapping[str, _builtins.str]] = None,
                 title: Optional[_builtins.str] = None,
                 uid: Optional[_builtins.str] = None):
        """
        :param _builtins.str url: The VictorOps webhook URL.
        :param _builtins.str description: Templated description of the message.
        :param _builtins.bool disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param _builtins.str message_type: The VictorOps alert state - typically either `CRITICAL` or `RECOVERY`.
        :param Mapping[str, _builtins.str] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param _builtins.str title: Templated title to display.
        :param _builtins.str uid: The UID of the contact point.
        """
        pulumi.set(__self__, "url", url)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if message_type is not None:
            pulumi.set(__self__, "message_type", message_type)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        The VictorOps webhook URL.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Templated description of the message.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[_builtins.bool]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @_builtins.property
    @pulumi.getter(name="messageType")
    def message_type(self) -> Optional[_builtins.str]:
        """
        The VictorOps alert state - typically either `CRITICAL` or `RECOVERY`.
        """
        return pulumi.get(self, "message_type")

    @_builtins.property
    @pulumi.getter
    def settings(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @_builtins.property
    @pulumi.getter
    def title(self) -> Optional[_builtins.str]:
        """
        Templated title to display.
        """
        return pulumi.get(self, "title")

    @_builtins.property
    @pulumi.getter
    def uid(self) -> Optional[_builtins.str]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")


@pulumi.output_type
class ContactPointWebex(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "roomId":
            suggest = "room_id"
        elif key == "apiUrl":
            suggest = "api_url"
        elif key == "disableResolveMessage":
            suggest = "disable_resolve_message"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContactPointWebex. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContactPointWebex.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContactPointWebex.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 room_id: _builtins.str,
                 token: _builtins.str,
                 api_url: Optional[_builtins.str] = None,
                 disable_resolve_message: Optional[_builtins.bool] = None,
                 message: Optional[_builtins.str] = None,
                 settings: Optional[Mapping[str, _builtins.str]] = None,
                 uid: Optional[_builtins.str] = None):
        """
        :param _builtins.str room_id: ID of the Webex Teams room where to send the messages.
        :param _builtins.str token: The bearer token used to authorize the client.
        :param _builtins.str api_url: The URL to send webhook requests to.
        :param _builtins.bool disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param _builtins.str message: The templated title of the message to send.
        :param Mapping[str, _builtins.str] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param _builtins.str uid: The UID of the contact point.
        """
        pulumi.set(__self__, "room_id", room_id)
        pulumi.set(__self__, "token", token)
        if api_url is not None:
            pulumi.set(__self__, "api_url", api_url)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @_builtins.property
    @pulumi.getter(name="roomId")
    def room_id(self) -> _builtins.str:
        """
        ID of the Webex Teams room where to send the messages.
        """
        return pulumi.get(self, "room_id")

    @_builtins.property
    @pulumi.getter
    def token(self) -> _builtins.str:
        """
        The bearer token used to authorize the client.
        """
        return pulumi.get(self, "token")

    @_builtins.property
    @pulumi.getter(name="apiUrl")
    def api_url(self) -> Optional[_builtins.str]:
        """
        The URL to send webhook requests to.
        """
        return pulumi.get(self, "api_url")

    @_builtins.property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[_builtins.bool]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[_builtins.str]:
        """
        The templated title of the message to send.
        """
        return pulumi.get(self, "message")

    @_builtins.property
    @pulumi.getter
    def settings(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @_builtins.property
    @pulumi.getter
    def uid(self) -> Optional[_builtins.str]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")


@pulumi.output_type
class ContactPointWebhook(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authorizationCredentials":
            suggest = "authorization_credentials"
        elif key == "authorizationScheme":
            suggest = "authorization_scheme"
        elif key == "basicAuthPassword":
            suggest = "basic_auth_password"
        elif key == "basicAuthUser":
            suggest = "basic_auth_user"
        elif key == "disableResolveMessage":
            suggest = "disable_resolve_message"
        elif key == "hmacConfig":
            suggest = "hmac_config"
        elif key == "httpConfig":
            suggest = "http_config"
        elif key == "httpMethod":
            suggest = "http_method"
        elif key == "maxAlerts":
            suggest = "max_alerts"
        elif key == "tlsConfig":
            suggest = "tls_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContactPointWebhook. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContactPointWebhook.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContactPointWebhook.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: _builtins.str,
                 authorization_credentials: Optional[_builtins.str] = None,
                 authorization_scheme: Optional[_builtins.str] = None,
                 basic_auth_password: Optional[_builtins.str] = None,
                 basic_auth_user: Optional[_builtins.str] = None,
                 disable_resolve_message: Optional[_builtins.bool] = None,
                 headers: Optional[Mapping[str, _builtins.str]] = None,
                 hmac_config: Optional['outputs.ContactPointWebhookHmacConfig'] = None,
                 http_config: Optional['outputs.ContactPointWebhookHttpConfig'] = None,
                 http_method: Optional[_builtins.str] = None,
                 max_alerts: Optional[_builtins.int] = None,
                 message: Optional[_builtins.str] = None,
                 payload: Optional['outputs.ContactPointWebhookPayload'] = None,
                 settings: Optional[Mapping[str, _builtins.str]] = None,
                 title: Optional[_builtins.str] = None,
                 tls_config: Optional[Mapping[str, _builtins.str]] = None,
                 uid: Optional[_builtins.str] = None):
        """
        :param _builtins.str url: The URL to send webhook requests to.
        :param _builtins.str authorization_credentials: Allows a custom authorization scheme - attaches an auth header with this value. Do not use in conjunction with basic auth parameters.
        :param _builtins.str authorization_scheme: Allows a custom authorization scheme - attaches an auth header with this name. Do not use in conjunction with basic auth parameters.
        :param _builtins.str basic_auth_password: The username to use in basic auth headers attached to the request. If omitted, basic auth will not be used.
        :param _builtins.str basic_auth_user: The username to use in basic auth headers attached to the request. If omitted, basic auth will not be used.
        :param _builtins.bool disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param Mapping[str, _builtins.str] headers: Custom headers to attach to the request.
        :param 'ContactPointWebhookHmacConfigArgs' hmac_config: HMAC signature configuration options.
        :param 'ContactPointWebhookHttpConfigArgs' http_config: Common HTTP client options.
        :param _builtins.str http_method: The HTTP method to use in the request. Defaults to `POST`.
        :param _builtins.int max_alerts: The maximum number of alerts to send in a single request. This can be helpful in limiting the size of the request body. The default is 0, which indicates no limit.
        :param _builtins.str message: Custom message. You can use template variables.
        :param 'ContactPointWebhookPayloadArgs' payload: Optionally provide a templated payload. Overrides 'Message' and 'Title' field.
        :param Mapping[str, _builtins.str] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param _builtins.str title: Templated title of the message.
        :param Mapping[str, _builtins.str] tls_config: Allows configuring TLS for the webhook notifier.
        :param _builtins.str uid: The UID of the contact point.
        """
        pulumi.set(__self__, "url", url)
        if authorization_credentials is not None:
            pulumi.set(__self__, "authorization_credentials", authorization_credentials)
        if authorization_scheme is not None:
            pulumi.set(__self__, "authorization_scheme", authorization_scheme)
        if basic_auth_password is not None:
            pulumi.set(__self__, "basic_auth_password", basic_auth_password)
        if basic_auth_user is not None:
            pulumi.set(__self__, "basic_auth_user", basic_auth_user)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if hmac_config is not None:
            pulumi.set(__self__, "hmac_config", hmac_config)
        if http_config is not None:
            pulumi.set(__self__, "http_config", http_config)
        if http_method is not None:
            pulumi.set(__self__, "http_method", http_method)
        if max_alerts is not None:
            pulumi.set(__self__, "max_alerts", max_alerts)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if payload is not None:
            pulumi.set(__self__, "payload", payload)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if tls_config is not None:
            pulumi.set(__self__, "tls_config", tls_config)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        The URL to send webhook requests to.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="authorizationCredentials")
    def authorization_credentials(self) -> Optional[_builtins.str]:
        """
        Allows a custom authorization scheme - attaches an auth header with this value. Do not use in conjunction with basic auth parameters.
        """
        return pulumi.get(self, "authorization_credentials")

    @_builtins.property
    @pulumi.getter(name="authorizationScheme")
    def authorization_scheme(self) -> Optional[_builtins.str]:
        """
        Allows a custom authorization scheme - attaches an auth header with this name. Do not use in conjunction with basic auth parameters.
        """
        return pulumi.get(self, "authorization_scheme")

    @_builtins.property
    @pulumi.getter(name="basicAuthPassword")
    def basic_auth_password(self) -> Optional[_builtins.str]:
        """
        The username to use in basic auth headers attached to the request. If omitted, basic auth will not be used.
        """
        return pulumi.get(self, "basic_auth_password")

    @_builtins.property
    @pulumi.getter(name="basicAuthUser")
    def basic_auth_user(self) -> Optional[_builtins.str]:
        """
        The username to use in basic auth headers attached to the request. If omitted, basic auth will not be used.
        """
        return pulumi.get(self, "basic_auth_user")

    @_builtins.property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[_builtins.bool]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Custom headers to attach to the request.
        """
        return pulumi.get(self, "headers")

    @_builtins.property
    @pulumi.getter(name="hmacConfig")
    def hmac_config(self) -> Optional['outputs.ContactPointWebhookHmacConfig']:
        """
        HMAC signature configuration options.
        """
        return pulumi.get(self, "hmac_config")

    @_builtins.property
    @pulumi.getter(name="httpConfig")
    def http_config(self) -> Optional['outputs.ContactPointWebhookHttpConfig']:
        """
        Common HTTP client options.
        """
        return pulumi.get(self, "http_config")

    @_builtins.property
    @pulumi.getter(name="httpMethod")
    def http_method(self) -> Optional[_builtins.str]:
        """
        The HTTP method to use in the request. Defaults to `POST`.
        """
        return pulumi.get(self, "http_method")

    @_builtins.property
    @pulumi.getter(name="maxAlerts")
    def max_alerts(self) -> Optional[_builtins.int]:
        """
        The maximum number of alerts to send in a single request. This can be helpful in limiting the size of the request body. The default is 0, which indicates no limit.
        """
        return pulumi.get(self, "max_alerts")

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[_builtins.str]:
        """
        Custom message. You can use template variables.
        """
        return pulumi.get(self, "message")

    @_builtins.property
    @pulumi.getter
    def payload(self) -> Optional['outputs.ContactPointWebhookPayload']:
        """
        Optionally provide a templated payload. Overrides 'Message' and 'Title' field.
        """
        return pulumi.get(self, "payload")

    @_builtins.property
    @pulumi.getter
    def settings(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @_builtins.property
    @pulumi.getter
    def title(self) -> Optional[_builtins.str]:
        """
        Templated title of the message.
        """
        return pulumi.get(self, "title")

    @_builtins.property
    @pulumi.getter(name="tlsConfig")
    def tls_config(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Allows configuring TLS for the webhook notifier.
        """
        return pulumi.get(self, "tls_config")

    @_builtins.property
    @pulumi.getter
    def uid(self) -> Optional[_builtins.str]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")


@pulumi.output_type
class ContactPointWebhookHmacConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "timestampHeader":
            suggest = "timestamp_header"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContactPointWebhookHmacConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContactPointWebhookHmacConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContactPointWebhookHmacConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 secret: _builtins.str,
                 header: Optional[_builtins.str] = None,
                 timestamp_header: Optional[_builtins.str] = None):
        """
        :param _builtins.str secret: The secret key used to generate the HMAC signature.
        :param _builtins.str header: The header in which the HMAC signature will be included. Defaults to `X-Grafana-Alerting-Signature`.
        :param _builtins.str timestamp_header: If set, the timestamp will be included in the HMAC signature. The value should be the name of the header to use.
        """
        pulumi.set(__self__, "secret", secret)
        if header is not None:
            pulumi.set(__self__, "header", header)
        if timestamp_header is not None:
            pulumi.set(__self__, "timestamp_header", timestamp_header)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> _builtins.str:
        """
        The secret key used to generate the HMAC signature.
        """
        return pulumi.get(self, "secret")

    @_builtins.property
    @pulumi.getter
    def header(self) -> Optional[_builtins.str]:
        """
        The header in which the HMAC signature will be included. Defaults to `X-Grafana-Alerting-Signature`.
        """
        return pulumi.get(self, "header")

    @_builtins.property
    @pulumi.getter(name="timestampHeader")
    def timestamp_header(self) -> Optional[_builtins.str]:
        """
        If set, the timestamp will be included in the HMAC signature. The value should be the name of the header to use.
        """
        return pulumi.get(self, "timestamp_header")


@pulumi.output_type
class ContactPointWebhookHttpConfig(dict):
    def __init__(__self__, *,
                 oauth2: Optional['outputs.ContactPointWebhookHttpConfigOauth2'] = None):
        """
        :param 'ContactPointWebhookHttpConfigOauth2Args' oauth2: OAuth2 configuration options.
        """
        if oauth2 is not None:
            pulumi.set(__self__, "oauth2", oauth2)

    @_builtins.property
    @pulumi.getter
    def oauth2(self) -> Optional['outputs.ContactPointWebhookHttpConfigOauth2']:
        """
        OAuth2 configuration options.
        """
        return pulumi.get(self, "oauth2")


@pulumi.output_type
class ContactPointWebhookHttpConfigOauth2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "tokenUrl":
            suggest = "token_url"
        elif key == "endpointParams":
            suggest = "endpoint_params"
        elif key == "proxyConfig":
            suggest = "proxy_config"
        elif key == "tlsConfig":
            suggest = "tls_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContactPointWebhookHttpConfigOauth2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContactPointWebhookHttpConfigOauth2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContactPointWebhookHttpConfigOauth2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: _builtins.str,
                 client_secret: _builtins.str,
                 token_url: _builtins.str,
                 endpoint_params: Optional[Mapping[str, _builtins.str]] = None,
                 proxy_config: Optional['outputs.ContactPointWebhookHttpConfigOauth2ProxyConfig'] = None,
                 scopes: Optional[Sequence[_builtins.str]] = None,
                 tls_config: Optional['outputs.ContactPointWebhookHttpConfigOauth2TlsConfig'] = None):
        """
        :param _builtins.str client_id: Client ID to use when authenticating.
        :param _builtins.str client_secret: Client secret to use when authenticating.
        :param _builtins.str token_url: URL for the access token endpoint.
        :param Mapping[str, _builtins.str] endpoint_params: Optional parameters to append to the access token request.
        :param 'ContactPointWebhookHttpConfigOauth2ProxyConfigArgs' proxy_config: Optional proxy configuration for OAuth2 requests.
        :param Sequence[_builtins.str] scopes: Optional scopes to request when obtaining an access token.
        :param 'ContactPointWebhookHttpConfigOauth2TlsConfigArgs' tls_config: Optional TLS configuration options for OAuth2 requests.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "token_url", token_url)
        if endpoint_params is not None:
            pulumi.set(__self__, "endpoint_params", endpoint_params)
        if proxy_config is not None:
            pulumi.set(__self__, "proxy_config", proxy_config)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if tls_config is not None:
            pulumi.set(__self__, "tls_config", tls_config)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> _builtins.str:
        """
        Client ID to use when authenticating.
        """
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> _builtins.str:
        """
        Client secret to use when authenticating.
        """
        return pulumi.get(self, "client_secret")

    @_builtins.property
    @pulumi.getter(name="tokenUrl")
    def token_url(self) -> _builtins.str:
        """
        URL for the access token endpoint.
        """
        return pulumi.get(self, "token_url")

    @_builtins.property
    @pulumi.getter(name="endpointParams")
    def endpoint_params(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Optional parameters to append to the access token request.
        """
        return pulumi.get(self, "endpoint_params")

    @_builtins.property
    @pulumi.getter(name="proxyConfig")
    def proxy_config(self) -> Optional['outputs.ContactPointWebhookHttpConfigOauth2ProxyConfig']:
        """
        Optional proxy configuration for OAuth2 requests.
        """
        return pulumi.get(self, "proxy_config")

    @_builtins.property
    @pulumi.getter
    def scopes(self) -> Optional[Sequence[_builtins.str]]:
        """
        Optional scopes to request when obtaining an access token.
        """
        return pulumi.get(self, "scopes")

    @_builtins.property
    @pulumi.getter(name="tlsConfig")
    def tls_config(self) -> Optional['outputs.ContactPointWebhookHttpConfigOauth2TlsConfig']:
        """
        Optional TLS configuration options for OAuth2 requests.
        """
        return pulumi.get(self, "tls_config")


@pulumi.output_type
class ContactPointWebhookHttpConfigOauth2ProxyConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "noProxy":
            suggest = "no_proxy"
        elif key == "proxyConnectHeader":
            suggest = "proxy_connect_header"
        elif key == "proxyFromEnvironment":
            suggest = "proxy_from_environment"
        elif key == "proxyUrl":
            suggest = "proxy_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContactPointWebhookHttpConfigOauth2ProxyConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContactPointWebhookHttpConfigOauth2ProxyConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContactPointWebhookHttpConfigOauth2ProxyConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 no_proxy: Optional[_builtins.str] = None,
                 proxy_connect_header: Optional[Mapping[str, _builtins.str]] = None,
                 proxy_from_environment: Optional[_builtins.bool] = None,
                 proxy_url: Optional[_builtins.str] = None):
        """
        :param _builtins.str no_proxy: Comma-separated list of addresses that should not use a proxy.
        :param Mapping[str, _builtins.str] proxy_connect_header: Optional headers to send to proxies during CONNECT requests.
        :param _builtins.bool proxy_from_environment: Use environment HTTP*PROXY, HTTPS*PROXY and NO_PROXY to determine proxies. Defaults to `false`.
        :param _builtins.str proxy_url: HTTP proxy server to use to connect to the targets.
        """
        if no_proxy is not None:
            pulumi.set(__self__, "no_proxy", no_proxy)
        if proxy_connect_header is not None:
            pulumi.set(__self__, "proxy_connect_header", proxy_connect_header)
        if proxy_from_environment is not None:
            pulumi.set(__self__, "proxy_from_environment", proxy_from_environment)
        if proxy_url is not None:
            pulumi.set(__self__, "proxy_url", proxy_url)

    @_builtins.property
    @pulumi.getter(name="noProxy")
    def no_proxy(self) -> Optional[_builtins.str]:
        """
        Comma-separated list of addresses that should not use a proxy.
        """
        return pulumi.get(self, "no_proxy")

    @_builtins.property
    @pulumi.getter(name="proxyConnectHeader")
    def proxy_connect_header(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Optional headers to send to proxies during CONNECT requests.
        """
        return pulumi.get(self, "proxy_connect_header")

    @_builtins.property
    @pulumi.getter(name="proxyFromEnvironment")
    def proxy_from_environment(self) -> Optional[_builtins.bool]:
        """
        Use environment HTTP*PROXY, HTTPS*PROXY and NO_PROXY to determine proxies. Defaults to `false`.
        """
        return pulumi.get(self, "proxy_from_environment")

    @_builtins.property
    @pulumi.getter(name="proxyUrl")
    def proxy_url(self) -> Optional[_builtins.str]:
        """
        HTTP proxy server to use to connect to the targets.
        """
        return pulumi.get(self, "proxy_url")


@pulumi.output_type
class ContactPointWebhookHttpConfigOauth2TlsConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caCertificate":
            suggest = "ca_certificate"
        elif key == "clientCertificate":
            suggest = "client_certificate"
        elif key == "clientKey":
            suggest = "client_key"
        elif key == "insecureSkipVerify":
            suggest = "insecure_skip_verify"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContactPointWebhookHttpConfigOauth2TlsConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContactPointWebhookHttpConfigOauth2TlsConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContactPointWebhookHttpConfigOauth2TlsConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ca_certificate: Optional[_builtins.str] = None,
                 client_certificate: Optional[_builtins.str] = None,
                 client_key: Optional[_builtins.str] = None,
                 insecure_skip_verify: Optional[_builtins.bool] = None):
        """
        :param _builtins.str ca_certificate: Certificate in PEM format to use when verifying the server's certificate chain.
        :param _builtins.str client_certificate: Client certificate in PEM format to use when connecting to the server.
        :param _builtins.str client_key: Client key in PEM format to use when connecting to the server.
        :param _builtins.bool insecure_skip_verify: Do not verify the server's certificate chain and host name. Defaults to `false`.
        """
        if ca_certificate is not None:
            pulumi.set(__self__, "ca_certificate", ca_certificate)
        if client_certificate is not None:
            pulumi.set(__self__, "client_certificate", client_certificate)
        if client_key is not None:
            pulumi.set(__self__, "client_key", client_key)
        if insecure_skip_verify is not None:
            pulumi.set(__self__, "insecure_skip_verify", insecure_skip_verify)

    @_builtins.property
    @pulumi.getter(name="caCertificate")
    def ca_certificate(self) -> Optional[_builtins.str]:
        """
        Certificate in PEM format to use when verifying the server's certificate chain.
        """
        return pulumi.get(self, "ca_certificate")

    @_builtins.property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> Optional[_builtins.str]:
        """
        Client certificate in PEM format to use when connecting to the server.
        """
        return pulumi.get(self, "client_certificate")

    @_builtins.property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> Optional[_builtins.str]:
        """
        Client key in PEM format to use when connecting to the server.
        """
        return pulumi.get(self, "client_key")

    @_builtins.property
    @pulumi.getter(name="insecureSkipVerify")
    def insecure_skip_verify(self) -> Optional[_builtins.bool]:
        """
        Do not verify the server's certificate chain and host name. Defaults to `false`.
        """
        return pulumi.get(self, "insecure_skip_verify")


@pulumi.output_type
class ContactPointWebhookPayload(dict):
    def __init__(__self__, *,
                 template: _builtins.str,
                 vars: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str template: Custom payload template.
        :param Mapping[str, _builtins.str] vars: Optionally provide a variables to be used in the payload template. They will be available in the template as `.Vars.<variable_name>`.
        """
        pulumi.set(__self__, "template", template)
        if vars is not None:
            pulumi.set(__self__, "vars", vars)

    @_builtins.property
    @pulumi.getter
    def template(self) -> _builtins.str:
        """
        Custom payload template.
        """
        return pulumi.get(self, "template")

    @_builtins.property
    @pulumi.getter
    def vars(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Optionally provide a variables to be used in the payload template. They will be available in the template as `.Vars.<variable_name>`.
        """
        return pulumi.get(self, "vars")


@pulumi.output_type
class ContactPointWecom(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "agentId":
            suggest = "agent_id"
        elif key == "corpId":
            suggest = "corp_id"
        elif key == "disableResolveMessage":
            suggest = "disable_resolve_message"
        elif key == "msgType":
            suggest = "msg_type"
        elif key == "toUser":
            suggest = "to_user"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContactPointWecom. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContactPointWecom.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContactPointWecom.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 agent_id: Optional[_builtins.str] = None,
                 corp_id: Optional[_builtins.str] = None,
                 disable_resolve_message: Optional[_builtins.bool] = None,
                 message: Optional[_builtins.str] = None,
                 msg_type: Optional[_builtins.str] = None,
                 secret: Optional[_builtins.str] = None,
                 settings: Optional[Mapping[str, _builtins.str]] = None,
                 title: Optional[_builtins.str] = None,
                 to_user: Optional[_builtins.str] = None,
                 uid: Optional[_builtins.str] = None,
                 url: Optional[_builtins.str] = None):
        """
        :param _builtins.str agent_id: Agent ID added to the request payload when using APIAPP.
        :param _builtins.str corp_id: Corp ID used to get token when using APIAPP.
        :param _builtins.bool disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param _builtins.str message: The templated content of the message to send.
        :param _builtins.str msg_type: The type of them message. Supported: markdown, text. Default: text.
        :param _builtins.str secret: The secret key required to obtain access token when using APIAPP. See https://work.weixin.qq.com/wework_admin/frame#apps to create APIAPP.
        :param Mapping[str, _builtins.str] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param _builtins.str title: The templated title of the message to send.
        :param _builtins.str to_user: The ID of user that should receive the message. Multiple entries should be separated by '|'. Default: @all.
        :param _builtins.str uid: The UID of the contact point.
        :param _builtins.str url: The WeCom webhook URL. Required if using GroupRobot.
        """
        if agent_id is not None:
            pulumi.set(__self__, "agent_id", agent_id)
        if corp_id is not None:
            pulumi.set(__self__, "corp_id", corp_id)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if msg_type is not None:
            pulumi.set(__self__, "msg_type", msg_type)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if to_user is not None:
            pulumi.set(__self__, "to_user", to_user)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter(name="agentId")
    def agent_id(self) -> Optional[_builtins.str]:
        """
        Agent ID added to the request payload when using APIAPP.
        """
        return pulumi.get(self, "agent_id")

    @_builtins.property
    @pulumi.getter(name="corpId")
    def corp_id(self) -> Optional[_builtins.str]:
        """
        Corp ID used to get token when using APIAPP.
        """
        return pulumi.get(self, "corp_id")

    @_builtins.property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[_builtins.bool]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[_builtins.str]:
        """
        The templated content of the message to send.
        """
        return pulumi.get(self, "message")

    @_builtins.property
    @pulumi.getter(name="msgType")
    def msg_type(self) -> Optional[_builtins.str]:
        """
        The type of them message. Supported: markdown, text. Default: text.
        """
        return pulumi.get(self, "msg_type")

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional[_builtins.str]:
        """
        The secret key required to obtain access token when using APIAPP. See https://work.weixin.qq.com/wework_admin/frame#apps to create APIAPP.
        """
        return pulumi.get(self, "secret")

    @_builtins.property
    @pulumi.getter
    def settings(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @_builtins.property
    @pulumi.getter
    def title(self) -> Optional[_builtins.str]:
        """
        The templated title of the message to send.
        """
        return pulumi.get(self, "title")

    @_builtins.property
    @pulumi.getter(name="toUser")
    def to_user(self) -> Optional[_builtins.str]:
        """
        The ID of user that should receive the message. Multiple entries should be separated by '|'. Default: @all.
        """
        return pulumi.get(self, "to_user")

    @_builtins.property
    @pulumi.getter
    def uid(self) -> Optional[_builtins.str]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        The WeCom webhook URL. Required if using GroupRobot.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class MuteTimingInterval(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "daysOfMonths":
            suggest = "days_of_months"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MuteTimingInterval. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MuteTimingInterval.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MuteTimingInterval.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 days_of_months: Optional[Sequence[_builtins.str]] = None,
                 location: Optional[_builtins.str] = None,
                 months: Optional[Sequence[_builtins.str]] = None,
                 times: Optional[Sequence['outputs.MuteTimingIntervalTime']] = None,
                 weekdays: Optional[Sequence[_builtins.str]] = None,
                 years: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] days_of_months: An inclusive range of days, 1-31, within a month, e.g. "1" or "14:16". Negative values can be used to represent days counting from the end of a month, e.g. "-1".
        :param _builtins.str location: Provides the time zone for the time interval. Must be a location in the IANA time zone database, e.g "America/New_York"
        :param Sequence[_builtins.str] months: An inclusive range of months, either numerical or full calendar month, e.g. "1:3", "december", or "may:august".
        :param Sequence['MuteTimingIntervalTimeArgs'] times: The time ranges, represented in minutes, during which to mute in a given day.
        :param Sequence[_builtins.str] weekdays: An inclusive range of weekdays, e.g. "monday" or "tuesday:thursday".
        :param Sequence[_builtins.str] years: A positive inclusive range of years, e.g. "2030" or "2025:2026".
        """
        if days_of_months is not None:
            pulumi.set(__self__, "days_of_months", days_of_months)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if months is not None:
            pulumi.set(__self__, "months", months)
        if times is not None:
            pulumi.set(__self__, "times", times)
        if weekdays is not None:
            pulumi.set(__self__, "weekdays", weekdays)
        if years is not None:
            pulumi.set(__self__, "years", years)

    @_builtins.property
    @pulumi.getter(name="daysOfMonths")
    def days_of_months(self) -> Optional[Sequence[_builtins.str]]:
        """
        An inclusive range of days, 1-31, within a month, e.g. "1" or "14:16". Negative values can be used to represent days counting from the end of a month, e.g. "-1".
        """
        return pulumi.get(self, "days_of_months")

    @_builtins.property
    @pulumi.getter
    def location(self) -> Optional[_builtins.str]:
        """
        Provides the time zone for the time interval. Must be a location in the IANA time zone database, e.g "America/New_York"
        """
        return pulumi.get(self, "location")

    @_builtins.property
    @pulumi.getter
    def months(self) -> Optional[Sequence[_builtins.str]]:
        """
        An inclusive range of months, either numerical or full calendar month, e.g. "1:3", "december", or "may:august".
        """
        return pulumi.get(self, "months")

    @_builtins.property
    @pulumi.getter
    def times(self) -> Optional[Sequence['outputs.MuteTimingIntervalTime']]:
        """
        The time ranges, represented in minutes, during which to mute in a given day.
        """
        return pulumi.get(self, "times")

    @_builtins.property
    @pulumi.getter
    def weekdays(self) -> Optional[Sequence[_builtins.str]]:
        """
        An inclusive range of weekdays, e.g. "monday" or "tuesday:thursday".
        """
        return pulumi.get(self, "weekdays")

    @_builtins.property
    @pulumi.getter
    def years(self) -> Optional[Sequence[_builtins.str]]:
        """
        A positive inclusive range of years, e.g. "2030" or "2025:2026".
        """
        return pulumi.get(self, "years")


@pulumi.output_type
class MuteTimingIntervalTime(dict):
    def __init__(__self__, *,
                 end: _builtins.str,
                 start: _builtins.str):
        """
        :param _builtins.str end: The time, in hh:mm format, of when the interval should end exclusively.
        :param _builtins.str start: The time, in hh:mm format, of when the interval should begin inclusively.
        """
        pulumi.set(__self__, "end", end)
        pulumi.set(__self__, "start", start)

    @_builtins.property
    @pulumi.getter
    def end(self) -> _builtins.str:
        """
        The time, in hh:mm format, of when the interval should end exclusively.
        """
        return pulumi.get(self, "end")

    @_builtins.property
    @pulumi.getter
    def start(self) -> _builtins.str:
        """
        The time, in hh:mm format, of when the interval should begin inclusively.
        """
        return pulumi.get(self, "start")


@pulumi.output_type
class NotificationPolicyPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "activeTimings":
            suggest = "active_timings"
        elif key == "contactPoint":
            suggest = "contact_point"
        elif key == "continue":
            suggest = "continue_"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "groupInterval":
            suggest = "group_interval"
        elif key == "groupWait":
            suggest = "group_wait"
        elif key == "muteTimings":
            suggest = "mute_timings"
        elif key == "repeatInterval":
            suggest = "repeat_interval"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotificationPolicyPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotificationPolicyPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotificationPolicyPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 active_timings: Optional[Sequence[_builtins.str]] = None,
                 contact_point: Optional[_builtins.str] = None,
                 continue_: Optional[_builtins.bool] = None,
                 group_bies: Optional[Sequence[_builtins.str]] = None,
                 group_interval: Optional[_builtins.str] = None,
                 group_wait: Optional[_builtins.str] = None,
                 matchers: Optional[Sequence['outputs.NotificationPolicyPolicyMatcher']] = None,
                 mute_timings: Optional[Sequence[_builtins.str]] = None,
                 policies: Optional[Sequence['outputs.NotificationPolicyPolicyPolicy']] = None,
                 repeat_interval: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] active_timings: A list of time interval names to apply to alerts that match this policy to suppress them unless they are sent at the specified time. Supported in Grafana 12.1.0 and later
        :param _builtins.str contact_point: The contact point to route notifications that match this rule to.
        :param _builtins.bool continue_: Whether to continue matching subsequent rules if an alert matches the current rule. Otherwise, the rule will be 'consumed' by the first policy to match it.
        :param Sequence[_builtins.str] group_bies: A list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping. Required for root policy only. If empty, the parent grouping is used.
        :param _builtins.str group_interval: Minimum time interval between two notifications for the same group. Default is 5 minutes.
        :param _builtins.str group_wait: Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.
        :param Sequence['NotificationPolicyPolicyMatcherArgs'] matchers: Describes which labels this rule should match. When multiple matchers are supplied, an alert must match ALL matchers to be accepted by this policy. When no matchers are supplied, the rule will match all alert instances.
        :param Sequence[_builtins.str] mute_timings: A list of time intervals to apply to alerts that match this policy to mute them for the specified time.
        :param Sequence['NotificationPolicyPolicyPolicyArgs'] policies: Routing rules for specific label sets.
        :param _builtins.str repeat_interval: Minimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.
        """
        if active_timings is not None:
            pulumi.set(__self__, "active_timings", active_timings)
        if contact_point is not None:
            pulumi.set(__self__, "contact_point", contact_point)
        if continue_ is not None:
            pulumi.set(__self__, "continue_", continue_)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if group_interval is not None:
            pulumi.set(__self__, "group_interval", group_interval)
        if group_wait is not None:
            pulumi.set(__self__, "group_wait", group_wait)
        if matchers is not None:
            pulumi.set(__self__, "matchers", matchers)
        if mute_timings is not None:
            pulumi.set(__self__, "mute_timings", mute_timings)
        if policies is not None:
            pulumi.set(__self__, "policies", policies)
        if repeat_interval is not None:
            pulumi.set(__self__, "repeat_interval", repeat_interval)

    @_builtins.property
    @pulumi.getter(name="activeTimings")
    def active_timings(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of time interval names to apply to alerts that match this policy to suppress them unless they are sent at the specified time. Supported in Grafana 12.1.0 and later
        """
        return pulumi.get(self, "active_timings")

    @_builtins.property
    @pulumi.getter(name="contactPoint")
    def contact_point(self) -> Optional[_builtins.str]:
        """
        The contact point to route notifications that match this rule to.
        """
        return pulumi.get(self, "contact_point")

    @_builtins.property
    @pulumi.getter(name="continue")
    def continue_(self) -> Optional[_builtins.bool]:
        """
        Whether to continue matching subsequent rules if an alert matches the current rule. Otherwise, the rule will be 'consumed' by the first policy to match it.
        """
        return pulumi.get(self, "continue_")

    @_builtins.property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping. Required for root policy only. If empty, the parent grouping is used.
        """
        return pulumi.get(self, "group_bies")

    @_builtins.property
    @pulumi.getter(name="groupInterval")
    def group_interval(self) -> Optional[_builtins.str]:
        """
        Minimum time interval between two notifications for the same group. Default is 5 minutes.
        """
        return pulumi.get(self, "group_interval")

    @_builtins.property
    @pulumi.getter(name="groupWait")
    def group_wait(self) -> Optional[_builtins.str]:
        """
        Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.
        """
        return pulumi.get(self, "group_wait")

    @_builtins.property
    @pulumi.getter
    def matchers(self) -> Optional[Sequence['outputs.NotificationPolicyPolicyMatcher']]:
        """
        Describes which labels this rule should match. When multiple matchers are supplied, an alert must match ALL matchers to be accepted by this policy. When no matchers are supplied, the rule will match all alert instances.
        """
        return pulumi.get(self, "matchers")

    @_builtins.property
    @pulumi.getter(name="muteTimings")
    def mute_timings(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of time intervals to apply to alerts that match this policy to mute them for the specified time.
        """
        return pulumi.get(self, "mute_timings")

    @_builtins.property
    @pulumi.getter
    def policies(self) -> Optional[Sequence['outputs.NotificationPolicyPolicyPolicy']]:
        """
        Routing rules for specific label sets.
        """
        return pulumi.get(self, "policies")

    @_builtins.property
    @pulumi.getter(name="repeatInterval")
    def repeat_interval(self) -> Optional[_builtins.str]:
        """
        Minimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.
        """
        return pulumi.get(self, "repeat_interval")


@pulumi.output_type
class NotificationPolicyPolicyMatcher(dict):
    def __init__(__self__, *,
                 label: _builtins.str,
                 match: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str label: The name of the label to match against.
        :param _builtins.str match: The operator to apply when matching values of the given label. Allowed operators are `=` for equality, `!=` for negated equality, `=~` for regex equality, and `!~` for negated regex equality.
        :param _builtins.str value: The label value to match against.
        """
        pulumi.set(__self__, "label", label)
        pulumi.set(__self__, "match", match)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def label(self) -> _builtins.str:
        """
        The name of the label to match against.
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter
    def match(self) -> _builtins.str:
        """
        The operator to apply when matching values of the given label. Allowed operators are `=` for equality, `!=` for negated equality, `=~` for regex equality, and `!~` for negated regex equality.
        """
        return pulumi.get(self, "match")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The label value to match against.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class NotificationPolicyPolicyPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "activeTimings":
            suggest = "active_timings"
        elif key == "contactPoint":
            suggest = "contact_point"
        elif key == "continue":
            suggest = "continue_"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "groupInterval":
            suggest = "group_interval"
        elif key == "groupWait":
            suggest = "group_wait"
        elif key == "muteTimings":
            suggest = "mute_timings"
        elif key == "repeatInterval":
            suggest = "repeat_interval"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotificationPolicyPolicyPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotificationPolicyPolicyPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotificationPolicyPolicyPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 active_timings: Optional[Sequence[_builtins.str]] = None,
                 contact_point: Optional[_builtins.str] = None,
                 continue_: Optional[_builtins.bool] = None,
                 group_bies: Optional[Sequence[_builtins.str]] = None,
                 group_interval: Optional[_builtins.str] = None,
                 group_wait: Optional[_builtins.str] = None,
                 matchers: Optional[Sequence['outputs.NotificationPolicyPolicyPolicyMatcher']] = None,
                 mute_timings: Optional[Sequence[_builtins.str]] = None,
                 policies: Optional[Sequence['outputs.NotificationPolicyPolicyPolicyPolicy']] = None,
                 repeat_interval: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] active_timings: A list of time interval names to apply to alerts that match this policy to suppress them unless they are sent at the specified time. Supported in Grafana 12.1.0 and later
        :param _builtins.str contact_point: The contact point to route notifications that match this rule to.
        :param _builtins.bool continue_: Whether to continue matching subsequent rules if an alert matches the current rule. Otherwise, the rule will be 'consumed' by the first policy to match it.
        :param Sequence[_builtins.str] group_bies: A list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping. Required for root policy only. If empty, the parent grouping is used.
        :param _builtins.str group_interval: Minimum time interval between two notifications for the same group. Default is 5 minutes.
        :param _builtins.str group_wait: Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.
        :param Sequence['NotificationPolicyPolicyPolicyMatcherArgs'] matchers: Describes which labels this rule should match. When multiple matchers are supplied, an alert must match ALL matchers to be accepted by this policy. When no matchers are supplied, the rule will match all alert instances.
        :param Sequence[_builtins.str] mute_timings: A list of time intervals to apply to alerts that match this policy to mute them for the specified time.
        :param Sequence['NotificationPolicyPolicyPolicyPolicyArgs'] policies: Routing rules for specific label sets.
        :param _builtins.str repeat_interval: Minimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.
        """
        if active_timings is not None:
            pulumi.set(__self__, "active_timings", active_timings)
        if contact_point is not None:
            pulumi.set(__self__, "contact_point", contact_point)
        if continue_ is not None:
            pulumi.set(__self__, "continue_", continue_)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if group_interval is not None:
            pulumi.set(__self__, "group_interval", group_interval)
        if group_wait is not None:
            pulumi.set(__self__, "group_wait", group_wait)
        if matchers is not None:
            pulumi.set(__self__, "matchers", matchers)
        if mute_timings is not None:
            pulumi.set(__self__, "mute_timings", mute_timings)
        if policies is not None:
            pulumi.set(__self__, "policies", policies)
        if repeat_interval is not None:
            pulumi.set(__self__, "repeat_interval", repeat_interval)

    @_builtins.property
    @pulumi.getter(name="activeTimings")
    def active_timings(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of time interval names to apply to alerts that match this policy to suppress them unless they are sent at the specified time. Supported in Grafana 12.1.0 and later
        """
        return pulumi.get(self, "active_timings")

    @_builtins.property
    @pulumi.getter(name="contactPoint")
    def contact_point(self) -> Optional[_builtins.str]:
        """
        The contact point to route notifications that match this rule to.
        """
        return pulumi.get(self, "contact_point")

    @_builtins.property
    @pulumi.getter(name="continue")
    def continue_(self) -> Optional[_builtins.bool]:
        """
        Whether to continue matching subsequent rules if an alert matches the current rule. Otherwise, the rule will be 'consumed' by the first policy to match it.
        """
        return pulumi.get(self, "continue_")

    @_builtins.property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping. Required for root policy only. If empty, the parent grouping is used.
        """
        return pulumi.get(self, "group_bies")

    @_builtins.property
    @pulumi.getter(name="groupInterval")
    def group_interval(self) -> Optional[_builtins.str]:
        """
        Minimum time interval between two notifications for the same group. Default is 5 minutes.
        """
        return pulumi.get(self, "group_interval")

    @_builtins.property
    @pulumi.getter(name="groupWait")
    def group_wait(self) -> Optional[_builtins.str]:
        """
        Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.
        """
        return pulumi.get(self, "group_wait")

    @_builtins.property
    @pulumi.getter
    def matchers(self) -> Optional[Sequence['outputs.NotificationPolicyPolicyPolicyMatcher']]:
        """
        Describes which labels this rule should match. When multiple matchers are supplied, an alert must match ALL matchers to be accepted by this policy. When no matchers are supplied, the rule will match all alert instances.
        """
        return pulumi.get(self, "matchers")

    @_builtins.property
    @pulumi.getter(name="muteTimings")
    def mute_timings(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of time intervals to apply to alerts that match this policy to mute them for the specified time.
        """
        return pulumi.get(self, "mute_timings")

    @_builtins.property
    @pulumi.getter
    def policies(self) -> Optional[Sequence['outputs.NotificationPolicyPolicyPolicyPolicy']]:
        """
        Routing rules for specific label sets.
        """
        return pulumi.get(self, "policies")

    @_builtins.property
    @pulumi.getter(name="repeatInterval")
    def repeat_interval(self) -> Optional[_builtins.str]:
        """
        Minimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.
        """
        return pulumi.get(self, "repeat_interval")


@pulumi.output_type
class NotificationPolicyPolicyPolicyMatcher(dict):
    def __init__(__self__, *,
                 label: _builtins.str,
                 match: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str label: The name of the label to match against.
        :param _builtins.str match: The operator to apply when matching values of the given label. Allowed operators are `=` for equality, `!=` for negated equality, `=~` for regex equality, and `!~` for negated regex equality.
        :param _builtins.str value: The label value to match against.
        """
        pulumi.set(__self__, "label", label)
        pulumi.set(__self__, "match", match)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def label(self) -> _builtins.str:
        """
        The name of the label to match against.
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter
    def match(self) -> _builtins.str:
        """
        The operator to apply when matching values of the given label. Allowed operators are `=` for equality, `!=` for negated equality, `=~` for regex equality, and `!~` for negated regex equality.
        """
        return pulumi.get(self, "match")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The label value to match against.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class NotificationPolicyPolicyPolicyPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "activeTimings":
            suggest = "active_timings"
        elif key == "contactPoint":
            suggest = "contact_point"
        elif key == "continue":
            suggest = "continue_"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "groupInterval":
            suggest = "group_interval"
        elif key == "groupWait":
            suggest = "group_wait"
        elif key == "muteTimings":
            suggest = "mute_timings"
        elif key == "repeatInterval":
            suggest = "repeat_interval"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotificationPolicyPolicyPolicyPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotificationPolicyPolicyPolicyPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotificationPolicyPolicyPolicyPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 active_timings: Optional[Sequence[_builtins.str]] = None,
                 contact_point: Optional[_builtins.str] = None,
                 continue_: Optional[_builtins.bool] = None,
                 group_bies: Optional[Sequence[_builtins.str]] = None,
                 group_interval: Optional[_builtins.str] = None,
                 group_wait: Optional[_builtins.str] = None,
                 matchers: Optional[Sequence['outputs.NotificationPolicyPolicyPolicyPolicyMatcher']] = None,
                 mute_timings: Optional[Sequence[_builtins.str]] = None,
                 policies: Optional[Sequence['outputs.NotificationPolicyPolicyPolicyPolicyPolicy']] = None,
                 repeat_interval: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] active_timings: A list of time interval names to apply to alerts that match this policy to suppress them unless they are sent at the specified time. Supported in Grafana 12.1.0 and later
        :param _builtins.str contact_point: The contact point to route notifications that match this rule to.
        :param _builtins.bool continue_: Whether to continue matching subsequent rules if an alert matches the current rule. Otherwise, the rule will be 'consumed' by the first policy to match it.
        :param Sequence[_builtins.str] group_bies: A list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping. Required for root policy only. If empty, the parent grouping is used.
        :param _builtins.str group_interval: Minimum time interval between two notifications for the same group. Default is 5 minutes.
        :param _builtins.str group_wait: Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.
        :param Sequence['NotificationPolicyPolicyPolicyPolicyMatcherArgs'] matchers: Describes which labels this rule should match. When multiple matchers are supplied, an alert must match ALL matchers to be accepted by this policy. When no matchers are supplied, the rule will match all alert instances.
        :param Sequence[_builtins.str] mute_timings: A list of time intervals to apply to alerts that match this policy to mute them for the specified time.
        :param Sequence['NotificationPolicyPolicyPolicyPolicyPolicyArgs'] policies: Routing rules for specific label sets.
        :param _builtins.str repeat_interval: Minimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.
        """
        if active_timings is not None:
            pulumi.set(__self__, "active_timings", active_timings)
        if contact_point is not None:
            pulumi.set(__self__, "contact_point", contact_point)
        if continue_ is not None:
            pulumi.set(__self__, "continue_", continue_)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if group_interval is not None:
            pulumi.set(__self__, "group_interval", group_interval)
        if group_wait is not None:
            pulumi.set(__self__, "group_wait", group_wait)
        if matchers is not None:
            pulumi.set(__self__, "matchers", matchers)
        if mute_timings is not None:
            pulumi.set(__self__, "mute_timings", mute_timings)
        if policies is not None:
            pulumi.set(__self__, "policies", policies)
        if repeat_interval is not None:
            pulumi.set(__self__, "repeat_interval", repeat_interval)

    @_builtins.property
    @pulumi.getter(name="activeTimings")
    def active_timings(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of time interval names to apply to alerts that match this policy to suppress them unless they are sent at the specified time. Supported in Grafana 12.1.0 and later
        """
        return pulumi.get(self, "active_timings")

    @_builtins.property
    @pulumi.getter(name="contactPoint")
    def contact_point(self) -> Optional[_builtins.str]:
        """
        The contact point to route notifications that match this rule to.
        """
        return pulumi.get(self, "contact_point")

    @_builtins.property
    @pulumi.getter(name="continue")
    def continue_(self) -> Optional[_builtins.bool]:
        """
        Whether to continue matching subsequent rules if an alert matches the current rule. Otherwise, the rule will be 'consumed' by the first policy to match it.
        """
        return pulumi.get(self, "continue_")

    @_builtins.property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping. Required for root policy only. If empty, the parent grouping is used.
        """
        return pulumi.get(self, "group_bies")

    @_builtins.property
    @pulumi.getter(name="groupInterval")
    def group_interval(self) -> Optional[_builtins.str]:
        """
        Minimum time interval between two notifications for the same group. Default is 5 minutes.
        """
        return pulumi.get(self, "group_interval")

    @_builtins.property
    @pulumi.getter(name="groupWait")
    def group_wait(self) -> Optional[_builtins.str]:
        """
        Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.
        """
        return pulumi.get(self, "group_wait")

    @_builtins.property
    @pulumi.getter
    def matchers(self) -> Optional[Sequence['outputs.NotificationPolicyPolicyPolicyPolicyMatcher']]:
        """
        Describes which labels this rule should match. When multiple matchers are supplied, an alert must match ALL matchers to be accepted by this policy. When no matchers are supplied, the rule will match all alert instances.
        """
        return pulumi.get(self, "matchers")

    @_builtins.property
    @pulumi.getter(name="muteTimings")
    def mute_timings(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of time intervals to apply to alerts that match this policy to mute them for the specified time.
        """
        return pulumi.get(self, "mute_timings")

    @_builtins.property
    @pulumi.getter
    def policies(self) -> Optional[Sequence['outputs.NotificationPolicyPolicyPolicyPolicyPolicy']]:
        """
        Routing rules for specific label sets.
        """
        return pulumi.get(self, "policies")

    @_builtins.property
    @pulumi.getter(name="repeatInterval")
    def repeat_interval(self) -> Optional[_builtins.str]:
        """
        Minimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.
        """
        return pulumi.get(self, "repeat_interval")


@pulumi.output_type
class NotificationPolicyPolicyPolicyPolicyMatcher(dict):
    def __init__(__self__, *,
                 label: _builtins.str,
                 match: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str label: The name of the label to match against.
        :param _builtins.str match: The operator to apply when matching values of the given label. Allowed operators are `=` for equality, `!=` for negated equality, `=~` for regex equality, and `!~` for negated regex equality.
        :param _builtins.str value: The label value to match against.
        """
        pulumi.set(__self__, "label", label)
        pulumi.set(__self__, "match", match)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def label(self) -> _builtins.str:
        """
        The name of the label to match against.
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter
    def match(self) -> _builtins.str:
        """
        The operator to apply when matching values of the given label. Allowed operators are `=` for equality, `!=` for negated equality, `=~` for regex equality, and `!~` for negated regex equality.
        """
        return pulumi.get(self, "match")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The label value to match against.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class NotificationPolicyPolicyPolicyPolicyPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupBies":
            suggest = "group_bies"
        elif key == "activeTimings":
            suggest = "active_timings"
        elif key == "contactPoint":
            suggest = "contact_point"
        elif key == "continue":
            suggest = "continue_"
        elif key == "groupInterval":
            suggest = "group_interval"
        elif key == "groupWait":
            suggest = "group_wait"
        elif key == "muteTimings":
            suggest = "mute_timings"
        elif key == "repeatInterval":
            suggest = "repeat_interval"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotificationPolicyPolicyPolicyPolicyPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotificationPolicyPolicyPolicyPolicyPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotificationPolicyPolicyPolicyPolicyPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 group_bies: Sequence[_builtins.str],
                 active_timings: Optional[Sequence[_builtins.str]] = None,
                 contact_point: Optional[_builtins.str] = None,
                 continue_: Optional[_builtins.bool] = None,
                 group_interval: Optional[_builtins.str] = None,
                 group_wait: Optional[_builtins.str] = None,
                 matchers: Optional[Sequence['outputs.NotificationPolicyPolicyPolicyPolicyPolicyMatcher']] = None,
                 mute_timings: Optional[Sequence[_builtins.str]] = None,
                 repeat_interval: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] group_bies: A list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping. Required for root policy only. If empty, the parent grouping is used.
        :param Sequence[_builtins.str] active_timings: A list of time interval names to apply to alerts that match this policy to suppress them unless they are sent at the specified time. Supported in Grafana 12.1.0 and later
        :param _builtins.str contact_point: The contact point to route notifications that match this rule to.
        :param _builtins.bool continue_: Whether to continue matching subsequent rules if an alert matches the current rule. Otherwise, the rule will be 'consumed' by the first policy to match it.
        :param _builtins.str group_interval: Minimum time interval between two notifications for the same group. Default is 5 minutes.
        :param _builtins.str group_wait: Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.
        :param Sequence['NotificationPolicyPolicyPolicyPolicyPolicyMatcherArgs'] matchers: Describes which labels this rule should match. When multiple matchers are supplied, an alert must match ALL matchers to be accepted by this policy. When no matchers are supplied, the rule will match all alert instances.
        :param Sequence[_builtins.str] mute_timings: A list of time intervals to apply to alerts that match this policy to mute them for the specified time.
        :param _builtins.str repeat_interval: Minimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.
        """
        pulumi.set(__self__, "group_bies", group_bies)
        if active_timings is not None:
            pulumi.set(__self__, "active_timings", active_timings)
        if contact_point is not None:
            pulumi.set(__self__, "contact_point", contact_point)
        if continue_ is not None:
            pulumi.set(__self__, "continue_", continue_)
        if group_interval is not None:
            pulumi.set(__self__, "group_interval", group_interval)
        if group_wait is not None:
            pulumi.set(__self__, "group_wait", group_wait)
        if matchers is not None:
            pulumi.set(__self__, "matchers", matchers)
        if mute_timings is not None:
            pulumi.set(__self__, "mute_timings", mute_timings)
        if repeat_interval is not None:
            pulumi.set(__self__, "repeat_interval", repeat_interval)

    @_builtins.property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Sequence[_builtins.str]:
        """
        A list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping. Required for root policy only. If empty, the parent grouping is used.
        """
        return pulumi.get(self, "group_bies")

    @_builtins.property
    @pulumi.getter(name="activeTimings")
    def active_timings(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of time interval names to apply to alerts that match this policy to suppress them unless they are sent at the specified time. Supported in Grafana 12.1.0 and later
        """
        return pulumi.get(self, "active_timings")

    @_builtins.property
    @pulumi.getter(name="contactPoint")
    def contact_point(self) -> Optional[_builtins.str]:
        """
        The contact point to route notifications that match this rule to.
        """
        return pulumi.get(self, "contact_point")

    @_builtins.property
    @pulumi.getter(name="continue")
    def continue_(self) -> Optional[_builtins.bool]:
        """
        Whether to continue matching subsequent rules if an alert matches the current rule. Otherwise, the rule will be 'consumed' by the first policy to match it.
        """
        return pulumi.get(self, "continue_")

    @_builtins.property
    @pulumi.getter(name="groupInterval")
    def group_interval(self) -> Optional[_builtins.str]:
        """
        Minimum time interval between two notifications for the same group. Default is 5 minutes.
        """
        return pulumi.get(self, "group_interval")

    @_builtins.property
    @pulumi.getter(name="groupWait")
    def group_wait(self) -> Optional[_builtins.str]:
        """
        Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.
        """
        return pulumi.get(self, "group_wait")

    @_builtins.property
    @pulumi.getter
    def matchers(self) -> Optional[Sequence['outputs.NotificationPolicyPolicyPolicyPolicyPolicyMatcher']]:
        """
        Describes which labels this rule should match. When multiple matchers are supplied, an alert must match ALL matchers to be accepted by this policy. When no matchers are supplied, the rule will match all alert instances.
        """
        return pulumi.get(self, "matchers")

    @_builtins.property
    @pulumi.getter(name="muteTimings")
    def mute_timings(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of time intervals to apply to alerts that match this policy to mute them for the specified time.
        """
        return pulumi.get(self, "mute_timings")

    @_builtins.property
    @pulumi.getter(name="repeatInterval")
    def repeat_interval(self) -> Optional[_builtins.str]:
        """
        Minimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.
        """
        return pulumi.get(self, "repeat_interval")


@pulumi.output_type
class NotificationPolicyPolicyPolicyPolicyPolicyMatcher(dict):
    def __init__(__self__, *,
                 label: _builtins.str,
                 match: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str label: The name of the label to match against.
        :param _builtins.str match: The operator to apply when matching values of the given label. Allowed operators are `=` for equality, `!=` for negated equality, `=~` for regex equality, and `!~` for negated regex equality.
        :param _builtins.str value: The label value to match against.
        """
        pulumi.set(__self__, "label", label)
        pulumi.set(__self__, "match", match)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def label(self) -> _builtins.str:
        """
        The name of the label to match against.
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter
    def match(self) -> _builtins.str:
        """
        The operator to apply when matching values of the given label. Allowed operators are `=` for equality, `!=` for negated equality, `=~` for regex equality, and `!~` for negated regex equality.
        """
        return pulumi.get(self, "match")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The label value to match against.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class RecordingRuleV0Alpha1Metadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "folderUid":
            suggest = "folder_uid"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RecordingRuleV0Alpha1Metadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RecordingRuleV0Alpha1Metadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RecordingRuleV0Alpha1Metadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 uid: _builtins.str,
                 annotations: Optional[Mapping[str, _builtins.str]] = None,
                 folder_uid: Optional[_builtins.str] = None,
                 url: Optional[_builtins.str] = None,
                 uuid: Optional[_builtins.str] = None,
                 version: Optional[_builtins.str] = None):
        """
        :param _builtins.str uid: The unique identifier of the resource.
        :param Mapping[str, _builtins.str] annotations: Annotations of the resource.
        :param _builtins.str folder_uid: The UID of the folder to save the resource in.
        :param _builtins.str url: The full URL of the resource.
        :param _builtins.str uuid: The globally unique identifier of a resource, used by the API for tracking.
        :param _builtins.str version: The version of the resource.
        """
        pulumi.set(__self__, "uid", uid)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if folder_uid is not None:
            pulumi.set(__self__, "folder_uid", folder_uid)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def uid(self) -> _builtins.str:
        """
        The unique identifier of the resource.
        """
        return pulumi.get(self, "uid")

    @_builtins.property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Annotations of the resource.
        """
        return pulumi.get(self, "annotations")

    @_builtins.property
    @pulumi.getter(name="folderUid")
    def folder_uid(self) -> Optional[_builtins.str]:
        """
        The UID of the folder to save the resource in.
        """
        return pulumi.get(self, "folder_uid")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        The full URL of the resource.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        The globally unique identifier of a resource, used by the API for tracking.
        """
        return pulumi.get(self, "uuid")

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[_builtins.str]:
        """
        The version of the resource.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class RecordingRuleV0Alpha1Options(dict):
    def __init__(__self__, *,
                 overwrite: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool overwrite: Set to true if you want to overwrite existing resource with newer version, same resource title in folder or same resource uid.
        """
        if overwrite is not None:
            pulumi.set(__self__, "overwrite", overwrite)

    @_builtins.property
    @pulumi.getter
    def overwrite(self) -> Optional[_builtins.bool]:
        """
        Set to true if you want to overwrite existing resource with newer version, same resource title in folder or same resource uid.
        """
        return pulumi.get(self, "overwrite")


@pulumi.output_type
class RecordingRuleV0Alpha1Spec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetDatasourceUid":
            suggest = "target_datasource_uid"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RecordingRuleV0Alpha1Spec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RecordingRuleV0Alpha1Spec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RecordingRuleV0Alpha1Spec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 expressions: Mapping[str, _builtins.str],
                 metric: _builtins.str,
                 target_datasource_uid: _builtins.str,
                 title: _builtins.str,
                 labels: Optional[Mapping[str, _builtins.str]] = None,
                 paused: Optional[_builtins.bool] = None,
                 trigger: Optional['outputs.RecordingRuleV0Alpha1SpecTrigger'] = None):
        """
        :param Mapping[str, _builtins.str] expressions: A sequence of stages that describe the contents of the rule. Each value is a JSON string representing an expression object.
        :param _builtins.str metric: The name of the metric to write to.
        :param _builtins.str target_datasource_uid: The UID of the datasource to write the metric to.
        :param _builtins.str title: The title of the recording rule.
        :param Mapping[str, _builtins.str] labels: Key-value pairs to attach to the recorded metric.
        :param _builtins.bool paused: Sets whether the recording rule should be paused or not.
        :param 'RecordingRuleV0Alpha1SpecTriggerArgs' trigger: The trigger configuration for the recording rule.
        """
        pulumi.set(__self__, "expressions", expressions)
        pulumi.set(__self__, "metric", metric)
        pulumi.set(__self__, "target_datasource_uid", target_datasource_uid)
        pulumi.set(__self__, "title", title)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if paused is not None:
            pulumi.set(__self__, "paused", paused)
        if trigger is not None:
            pulumi.set(__self__, "trigger", trigger)

    @_builtins.property
    @pulumi.getter
    def expressions(self) -> Mapping[str, _builtins.str]:
        """
        A sequence of stages that describe the contents of the rule. Each value is a JSON string representing an expression object.
        """
        return pulumi.get(self, "expressions")

    @_builtins.property
    @pulumi.getter
    def metric(self) -> _builtins.str:
        """
        The name of the metric to write to.
        """
        return pulumi.get(self, "metric")

    @_builtins.property
    @pulumi.getter(name="targetDatasourceUid")
    def target_datasource_uid(self) -> _builtins.str:
        """
        The UID of the datasource to write the metric to.
        """
        return pulumi.get(self, "target_datasource_uid")

    @_builtins.property
    @pulumi.getter
    def title(self) -> _builtins.str:
        """
        The title of the recording rule.
        """
        return pulumi.get(self, "title")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Key-value pairs to attach to the recorded metric.
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter
    def paused(self) -> Optional[_builtins.bool]:
        """
        Sets whether the recording rule should be paused or not.
        """
        return pulumi.get(self, "paused")

    @_builtins.property
    @pulumi.getter
    def trigger(self) -> Optional['outputs.RecordingRuleV0Alpha1SpecTrigger']:
        """
        The trigger configuration for the recording rule.
        """
        return pulumi.get(self, "trigger")


@pulumi.output_type
class RecordingRuleV0Alpha1SpecTrigger(dict):
    def __init__(__self__, *,
                 interval: _builtins.str):
        """
        :param _builtins.str interval: The interval at which the recording rule should be evaluated.
        """
        pulumi.set(__self__, "interval", interval)

    @_builtins.property
    @pulumi.getter
    def interval(self) -> _builtins.str:
        """
        The interval at which the recording rule should be evaluated.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class RuleGroupRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "execErrState":
            suggest = "exec_err_state"
        elif key == "for":
            suggest = "for_"
        elif key == "isPaused":
            suggest = "is_paused"
        elif key == "keepFiringFor":
            suggest = "keep_firing_for"
        elif key == "missingSeriesEvalsToResolve":
            suggest = "missing_series_evals_to_resolve"
        elif key == "noDataState":
            suggest = "no_data_state"
        elif key == "notificationSettings":
            suggest = "notification_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 datas: Sequence['outputs.RuleGroupRuleData'],
                 name: _builtins.str,
                 annotations: Optional[Mapping[str, _builtins.str]] = None,
                 condition: Optional[_builtins.str] = None,
                 exec_err_state: Optional[_builtins.str] = None,
                 for_: Optional[_builtins.str] = None,
                 is_paused: Optional[_builtins.bool] = None,
                 keep_firing_for: Optional[_builtins.str] = None,
                 labels: Optional[Mapping[str, _builtins.str]] = None,
                 missing_series_evals_to_resolve: Optional[_builtins.int] = None,
                 no_data_state: Optional[_builtins.str] = None,
                 notification_settings: Optional['outputs.RuleGroupRuleNotificationSettings'] = None,
                 record: Optional['outputs.RuleGroupRuleRecord'] = None,
                 uid: Optional[_builtins.str] = None):
        """
        :param Sequence['RuleGroupRuleDataArgs'] datas: A sequence of stages that describe the contents of the rule.
        :param _builtins.str name: The name of the alert rule.
        :param Mapping[str, _builtins.str] annotations: Key-value pairs of metadata to attach to the alert rule. They add additional information, such as a `summary` or `runbook_url`, to help identify and investigate alerts. The `__dashboardUid__` and `__panelId__` annotations, which link alerts to a panel, must be set together. Defaults to `map[]`.
        :param _builtins.str condition: The `ref_id` of the query node in the `data` field to use as the alert condition.
        :param _builtins.str exec_err_state: Describes what state to enter when the rule's query is invalid and the rule cannot be executed. Options are OK, Error, KeepLast, and Alerting.  Defaults to Alerting if not set.
        :param _builtins.str for_: The amount of time for which the rule must be breached for the rule to be considered to be Firing. Before this time has elapsed, the rule is only considered to be Pending. Defaults to `0`.
        :param _builtins.bool is_paused: Sets whether the alert should be paused or not. Defaults to `false`.
        :param _builtins.str keep_firing_for: The amount of time for which the rule will considered to be Recovering after initially Firing. Before this time has elapsed, the rule will continue to fire once it's been triggered.
        :param Mapping[str, _builtins.str] labels: Key-value pairs to attach to the alert rule that can be used in matching, grouping, and routing. Defaults to `map[]`.
        :param _builtins.int missing_series_evals_to_resolve: The number of missing series evaluations that must occur before the rule is considered to be resolved.
        :param _builtins.str no_data_state: Describes what state to enter when the rule's query returns No Data. Options are OK, NoData, KeepLast, and Alerting. Defaults to NoData if not set.
        :param 'RuleGroupRuleNotificationSettingsArgs' notification_settings: Notification settings for the rule. If specified, it overrides the notification policies. Available since Grafana 10.4, requires feature flag 'alertingSimplifiedRouting' to be enabled.
        :param 'RuleGroupRuleRecordArgs' record: Settings for a recording rule. Available since Grafana 11.2, requires feature flag 'grafanaManagedRecordingRules' to be enabled.
        :param _builtins.str uid: The unique identifier of the alert rule.
        """
        pulumi.set(__self__, "datas", datas)
        pulumi.set(__self__, "name", name)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if exec_err_state is not None:
            pulumi.set(__self__, "exec_err_state", exec_err_state)
        if for_ is not None:
            pulumi.set(__self__, "for_", for_)
        if is_paused is not None:
            pulumi.set(__self__, "is_paused", is_paused)
        if keep_firing_for is not None:
            pulumi.set(__self__, "keep_firing_for", keep_firing_for)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if missing_series_evals_to_resolve is not None:
            pulumi.set(__self__, "missing_series_evals_to_resolve", missing_series_evals_to_resolve)
        if no_data_state is not None:
            pulumi.set(__self__, "no_data_state", no_data_state)
        if notification_settings is not None:
            pulumi.set(__self__, "notification_settings", notification_settings)
        if record is not None:
            pulumi.set(__self__, "record", record)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @_builtins.property
    @pulumi.getter
    def datas(self) -> Sequence['outputs.RuleGroupRuleData']:
        """
        A sequence of stages that describe the contents of the rule.
        """
        return pulumi.get(self, "datas")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the alert rule.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Key-value pairs of metadata to attach to the alert rule. They add additional information, such as a `summary` or `runbook_url`, to help identify and investigate alerts. The `__dashboardUid__` and `__panelId__` annotations, which link alerts to a panel, must be set together. Defaults to `map[]`.
        """
        return pulumi.get(self, "annotations")

    @_builtins.property
    @pulumi.getter
    def condition(self) -> Optional[_builtins.str]:
        """
        The `ref_id` of the query node in the `data` field to use as the alert condition.
        """
        return pulumi.get(self, "condition")

    @_builtins.property
    @pulumi.getter(name="execErrState")
    def exec_err_state(self) -> Optional[_builtins.str]:
        """
        Describes what state to enter when the rule's query is invalid and the rule cannot be executed. Options are OK, Error, KeepLast, and Alerting.  Defaults to Alerting if not set.
        """
        return pulumi.get(self, "exec_err_state")

    @_builtins.property
    @pulumi.getter(name="for")
    def for_(self) -> Optional[_builtins.str]:
        """
        The amount of time for which the rule must be breached for the rule to be considered to be Firing. Before this time has elapsed, the rule is only considered to be Pending. Defaults to `0`.
        """
        return pulumi.get(self, "for_")

    @_builtins.property
    @pulumi.getter(name="isPaused")
    def is_paused(self) -> Optional[_builtins.bool]:
        """
        Sets whether the alert should be paused or not. Defaults to `false`.
        """
        return pulumi.get(self, "is_paused")

    @_builtins.property
    @pulumi.getter(name="keepFiringFor")
    def keep_firing_for(self) -> Optional[_builtins.str]:
        """
        The amount of time for which the rule will considered to be Recovering after initially Firing. Before this time has elapsed, the rule will continue to fire once it's been triggered.
        """
        return pulumi.get(self, "keep_firing_for")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Key-value pairs to attach to the alert rule that can be used in matching, grouping, and routing. Defaults to `map[]`.
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter(name="missingSeriesEvalsToResolve")
    def missing_series_evals_to_resolve(self) -> Optional[_builtins.int]:
        """
        The number of missing series evaluations that must occur before the rule is considered to be resolved.
        """
        return pulumi.get(self, "missing_series_evals_to_resolve")

    @_builtins.property
    @pulumi.getter(name="noDataState")
    def no_data_state(self) -> Optional[_builtins.str]:
        """
        Describes what state to enter when the rule's query returns No Data. Options are OK, NoData, KeepLast, and Alerting. Defaults to NoData if not set.
        """
        return pulumi.get(self, "no_data_state")

    @_builtins.property
    @pulumi.getter(name="notificationSettings")
    def notification_settings(self) -> Optional['outputs.RuleGroupRuleNotificationSettings']:
        """
        Notification settings for the rule. If specified, it overrides the notification policies. Available since Grafana 10.4, requires feature flag 'alertingSimplifiedRouting' to be enabled.
        """
        return pulumi.get(self, "notification_settings")

    @_builtins.property
    @pulumi.getter
    def record(self) -> Optional['outputs.RuleGroupRuleRecord']:
        """
        Settings for a recording rule. Available since Grafana 11.2, requires feature flag 'grafanaManagedRecordingRules' to be enabled.
        """
        return pulumi.get(self, "record")

    @_builtins.property
    @pulumi.getter
    def uid(self) -> Optional[_builtins.str]:
        """
        The unique identifier of the alert rule.
        """
        return pulumi.get(self, "uid")


@pulumi.output_type
class RuleGroupRuleData(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "datasourceUid":
            suggest = "datasource_uid"
        elif key == "refId":
            suggest = "ref_id"
        elif key == "relativeTimeRange":
            suggest = "relative_time_range"
        elif key == "queryType":
            suggest = "query_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleData. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleData.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleData.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 datasource_uid: _builtins.str,
                 model: _builtins.str,
                 ref_id: _builtins.str,
                 relative_time_range: 'outputs.RuleGroupRuleDataRelativeTimeRange',
                 query_type: Optional[_builtins.str] = None):
        """
        :param _builtins.str datasource_uid: The UID of the datasource being queried, or "-100" if this stage is an expression stage.
        :param _builtins.str model: Custom JSON data to send to the specified datasource when querying.
        :param _builtins.str ref_id: A unique string to identify this query stage within a rule.
        :param 'RuleGroupRuleDataRelativeTimeRangeArgs' relative_time_range: The time range, relative to when the query is executed, across which to query.
        :param _builtins.str query_type: An optional identifier for the type of query being executed. Defaults to ``.
        """
        pulumi.set(__self__, "datasource_uid", datasource_uid)
        pulumi.set(__self__, "model", model)
        pulumi.set(__self__, "ref_id", ref_id)
        pulumi.set(__self__, "relative_time_range", relative_time_range)
        if query_type is not None:
            pulumi.set(__self__, "query_type", query_type)

    @_builtins.property
    @pulumi.getter(name="datasourceUid")
    def datasource_uid(self) -> _builtins.str:
        """
        The UID of the datasource being queried, or "-100" if this stage is an expression stage.
        """
        return pulumi.get(self, "datasource_uid")

    @_builtins.property
    @pulumi.getter
    def model(self) -> _builtins.str:
        """
        Custom JSON data to send to the specified datasource when querying.
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter(name="refId")
    def ref_id(self) -> _builtins.str:
        """
        A unique string to identify this query stage within a rule.
        """
        return pulumi.get(self, "ref_id")

    @_builtins.property
    @pulumi.getter(name="relativeTimeRange")
    def relative_time_range(self) -> 'outputs.RuleGroupRuleDataRelativeTimeRange':
        """
        The time range, relative to when the query is executed, across which to query.
        """
        return pulumi.get(self, "relative_time_range")

    @_builtins.property
    @pulumi.getter(name="queryType")
    def query_type(self) -> Optional[_builtins.str]:
        """
        An optional identifier for the type of query being executed. Defaults to ``.
        """
        return pulumi.get(self, "query_type")


@pulumi.output_type
class RuleGroupRuleDataRelativeTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleDataRelativeTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleDataRelativeTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleDataRelativeTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_: _builtins.int,
                 to: _builtins.int):
        """
        :param _builtins.int from_: The number of seconds in the past, relative to when the rule is evaluated, at which the time range begins.
        :param _builtins.int to: The number of seconds in the past, relative to when the rule is evaluated, at which the time range ends.
        """
        pulumi.set(__self__, "from_", from_)
        pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> _builtins.int:
        """
        The number of seconds in the past, relative to when the rule is evaluated, at which the time range begins.
        """
        return pulumi.get(self, "from_")

    @_builtins.property
    @pulumi.getter
    def to(self) -> _builtins.int:
        """
        The number of seconds in the past, relative to when the rule is evaluated, at which the time range ends.
        """
        return pulumi.get(self, "to")


@pulumi.output_type
class RuleGroupRuleNotificationSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contactPoint":
            suggest = "contact_point"
        elif key == "activeTimings":
            suggest = "active_timings"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "groupInterval":
            suggest = "group_interval"
        elif key == "groupWait":
            suggest = "group_wait"
        elif key == "muteTimings":
            suggest = "mute_timings"
        elif key == "repeatInterval":
            suggest = "repeat_interval"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleNotificationSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleNotificationSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleNotificationSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 contact_point: _builtins.str,
                 active_timings: Optional[Sequence[_builtins.str]] = None,
                 group_bies: Optional[Sequence[_builtins.str]] = None,
                 group_interval: Optional[_builtins.str] = None,
                 group_wait: Optional[_builtins.str] = None,
                 mute_timings: Optional[Sequence[_builtins.str]] = None,
                 repeat_interval: Optional[_builtins.str] = None):
        """
        :param _builtins.str contact_point: The contact point to route notifications that match this rule to.
        :param Sequence[_builtins.str] active_timings: A list of time interval names to apply to alerts that match this policy to suppress them unless they are sent at the specified time. Supported in Grafana 12.1.0 and later
        :param Sequence[_builtins.str] group_bies: A list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping. If empty, no grouping is used. If specified, requires labels 'alertname' and 'grafana_folder' to be included.
        :param _builtins.str group_interval: Minimum time interval between two notifications for the same group. Default is 5 minutes.
        :param _builtins.str group_wait: Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.
        :param Sequence[_builtins.str] mute_timings: A list of mute timing names to apply to alerts that match this policy.
        :param _builtins.str repeat_interval: Minimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.
        """
        pulumi.set(__self__, "contact_point", contact_point)
        if active_timings is not None:
            pulumi.set(__self__, "active_timings", active_timings)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if group_interval is not None:
            pulumi.set(__self__, "group_interval", group_interval)
        if group_wait is not None:
            pulumi.set(__self__, "group_wait", group_wait)
        if mute_timings is not None:
            pulumi.set(__self__, "mute_timings", mute_timings)
        if repeat_interval is not None:
            pulumi.set(__self__, "repeat_interval", repeat_interval)

    @_builtins.property
    @pulumi.getter(name="contactPoint")
    def contact_point(self) -> _builtins.str:
        """
        The contact point to route notifications that match this rule to.
        """
        return pulumi.get(self, "contact_point")

    @_builtins.property
    @pulumi.getter(name="activeTimings")
    def active_timings(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of time interval names to apply to alerts that match this policy to suppress them unless they are sent at the specified time. Supported in Grafana 12.1.0 and later
        """
        return pulumi.get(self, "active_timings")

    @_builtins.property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping. If empty, no grouping is used. If specified, requires labels 'alertname' and 'grafana_folder' to be included.
        """
        return pulumi.get(self, "group_bies")

    @_builtins.property
    @pulumi.getter(name="groupInterval")
    def group_interval(self) -> Optional[_builtins.str]:
        """
        Minimum time interval between two notifications for the same group. Default is 5 minutes.
        """
        return pulumi.get(self, "group_interval")

    @_builtins.property
    @pulumi.getter(name="groupWait")
    def group_wait(self) -> Optional[_builtins.str]:
        """
        Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.
        """
        return pulumi.get(self, "group_wait")

    @_builtins.property
    @pulumi.getter(name="muteTimings")
    def mute_timings(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of mute timing names to apply to alerts that match this policy.
        """
        return pulumi.get(self, "mute_timings")

    @_builtins.property
    @pulumi.getter(name="repeatInterval")
    def repeat_interval(self) -> Optional[_builtins.str]:
        """
        Minimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.
        """
        return pulumi.get(self, "repeat_interval")


@pulumi.output_type
class RuleGroupRuleRecord(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"
        elif key == "targetDatasourceUid":
            suggest = "target_datasource_uid"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleRecord. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleRecord.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleRecord.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_: _builtins.str,
                 metric: _builtins.str,
                 target_datasource_uid: Optional[_builtins.str] = None):
        """
        :param _builtins.str from_: The ref id of the query node in the data field to use as the source of the metric.
        :param _builtins.str metric: The name of the metric to write to.
        :param _builtins.str target_datasource_uid: The UID of the datasource to write the metric to.
        """
        pulumi.set(__self__, "from_", from_)
        pulumi.set(__self__, "metric", metric)
        if target_datasource_uid is not None:
            pulumi.set(__self__, "target_datasource_uid", target_datasource_uid)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> _builtins.str:
        """
        The ref id of the query node in the data field to use as the source of the metric.
        """
        return pulumi.get(self, "from_")

    @_builtins.property
    @pulumi.getter
    def metric(self) -> _builtins.str:
        """
        The name of the metric to write to.
        """
        return pulumi.get(self, "metric")

    @_builtins.property
    @pulumi.getter(name="targetDatasourceUid")
    def target_datasource_uid(self) -> Optional[_builtins.str]:
        """
        The UID of the datasource to write the metric to.
        """
        return pulumi.get(self, "target_datasource_uid")


