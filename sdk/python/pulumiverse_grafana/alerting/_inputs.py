# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'ContactPointAlertmanagerArgs',
    'ContactPointAlertmanagerArgsDict',
    'ContactPointDingdingArgs',
    'ContactPointDingdingArgsDict',
    'ContactPointDiscordArgs',
    'ContactPointDiscordArgsDict',
    'ContactPointEmailArgs',
    'ContactPointEmailArgsDict',
    'ContactPointGooglechatArgs',
    'ContactPointGooglechatArgsDict',
    'ContactPointKafkaArgs',
    'ContactPointKafkaArgsDict',
    'ContactPointLineArgs',
    'ContactPointLineArgsDict',
    'ContactPointOncallArgs',
    'ContactPointOncallArgsDict',
    'ContactPointOpsgenyArgs',
    'ContactPointOpsgenyArgsDict',
    'ContactPointOpsgenyResponderArgs',
    'ContactPointOpsgenyResponderArgsDict',
    'ContactPointPagerdutyArgs',
    'ContactPointPagerdutyArgsDict',
    'ContactPointPushoverArgs',
    'ContactPointPushoverArgsDict',
    'ContactPointSensugoArgs',
    'ContactPointSensugoArgsDict',
    'ContactPointSlackArgs',
    'ContactPointSlackArgsDict',
    'ContactPointSnArgs',
    'ContactPointSnArgsDict',
    'ContactPointTeamArgs',
    'ContactPointTeamArgsDict',
    'ContactPointTelegramArgs',
    'ContactPointTelegramArgsDict',
    'ContactPointThreemaArgs',
    'ContactPointThreemaArgsDict',
    'ContactPointVictoropArgs',
    'ContactPointVictoropArgsDict',
    'ContactPointWebexArgs',
    'ContactPointWebexArgsDict',
    'ContactPointWebhookArgs',
    'ContactPointWebhookArgsDict',
    'ContactPointWecomArgs',
    'ContactPointWecomArgsDict',
    'MuteTimingIntervalArgs',
    'MuteTimingIntervalArgsDict',
    'MuteTimingIntervalTimeArgs',
    'MuteTimingIntervalTimeArgsDict',
    'NotificationPolicyPolicyArgs',
    'NotificationPolicyPolicyArgsDict',
    'NotificationPolicyPolicyMatcherArgs',
    'NotificationPolicyPolicyMatcherArgsDict',
    'NotificationPolicyPolicyPolicyArgs',
    'NotificationPolicyPolicyPolicyArgsDict',
    'NotificationPolicyPolicyPolicyMatcherArgs',
    'NotificationPolicyPolicyPolicyMatcherArgsDict',
    'NotificationPolicyPolicyPolicyPolicyArgs',
    'NotificationPolicyPolicyPolicyPolicyArgsDict',
    'NotificationPolicyPolicyPolicyPolicyMatcherArgs',
    'NotificationPolicyPolicyPolicyPolicyMatcherArgsDict',
    'NotificationPolicyPolicyPolicyPolicyPolicyArgs',
    'NotificationPolicyPolicyPolicyPolicyPolicyArgsDict',
    'NotificationPolicyPolicyPolicyPolicyPolicyMatcherArgs',
    'NotificationPolicyPolicyPolicyPolicyPolicyMatcherArgsDict',
    'RuleGroupRuleArgs',
    'RuleGroupRuleArgsDict',
    'RuleGroupRuleDataArgs',
    'RuleGroupRuleDataArgsDict',
    'RuleGroupRuleDataRelativeTimeRangeArgs',
    'RuleGroupRuleDataRelativeTimeRangeArgsDict',
    'RuleGroupRuleNotificationSettingsArgs',
    'RuleGroupRuleNotificationSettingsArgsDict',
    'RuleGroupRuleRecordArgs',
    'RuleGroupRuleRecordArgsDict',
]

MYPY = False

if not MYPY:
    class ContactPointAlertmanagerArgsDict(TypedDict):
        url: pulumi.Input[str]
        """
        The URL of the Alertmanager instance.
        """
        basic_auth_password: NotRequired[pulumi.Input[str]]
        """
        The password component of the basic auth credentials to use.
        """
        basic_auth_user: NotRequired[pulumi.Input[str]]
        """
        The username component of the basic auth credentials to use.
        """
        disable_resolve_message: NotRequired[pulumi.Input[bool]]
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        settings: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        uid: NotRequired[pulumi.Input[str]]
        """
        The UID of the contact point.
        """
elif False:
    ContactPointAlertmanagerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContactPointAlertmanagerArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 basic_auth_password: Optional[pulumi.Input[str]] = None,
                 basic_auth_user: Optional[pulumi.Input[str]] = None,
                 disable_resolve_message: Optional[pulumi.Input[bool]] = None,
                 settings: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 uid: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] url: The URL of the Alertmanager instance.
        :param pulumi.Input[str] basic_auth_password: The password component of the basic auth credentials to use.
        :param pulumi.Input[str] basic_auth_user: The username component of the basic auth credentials to use.
        :param pulumi.Input[bool] disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param pulumi.Input[str] uid: The UID of the contact point.
        """
        pulumi.set(__self__, "url", url)
        if basic_auth_password is not None:
            pulumi.set(__self__, "basic_auth_password", basic_auth_password)
        if basic_auth_user is not None:
            pulumi.set(__self__, "basic_auth_user", basic_auth_user)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        The URL of the Alertmanager instance.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="basicAuthPassword")
    def basic_auth_password(self) -> Optional[pulumi.Input[str]]:
        """
        The password component of the basic auth credentials to use.
        """
        return pulumi.get(self, "basic_auth_password")

    @basic_auth_password.setter
    def basic_auth_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "basic_auth_password", value)

    @property
    @pulumi.getter(name="basicAuthUser")
    def basic_auth_user(self) -> Optional[pulumi.Input[str]]:
        """
        The username component of the basic auth credentials to use.
        """
        return pulumi.get(self, "basic_auth_user")

    @basic_auth_user.setter
    def basic_auth_user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "basic_auth_user", value)

    @property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @disable_resolve_message.setter
    def disable_resolve_message(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_resolve_message", value)

    @property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "settings", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)


if not MYPY:
    class ContactPointDingdingArgsDict(TypedDict):
        url: pulumi.Input[str]
        """
        The DingDing webhook URL.
        """
        disable_resolve_message: NotRequired[pulumi.Input[bool]]
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        message: NotRequired[pulumi.Input[str]]
        """
        The templated content of the message.
        """
        message_type: NotRequired[pulumi.Input[str]]
        """
        The format of message to send - either 'link' or 'actionCard'
        """
        settings: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        title: NotRequired[pulumi.Input[str]]
        """
        The templated title of the message.
        """
        uid: NotRequired[pulumi.Input[str]]
        """
        The UID of the contact point.
        """
elif False:
    ContactPointDingdingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContactPointDingdingArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 disable_resolve_message: Optional[pulumi.Input[bool]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 message_type: Optional[pulumi.Input[str]] = None,
                 settings: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 uid: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] url: The DingDing webhook URL.
        :param pulumi.Input[bool] disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param pulumi.Input[str] message: The templated content of the message.
        :param pulumi.Input[str] message_type: The format of message to send - either 'link' or 'actionCard'
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param pulumi.Input[str] title: The templated title of the message.
        :param pulumi.Input[str] uid: The UID of the contact point.
        """
        pulumi.set(__self__, "url", url)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if message_type is not None:
            pulumi.set(__self__, "message_type", message_type)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        The DingDing webhook URL.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @disable_resolve_message.setter
    def disable_resolve_message(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_resolve_message", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        The templated content of the message.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter(name="messageType")
    def message_type(self) -> Optional[pulumi.Input[str]]:
        """
        The format of message to send - either 'link' or 'actionCard'
        """
        return pulumi.get(self, "message_type")

    @message_type.setter
    def message_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message_type", value)

    @property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "settings", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        The templated title of the message.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)


if not MYPY:
    class ContactPointDiscordArgsDict(TypedDict):
        url: pulumi.Input[str]
        """
        The discord webhook URL.
        """
        avatar_url: NotRequired[pulumi.Input[str]]
        """
        The URL of a custom avatar image to use. Defaults to ``.
        """
        disable_resolve_message: NotRequired[pulumi.Input[bool]]
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        message: NotRequired[pulumi.Input[str]]
        """
        The templated content of the message. Defaults to ``.
        """
        settings: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        title: NotRequired[pulumi.Input[str]]
        """
        The templated content of the title.
        """
        uid: NotRequired[pulumi.Input[str]]
        """
        The UID of the contact point.
        """
        use_discord_username: NotRequired[pulumi.Input[bool]]
        """
        Whether to use the bot account's plain username instead of "Grafana." Defaults to `false`.
        """
elif False:
    ContactPointDiscordArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContactPointDiscordArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 avatar_url: Optional[pulumi.Input[str]] = None,
                 disable_resolve_message: Optional[pulumi.Input[bool]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 settings: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 uid: Optional[pulumi.Input[str]] = None,
                 use_discord_username: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] url: The discord webhook URL.
        :param pulumi.Input[str] avatar_url: The URL of a custom avatar image to use. Defaults to ``.
        :param pulumi.Input[bool] disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param pulumi.Input[str] message: The templated content of the message. Defaults to ``.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param pulumi.Input[str] title: The templated content of the title.
        :param pulumi.Input[str] uid: The UID of the contact point.
        :param pulumi.Input[bool] use_discord_username: Whether to use the bot account's plain username instead of "Grafana." Defaults to `false`.
        """
        pulumi.set(__self__, "url", url)
        if avatar_url is not None:
            pulumi.set(__self__, "avatar_url", avatar_url)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)
        if use_discord_username is not None:
            pulumi.set(__self__, "use_discord_username", use_discord_username)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        The discord webhook URL.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="avatarUrl")
    def avatar_url(self) -> Optional[pulumi.Input[str]]:
        """
        The URL of a custom avatar image to use. Defaults to ``.
        """
        return pulumi.get(self, "avatar_url")

    @avatar_url.setter
    def avatar_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "avatar_url", value)

    @property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @disable_resolve_message.setter
    def disable_resolve_message(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_resolve_message", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        The templated content of the message. Defaults to ``.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "settings", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        The templated content of the title.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)

    @property
    @pulumi.getter(name="useDiscordUsername")
    def use_discord_username(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to use the bot account's plain username instead of "Grafana." Defaults to `false`.
        """
        return pulumi.get(self, "use_discord_username")

    @use_discord_username.setter
    def use_discord_username(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_discord_username", value)


if not MYPY:
    class ContactPointEmailArgsDict(TypedDict):
        addresses: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        The addresses to send emails to.
        """
        disable_resolve_message: NotRequired[pulumi.Input[bool]]
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        message: NotRequired[pulumi.Input[str]]
        """
        The templated content of the email. Defaults to ``.
        """
        settings: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        single_email: NotRequired[pulumi.Input[bool]]
        """
        Whether to send a single email CC'ing all addresses, rather than a separate email to each address. Defaults to `false`.
        """
        subject: NotRequired[pulumi.Input[str]]
        """
        The templated subject line of the email. Defaults to ``.
        """
        uid: NotRequired[pulumi.Input[str]]
        """
        The UID of the contact point.
        """
elif False:
    ContactPointEmailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContactPointEmailArgs:
    def __init__(__self__, *,
                 addresses: pulumi.Input[Sequence[pulumi.Input[str]]],
                 disable_resolve_message: Optional[pulumi.Input[bool]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 settings: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 single_email: Optional[pulumi.Input[bool]] = None,
                 subject: Optional[pulumi.Input[str]] = None,
                 uid: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] addresses: The addresses to send emails to.
        :param pulumi.Input[bool] disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param pulumi.Input[str] message: The templated content of the email. Defaults to ``.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param pulumi.Input[bool] single_email: Whether to send a single email CC'ing all addresses, rather than a separate email to each address. Defaults to `false`.
        :param pulumi.Input[str] subject: The templated subject line of the email. Defaults to ``.
        :param pulumi.Input[str] uid: The UID of the contact point.
        """
        pulumi.set(__self__, "addresses", addresses)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if single_email is not None:
            pulumi.set(__self__, "single_email", single_email)
        if subject is not None:
            pulumi.set(__self__, "subject", subject)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter
    def addresses(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The addresses to send emails to.
        """
        return pulumi.get(self, "addresses")

    @addresses.setter
    def addresses(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "addresses", value)

    @property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @disable_resolve_message.setter
    def disable_resolve_message(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_resolve_message", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        The templated content of the email. Defaults to ``.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "settings", value)

    @property
    @pulumi.getter(name="singleEmail")
    def single_email(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to send a single email CC'ing all addresses, rather than a separate email to each address. Defaults to `false`.
        """
        return pulumi.get(self, "single_email")

    @single_email.setter
    def single_email(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "single_email", value)

    @property
    @pulumi.getter
    def subject(self) -> Optional[pulumi.Input[str]]:
        """
        The templated subject line of the email. Defaults to ``.
        """
        return pulumi.get(self, "subject")

    @subject.setter
    def subject(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subject", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)


if not MYPY:
    class ContactPointGooglechatArgsDict(TypedDict):
        url: pulumi.Input[str]
        """
        The Google Chat webhook URL.
        """
        disable_resolve_message: NotRequired[pulumi.Input[bool]]
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        message: NotRequired[pulumi.Input[str]]
        """
        The templated content of the message.
        """
        settings: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        title: NotRequired[pulumi.Input[str]]
        """
        The templated content of the title.
        """
        uid: NotRequired[pulumi.Input[str]]
        """
        The UID of the contact point.
        """
elif False:
    ContactPointGooglechatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContactPointGooglechatArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 disable_resolve_message: Optional[pulumi.Input[bool]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 settings: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 uid: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] url: The Google Chat webhook URL.
        :param pulumi.Input[bool] disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param pulumi.Input[str] message: The templated content of the message.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param pulumi.Input[str] title: The templated content of the title.
        :param pulumi.Input[str] uid: The UID of the contact point.
        """
        pulumi.set(__self__, "url", url)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        The Google Chat webhook URL.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @disable_resolve_message.setter
    def disable_resolve_message(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_resolve_message", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        The templated content of the message.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "settings", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        The templated content of the title.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)


if not MYPY:
    class ContactPointKafkaArgsDict(TypedDict):
        rest_proxy_url: pulumi.Input[str]
        """
        The URL of the Kafka REST proxy to send requests to.
        """
        topic: pulumi.Input[str]
        """
        The name of the Kafka topic to publish to.
        """
        api_version: NotRequired[pulumi.Input[str]]
        """
        The API version to use when contacting the Kafka REST Server. Supported: v2 (default) and v3. Defaults to `v2`.
        """
        cluster_id: NotRequired[pulumi.Input[str]]
        """
        The Id of cluster to use when contacting the Kafka REST Server. Required api_version to be 'v3'
        """
        description: NotRequired[pulumi.Input[str]]
        """
        The templated description of the Kafka message.
        """
        details: NotRequired[pulumi.Input[str]]
        """
        The templated details to include with the message.
        """
        disable_resolve_message: NotRequired[pulumi.Input[bool]]
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        password: NotRequired[pulumi.Input[str]]
        """
        The password to use when making a call to the Kafka REST Proxy
        """
        settings: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        uid: NotRequired[pulumi.Input[str]]
        """
        The UID of the contact point.
        """
        username: NotRequired[pulumi.Input[str]]
        """
        The user name to use when making a call to the Kafka REST Proxy
        """
elif False:
    ContactPointKafkaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContactPointKafkaArgs:
    def __init__(__self__, *,
                 rest_proxy_url: pulumi.Input[str],
                 topic: pulumi.Input[str],
                 api_version: Optional[pulumi.Input[str]] = None,
                 cluster_id: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 details: Optional[pulumi.Input[str]] = None,
                 disable_resolve_message: Optional[pulumi.Input[bool]] = None,
                 password: Optional[pulumi.Input[str]] = None,
                 settings: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 uid: Optional[pulumi.Input[str]] = None,
                 username: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] rest_proxy_url: The URL of the Kafka REST proxy to send requests to.
        :param pulumi.Input[str] topic: The name of the Kafka topic to publish to.
        :param pulumi.Input[str] api_version: The API version to use when contacting the Kafka REST Server. Supported: v2 (default) and v3. Defaults to `v2`.
        :param pulumi.Input[str] cluster_id: The Id of cluster to use when contacting the Kafka REST Server. Required api_version to be 'v3'
        :param pulumi.Input[str] description: The templated description of the Kafka message.
        :param pulumi.Input[str] details: The templated details to include with the message.
        :param pulumi.Input[bool] disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param pulumi.Input[str] password: The password to use when making a call to the Kafka REST Proxy
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param pulumi.Input[str] uid: The UID of the contact point.
        :param pulumi.Input[str] username: The user name to use when making a call to the Kafka REST Proxy
        """
        pulumi.set(__self__, "rest_proxy_url", rest_proxy_url)
        pulumi.set(__self__, "topic", topic)
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if cluster_id is not None:
            pulumi.set(__self__, "cluster_id", cluster_id)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if details is not None:
            pulumi.set(__self__, "details", details)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="restProxyUrl")
    def rest_proxy_url(self) -> pulumi.Input[str]:
        """
        The URL of the Kafka REST proxy to send requests to.
        """
        return pulumi.get(self, "rest_proxy_url")

    @rest_proxy_url.setter
    def rest_proxy_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "rest_proxy_url", value)

    @property
    @pulumi.getter
    def topic(self) -> pulumi.Input[str]:
        """
        The name of the Kafka topic to publish to.
        """
        return pulumi.get(self, "topic")

    @topic.setter
    def topic(self, value: pulumi.Input[str]):
        pulumi.set(self, "topic", value)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[pulumi.Input[str]]:
        """
        The API version to use when contacting the Kafka REST Server. Supported: v2 (default) and v3. Defaults to `v2`.
        """
        return pulumi.get(self, "api_version")

    @api_version.setter
    def api_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_version", value)

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Id of cluster to use when contacting the Kafka REST Server. Required api_version to be 'v3'
        """
        return pulumi.get(self, "cluster_id")

    @cluster_id.setter
    def cluster_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_id", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The templated description of the Kafka message.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def details(self) -> Optional[pulumi.Input[str]]:
        """
        The templated details to include with the message.
        """
        return pulumi.get(self, "details")

    @details.setter
    def details(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "details", value)

    @property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @disable_resolve_message.setter
    def disable_resolve_message(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_resolve_message", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        The password to use when making a call to the Kafka REST Proxy
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "settings", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        The user name to use when making a call to the Kafka REST Proxy
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ContactPointLineArgsDict(TypedDict):
        token: pulumi.Input[str]
        """
        The bearer token used to authorize the client.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        The templated description of the message.
        """
        disable_resolve_message: NotRequired[pulumi.Input[bool]]
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        settings: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        title: NotRequired[pulumi.Input[str]]
        """
        The templated title of the message.
        """
        uid: NotRequired[pulumi.Input[str]]
        """
        The UID of the contact point.
        """
elif False:
    ContactPointLineArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContactPointLineArgs:
    def __init__(__self__, *,
                 token: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None,
                 disable_resolve_message: Optional[pulumi.Input[bool]] = None,
                 settings: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 uid: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] token: The bearer token used to authorize the client.
        :param pulumi.Input[str] description: The templated description of the message.
        :param pulumi.Input[bool] disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param pulumi.Input[str] title: The templated title of the message.
        :param pulumi.Input[str] uid: The UID of the contact point.
        """
        pulumi.set(__self__, "token", token)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter
    def token(self) -> pulumi.Input[str]:
        """
        The bearer token used to authorize the client.
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: pulumi.Input[str]):
        pulumi.set(self, "token", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The templated description of the message.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @disable_resolve_message.setter
    def disable_resolve_message(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_resolve_message", value)

    @property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "settings", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        The templated title of the message.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)


if not MYPY:
    class ContactPointOncallArgsDict(TypedDict):
        url: pulumi.Input[str]
        """
        The URL to send webhook requests to.
        """
        authorization_credentials: NotRequired[pulumi.Input[str]]
        """
        Allows a custom authorization scheme - attaches an auth header with this value. Do not use in conjunction with basic auth parameters.
        """
        authorization_scheme: NotRequired[pulumi.Input[str]]
        """
        Allows a custom authorization scheme - attaches an auth header with this name. Do not use in conjunction with basic auth parameters.
        """
        basic_auth_password: NotRequired[pulumi.Input[str]]
        """
        The username to use in basic auth headers attached to the request. If omitted, basic auth will not be used.
        """
        basic_auth_user: NotRequired[pulumi.Input[str]]
        """
        The username to use in basic auth headers attached to the request. If omitted, basic auth will not be used.
        """
        disable_resolve_message: NotRequired[pulumi.Input[bool]]
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        http_method: NotRequired[pulumi.Input[str]]
        """
        The HTTP method to use in the request. Defaults to `POST`.
        """
        max_alerts: NotRequired[pulumi.Input[int]]
        """
        The maximum number of alerts to send in a single request. This can be helpful in limiting the size of the request body. The default is 0, which indicates no limit.
        """
        message: NotRequired[pulumi.Input[str]]
        """
        Custom message. You can use template variables.
        """
        settings: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        title: NotRequired[pulumi.Input[str]]
        """
        Templated title of the message.
        """
        uid: NotRequired[pulumi.Input[str]]
        """
        The UID of the contact point.
        """
elif False:
    ContactPointOncallArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContactPointOncallArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 authorization_credentials: Optional[pulumi.Input[str]] = None,
                 authorization_scheme: Optional[pulumi.Input[str]] = None,
                 basic_auth_password: Optional[pulumi.Input[str]] = None,
                 basic_auth_user: Optional[pulumi.Input[str]] = None,
                 disable_resolve_message: Optional[pulumi.Input[bool]] = None,
                 http_method: Optional[pulumi.Input[str]] = None,
                 max_alerts: Optional[pulumi.Input[int]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 settings: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 uid: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] url: The URL to send webhook requests to.
        :param pulumi.Input[str] authorization_credentials: Allows a custom authorization scheme - attaches an auth header with this value. Do not use in conjunction with basic auth parameters.
        :param pulumi.Input[str] authorization_scheme: Allows a custom authorization scheme - attaches an auth header with this name. Do not use in conjunction with basic auth parameters.
        :param pulumi.Input[str] basic_auth_password: The username to use in basic auth headers attached to the request. If omitted, basic auth will not be used.
        :param pulumi.Input[str] basic_auth_user: The username to use in basic auth headers attached to the request. If omitted, basic auth will not be used.
        :param pulumi.Input[bool] disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param pulumi.Input[str] http_method: The HTTP method to use in the request. Defaults to `POST`.
        :param pulumi.Input[int] max_alerts: The maximum number of alerts to send in a single request. This can be helpful in limiting the size of the request body. The default is 0, which indicates no limit.
        :param pulumi.Input[str] message: Custom message. You can use template variables.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param pulumi.Input[str] title: Templated title of the message.
        :param pulumi.Input[str] uid: The UID of the contact point.
        """
        pulumi.set(__self__, "url", url)
        if authorization_credentials is not None:
            pulumi.set(__self__, "authorization_credentials", authorization_credentials)
        if authorization_scheme is not None:
            pulumi.set(__self__, "authorization_scheme", authorization_scheme)
        if basic_auth_password is not None:
            pulumi.set(__self__, "basic_auth_password", basic_auth_password)
        if basic_auth_user is not None:
            pulumi.set(__self__, "basic_auth_user", basic_auth_user)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if http_method is not None:
            pulumi.set(__self__, "http_method", http_method)
        if max_alerts is not None:
            pulumi.set(__self__, "max_alerts", max_alerts)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        The URL to send webhook requests to.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="authorizationCredentials")
    def authorization_credentials(self) -> Optional[pulumi.Input[str]]:
        """
        Allows a custom authorization scheme - attaches an auth header with this value. Do not use in conjunction with basic auth parameters.
        """
        return pulumi.get(self, "authorization_credentials")

    @authorization_credentials.setter
    def authorization_credentials(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "authorization_credentials", value)

    @property
    @pulumi.getter(name="authorizationScheme")
    def authorization_scheme(self) -> Optional[pulumi.Input[str]]:
        """
        Allows a custom authorization scheme - attaches an auth header with this name. Do not use in conjunction with basic auth parameters.
        """
        return pulumi.get(self, "authorization_scheme")

    @authorization_scheme.setter
    def authorization_scheme(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "authorization_scheme", value)

    @property
    @pulumi.getter(name="basicAuthPassword")
    def basic_auth_password(self) -> Optional[pulumi.Input[str]]:
        """
        The username to use in basic auth headers attached to the request. If omitted, basic auth will not be used.
        """
        return pulumi.get(self, "basic_auth_password")

    @basic_auth_password.setter
    def basic_auth_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "basic_auth_password", value)

    @property
    @pulumi.getter(name="basicAuthUser")
    def basic_auth_user(self) -> Optional[pulumi.Input[str]]:
        """
        The username to use in basic auth headers attached to the request. If omitted, basic auth will not be used.
        """
        return pulumi.get(self, "basic_auth_user")

    @basic_auth_user.setter
    def basic_auth_user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "basic_auth_user", value)

    @property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @disable_resolve_message.setter
    def disable_resolve_message(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_resolve_message", value)

    @property
    @pulumi.getter(name="httpMethod")
    def http_method(self) -> Optional[pulumi.Input[str]]:
        """
        The HTTP method to use in the request. Defaults to `POST`.
        """
        return pulumi.get(self, "http_method")

    @http_method.setter
    def http_method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "http_method", value)

    @property
    @pulumi.getter(name="maxAlerts")
    def max_alerts(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of alerts to send in a single request. This can be helpful in limiting the size of the request body. The default is 0, which indicates no limit.
        """
        return pulumi.get(self, "max_alerts")

    @max_alerts.setter
    def max_alerts(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_alerts", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        Custom message. You can use template variables.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "settings", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        Templated title of the message.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)


if not MYPY:
    class ContactPointOpsgenyArgsDict(TypedDict):
        api_key: pulumi.Input[str]
        """
        The OpsGenie API key to use.
        """
        auto_close: NotRequired[pulumi.Input[bool]]
        """
        Whether to auto-close alerts in OpsGenie when they resolve in the Alertmanager.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        A templated high-level description to use for the alert.
        """
        disable_resolve_message: NotRequired[pulumi.Input[bool]]
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        message: NotRequired[pulumi.Input[str]]
        """
        The templated content of the message.
        """
        override_priority: NotRequired[pulumi.Input[bool]]
        """
        Whether to allow the alert priority to be configured via the value of the `og_priority` annotation on the alert.
        """
        responders: NotRequired[pulumi.Input[Sequence[pulumi.Input['ContactPointOpsgenyResponderArgsDict']]]]
        """
        Teams, users, escalations and schedules that the alert will be routed to send notifications. If the API Key belongs to a team integration, this field will be overwritten with the owner team. This feature is available from Grafana 10.3+.
        """
        send_tags_as: NotRequired[pulumi.Input[str]]
        """
        Whether to send annotations to OpsGenie as Tags, Details, or both. Supported values are `tags`, `details`, `both`, or empty to use the default behavior of Tags.
        """
        settings: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        uid: NotRequired[pulumi.Input[str]]
        """
        The UID of the contact point.
        """
        url: NotRequired[pulumi.Input[str]]
        """
        Allows customization of the OpsGenie API URL.
        """
elif False:
    ContactPointOpsgenyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContactPointOpsgenyArgs:
    def __init__(__self__, *,
                 api_key: pulumi.Input[str],
                 auto_close: Optional[pulumi.Input[bool]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 disable_resolve_message: Optional[pulumi.Input[bool]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 override_priority: Optional[pulumi.Input[bool]] = None,
                 responders: Optional[pulumi.Input[Sequence[pulumi.Input['ContactPointOpsgenyResponderArgs']]]] = None,
                 send_tags_as: Optional[pulumi.Input[str]] = None,
                 settings: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 uid: Optional[pulumi.Input[str]] = None,
                 url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] api_key: The OpsGenie API key to use.
        :param pulumi.Input[bool] auto_close: Whether to auto-close alerts in OpsGenie when they resolve in the Alertmanager.
        :param pulumi.Input[str] description: A templated high-level description to use for the alert.
        :param pulumi.Input[bool] disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param pulumi.Input[str] message: The templated content of the message.
        :param pulumi.Input[bool] override_priority: Whether to allow the alert priority to be configured via the value of the `og_priority` annotation on the alert.
        :param pulumi.Input[Sequence[pulumi.Input['ContactPointOpsgenyResponderArgs']]] responders: Teams, users, escalations and schedules that the alert will be routed to send notifications. If the API Key belongs to a team integration, this field will be overwritten with the owner team. This feature is available from Grafana 10.3+.
        :param pulumi.Input[str] send_tags_as: Whether to send annotations to OpsGenie as Tags, Details, or both. Supported values are `tags`, `details`, `both`, or empty to use the default behavior of Tags.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param pulumi.Input[str] uid: The UID of the contact point.
        :param pulumi.Input[str] url: Allows customization of the OpsGenie API URL.
        """
        pulumi.set(__self__, "api_key", api_key)
        if auto_close is not None:
            pulumi.set(__self__, "auto_close", auto_close)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if override_priority is not None:
            pulumi.set(__self__, "override_priority", override_priority)
        if responders is not None:
            pulumi.set(__self__, "responders", responders)
        if send_tags_as is not None:
            pulumi.set(__self__, "send_tags_as", send_tags_as)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[str]:
        """
        The OpsGenie API key to use.
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_key", value)

    @property
    @pulumi.getter(name="autoClose")
    def auto_close(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to auto-close alerts in OpsGenie when they resolve in the Alertmanager.
        """
        return pulumi.get(self, "auto_close")

    @auto_close.setter
    def auto_close(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "auto_close", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        A templated high-level description to use for the alert.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @disable_resolve_message.setter
    def disable_resolve_message(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_resolve_message", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        The templated content of the message.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter(name="overridePriority")
    def override_priority(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to allow the alert priority to be configured via the value of the `og_priority` annotation on the alert.
        """
        return pulumi.get(self, "override_priority")

    @override_priority.setter
    def override_priority(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "override_priority", value)

    @property
    @pulumi.getter
    def responders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ContactPointOpsgenyResponderArgs']]]]:
        """
        Teams, users, escalations and schedules that the alert will be routed to send notifications. If the API Key belongs to a team integration, this field will be overwritten with the owner team. This feature is available from Grafana 10.3+.
        """
        return pulumi.get(self, "responders")

    @responders.setter
    def responders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ContactPointOpsgenyResponderArgs']]]]):
        pulumi.set(self, "responders", value)

    @property
    @pulumi.getter(name="sendTagsAs")
    def send_tags_as(self) -> Optional[pulumi.Input[str]]:
        """
        Whether to send annotations to OpsGenie as Tags, Details, or both. Supported values are `tags`, `details`, `both`, or empty to use the default behavior of Tags.
        """
        return pulumi.get(self, "send_tags_as")

    @send_tags_as.setter
    def send_tags_as(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "send_tags_as", value)

    @property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "settings", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)

    @property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[str]]:
        """
        Allows customization of the OpsGenie API URL.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class ContactPointOpsgenyResponderArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        Type of the responder. Supported: team, teams, user, escalation, schedule or a template that is expanded to one of these values.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        ID of the responder. Must be specified if name and username are empty.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name of the responder. Must be specified if username and id are empty.
        """
        username: NotRequired[pulumi.Input[str]]
        """
        User name of the responder. Must be specified if name and id are empty.
        """
elif False:
    ContactPointOpsgenyResponderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContactPointOpsgenyResponderArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 username: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: Type of the responder. Supported: team, teams, user, escalation, schedule or a template that is expanded to one of these values.
        :param pulumi.Input[str] id: ID of the responder. Must be specified if name and username are empty.
        :param pulumi.Input[str] name: Name of the responder. Must be specified if username and id are empty.
        :param pulumi.Input[str] username: User name of the responder. Must be specified if name and id are empty.
        """
        pulumi.set(__self__, "type", type)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of the responder. Supported: team, teams, user, escalation, schedule or a template that is expanded to one of these values.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the responder. Must be specified if name and username are empty.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the responder. Must be specified if username and id are empty.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        User name of the responder. Must be specified if name and id are empty.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ContactPointPagerdutyArgsDict(TypedDict):
        integration_key: pulumi.Input[str]
        """
        The PagerDuty API key.
        """
        class_: NotRequired[pulumi.Input[str]]
        """
        The class or type of event, for example `ping failure`.
        """
        client: NotRequired[pulumi.Input[str]]
        """
        The name of the monitoring client that is triggering this event.
        """
        client_url: NotRequired[pulumi.Input[str]]
        """
        The URL of the monitoring client that is triggering this event.
        """
        component: NotRequired[pulumi.Input[str]]
        """
        The component being affected by the event.
        """
        details: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        A set of arbitrary key/value pairs that provide further detail about the incident.
        """
        disable_resolve_message: NotRequired[pulumi.Input[bool]]
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        group: NotRequired[pulumi.Input[str]]
        """
        The group to which the provided component belongs to.
        """
        settings: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        severity: NotRequired[pulumi.Input[str]]
        """
        The PagerDuty event severity level. Default is `critical`.
        """
        source: NotRequired[pulumi.Input[str]]
        """
        The unique location of the affected system.
        """
        summary: NotRequired[pulumi.Input[str]]
        """
        The templated summary message of the event.
        """
        uid: NotRequired[pulumi.Input[str]]
        """
        The UID of the contact point.
        """
        url: NotRequired[pulumi.Input[str]]
        """
        The URL to send API requests to
        """
elif False:
    ContactPointPagerdutyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContactPointPagerdutyArgs:
    def __init__(__self__, *,
                 integration_key: pulumi.Input[str],
                 class_: Optional[pulumi.Input[str]] = None,
                 client: Optional[pulumi.Input[str]] = None,
                 client_url: Optional[pulumi.Input[str]] = None,
                 component: Optional[pulumi.Input[str]] = None,
                 details: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 disable_resolve_message: Optional[pulumi.Input[bool]] = None,
                 group: Optional[pulumi.Input[str]] = None,
                 settings: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 severity: Optional[pulumi.Input[str]] = None,
                 source: Optional[pulumi.Input[str]] = None,
                 summary: Optional[pulumi.Input[str]] = None,
                 uid: Optional[pulumi.Input[str]] = None,
                 url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] integration_key: The PagerDuty API key.
        :param pulumi.Input[str] class_: The class or type of event, for example `ping failure`.
        :param pulumi.Input[str] client: The name of the monitoring client that is triggering this event.
        :param pulumi.Input[str] client_url: The URL of the monitoring client that is triggering this event.
        :param pulumi.Input[str] component: The component being affected by the event.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] details: A set of arbitrary key/value pairs that provide further detail about the incident.
        :param pulumi.Input[bool] disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param pulumi.Input[str] group: The group to which the provided component belongs to.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param pulumi.Input[str] severity: The PagerDuty event severity level. Default is `critical`.
        :param pulumi.Input[str] source: The unique location of the affected system.
        :param pulumi.Input[str] summary: The templated summary message of the event.
        :param pulumi.Input[str] uid: The UID of the contact point.
        :param pulumi.Input[str] url: The URL to send API requests to
        """
        pulumi.set(__self__, "integration_key", integration_key)
        if class_ is not None:
            pulumi.set(__self__, "class_", class_)
        if client is not None:
            pulumi.set(__self__, "client", client)
        if client_url is not None:
            pulumi.set(__self__, "client_url", client_url)
        if component is not None:
            pulumi.set(__self__, "component", component)
        if details is not None:
            pulumi.set(__self__, "details", details)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if group is not None:
            pulumi.set(__self__, "group", group)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if summary is not None:
            pulumi.set(__self__, "summary", summary)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter(name="integrationKey")
    def integration_key(self) -> pulumi.Input[str]:
        """
        The PagerDuty API key.
        """
        return pulumi.get(self, "integration_key")

    @integration_key.setter
    def integration_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "integration_key", value)

    @property
    @pulumi.getter(name="class")
    def class_(self) -> Optional[pulumi.Input[str]]:
        """
        The class or type of event, for example `ping failure`.
        """
        return pulumi.get(self, "class_")

    @class_.setter
    def class_(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "class_", value)

    @property
    @pulumi.getter
    def client(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the monitoring client that is triggering this event.
        """
        return pulumi.get(self, "client")

    @client.setter
    def client(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client", value)

    @property
    @pulumi.getter(name="clientUrl")
    def client_url(self) -> Optional[pulumi.Input[str]]:
        """
        The URL of the monitoring client that is triggering this event.
        """
        return pulumi.get(self, "client_url")

    @client_url.setter
    def client_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_url", value)

    @property
    @pulumi.getter
    def component(self) -> Optional[pulumi.Input[str]]:
        """
        The component being affected by the event.
        """
        return pulumi.get(self, "component")

    @component.setter
    def component(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "component", value)

    @property
    @pulumi.getter
    def details(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A set of arbitrary key/value pairs that provide further detail about the incident.
        """
        return pulumi.get(self, "details")

    @details.setter
    def details(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "details", value)

    @property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @disable_resolve_message.setter
    def disable_resolve_message(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_resolve_message", value)

    @property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input[str]]:
        """
        The group to which the provided component belongs to.
        """
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group", value)

    @property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "settings", value)

    @property
    @pulumi.getter
    def severity(self) -> Optional[pulumi.Input[str]]:
        """
        The PagerDuty event severity level. Default is `critical`.
        """
        return pulumi.get(self, "severity")

    @severity.setter
    def severity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "severity", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[str]]:
        """
        The unique location of the affected system.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter
    def summary(self) -> Optional[pulumi.Input[str]]:
        """
        The templated summary message of the event.
        """
        return pulumi.get(self, "summary")

    @summary.setter
    def summary(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "summary", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)

    @property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[str]]:
        """
        The URL to send API requests to
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class ContactPointPushoverArgsDict(TypedDict):
        api_token: pulumi.Input[str]
        """
        The Pushover API token.
        """
        user_key: pulumi.Input[str]
        """
        The Pushover user key.
        """
        device: NotRequired[pulumi.Input[str]]
        """
        Comma-separated list of devices to which the event is associated.
        """
        disable_resolve_message: NotRequired[pulumi.Input[bool]]
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        expire: NotRequired[pulumi.Input[int]]
        """
        How many seconds for which the notification will continue to be retried by Pushover.
        """
        message: NotRequired[pulumi.Input[str]]
        """
        The templated notification message content.
        """
        ok_priority: NotRequired[pulumi.Input[int]]
        """
        The priority level of the resolved event.
        """
        ok_sound: NotRequired[pulumi.Input[str]]
        """
        The sound associated with the resolved notification.
        """
        priority: NotRequired[pulumi.Input[int]]
        """
        The priority level of the event.
        """
        retry: NotRequired[pulumi.Input[int]]
        """
        How often, in seconds, the Pushover servers will send the same notification to the user.
        """
        settings: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        sound: NotRequired[pulumi.Input[str]]
        """
        The sound associated with the notification.
        """
        title: NotRequired[pulumi.Input[str]]
        """
        The templated title of the message.
        """
        uid: NotRequired[pulumi.Input[str]]
        """
        The UID of the contact point.
        """
        upload_image: NotRequired[pulumi.Input[bool]]
        """
        Whether to send images in the notification or not. Default is true. Requires Grafana to be configured to send images in notifications.
        """
elif False:
    ContactPointPushoverArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContactPointPushoverArgs:
    def __init__(__self__, *,
                 api_token: pulumi.Input[str],
                 user_key: pulumi.Input[str],
                 device: Optional[pulumi.Input[str]] = None,
                 disable_resolve_message: Optional[pulumi.Input[bool]] = None,
                 expire: Optional[pulumi.Input[int]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 ok_priority: Optional[pulumi.Input[int]] = None,
                 ok_sound: Optional[pulumi.Input[str]] = None,
                 priority: Optional[pulumi.Input[int]] = None,
                 retry: Optional[pulumi.Input[int]] = None,
                 settings: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 sound: Optional[pulumi.Input[str]] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 uid: Optional[pulumi.Input[str]] = None,
                 upload_image: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] api_token: The Pushover API token.
        :param pulumi.Input[str] user_key: The Pushover user key.
        :param pulumi.Input[str] device: Comma-separated list of devices to which the event is associated.
        :param pulumi.Input[bool] disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param pulumi.Input[int] expire: How many seconds for which the notification will continue to be retried by Pushover.
        :param pulumi.Input[str] message: The templated notification message content.
        :param pulumi.Input[int] ok_priority: The priority level of the resolved event.
        :param pulumi.Input[str] ok_sound: The sound associated with the resolved notification.
        :param pulumi.Input[int] priority: The priority level of the event.
        :param pulumi.Input[int] retry: How often, in seconds, the Pushover servers will send the same notification to the user.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param pulumi.Input[str] sound: The sound associated with the notification.
        :param pulumi.Input[str] title: The templated title of the message.
        :param pulumi.Input[str] uid: The UID of the contact point.
        :param pulumi.Input[bool] upload_image: Whether to send images in the notification or not. Default is true. Requires Grafana to be configured to send images in notifications.
        """
        pulumi.set(__self__, "api_token", api_token)
        pulumi.set(__self__, "user_key", user_key)
        if device is not None:
            pulumi.set(__self__, "device", device)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if expire is not None:
            pulumi.set(__self__, "expire", expire)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if ok_priority is not None:
            pulumi.set(__self__, "ok_priority", ok_priority)
        if ok_sound is not None:
            pulumi.set(__self__, "ok_sound", ok_sound)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if retry is not None:
            pulumi.set(__self__, "retry", retry)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if sound is not None:
            pulumi.set(__self__, "sound", sound)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)
        if upload_image is not None:
            pulumi.set(__self__, "upload_image", upload_image)

    @property
    @pulumi.getter(name="apiToken")
    def api_token(self) -> pulumi.Input[str]:
        """
        The Pushover API token.
        """
        return pulumi.get(self, "api_token")

    @api_token.setter
    def api_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_token", value)

    @property
    @pulumi.getter(name="userKey")
    def user_key(self) -> pulumi.Input[str]:
        """
        The Pushover user key.
        """
        return pulumi.get(self, "user_key")

    @user_key.setter
    def user_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "user_key", value)

    @property
    @pulumi.getter
    def device(self) -> Optional[pulumi.Input[str]]:
        """
        Comma-separated list of devices to which the event is associated.
        """
        return pulumi.get(self, "device")

    @device.setter
    def device(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "device", value)

    @property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @disable_resolve_message.setter
    def disable_resolve_message(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_resolve_message", value)

    @property
    @pulumi.getter
    def expire(self) -> Optional[pulumi.Input[int]]:
        """
        How many seconds for which the notification will continue to be retried by Pushover.
        """
        return pulumi.get(self, "expire")

    @expire.setter
    def expire(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "expire", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        The templated notification message content.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter(name="okPriority")
    def ok_priority(self) -> Optional[pulumi.Input[int]]:
        """
        The priority level of the resolved event.
        """
        return pulumi.get(self, "ok_priority")

    @ok_priority.setter
    def ok_priority(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ok_priority", value)

    @property
    @pulumi.getter(name="okSound")
    def ok_sound(self) -> Optional[pulumi.Input[str]]:
        """
        The sound associated with the resolved notification.
        """
        return pulumi.get(self, "ok_sound")

    @ok_sound.setter
    def ok_sound(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ok_sound", value)

    @property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[int]]:
        """
        The priority level of the event.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def retry(self) -> Optional[pulumi.Input[int]]:
        """
        How often, in seconds, the Pushover servers will send the same notification to the user.
        """
        return pulumi.get(self, "retry")

    @retry.setter
    def retry(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "retry", value)

    @property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "settings", value)

    @property
    @pulumi.getter
    def sound(self) -> Optional[pulumi.Input[str]]:
        """
        The sound associated with the notification.
        """
        return pulumi.get(self, "sound")

    @sound.setter
    def sound(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sound", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        The templated title of the message.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)

    @property
    @pulumi.getter(name="uploadImage")
    def upload_image(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to send images in the notification or not. Default is true. Requires Grafana to be configured to send images in notifications.
        """
        return pulumi.get(self, "upload_image")

    @upload_image.setter
    def upload_image(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "upload_image", value)


if not MYPY:
    class ContactPointSensugoArgsDict(TypedDict):
        api_key: pulumi.Input[str]
        """
        The SensuGo API key.
        """
        url: pulumi.Input[str]
        """
        The SensuGo URL to send requests to.
        """
        check: NotRequired[pulumi.Input[str]]
        """
        The SensuGo check to which the event should be routed.
        """
        disable_resolve_message: NotRequired[pulumi.Input[bool]]
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        entity: NotRequired[pulumi.Input[str]]
        """
        The entity being monitored.
        """
        handler: NotRequired[pulumi.Input[str]]
        """
        A custom handler to execute in addition to the check.
        """
        message: NotRequired[pulumi.Input[str]]
        """
        Templated message content describing the alert.
        """
        namespace: NotRequired[pulumi.Input[str]]
        """
        The namespace in which the check resides.
        """
        settings: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        uid: NotRequired[pulumi.Input[str]]
        """
        The UID of the contact point.
        """
elif False:
    ContactPointSensugoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContactPointSensugoArgs:
    def __init__(__self__, *,
                 api_key: pulumi.Input[str],
                 url: pulumi.Input[str],
                 check: Optional[pulumi.Input[str]] = None,
                 disable_resolve_message: Optional[pulumi.Input[bool]] = None,
                 entity: Optional[pulumi.Input[str]] = None,
                 handler: Optional[pulumi.Input[str]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 namespace: Optional[pulumi.Input[str]] = None,
                 settings: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 uid: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] api_key: The SensuGo API key.
        :param pulumi.Input[str] url: The SensuGo URL to send requests to.
        :param pulumi.Input[str] check: The SensuGo check to which the event should be routed.
        :param pulumi.Input[bool] disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param pulumi.Input[str] entity: The entity being monitored.
        :param pulumi.Input[str] handler: A custom handler to execute in addition to the check.
        :param pulumi.Input[str] message: Templated message content describing the alert.
        :param pulumi.Input[str] namespace: The namespace in which the check resides.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param pulumi.Input[str] uid: The UID of the contact point.
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "url", url)
        if check is not None:
            pulumi.set(__self__, "check", check)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if entity is not None:
            pulumi.set(__self__, "entity", entity)
        if handler is not None:
            pulumi.set(__self__, "handler", handler)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[str]:
        """
        The SensuGo API key.
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_key", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        The SensuGo URL to send requests to.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter
    def check(self) -> Optional[pulumi.Input[str]]:
        """
        The SensuGo check to which the event should be routed.
        """
        return pulumi.get(self, "check")

    @check.setter
    def check(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "check", value)

    @property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @disable_resolve_message.setter
    def disable_resolve_message(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_resolve_message", value)

    @property
    @pulumi.getter
    def entity(self) -> Optional[pulumi.Input[str]]:
        """
        The entity being monitored.
        """
        return pulumi.get(self, "entity")

    @entity.setter
    def entity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "entity", value)

    @property
    @pulumi.getter
    def handler(self) -> Optional[pulumi.Input[str]]:
        """
        A custom handler to execute in addition to the check.
        """
        return pulumi.get(self, "handler")

    @handler.setter
    def handler(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "handler", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        Templated message content describing the alert.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        """
        The namespace in which the check resides.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "settings", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)


if not MYPY:
    class ContactPointSlackArgsDict(TypedDict):
        disable_resolve_message: NotRequired[pulumi.Input[bool]]
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        endpoint_url: NotRequired[pulumi.Input[str]]
        """
        Use this to override the Slack API endpoint URL to send requests to.
        """
        icon_emoji: NotRequired[pulumi.Input[str]]
        """
        The name of a Slack workspace emoji to use as the bot icon.
        """
        icon_url: NotRequired[pulumi.Input[str]]
        """
        A URL of an image to use as the bot icon.
        """
        mention_channel: NotRequired[pulumi.Input[str]]
        """
        Describes how to ping the slack channel that messages are being sent to. Options are `here` for an @here ping, `channel` for @channel, or empty for no ping.
        """
        mention_groups: NotRequired[pulumi.Input[str]]
        """
        Comma-separated list of groups to mention in the message.
        """
        mention_users: NotRequired[pulumi.Input[str]]
        """
        Comma-separated list of users to mention in the message.
        """
        recipient: NotRequired[pulumi.Input[str]]
        """
        Channel, private group, or IM channel (can be an encoded ID or a name) to send messages to.
        """
        settings: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        text: NotRequired[pulumi.Input[str]]
        """
        Templated content of the message.
        """
        title: NotRequired[pulumi.Input[str]]
        """
        Templated title of the message.
        """
        token: NotRequired[pulumi.Input[str]]
        """
        A Slack API token,for sending messages directly without the webhook method.
        """
        uid: NotRequired[pulumi.Input[str]]
        """
        The UID of the contact point.
        """
        url: NotRequired[pulumi.Input[str]]
        """
        A Slack webhook URL,for sending messages via the webhook method.
        """
        username: NotRequired[pulumi.Input[str]]
        """
        Username for the bot to use.
        """
elif False:
    ContactPointSlackArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContactPointSlackArgs:
    def __init__(__self__, *,
                 disable_resolve_message: Optional[pulumi.Input[bool]] = None,
                 endpoint_url: Optional[pulumi.Input[str]] = None,
                 icon_emoji: Optional[pulumi.Input[str]] = None,
                 icon_url: Optional[pulumi.Input[str]] = None,
                 mention_channel: Optional[pulumi.Input[str]] = None,
                 mention_groups: Optional[pulumi.Input[str]] = None,
                 mention_users: Optional[pulumi.Input[str]] = None,
                 recipient: Optional[pulumi.Input[str]] = None,
                 settings: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 text: Optional[pulumi.Input[str]] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 token: Optional[pulumi.Input[str]] = None,
                 uid: Optional[pulumi.Input[str]] = None,
                 url: Optional[pulumi.Input[str]] = None,
                 username: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param pulumi.Input[str] endpoint_url: Use this to override the Slack API endpoint URL to send requests to.
        :param pulumi.Input[str] icon_emoji: The name of a Slack workspace emoji to use as the bot icon.
        :param pulumi.Input[str] icon_url: A URL of an image to use as the bot icon.
        :param pulumi.Input[str] mention_channel: Describes how to ping the slack channel that messages are being sent to. Options are `here` for an @here ping, `channel` for @channel, or empty for no ping.
        :param pulumi.Input[str] mention_groups: Comma-separated list of groups to mention in the message.
        :param pulumi.Input[str] mention_users: Comma-separated list of users to mention in the message.
        :param pulumi.Input[str] recipient: Channel, private group, or IM channel (can be an encoded ID or a name) to send messages to.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param pulumi.Input[str] text: Templated content of the message.
        :param pulumi.Input[str] title: Templated title of the message.
        :param pulumi.Input[str] token: A Slack API token,for sending messages directly without the webhook method.
        :param pulumi.Input[str] uid: The UID of the contact point.
        :param pulumi.Input[str] url: A Slack webhook URL,for sending messages via the webhook method.
        :param pulumi.Input[str] username: Username for the bot to use.
        """
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if endpoint_url is not None:
            pulumi.set(__self__, "endpoint_url", endpoint_url)
        if icon_emoji is not None:
            pulumi.set(__self__, "icon_emoji", icon_emoji)
        if icon_url is not None:
            pulumi.set(__self__, "icon_url", icon_url)
        if mention_channel is not None:
            pulumi.set(__self__, "mention_channel", mention_channel)
        if mention_groups is not None:
            pulumi.set(__self__, "mention_groups", mention_groups)
        if mention_users is not None:
            pulumi.set(__self__, "mention_users", mention_users)
        if recipient is not None:
            pulumi.set(__self__, "recipient", recipient)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if text is not None:
            pulumi.set(__self__, "text", text)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if token is not None:
            pulumi.set(__self__, "token", token)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @disable_resolve_message.setter
    def disable_resolve_message(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_resolve_message", value)

    @property
    @pulumi.getter(name="endpointUrl")
    def endpoint_url(self) -> Optional[pulumi.Input[str]]:
        """
        Use this to override the Slack API endpoint URL to send requests to.
        """
        return pulumi.get(self, "endpoint_url")

    @endpoint_url.setter
    def endpoint_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "endpoint_url", value)

    @property
    @pulumi.getter(name="iconEmoji")
    def icon_emoji(self) -> Optional[pulumi.Input[str]]:
        """
        The name of a Slack workspace emoji to use as the bot icon.
        """
        return pulumi.get(self, "icon_emoji")

    @icon_emoji.setter
    def icon_emoji(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "icon_emoji", value)

    @property
    @pulumi.getter(name="iconUrl")
    def icon_url(self) -> Optional[pulumi.Input[str]]:
        """
        A URL of an image to use as the bot icon.
        """
        return pulumi.get(self, "icon_url")

    @icon_url.setter
    def icon_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "icon_url", value)

    @property
    @pulumi.getter(name="mentionChannel")
    def mention_channel(self) -> Optional[pulumi.Input[str]]:
        """
        Describes how to ping the slack channel that messages are being sent to. Options are `here` for an @here ping, `channel` for @channel, or empty for no ping.
        """
        return pulumi.get(self, "mention_channel")

    @mention_channel.setter
    def mention_channel(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mention_channel", value)

    @property
    @pulumi.getter(name="mentionGroups")
    def mention_groups(self) -> Optional[pulumi.Input[str]]:
        """
        Comma-separated list of groups to mention in the message.
        """
        return pulumi.get(self, "mention_groups")

    @mention_groups.setter
    def mention_groups(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mention_groups", value)

    @property
    @pulumi.getter(name="mentionUsers")
    def mention_users(self) -> Optional[pulumi.Input[str]]:
        """
        Comma-separated list of users to mention in the message.
        """
        return pulumi.get(self, "mention_users")

    @mention_users.setter
    def mention_users(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mention_users", value)

    @property
    @pulumi.getter
    def recipient(self) -> Optional[pulumi.Input[str]]:
        """
        Channel, private group, or IM channel (can be an encoded ID or a name) to send messages to.
        """
        return pulumi.get(self, "recipient")

    @recipient.setter
    def recipient(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "recipient", value)

    @property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "settings", value)

    @property
    @pulumi.getter
    def text(self) -> Optional[pulumi.Input[str]]:
        """
        Templated content of the message.
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "text", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        Templated title of the message.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def token(self) -> Optional[pulumi.Input[str]]:
        """
        A Slack API token,for sending messages directly without the webhook method.
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "token", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)

    @property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[str]]:
        """
        A Slack webhook URL,for sending messages via the webhook method.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        Username for the bot to use.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ContactPointSnArgsDict(TypedDict):
        topic: pulumi.Input[str]
        """
        The Amazon SNS topic to send notifications to.
        """
        access_key: NotRequired[pulumi.Input[str]]
        """
        AWS access key ID used to authenticate with Amazon SNS.
        """
        assume_role_arn: NotRequired[pulumi.Input[str]]
        """
        The Amazon Resource Name (ARN) of the role to assume to send notifications to Amazon SNS.
        """
        auth_provider: NotRequired[pulumi.Input[str]]
        """
        The authentication provider to use. Valid values are `default`, `arn` and `keys`. Default is `default`. Defaults to `default`.
        """
        body: NotRequired[pulumi.Input[str]]
        disable_resolve_message: NotRequired[pulumi.Input[bool]]
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        external_id: NotRequired[pulumi.Input[str]]
        """
        The external ID to use when assuming the role.
        """
        message_format: NotRequired[pulumi.Input[str]]
        """
        The format of the message to send. Valid values are `text`, `body` and `json`. Default is `text`. Defaults to `text`.
        """
        secret_key: NotRequired[pulumi.Input[str]]
        """
        AWS secret access key used to authenticate with Amazon SNS.
        """
        settings: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        subject: NotRequired[pulumi.Input[str]]
        uid: NotRequired[pulumi.Input[str]]
        """
        The UID of the contact point.
        """
elif False:
    ContactPointSnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContactPointSnArgs:
    def __init__(__self__, *,
                 topic: pulumi.Input[str],
                 access_key: Optional[pulumi.Input[str]] = None,
                 assume_role_arn: Optional[pulumi.Input[str]] = None,
                 auth_provider: Optional[pulumi.Input[str]] = None,
                 body: Optional[pulumi.Input[str]] = None,
                 disable_resolve_message: Optional[pulumi.Input[bool]] = None,
                 external_id: Optional[pulumi.Input[str]] = None,
                 message_format: Optional[pulumi.Input[str]] = None,
                 secret_key: Optional[pulumi.Input[str]] = None,
                 settings: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 subject: Optional[pulumi.Input[str]] = None,
                 uid: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] topic: The Amazon SNS topic to send notifications to.
        :param pulumi.Input[str] access_key: AWS access key ID used to authenticate with Amazon SNS.
        :param pulumi.Input[str] assume_role_arn: The Amazon Resource Name (ARN) of the role to assume to send notifications to Amazon SNS.
        :param pulumi.Input[str] auth_provider: The authentication provider to use. Valid values are `default`, `arn` and `keys`. Default is `default`. Defaults to `default`.
        :param pulumi.Input[bool] disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param pulumi.Input[str] external_id: The external ID to use when assuming the role.
        :param pulumi.Input[str] message_format: The format of the message to send. Valid values are `text`, `body` and `json`. Default is `text`. Defaults to `text`.
        :param pulumi.Input[str] secret_key: AWS secret access key used to authenticate with Amazon SNS.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param pulumi.Input[str] uid: The UID of the contact point.
        """
        pulumi.set(__self__, "topic", topic)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if assume_role_arn is not None:
            pulumi.set(__self__, "assume_role_arn", assume_role_arn)
        if auth_provider is not None:
            pulumi.set(__self__, "auth_provider", auth_provider)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)
        if message_format is not None:
            pulumi.set(__self__, "message_format", message_format)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if subject is not None:
            pulumi.set(__self__, "subject", subject)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter
    def topic(self) -> pulumi.Input[str]:
        """
        The Amazon SNS topic to send notifications to.
        """
        return pulumi.get(self, "topic")

    @topic.setter
    def topic(self, value: pulumi.Input[str]):
        pulumi.set(self, "topic", value)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[pulumi.Input[str]]:
        """
        AWS access key ID used to authenticate with Amazon SNS.
        """
        return pulumi.get(self, "access_key")

    @access_key.setter
    def access_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_key", value)

    @property
    @pulumi.getter(name="assumeRoleArn")
    def assume_role_arn(self) -> Optional[pulumi.Input[str]]:
        """
        The Amazon Resource Name (ARN) of the role to assume to send notifications to Amazon SNS.
        """
        return pulumi.get(self, "assume_role_arn")

    @assume_role_arn.setter
    def assume_role_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "assume_role_arn", value)

    @property
    @pulumi.getter(name="authProvider")
    def auth_provider(self) -> Optional[pulumi.Input[str]]:
        """
        The authentication provider to use. Valid values are `default`, `arn` and `keys`. Default is `default`. Defaults to `default`.
        """
        return pulumi.get(self, "auth_provider")

    @auth_provider.setter
    def auth_provider(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auth_provider", value)

    @property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "body", value)

    @property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @disable_resolve_message.setter
    def disable_resolve_message(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_resolve_message", value)

    @property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[pulumi.Input[str]]:
        """
        The external ID to use when assuming the role.
        """
        return pulumi.get(self, "external_id")

    @external_id.setter
    def external_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "external_id", value)

    @property
    @pulumi.getter(name="messageFormat")
    def message_format(self) -> Optional[pulumi.Input[str]]:
        """
        The format of the message to send. Valid values are `text`, `body` and `json`. Default is `text`. Defaults to `text`.
        """
        return pulumi.get(self, "message_format")

    @message_format.setter
    def message_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message_format", value)

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[pulumi.Input[str]]:
        """
        AWS secret access key used to authenticate with Amazon SNS.
        """
        return pulumi.get(self, "secret_key")

    @secret_key.setter
    def secret_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret_key", value)

    @property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "settings", value)

    @property
    @pulumi.getter
    def subject(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "subject")

    @subject.setter
    def subject(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subject", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)


if not MYPY:
    class ContactPointTeamArgsDict(TypedDict):
        url: pulumi.Input[str]
        """
        A Teams webhook URL.
        """
        disable_resolve_message: NotRequired[pulumi.Input[bool]]
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        message: NotRequired[pulumi.Input[str]]
        """
        The templated message content to send.
        """
        section_title: NotRequired[pulumi.Input[str]]
        """
        The templated subtitle for each message section.
        """
        settings: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        title: NotRequired[pulumi.Input[str]]
        """
        The templated title of the message.
        """
        uid: NotRequired[pulumi.Input[str]]
        """
        The UID of the contact point.
        """
elif False:
    ContactPointTeamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContactPointTeamArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 disable_resolve_message: Optional[pulumi.Input[bool]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 section_title: Optional[pulumi.Input[str]] = None,
                 settings: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 uid: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] url: A Teams webhook URL.
        :param pulumi.Input[bool] disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param pulumi.Input[str] message: The templated message content to send.
        :param pulumi.Input[str] section_title: The templated subtitle for each message section.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param pulumi.Input[str] title: The templated title of the message.
        :param pulumi.Input[str] uid: The UID of the contact point.
        """
        pulumi.set(__self__, "url", url)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if section_title is not None:
            pulumi.set(__self__, "section_title", section_title)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        A Teams webhook URL.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @disable_resolve_message.setter
    def disable_resolve_message(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_resolve_message", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        The templated message content to send.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter(name="sectionTitle")
    def section_title(self) -> Optional[pulumi.Input[str]]:
        """
        The templated subtitle for each message section.
        """
        return pulumi.get(self, "section_title")

    @section_title.setter
    def section_title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "section_title", value)

    @property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "settings", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        The templated title of the message.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)


if not MYPY:
    class ContactPointTelegramArgsDict(TypedDict):
        chat_id: pulumi.Input[str]
        """
        The chat ID to send messages to.
        """
        token: pulumi.Input[str]
        """
        The Telegram bot token.
        """
        disable_notifications: NotRequired[pulumi.Input[bool]]
        """
        When set users will receive a notification with no sound.
        """
        disable_resolve_message: NotRequired[pulumi.Input[bool]]
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        disable_web_page_preview: NotRequired[pulumi.Input[bool]]
        """
        When set it disables link previews for links in the message.
        """
        message: NotRequired[pulumi.Input[str]]
        """
        The templated content of the message.
        """
        message_thread_id: NotRequired[pulumi.Input[str]]
        """
        The ID of the message thread to send the message to.
        """
        parse_mode: NotRequired[pulumi.Input[str]]
        """
        Mode for parsing entities in the message text. Supported: None, Markdown, MarkdownV2, and HTML. HTML is the default.
        """
        protect_content: NotRequired[pulumi.Input[bool]]
        """
        When set it protects the contents of the message from forwarding and saving.
        """
        settings: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        uid: NotRequired[pulumi.Input[str]]
        """
        The UID of the contact point.
        """
elif False:
    ContactPointTelegramArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContactPointTelegramArgs:
    def __init__(__self__, *,
                 chat_id: pulumi.Input[str],
                 token: pulumi.Input[str],
                 disable_notifications: Optional[pulumi.Input[bool]] = None,
                 disable_resolve_message: Optional[pulumi.Input[bool]] = None,
                 disable_web_page_preview: Optional[pulumi.Input[bool]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 message_thread_id: Optional[pulumi.Input[str]] = None,
                 parse_mode: Optional[pulumi.Input[str]] = None,
                 protect_content: Optional[pulumi.Input[bool]] = None,
                 settings: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 uid: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] chat_id: The chat ID to send messages to.
        :param pulumi.Input[str] token: The Telegram bot token.
        :param pulumi.Input[bool] disable_notifications: When set users will receive a notification with no sound.
        :param pulumi.Input[bool] disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param pulumi.Input[bool] disable_web_page_preview: When set it disables link previews for links in the message.
        :param pulumi.Input[str] message: The templated content of the message.
        :param pulumi.Input[str] message_thread_id: The ID of the message thread to send the message to.
        :param pulumi.Input[str] parse_mode: Mode for parsing entities in the message text. Supported: None, Markdown, MarkdownV2, and HTML. HTML is the default.
        :param pulumi.Input[bool] protect_content: When set it protects the contents of the message from forwarding and saving.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param pulumi.Input[str] uid: The UID of the contact point.
        """
        pulumi.set(__self__, "chat_id", chat_id)
        pulumi.set(__self__, "token", token)
        if disable_notifications is not None:
            pulumi.set(__self__, "disable_notifications", disable_notifications)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if disable_web_page_preview is not None:
            pulumi.set(__self__, "disable_web_page_preview", disable_web_page_preview)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if message_thread_id is not None:
            pulumi.set(__self__, "message_thread_id", message_thread_id)
        if parse_mode is not None:
            pulumi.set(__self__, "parse_mode", parse_mode)
        if protect_content is not None:
            pulumi.set(__self__, "protect_content", protect_content)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="chatId")
    def chat_id(self) -> pulumi.Input[str]:
        """
        The chat ID to send messages to.
        """
        return pulumi.get(self, "chat_id")

    @chat_id.setter
    def chat_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "chat_id", value)

    @property
    @pulumi.getter
    def token(self) -> pulumi.Input[str]:
        """
        The Telegram bot token.
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: pulumi.Input[str]):
        pulumi.set(self, "token", value)

    @property
    @pulumi.getter(name="disableNotifications")
    def disable_notifications(self) -> Optional[pulumi.Input[bool]]:
        """
        When set users will receive a notification with no sound.
        """
        return pulumi.get(self, "disable_notifications")

    @disable_notifications.setter
    def disable_notifications(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_notifications", value)

    @property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @disable_resolve_message.setter
    def disable_resolve_message(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_resolve_message", value)

    @property
    @pulumi.getter(name="disableWebPagePreview")
    def disable_web_page_preview(self) -> Optional[pulumi.Input[bool]]:
        """
        When set it disables link previews for links in the message.
        """
        return pulumi.get(self, "disable_web_page_preview")

    @disable_web_page_preview.setter
    def disable_web_page_preview(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_web_page_preview", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        The templated content of the message.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter(name="messageThreadId")
    def message_thread_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the message thread to send the message to.
        """
        return pulumi.get(self, "message_thread_id")

    @message_thread_id.setter
    def message_thread_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message_thread_id", value)

    @property
    @pulumi.getter(name="parseMode")
    def parse_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Mode for parsing entities in the message text. Supported: None, Markdown, MarkdownV2, and HTML. HTML is the default.
        """
        return pulumi.get(self, "parse_mode")

    @parse_mode.setter
    def parse_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "parse_mode", value)

    @property
    @pulumi.getter(name="protectContent")
    def protect_content(self) -> Optional[pulumi.Input[bool]]:
        """
        When set it protects the contents of the message from forwarding and saving.
        """
        return pulumi.get(self, "protect_content")

    @protect_content.setter
    def protect_content(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "protect_content", value)

    @property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "settings", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)


if not MYPY:
    class ContactPointThreemaArgsDict(TypedDict):
        api_secret: pulumi.Input[str]
        """
        The Threema API key.
        """
        gateway_id: pulumi.Input[str]
        """
        The Threema gateway ID.
        """
        recipient_id: pulumi.Input[str]
        """
        The ID of the recipient of the message.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        The templated description of the message.
        """
        disable_resolve_message: NotRequired[pulumi.Input[bool]]
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        settings: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        title: NotRequired[pulumi.Input[str]]
        """
        The templated title of the message.
        """
        uid: NotRequired[pulumi.Input[str]]
        """
        The UID of the contact point.
        """
elif False:
    ContactPointThreemaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContactPointThreemaArgs:
    def __init__(__self__, *,
                 api_secret: pulumi.Input[str],
                 gateway_id: pulumi.Input[str],
                 recipient_id: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None,
                 disable_resolve_message: Optional[pulumi.Input[bool]] = None,
                 settings: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 uid: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] api_secret: The Threema API key.
        :param pulumi.Input[str] gateway_id: The Threema gateway ID.
        :param pulumi.Input[str] recipient_id: The ID of the recipient of the message.
        :param pulumi.Input[str] description: The templated description of the message.
        :param pulumi.Input[bool] disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param pulumi.Input[str] title: The templated title of the message.
        :param pulumi.Input[str] uid: The UID of the contact point.
        """
        pulumi.set(__self__, "api_secret", api_secret)
        pulumi.set(__self__, "gateway_id", gateway_id)
        pulumi.set(__self__, "recipient_id", recipient_id)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="apiSecret")
    def api_secret(self) -> pulumi.Input[str]:
        """
        The Threema API key.
        """
        return pulumi.get(self, "api_secret")

    @api_secret.setter
    def api_secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_secret", value)

    @property
    @pulumi.getter(name="gatewayId")
    def gateway_id(self) -> pulumi.Input[str]:
        """
        The Threema gateway ID.
        """
        return pulumi.get(self, "gateway_id")

    @gateway_id.setter
    def gateway_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "gateway_id", value)

    @property
    @pulumi.getter(name="recipientId")
    def recipient_id(self) -> pulumi.Input[str]:
        """
        The ID of the recipient of the message.
        """
        return pulumi.get(self, "recipient_id")

    @recipient_id.setter
    def recipient_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "recipient_id", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The templated description of the message.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @disable_resolve_message.setter
    def disable_resolve_message(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_resolve_message", value)

    @property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "settings", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        The templated title of the message.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)


if not MYPY:
    class ContactPointVictoropArgsDict(TypedDict):
        url: pulumi.Input[str]
        """
        The VictorOps webhook URL.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        Templated description of the message.
        """
        disable_resolve_message: NotRequired[pulumi.Input[bool]]
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        message_type: NotRequired[pulumi.Input[str]]
        """
        The VictorOps alert state - typically either `CRITICAL` or `RECOVERY`.
        """
        settings: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        title: NotRequired[pulumi.Input[str]]
        """
        Templated title to display.
        """
        uid: NotRequired[pulumi.Input[str]]
        """
        The UID of the contact point.
        """
elif False:
    ContactPointVictoropArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContactPointVictoropArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None,
                 disable_resolve_message: Optional[pulumi.Input[bool]] = None,
                 message_type: Optional[pulumi.Input[str]] = None,
                 settings: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 uid: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] url: The VictorOps webhook URL.
        :param pulumi.Input[str] description: Templated description of the message.
        :param pulumi.Input[bool] disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param pulumi.Input[str] message_type: The VictorOps alert state - typically either `CRITICAL` or `RECOVERY`.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param pulumi.Input[str] title: Templated title to display.
        :param pulumi.Input[str] uid: The UID of the contact point.
        """
        pulumi.set(__self__, "url", url)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if message_type is not None:
            pulumi.set(__self__, "message_type", message_type)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        The VictorOps webhook URL.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Templated description of the message.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @disable_resolve_message.setter
    def disable_resolve_message(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_resolve_message", value)

    @property
    @pulumi.getter(name="messageType")
    def message_type(self) -> Optional[pulumi.Input[str]]:
        """
        The VictorOps alert state - typically either `CRITICAL` or `RECOVERY`.
        """
        return pulumi.get(self, "message_type")

    @message_type.setter
    def message_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message_type", value)

    @property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "settings", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        Templated title to display.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)


if not MYPY:
    class ContactPointWebexArgsDict(TypedDict):
        api_url: NotRequired[pulumi.Input[str]]
        """
        The URL to send webhook requests to.
        """
        disable_resolve_message: NotRequired[pulumi.Input[bool]]
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        message: NotRequired[pulumi.Input[str]]
        """
        The templated title of the message to send.
        """
        room_id: NotRequired[pulumi.Input[str]]
        """
        ID of the Webex Teams room where to send the messages.
        """
        settings: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        token: NotRequired[pulumi.Input[str]]
        """
        The bearer token used to authorize the client.
        """
        uid: NotRequired[pulumi.Input[str]]
        """
        The UID of the contact point.
        """
elif False:
    ContactPointWebexArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContactPointWebexArgs:
    def __init__(__self__, *,
                 api_url: Optional[pulumi.Input[str]] = None,
                 disable_resolve_message: Optional[pulumi.Input[bool]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 room_id: Optional[pulumi.Input[str]] = None,
                 settings: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 token: Optional[pulumi.Input[str]] = None,
                 uid: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] api_url: The URL to send webhook requests to.
        :param pulumi.Input[bool] disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param pulumi.Input[str] message: The templated title of the message to send.
        :param pulumi.Input[str] room_id: ID of the Webex Teams room where to send the messages.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param pulumi.Input[str] token: The bearer token used to authorize the client.
        :param pulumi.Input[str] uid: The UID of the contact point.
        """
        if api_url is not None:
            pulumi.set(__self__, "api_url", api_url)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if room_id is not None:
            pulumi.set(__self__, "room_id", room_id)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if token is not None:
            pulumi.set(__self__, "token", token)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="apiUrl")
    def api_url(self) -> Optional[pulumi.Input[str]]:
        """
        The URL to send webhook requests to.
        """
        return pulumi.get(self, "api_url")

    @api_url.setter
    def api_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_url", value)

    @property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @disable_resolve_message.setter
    def disable_resolve_message(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_resolve_message", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        The templated title of the message to send.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter(name="roomId")
    def room_id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the Webex Teams room where to send the messages.
        """
        return pulumi.get(self, "room_id")

    @room_id.setter
    def room_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "room_id", value)

    @property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "settings", value)

    @property
    @pulumi.getter
    def token(self) -> Optional[pulumi.Input[str]]:
        """
        The bearer token used to authorize the client.
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "token", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)


if not MYPY:
    class ContactPointWebhookArgsDict(TypedDict):
        url: pulumi.Input[str]
        """
        The URL to send webhook requests to.
        """
        authorization_credentials: NotRequired[pulumi.Input[str]]
        """
        Allows a custom authorization scheme - attaches an auth header with this value. Do not use in conjunction with basic auth parameters.
        """
        authorization_scheme: NotRequired[pulumi.Input[str]]
        """
        Allows a custom authorization scheme - attaches an auth header with this name. Do not use in conjunction with basic auth parameters.
        """
        basic_auth_password: NotRequired[pulumi.Input[str]]
        """
        The username to use in basic auth headers attached to the request. If omitted, basic auth will not be used.
        """
        basic_auth_user: NotRequired[pulumi.Input[str]]
        """
        The username to use in basic auth headers attached to the request. If omitted, basic auth will not be used.
        """
        disable_resolve_message: NotRequired[pulumi.Input[bool]]
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        http_method: NotRequired[pulumi.Input[str]]
        """
        The HTTP method to use in the request. Defaults to `POST`.
        """
        max_alerts: NotRequired[pulumi.Input[int]]
        """
        The maximum number of alerts to send in a single request. This can be helpful in limiting the size of the request body. The default is 0, which indicates no limit.
        """
        message: NotRequired[pulumi.Input[str]]
        """
        Custom message. You can use template variables.
        """
        settings: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        title: NotRequired[pulumi.Input[str]]
        """
        Templated title of the message.
        """
        uid: NotRequired[pulumi.Input[str]]
        """
        The UID of the contact point.
        """
elif False:
    ContactPointWebhookArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContactPointWebhookArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 authorization_credentials: Optional[pulumi.Input[str]] = None,
                 authorization_scheme: Optional[pulumi.Input[str]] = None,
                 basic_auth_password: Optional[pulumi.Input[str]] = None,
                 basic_auth_user: Optional[pulumi.Input[str]] = None,
                 disable_resolve_message: Optional[pulumi.Input[bool]] = None,
                 http_method: Optional[pulumi.Input[str]] = None,
                 max_alerts: Optional[pulumi.Input[int]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 settings: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 uid: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] url: The URL to send webhook requests to.
        :param pulumi.Input[str] authorization_credentials: Allows a custom authorization scheme - attaches an auth header with this value. Do not use in conjunction with basic auth parameters.
        :param pulumi.Input[str] authorization_scheme: Allows a custom authorization scheme - attaches an auth header with this name. Do not use in conjunction with basic auth parameters.
        :param pulumi.Input[str] basic_auth_password: The username to use in basic auth headers attached to the request. If omitted, basic auth will not be used.
        :param pulumi.Input[str] basic_auth_user: The username to use in basic auth headers attached to the request. If omitted, basic auth will not be used.
        :param pulumi.Input[bool] disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param pulumi.Input[str] http_method: The HTTP method to use in the request. Defaults to `POST`.
        :param pulumi.Input[int] max_alerts: The maximum number of alerts to send in a single request. This can be helpful in limiting the size of the request body. The default is 0, which indicates no limit.
        :param pulumi.Input[str] message: Custom message. You can use template variables.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param pulumi.Input[str] title: Templated title of the message.
        :param pulumi.Input[str] uid: The UID of the contact point.
        """
        pulumi.set(__self__, "url", url)
        if authorization_credentials is not None:
            pulumi.set(__self__, "authorization_credentials", authorization_credentials)
        if authorization_scheme is not None:
            pulumi.set(__self__, "authorization_scheme", authorization_scheme)
        if basic_auth_password is not None:
            pulumi.set(__self__, "basic_auth_password", basic_auth_password)
        if basic_auth_user is not None:
            pulumi.set(__self__, "basic_auth_user", basic_auth_user)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if http_method is not None:
            pulumi.set(__self__, "http_method", http_method)
        if max_alerts is not None:
            pulumi.set(__self__, "max_alerts", max_alerts)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        The URL to send webhook requests to.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="authorizationCredentials")
    def authorization_credentials(self) -> Optional[pulumi.Input[str]]:
        """
        Allows a custom authorization scheme - attaches an auth header with this value. Do not use in conjunction with basic auth parameters.
        """
        return pulumi.get(self, "authorization_credentials")

    @authorization_credentials.setter
    def authorization_credentials(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "authorization_credentials", value)

    @property
    @pulumi.getter(name="authorizationScheme")
    def authorization_scheme(self) -> Optional[pulumi.Input[str]]:
        """
        Allows a custom authorization scheme - attaches an auth header with this name. Do not use in conjunction with basic auth parameters.
        """
        return pulumi.get(self, "authorization_scheme")

    @authorization_scheme.setter
    def authorization_scheme(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "authorization_scheme", value)

    @property
    @pulumi.getter(name="basicAuthPassword")
    def basic_auth_password(self) -> Optional[pulumi.Input[str]]:
        """
        The username to use in basic auth headers attached to the request. If omitted, basic auth will not be used.
        """
        return pulumi.get(self, "basic_auth_password")

    @basic_auth_password.setter
    def basic_auth_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "basic_auth_password", value)

    @property
    @pulumi.getter(name="basicAuthUser")
    def basic_auth_user(self) -> Optional[pulumi.Input[str]]:
        """
        The username to use in basic auth headers attached to the request. If omitted, basic auth will not be used.
        """
        return pulumi.get(self, "basic_auth_user")

    @basic_auth_user.setter
    def basic_auth_user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "basic_auth_user", value)

    @property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @disable_resolve_message.setter
    def disable_resolve_message(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_resolve_message", value)

    @property
    @pulumi.getter(name="httpMethod")
    def http_method(self) -> Optional[pulumi.Input[str]]:
        """
        The HTTP method to use in the request. Defaults to `POST`.
        """
        return pulumi.get(self, "http_method")

    @http_method.setter
    def http_method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "http_method", value)

    @property
    @pulumi.getter(name="maxAlerts")
    def max_alerts(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of alerts to send in a single request. This can be helpful in limiting the size of the request body. The default is 0, which indicates no limit.
        """
        return pulumi.get(self, "max_alerts")

    @max_alerts.setter
    def max_alerts(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_alerts", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        Custom message. You can use template variables.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "settings", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        Templated title of the message.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)


if not MYPY:
    class ContactPointWecomArgsDict(TypedDict):
        agent_id: NotRequired[pulumi.Input[str]]
        """
        Agent ID added to the request payload when using APIAPP.
        """
        corp_id: NotRequired[pulumi.Input[str]]
        """
        Corp ID used to get token when using APIAPP.
        """
        disable_resolve_message: NotRequired[pulumi.Input[bool]]
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        message: NotRequired[pulumi.Input[str]]
        """
        The templated content of the message to send.
        """
        msg_type: NotRequired[pulumi.Input[str]]
        """
        The type of them message. Supported: markdown, text. Default: text.
        """
        secret: NotRequired[pulumi.Input[str]]
        """
        The secret key required to obtain access token when using APIAPP. See https://work.weixin.qq.com/wework_admin/frame#apps to create APIAPP.
        """
        settings: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        title: NotRequired[pulumi.Input[str]]
        """
        The templated title of the message to send.
        """
        to_user: NotRequired[pulumi.Input[str]]
        """
        The ID of user that should receive the message. Multiple entries should be separated by '|'. Default: @all.
        """
        uid: NotRequired[pulumi.Input[str]]
        """
        The UID of the contact point.
        """
        url: NotRequired[pulumi.Input[str]]
        """
        The WeCom webhook URL. Required if using GroupRobot.
        """
elif False:
    ContactPointWecomArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContactPointWecomArgs:
    def __init__(__self__, *,
                 agent_id: Optional[pulumi.Input[str]] = None,
                 corp_id: Optional[pulumi.Input[str]] = None,
                 disable_resolve_message: Optional[pulumi.Input[bool]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 msg_type: Optional[pulumi.Input[str]] = None,
                 secret: Optional[pulumi.Input[str]] = None,
                 settings: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 to_user: Optional[pulumi.Input[str]] = None,
                 uid: Optional[pulumi.Input[str]] = None,
                 url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] agent_id: Agent ID added to the request payload when using APIAPP.
        :param pulumi.Input[str] corp_id: Corp ID used to get token when using APIAPP.
        :param pulumi.Input[bool] disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param pulumi.Input[str] message: The templated content of the message to send.
        :param pulumi.Input[str] msg_type: The type of them message. Supported: markdown, text. Default: text.
        :param pulumi.Input[str] secret: The secret key required to obtain access token when using APIAPP. See https://work.weixin.qq.com/wework_admin/frame#apps to create APIAPP.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param pulumi.Input[str] title: The templated title of the message to send.
        :param pulumi.Input[str] to_user: The ID of user that should receive the message. Multiple entries should be separated by '|'. Default: @all.
        :param pulumi.Input[str] uid: The UID of the contact point.
        :param pulumi.Input[str] url: The WeCom webhook URL. Required if using GroupRobot.
        """
        if agent_id is not None:
            pulumi.set(__self__, "agent_id", agent_id)
        if corp_id is not None:
            pulumi.set(__self__, "corp_id", corp_id)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if msg_type is not None:
            pulumi.set(__self__, "msg_type", msg_type)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if to_user is not None:
            pulumi.set(__self__, "to_user", to_user)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter(name="agentId")
    def agent_id(self) -> Optional[pulumi.Input[str]]:
        """
        Agent ID added to the request payload when using APIAPP.
        """
        return pulumi.get(self, "agent_id")

    @agent_id.setter
    def agent_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "agent_id", value)

    @property
    @pulumi.getter(name="corpId")
    def corp_id(self) -> Optional[pulumi.Input[str]]:
        """
        Corp ID used to get token when using APIAPP.
        """
        return pulumi.get(self, "corp_id")

    @corp_id.setter
    def corp_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "corp_id", value)

    @property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @disable_resolve_message.setter
    def disable_resolve_message(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_resolve_message", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        The templated content of the message to send.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter(name="msgType")
    def msg_type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of them message. Supported: markdown, text. Default: text.
        """
        return pulumi.get(self, "msg_type")

    @msg_type.setter
    def msg_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "msg_type", value)

    @property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input[str]]:
        """
        The secret key required to obtain access token when using APIAPP. See https://work.weixin.qq.com/wework_admin/frame#apps to create APIAPP.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret", value)

    @property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "settings", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        The templated title of the message to send.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter(name="toUser")
    def to_user(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of user that should receive the message. Multiple entries should be separated by '|'. Default: @all.
        """
        return pulumi.get(self, "to_user")

    @to_user.setter
    def to_user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "to_user", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)

    @property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[str]]:
        """
        The WeCom webhook URL. Required if using GroupRobot.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class MuteTimingIntervalArgsDict(TypedDict):
        days_of_months: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        An inclusive range of days, 1-31, within a month, e.g. "1" or "14:16". Negative values can be used to represent days counting from the end of a month, e.g. "-1".
        """
        location: NotRequired[pulumi.Input[str]]
        """
        Provides the time zone for the time interval. Must be a location in the IANA time zone database, e.g "America/New_York"
        """
        months: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        An inclusive range of months, either numerical or full calendar month, e.g. "1:3", "december", or "may:august".
        """
        times: NotRequired[pulumi.Input[Sequence[pulumi.Input['MuteTimingIntervalTimeArgsDict']]]]
        """
        The time ranges, represented in minutes, during which to mute in a given day.
        """
        weekdays: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        An inclusive range of weekdays, e.g. "monday" or "tuesday:thursday".
        """
        years: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A positive inclusive range of years, e.g. "2030" or "2025:2026".
        """
elif False:
    MuteTimingIntervalArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MuteTimingIntervalArgs:
    def __init__(__self__, *,
                 days_of_months: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 location: Optional[pulumi.Input[str]] = None,
                 months: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 times: Optional[pulumi.Input[Sequence[pulumi.Input['MuteTimingIntervalTimeArgs']]]] = None,
                 weekdays: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 years: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] days_of_months: An inclusive range of days, 1-31, within a month, e.g. "1" or "14:16". Negative values can be used to represent days counting from the end of a month, e.g. "-1".
        :param pulumi.Input[str] location: Provides the time zone for the time interval. Must be a location in the IANA time zone database, e.g "America/New_York"
        :param pulumi.Input[Sequence[pulumi.Input[str]]] months: An inclusive range of months, either numerical or full calendar month, e.g. "1:3", "december", or "may:august".
        :param pulumi.Input[Sequence[pulumi.Input['MuteTimingIntervalTimeArgs']]] times: The time ranges, represented in minutes, during which to mute in a given day.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] weekdays: An inclusive range of weekdays, e.g. "monday" or "tuesday:thursday".
        :param pulumi.Input[Sequence[pulumi.Input[str]]] years: A positive inclusive range of years, e.g. "2030" or "2025:2026".
        """
        if days_of_months is not None:
            pulumi.set(__self__, "days_of_months", days_of_months)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if months is not None:
            pulumi.set(__self__, "months", months)
        if times is not None:
            pulumi.set(__self__, "times", times)
        if weekdays is not None:
            pulumi.set(__self__, "weekdays", weekdays)
        if years is not None:
            pulumi.set(__self__, "years", years)

    @property
    @pulumi.getter(name="daysOfMonths")
    def days_of_months(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An inclusive range of days, 1-31, within a month, e.g. "1" or "14:16". Negative values can be used to represent days counting from the end of a month, e.g. "-1".
        """
        return pulumi.get(self, "days_of_months")

    @days_of_months.setter
    def days_of_months(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "days_of_months", value)

    @property
    @pulumi.getter
    def location(self) -> Optional[pulumi.Input[str]]:
        """
        Provides the time zone for the time interval. Must be a location in the IANA time zone database, e.g "America/New_York"
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "location", value)

    @property
    @pulumi.getter
    def months(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An inclusive range of months, either numerical or full calendar month, e.g. "1:3", "december", or "may:august".
        """
        return pulumi.get(self, "months")

    @months.setter
    def months(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "months", value)

    @property
    @pulumi.getter
    def times(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MuteTimingIntervalTimeArgs']]]]:
        """
        The time ranges, represented in minutes, during which to mute in a given day.
        """
        return pulumi.get(self, "times")

    @times.setter
    def times(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MuteTimingIntervalTimeArgs']]]]):
        pulumi.set(self, "times", value)

    @property
    @pulumi.getter
    def weekdays(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An inclusive range of weekdays, e.g. "monday" or "tuesday:thursday".
        """
        return pulumi.get(self, "weekdays")

    @weekdays.setter
    def weekdays(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "weekdays", value)

    @property
    @pulumi.getter
    def years(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A positive inclusive range of years, e.g. "2030" or "2025:2026".
        """
        return pulumi.get(self, "years")

    @years.setter
    def years(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "years", value)


if not MYPY:
    class MuteTimingIntervalTimeArgsDict(TypedDict):
        end: pulumi.Input[str]
        """
        The time, in hh:mm format, of when the interval should end exclusively.
        """
        start: pulumi.Input[str]
        """
        The time, in hh:mm format, of when the interval should begin inclusively.
        """
elif False:
    MuteTimingIntervalTimeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MuteTimingIntervalTimeArgs:
    def __init__(__self__, *,
                 end: pulumi.Input[str],
                 start: pulumi.Input[str]):
        """
        :param pulumi.Input[str] end: The time, in hh:mm format, of when the interval should end exclusively.
        :param pulumi.Input[str] start: The time, in hh:mm format, of when the interval should begin inclusively.
        """
        pulumi.set(__self__, "end", end)
        pulumi.set(__self__, "start", start)

    @property
    @pulumi.getter
    def end(self) -> pulumi.Input[str]:
        """
        The time, in hh:mm format, of when the interval should end exclusively.
        """
        return pulumi.get(self, "end")

    @end.setter
    def end(self, value: pulumi.Input[str]):
        pulumi.set(self, "end", value)

    @property
    @pulumi.getter
    def start(self) -> pulumi.Input[str]:
        """
        The time, in hh:mm format, of when the interval should begin inclusively.
        """
        return pulumi.get(self, "start")

    @start.setter
    def start(self, value: pulumi.Input[str]):
        pulumi.set(self, "start", value)


if not MYPY:
    class NotificationPolicyPolicyArgsDict(TypedDict):
        contact_point: NotRequired[pulumi.Input[str]]
        """
        The contact point to route notifications that match this rule to.
        """
        continue_: NotRequired[pulumi.Input[bool]]
        """
        Whether to continue matching subsequent rules if an alert matches the current rule. Otherwise, the rule will be 'consumed' by the first policy to match it.
        """
        group_bies: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping. Required for root policy only. If empty, the parent grouping is used.
        """
        group_interval: NotRequired[pulumi.Input[str]]
        """
        Minimum time interval between two notifications for the same group. Default is 5 minutes.
        """
        group_wait: NotRequired[pulumi.Input[str]]
        """
        Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.
        """
        matchers: NotRequired[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyMatcherArgsDict']]]]
        """
        Describes which labels this rule should match. When multiple matchers are supplied, an alert must match ALL matchers to be accepted by this policy. When no matchers are supplied, the rule will match all alert instances.
        """
        mute_timings: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of mute timing names to apply to alerts that match this policy.
        """
        policies: NotRequired[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyArgsDict']]]]
        """
        Routing rules for specific label sets.
        """
        repeat_interval: NotRequired[pulumi.Input[str]]
        """
        Minimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.
        """
elif False:
    NotificationPolicyPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NotificationPolicyPolicyArgs:
    def __init__(__self__, *,
                 contact_point: Optional[pulumi.Input[str]] = None,
                 continue_: Optional[pulumi.Input[bool]] = None,
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 group_interval: Optional[pulumi.Input[str]] = None,
                 group_wait: Optional[pulumi.Input[str]] = None,
                 matchers: Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyMatcherArgs']]]] = None,
                 mute_timings: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 policies: Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyArgs']]]] = None,
                 repeat_interval: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] contact_point: The contact point to route notifications that match this rule to.
        :param pulumi.Input[bool] continue_: Whether to continue matching subsequent rules if an alert matches the current rule. Otherwise, the rule will be 'consumed' by the first policy to match it.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] group_bies: A list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping. Required for root policy only. If empty, the parent grouping is used.
        :param pulumi.Input[str] group_interval: Minimum time interval between two notifications for the same group. Default is 5 minutes.
        :param pulumi.Input[str] group_wait: Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.
        :param pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyMatcherArgs']]] matchers: Describes which labels this rule should match. When multiple matchers are supplied, an alert must match ALL matchers to be accepted by this policy. When no matchers are supplied, the rule will match all alert instances.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] mute_timings: A list of mute timing names to apply to alerts that match this policy.
        :param pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyArgs']]] policies: Routing rules for specific label sets.
        :param pulumi.Input[str] repeat_interval: Minimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.
        """
        if contact_point is not None:
            pulumi.set(__self__, "contact_point", contact_point)
        if continue_ is not None:
            pulumi.set(__self__, "continue_", continue_)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if group_interval is not None:
            pulumi.set(__self__, "group_interval", group_interval)
        if group_wait is not None:
            pulumi.set(__self__, "group_wait", group_wait)
        if matchers is not None:
            pulumi.set(__self__, "matchers", matchers)
        if mute_timings is not None:
            pulumi.set(__self__, "mute_timings", mute_timings)
        if policies is not None:
            pulumi.set(__self__, "policies", policies)
        if repeat_interval is not None:
            pulumi.set(__self__, "repeat_interval", repeat_interval)

    @property
    @pulumi.getter(name="contactPoint")
    def contact_point(self) -> Optional[pulumi.Input[str]]:
        """
        The contact point to route notifications that match this rule to.
        """
        return pulumi.get(self, "contact_point")

    @contact_point.setter
    def contact_point(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "contact_point", value)

    @property
    @pulumi.getter(name="continue")
    def continue_(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to continue matching subsequent rules if an alert matches the current rule. Otherwise, the rule will be 'consumed' by the first policy to match it.
        """
        return pulumi.get(self, "continue_")

    @continue_.setter
    def continue_(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "continue_", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping. Required for root policy only. If empty, the parent grouping is used.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="groupInterval")
    def group_interval(self) -> Optional[pulumi.Input[str]]:
        """
        Minimum time interval between two notifications for the same group. Default is 5 minutes.
        """
        return pulumi.get(self, "group_interval")

    @group_interval.setter
    def group_interval(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group_interval", value)

    @property
    @pulumi.getter(name="groupWait")
    def group_wait(self) -> Optional[pulumi.Input[str]]:
        """
        Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.
        """
        return pulumi.get(self, "group_wait")

    @group_wait.setter
    def group_wait(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group_wait", value)

    @property
    @pulumi.getter
    def matchers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyMatcherArgs']]]]:
        """
        Describes which labels this rule should match. When multiple matchers are supplied, an alert must match ALL matchers to be accepted by this policy. When no matchers are supplied, the rule will match all alert instances.
        """
        return pulumi.get(self, "matchers")

    @matchers.setter
    def matchers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyMatcherArgs']]]]):
        pulumi.set(self, "matchers", value)

    @property
    @pulumi.getter(name="muteTimings")
    def mute_timings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of mute timing names to apply to alerts that match this policy.
        """
        return pulumi.get(self, "mute_timings")

    @mute_timings.setter
    def mute_timings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "mute_timings", value)

    @property
    @pulumi.getter
    def policies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyArgs']]]]:
        """
        Routing rules for specific label sets.
        """
        return pulumi.get(self, "policies")

    @policies.setter
    def policies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyArgs']]]]):
        pulumi.set(self, "policies", value)

    @property
    @pulumi.getter(name="repeatInterval")
    def repeat_interval(self) -> Optional[pulumi.Input[str]]:
        """
        Minimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.
        """
        return pulumi.get(self, "repeat_interval")

    @repeat_interval.setter
    def repeat_interval(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repeat_interval", value)


if not MYPY:
    class NotificationPolicyPolicyMatcherArgsDict(TypedDict):
        label: pulumi.Input[str]
        """
        The name of the label to match against.
        """
        match: pulumi.Input[str]
        """
        The operator to apply when matching values of the given label. Allowed operators are `=` for equality, `!=` for negated equality, `=~` for regex equality, and `!~` for negated regex equality.
        """
        value: pulumi.Input[str]
        """
        The label value to match against.
        """
elif False:
    NotificationPolicyPolicyMatcherArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NotificationPolicyPolicyMatcherArgs:
    def __init__(__self__, *,
                 label: pulumi.Input[str],
                 match: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] label: The name of the label to match against.
        :param pulumi.Input[str] match: The operator to apply when matching values of the given label. Allowed operators are `=` for equality, `!=` for negated equality, `=~` for regex equality, and `!~` for negated regex equality.
        :param pulumi.Input[str] value: The label value to match against.
        """
        pulumi.set(__self__, "label", label)
        pulumi.set(__self__, "match", match)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def label(self) -> pulumi.Input[str]:
        """
        The name of the label to match against.
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: pulumi.Input[str]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def match(self) -> pulumi.Input[str]:
        """
        The operator to apply when matching values of the given label. Allowed operators are `=` for equality, `!=` for negated equality, `=~` for regex equality, and `!~` for negated regex equality.
        """
        return pulumi.get(self, "match")

    @match.setter
    def match(self, value: pulumi.Input[str]):
        pulumi.set(self, "match", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The label value to match against.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NotificationPolicyPolicyPolicyArgsDict(TypedDict):
        contact_point: NotRequired[pulumi.Input[str]]
        """
        The contact point to route notifications that match this rule to.
        """
        continue_: NotRequired[pulumi.Input[bool]]
        """
        Whether to continue matching subsequent rules if an alert matches the current rule. Otherwise, the rule will be 'consumed' by the first policy to match it.
        """
        group_bies: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping. Required for root policy only. If empty, the parent grouping is used.
        """
        group_interval: NotRequired[pulumi.Input[str]]
        """
        Minimum time interval between two notifications for the same group. Default is 5 minutes.
        """
        group_wait: NotRequired[pulumi.Input[str]]
        """
        Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.
        """
        matchers: NotRequired[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyMatcherArgsDict']]]]
        """
        Describes which labels this rule should match. When multiple matchers are supplied, an alert must match ALL matchers to be accepted by this policy. When no matchers are supplied, the rule will match all alert instances.
        """
        mute_timings: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of mute timing names to apply to alerts that match this policy.
        """
        policies: NotRequired[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyPolicyArgsDict']]]]
        """
        Routing rules for specific label sets.
        """
        repeat_interval: NotRequired[pulumi.Input[str]]
        """
        Minimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.
        """
elif False:
    NotificationPolicyPolicyPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NotificationPolicyPolicyPolicyArgs:
    def __init__(__self__, *,
                 contact_point: Optional[pulumi.Input[str]] = None,
                 continue_: Optional[pulumi.Input[bool]] = None,
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 group_interval: Optional[pulumi.Input[str]] = None,
                 group_wait: Optional[pulumi.Input[str]] = None,
                 matchers: Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyMatcherArgs']]]] = None,
                 mute_timings: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 policies: Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyPolicyArgs']]]] = None,
                 repeat_interval: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] contact_point: The contact point to route notifications that match this rule to.
        :param pulumi.Input[bool] continue_: Whether to continue matching subsequent rules if an alert matches the current rule. Otherwise, the rule will be 'consumed' by the first policy to match it.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] group_bies: A list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping. Required for root policy only. If empty, the parent grouping is used.
        :param pulumi.Input[str] group_interval: Minimum time interval between two notifications for the same group. Default is 5 minutes.
        :param pulumi.Input[str] group_wait: Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.
        :param pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyMatcherArgs']]] matchers: Describes which labels this rule should match. When multiple matchers are supplied, an alert must match ALL matchers to be accepted by this policy. When no matchers are supplied, the rule will match all alert instances.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] mute_timings: A list of mute timing names to apply to alerts that match this policy.
        :param pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyPolicyArgs']]] policies: Routing rules for specific label sets.
        :param pulumi.Input[str] repeat_interval: Minimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.
        """
        if contact_point is not None:
            pulumi.set(__self__, "contact_point", contact_point)
        if continue_ is not None:
            pulumi.set(__self__, "continue_", continue_)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if group_interval is not None:
            pulumi.set(__self__, "group_interval", group_interval)
        if group_wait is not None:
            pulumi.set(__self__, "group_wait", group_wait)
        if matchers is not None:
            pulumi.set(__self__, "matchers", matchers)
        if mute_timings is not None:
            pulumi.set(__self__, "mute_timings", mute_timings)
        if policies is not None:
            pulumi.set(__self__, "policies", policies)
        if repeat_interval is not None:
            pulumi.set(__self__, "repeat_interval", repeat_interval)

    @property
    @pulumi.getter(name="contactPoint")
    def contact_point(self) -> Optional[pulumi.Input[str]]:
        """
        The contact point to route notifications that match this rule to.
        """
        return pulumi.get(self, "contact_point")

    @contact_point.setter
    def contact_point(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "contact_point", value)

    @property
    @pulumi.getter(name="continue")
    def continue_(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to continue matching subsequent rules if an alert matches the current rule. Otherwise, the rule will be 'consumed' by the first policy to match it.
        """
        return pulumi.get(self, "continue_")

    @continue_.setter
    def continue_(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "continue_", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping. Required for root policy only. If empty, the parent grouping is used.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="groupInterval")
    def group_interval(self) -> Optional[pulumi.Input[str]]:
        """
        Minimum time interval between two notifications for the same group. Default is 5 minutes.
        """
        return pulumi.get(self, "group_interval")

    @group_interval.setter
    def group_interval(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group_interval", value)

    @property
    @pulumi.getter(name="groupWait")
    def group_wait(self) -> Optional[pulumi.Input[str]]:
        """
        Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.
        """
        return pulumi.get(self, "group_wait")

    @group_wait.setter
    def group_wait(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group_wait", value)

    @property
    @pulumi.getter
    def matchers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyMatcherArgs']]]]:
        """
        Describes which labels this rule should match. When multiple matchers are supplied, an alert must match ALL matchers to be accepted by this policy. When no matchers are supplied, the rule will match all alert instances.
        """
        return pulumi.get(self, "matchers")

    @matchers.setter
    def matchers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyMatcherArgs']]]]):
        pulumi.set(self, "matchers", value)

    @property
    @pulumi.getter(name="muteTimings")
    def mute_timings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of mute timing names to apply to alerts that match this policy.
        """
        return pulumi.get(self, "mute_timings")

    @mute_timings.setter
    def mute_timings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "mute_timings", value)

    @property
    @pulumi.getter
    def policies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyPolicyArgs']]]]:
        """
        Routing rules for specific label sets.
        """
        return pulumi.get(self, "policies")

    @policies.setter
    def policies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyPolicyArgs']]]]):
        pulumi.set(self, "policies", value)

    @property
    @pulumi.getter(name="repeatInterval")
    def repeat_interval(self) -> Optional[pulumi.Input[str]]:
        """
        Minimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.
        """
        return pulumi.get(self, "repeat_interval")

    @repeat_interval.setter
    def repeat_interval(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repeat_interval", value)


if not MYPY:
    class NotificationPolicyPolicyPolicyMatcherArgsDict(TypedDict):
        label: pulumi.Input[str]
        """
        The name of the label to match against.
        """
        match: pulumi.Input[str]
        """
        The operator to apply when matching values of the given label. Allowed operators are `=` for equality, `!=` for negated equality, `=~` for regex equality, and `!~` for negated regex equality.
        """
        value: pulumi.Input[str]
        """
        The label value to match against.
        """
elif False:
    NotificationPolicyPolicyPolicyMatcherArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NotificationPolicyPolicyPolicyMatcherArgs:
    def __init__(__self__, *,
                 label: pulumi.Input[str],
                 match: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] label: The name of the label to match against.
        :param pulumi.Input[str] match: The operator to apply when matching values of the given label. Allowed operators are `=` for equality, `!=` for negated equality, `=~` for regex equality, and `!~` for negated regex equality.
        :param pulumi.Input[str] value: The label value to match against.
        """
        pulumi.set(__self__, "label", label)
        pulumi.set(__self__, "match", match)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def label(self) -> pulumi.Input[str]:
        """
        The name of the label to match against.
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: pulumi.Input[str]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def match(self) -> pulumi.Input[str]:
        """
        The operator to apply when matching values of the given label. Allowed operators are `=` for equality, `!=` for negated equality, `=~` for regex equality, and `!~` for negated regex equality.
        """
        return pulumi.get(self, "match")

    @match.setter
    def match(self, value: pulumi.Input[str]):
        pulumi.set(self, "match", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The label value to match against.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NotificationPolicyPolicyPolicyPolicyArgsDict(TypedDict):
        contact_point: NotRequired[pulumi.Input[str]]
        """
        The contact point to route notifications that match this rule to.
        """
        continue_: NotRequired[pulumi.Input[bool]]
        """
        Whether to continue matching subsequent rules if an alert matches the current rule. Otherwise, the rule will be 'consumed' by the first policy to match it.
        """
        group_bies: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping. Required for root policy only. If empty, the parent grouping is used.
        """
        group_interval: NotRequired[pulumi.Input[str]]
        """
        Minimum time interval between two notifications for the same group. Default is 5 minutes.
        """
        group_wait: NotRequired[pulumi.Input[str]]
        """
        Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.
        """
        matchers: NotRequired[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyPolicyMatcherArgsDict']]]]
        """
        Describes which labels this rule should match. When multiple matchers are supplied, an alert must match ALL matchers to be accepted by this policy. When no matchers are supplied, the rule will match all alert instances.
        """
        mute_timings: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of mute timing names to apply to alerts that match this policy.
        """
        policies: NotRequired[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyPolicyPolicyArgsDict']]]]
        """
        Routing rules for specific label sets.
        """
        repeat_interval: NotRequired[pulumi.Input[str]]
        """
        Minimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.
        """
elif False:
    NotificationPolicyPolicyPolicyPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NotificationPolicyPolicyPolicyPolicyArgs:
    def __init__(__self__, *,
                 contact_point: Optional[pulumi.Input[str]] = None,
                 continue_: Optional[pulumi.Input[bool]] = None,
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 group_interval: Optional[pulumi.Input[str]] = None,
                 group_wait: Optional[pulumi.Input[str]] = None,
                 matchers: Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyPolicyMatcherArgs']]]] = None,
                 mute_timings: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 policies: Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyPolicyPolicyArgs']]]] = None,
                 repeat_interval: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] contact_point: The contact point to route notifications that match this rule to.
        :param pulumi.Input[bool] continue_: Whether to continue matching subsequent rules if an alert matches the current rule. Otherwise, the rule will be 'consumed' by the first policy to match it.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] group_bies: A list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping. Required for root policy only. If empty, the parent grouping is used.
        :param pulumi.Input[str] group_interval: Minimum time interval between two notifications for the same group. Default is 5 minutes.
        :param pulumi.Input[str] group_wait: Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.
        :param pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyPolicyMatcherArgs']]] matchers: Describes which labels this rule should match. When multiple matchers are supplied, an alert must match ALL matchers to be accepted by this policy. When no matchers are supplied, the rule will match all alert instances.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] mute_timings: A list of mute timing names to apply to alerts that match this policy.
        :param pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyPolicyPolicyArgs']]] policies: Routing rules for specific label sets.
        :param pulumi.Input[str] repeat_interval: Minimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.
        """
        if contact_point is not None:
            pulumi.set(__self__, "contact_point", contact_point)
        if continue_ is not None:
            pulumi.set(__self__, "continue_", continue_)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if group_interval is not None:
            pulumi.set(__self__, "group_interval", group_interval)
        if group_wait is not None:
            pulumi.set(__self__, "group_wait", group_wait)
        if matchers is not None:
            pulumi.set(__self__, "matchers", matchers)
        if mute_timings is not None:
            pulumi.set(__self__, "mute_timings", mute_timings)
        if policies is not None:
            pulumi.set(__self__, "policies", policies)
        if repeat_interval is not None:
            pulumi.set(__self__, "repeat_interval", repeat_interval)

    @property
    @pulumi.getter(name="contactPoint")
    def contact_point(self) -> Optional[pulumi.Input[str]]:
        """
        The contact point to route notifications that match this rule to.
        """
        return pulumi.get(self, "contact_point")

    @contact_point.setter
    def contact_point(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "contact_point", value)

    @property
    @pulumi.getter(name="continue")
    def continue_(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to continue matching subsequent rules if an alert matches the current rule. Otherwise, the rule will be 'consumed' by the first policy to match it.
        """
        return pulumi.get(self, "continue_")

    @continue_.setter
    def continue_(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "continue_", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping. Required for root policy only. If empty, the parent grouping is used.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="groupInterval")
    def group_interval(self) -> Optional[pulumi.Input[str]]:
        """
        Minimum time interval between two notifications for the same group. Default is 5 minutes.
        """
        return pulumi.get(self, "group_interval")

    @group_interval.setter
    def group_interval(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group_interval", value)

    @property
    @pulumi.getter(name="groupWait")
    def group_wait(self) -> Optional[pulumi.Input[str]]:
        """
        Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.
        """
        return pulumi.get(self, "group_wait")

    @group_wait.setter
    def group_wait(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group_wait", value)

    @property
    @pulumi.getter
    def matchers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyPolicyMatcherArgs']]]]:
        """
        Describes which labels this rule should match. When multiple matchers are supplied, an alert must match ALL matchers to be accepted by this policy. When no matchers are supplied, the rule will match all alert instances.
        """
        return pulumi.get(self, "matchers")

    @matchers.setter
    def matchers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyPolicyMatcherArgs']]]]):
        pulumi.set(self, "matchers", value)

    @property
    @pulumi.getter(name="muteTimings")
    def mute_timings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of mute timing names to apply to alerts that match this policy.
        """
        return pulumi.get(self, "mute_timings")

    @mute_timings.setter
    def mute_timings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "mute_timings", value)

    @property
    @pulumi.getter
    def policies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyPolicyPolicyArgs']]]]:
        """
        Routing rules for specific label sets.
        """
        return pulumi.get(self, "policies")

    @policies.setter
    def policies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyPolicyPolicyArgs']]]]):
        pulumi.set(self, "policies", value)

    @property
    @pulumi.getter(name="repeatInterval")
    def repeat_interval(self) -> Optional[pulumi.Input[str]]:
        """
        Minimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.
        """
        return pulumi.get(self, "repeat_interval")

    @repeat_interval.setter
    def repeat_interval(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repeat_interval", value)


if not MYPY:
    class NotificationPolicyPolicyPolicyPolicyMatcherArgsDict(TypedDict):
        label: pulumi.Input[str]
        """
        The name of the label to match against.
        """
        match: pulumi.Input[str]
        """
        The operator to apply when matching values of the given label. Allowed operators are `=` for equality, `!=` for negated equality, `=~` for regex equality, and `!~` for negated regex equality.
        """
        value: pulumi.Input[str]
        """
        The label value to match against.
        """
elif False:
    NotificationPolicyPolicyPolicyPolicyMatcherArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NotificationPolicyPolicyPolicyPolicyMatcherArgs:
    def __init__(__self__, *,
                 label: pulumi.Input[str],
                 match: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] label: The name of the label to match against.
        :param pulumi.Input[str] match: The operator to apply when matching values of the given label. Allowed operators are `=` for equality, `!=` for negated equality, `=~` for regex equality, and `!~` for negated regex equality.
        :param pulumi.Input[str] value: The label value to match against.
        """
        pulumi.set(__self__, "label", label)
        pulumi.set(__self__, "match", match)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def label(self) -> pulumi.Input[str]:
        """
        The name of the label to match against.
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: pulumi.Input[str]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def match(self) -> pulumi.Input[str]:
        """
        The operator to apply when matching values of the given label. Allowed operators are `=` for equality, `!=` for negated equality, `=~` for regex equality, and `!~` for negated regex equality.
        """
        return pulumi.get(self, "match")

    @match.setter
    def match(self, value: pulumi.Input[str]):
        pulumi.set(self, "match", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The label value to match against.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NotificationPolicyPolicyPolicyPolicyPolicyArgsDict(TypedDict):
        group_bies: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        A list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping. Required for root policy only. If empty, the parent grouping is used.
        """
        contact_point: NotRequired[pulumi.Input[str]]
        """
        The contact point to route notifications that match this rule to.
        """
        continue_: NotRequired[pulumi.Input[bool]]
        """
        Whether to continue matching subsequent rules if an alert matches the current rule. Otherwise, the rule will be 'consumed' by the first policy to match it.
        """
        group_interval: NotRequired[pulumi.Input[str]]
        """
        Minimum time interval between two notifications for the same group. Default is 5 minutes.
        """
        group_wait: NotRequired[pulumi.Input[str]]
        """
        Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.
        """
        matchers: NotRequired[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyPolicyPolicyMatcherArgsDict']]]]
        """
        Describes which labels this rule should match. When multiple matchers are supplied, an alert must match ALL matchers to be accepted by this policy. When no matchers are supplied, the rule will match all alert instances.
        """
        mute_timings: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of mute timing names to apply to alerts that match this policy.
        """
        repeat_interval: NotRequired[pulumi.Input[str]]
        """
        Minimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.
        """
elif False:
    NotificationPolicyPolicyPolicyPolicyPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NotificationPolicyPolicyPolicyPolicyPolicyArgs:
    def __init__(__self__, *,
                 group_bies: pulumi.Input[Sequence[pulumi.Input[str]]],
                 contact_point: Optional[pulumi.Input[str]] = None,
                 continue_: Optional[pulumi.Input[bool]] = None,
                 group_interval: Optional[pulumi.Input[str]] = None,
                 group_wait: Optional[pulumi.Input[str]] = None,
                 matchers: Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyPolicyPolicyMatcherArgs']]]] = None,
                 mute_timings: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 repeat_interval: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] group_bies: A list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping. Required for root policy only. If empty, the parent grouping is used.
        :param pulumi.Input[str] contact_point: The contact point to route notifications that match this rule to.
        :param pulumi.Input[bool] continue_: Whether to continue matching subsequent rules if an alert matches the current rule. Otherwise, the rule will be 'consumed' by the first policy to match it.
        :param pulumi.Input[str] group_interval: Minimum time interval between two notifications for the same group. Default is 5 minutes.
        :param pulumi.Input[str] group_wait: Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.
        :param pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyPolicyPolicyMatcherArgs']]] matchers: Describes which labels this rule should match. When multiple matchers are supplied, an alert must match ALL matchers to be accepted by this policy. When no matchers are supplied, the rule will match all alert instances.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] mute_timings: A list of mute timing names to apply to alerts that match this policy.
        :param pulumi.Input[str] repeat_interval: Minimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.
        """
        pulumi.set(__self__, "group_bies", group_bies)
        if contact_point is not None:
            pulumi.set(__self__, "contact_point", contact_point)
        if continue_ is not None:
            pulumi.set(__self__, "continue_", continue_)
        if group_interval is not None:
            pulumi.set(__self__, "group_interval", group_interval)
        if group_wait is not None:
            pulumi.set(__self__, "group_wait", group_wait)
        if matchers is not None:
            pulumi.set(__self__, "matchers", matchers)
        if mute_timings is not None:
            pulumi.set(__self__, "mute_timings", mute_timings)
        if repeat_interval is not None:
            pulumi.set(__self__, "repeat_interval", repeat_interval)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping. Required for root policy only. If empty, the parent grouping is used.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="contactPoint")
    def contact_point(self) -> Optional[pulumi.Input[str]]:
        """
        The contact point to route notifications that match this rule to.
        """
        return pulumi.get(self, "contact_point")

    @contact_point.setter
    def contact_point(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "contact_point", value)

    @property
    @pulumi.getter(name="continue")
    def continue_(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to continue matching subsequent rules if an alert matches the current rule. Otherwise, the rule will be 'consumed' by the first policy to match it.
        """
        return pulumi.get(self, "continue_")

    @continue_.setter
    def continue_(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "continue_", value)

    @property
    @pulumi.getter(name="groupInterval")
    def group_interval(self) -> Optional[pulumi.Input[str]]:
        """
        Minimum time interval between two notifications for the same group. Default is 5 minutes.
        """
        return pulumi.get(self, "group_interval")

    @group_interval.setter
    def group_interval(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group_interval", value)

    @property
    @pulumi.getter(name="groupWait")
    def group_wait(self) -> Optional[pulumi.Input[str]]:
        """
        Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.
        """
        return pulumi.get(self, "group_wait")

    @group_wait.setter
    def group_wait(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group_wait", value)

    @property
    @pulumi.getter
    def matchers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyPolicyPolicyMatcherArgs']]]]:
        """
        Describes which labels this rule should match. When multiple matchers are supplied, an alert must match ALL matchers to be accepted by this policy. When no matchers are supplied, the rule will match all alert instances.
        """
        return pulumi.get(self, "matchers")

    @matchers.setter
    def matchers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyPolicyPolicyMatcherArgs']]]]):
        pulumi.set(self, "matchers", value)

    @property
    @pulumi.getter(name="muteTimings")
    def mute_timings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of mute timing names to apply to alerts that match this policy.
        """
        return pulumi.get(self, "mute_timings")

    @mute_timings.setter
    def mute_timings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "mute_timings", value)

    @property
    @pulumi.getter(name="repeatInterval")
    def repeat_interval(self) -> Optional[pulumi.Input[str]]:
        """
        Minimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.
        """
        return pulumi.get(self, "repeat_interval")

    @repeat_interval.setter
    def repeat_interval(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repeat_interval", value)


if not MYPY:
    class NotificationPolicyPolicyPolicyPolicyPolicyMatcherArgsDict(TypedDict):
        label: pulumi.Input[str]
        """
        The name of the label to match against.
        """
        match: pulumi.Input[str]
        """
        The operator to apply when matching values of the given label. Allowed operators are `=` for equality, `!=` for negated equality, `=~` for regex equality, and `!~` for negated regex equality.
        """
        value: pulumi.Input[str]
        """
        The label value to match against.
        """
elif False:
    NotificationPolicyPolicyPolicyPolicyPolicyMatcherArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NotificationPolicyPolicyPolicyPolicyPolicyMatcherArgs:
    def __init__(__self__, *,
                 label: pulumi.Input[str],
                 match: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] label: The name of the label to match against.
        :param pulumi.Input[str] match: The operator to apply when matching values of the given label. Allowed operators are `=` for equality, `!=` for negated equality, `=~` for regex equality, and `!~` for negated regex equality.
        :param pulumi.Input[str] value: The label value to match against.
        """
        pulumi.set(__self__, "label", label)
        pulumi.set(__self__, "match", match)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def label(self) -> pulumi.Input[str]:
        """
        The name of the label to match against.
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: pulumi.Input[str]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def match(self) -> pulumi.Input[str]:
        """
        The operator to apply when matching values of the given label. Allowed operators are `=` for equality, `!=` for negated equality, `=~` for regex equality, and `!~` for negated regex equality.
        """
        return pulumi.get(self, "match")

    @match.setter
    def match(self, value: pulumi.Input[str]):
        pulumi.set(self, "match", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The label value to match against.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class RuleGroupRuleArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        The `ref_id` of the query node in the `data` field to use as the alert condition.
        """
        datas: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleDataArgsDict']]]
        """
        A sequence of stages that describe the contents of the rule.
        """
        name: pulumi.Input[str]
        """
        The name of the alert rule.
        """
        annotations: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Key-value pairs of metadata to attach to the alert rule. They add additional information, such as a `summary` or `runbook_url`, to help identify and investigate alerts. The `dashboardUId` and `panelId` annotations, which link alerts to a panel, must be set together. Defaults to `map[]`.
        """
        exec_err_state: NotRequired[pulumi.Input[str]]
        """
        Describes what state to enter when the rule's query is invalid and the rule cannot be executed. Options are OK, Error, KeepLast, and Alerting. Defaults to `Alerting`.
        """
        for_: NotRequired[pulumi.Input[str]]
        """
        The amount of time for which the rule must be breached for the rule to be considered to be Firing. Before this time has elapsed, the rule is only considered to be Pending. Defaults to `0`.
        """
        is_paused: NotRequired[pulumi.Input[bool]]
        """
        Sets whether the alert should be paused or not. Defaults to `false`.
        """
        labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Key-value pairs to attach to the alert rule that can be used in matching, grouping, and routing. Defaults to `map[]`.
        """
        no_data_state: NotRequired[pulumi.Input[str]]
        """
        Describes what state to enter when the rule's query returns No Data. Options are OK, NoData, KeepLast, and Alerting. Defaults to `NoData`.
        """
        notification_settings: NotRequired[pulumi.Input['RuleGroupRuleNotificationSettingsArgsDict']]
        """
        Notification settings for the rule. If specified, it overrides the notification policies. Available since Grafana 10.4, requires feature flag 'alertingSimplifiedRouting' to be enabled.
        """
        record: NotRequired[pulumi.Input['RuleGroupRuleRecordArgsDict']]
        """
        Settings for a recording rule. Available since Grafana 11.2, requires feature flag 'grafanaManagedRecordingRules' to be enabled.
        """
        uid: NotRequired[pulumi.Input[str]]
        """
        The unique identifier of the alert rule.
        """
elif False:
    RuleGroupRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 datas: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleDataArgs']]],
                 name: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 exec_err_state: Optional[pulumi.Input[str]] = None,
                 for_: Optional[pulumi.Input[str]] = None,
                 is_paused: Optional[pulumi.Input[bool]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 no_data_state: Optional[pulumi.Input[str]] = None,
                 notification_settings: Optional[pulumi.Input['RuleGroupRuleNotificationSettingsArgs']] = None,
                 record: Optional[pulumi.Input['RuleGroupRuleRecordArgs']] = None,
                 uid: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] condition: The `ref_id` of the query node in the `data` field to use as the alert condition.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleDataArgs']]] datas: A sequence of stages that describe the contents of the rule.
        :param pulumi.Input[str] name: The name of the alert rule.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] annotations: Key-value pairs of metadata to attach to the alert rule. They add additional information, such as a `summary` or `runbook_url`, to help identify and investigate alerts. The `dashboardUId` and `panelId` annotations, which link alerts to a panel, must be set together. Defaults to `map[]`.
        :param pulumi.Input[str] exec_err_state: Describes what state to enter when the rule's query is invalid and the rule cannot be executed. Options are OK, Error, KeepLast, and Alerting. Defaults to `Alerting`.
        :param pulumi.Input[str] for_: The amount of time for which the rule must be breached for the rule to be considered to be Firing. Before this time has elapsed, the rule is only considered to be Pending. Defaults to `0`.
        :param pulumi.Input[bool] is_paused: Sets whether the alert should be paused or not. Defaults to `false`.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] labels: Key-value pairs to attach to the alert rule that can be used in matching, grouping, and routing. Defaults to `map[]`.
        :param pulumi.Input[str] no_data_state: Describes what state to enter when the rule's query returns No Data. Options are OK, NoData, KeepLast, and Alerting. Defaults to `NoData`.
        :param pulumi.Input['RuleGroupRuleNotificationSettingsArgs'] notification_settings: Notification settings for the rule. If specified, it overrides the notification policies. Available since Grafana 10.4, requires feature flag 'alertingSimplifiedRouting' to be enabled.
        :param pulumi.Input['RuleGroupRuleRecordArgs'] record: Settings for a recording rule. Available since Grafana 11.2, requires feature flag 'grafanaManagedRecordingRules' to be enabled.
        :param pulumi.Input[str] uid: The unique identifier of the alert rule.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "datas", datas)
        pulumi.set(__self__, "name", name)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if exec_err_state is not None:
            pulumi.set(__self__, "exec_err_state", exec_err_state)
        if for_ is not None:
            pulumi.set(__self__, "for_", for_)
        if is_paused is not None:
            pulumi.set(__self__, "is_paused", is_paused)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if no_data_state is not None:
            pulumi.set(__self__, "no_data_state", no_data_state)
        if notification_settings is not None:
            pulumi.set(__self__, "notification_settings", notification_settings)
        if record is not None:
            pulumi.set(__self__, "record", record)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        The `ref_id` of the query node in the `data` field to use as the alert condition.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def datas(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleDataArgs']]]:
        """
        A sequence of stages that describe the contents of the rule.
        """
        return pulumi.get(self, "datas")

    @datas.setter
    def datas(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleDataArgs']]]):
        pulumi.set(self, "datas", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the alert rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Key-value pairs of metadata to attach to the alert rule. They add additional information, such as a `summary` or `runbook_url`, to help identify and investigate alerts. The `dashboardUId` and `panelId` annotations, which link alerts to a panel, must be set together. Defaults to `map[]`.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="execErrState")
    def exec_err_state(self) -> Optional[pulumi.Input[str]]:
        """
        Describes what state to enter when the rule's query is invalid and the rule cannot be executed. Options are OK, Error, KeepLast, and Alerting. Defaults to `Alerting`.
        """
        return pulumi.get(self, "exec_err_state")

    @exec_err_state.setter
    def exec_err_state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exec_err_state", value)

    @property
    @pulumi.getter(name="for")
    def for_(self) -> Optional[pulumi.Input[str]]:
        """
        The amount of time for which the rule must be breached for the rule to be considered to be Firing. Before this time has elapsed, the rule is only considered to be Pending. Defaults to `0`.
        """
        return pulumi.get(self, "for_")

    @for_.setter
    def for_(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "for_", value)

    @property
    @pulumi.getter(name="isPaused")
    def is_paused(self) -> Optional[pulumi.Input[bool]]:
        """
        Sets whether the alert should be paused or not. Defaults to `false`.
        """
        return pulumi.get(self, "is_paused")

    @is_paused.setter
    def is_paused(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_paused", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Key-value pairs to attach to the alert rule that can be used in matching, grouping, and routing. Defaults to `map[]`.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "labels", value)

    @property
    @pulumi.getter(name="noDataState")
    def no_data_state(self) -> Optional[pulumi.Input[str]]:
        """
        Describes what state to enter when the rule's query returns No Data. Options are OK, NoData, KeepLast, and Alerting. Defaults to `NoData`.
        """
        return pulumi.get(self, "no_data_state")

    @no_data_state.setter
    def no_data_state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "no_data_state", value)

    @property
    @pulumi.getter(name="notificationSettings")
    def notification_settings(self) -> Optional[pulumi.Input['RuleGroupRuleNotificationSettingsArgs']]:
        """
        Notification settings for the rule. If specified, it overrides the notification policies. Available since Grafana 10.4, requires feature flag 'alertingSimplifiedRouting' to be enabled.
        """
        return pulumi.get(self, "notification_settings")

    @notification_settings.setter
    def notification_settings(self, value: Optional[pulumi.Input['RuleGroupRuleNotificationSettingsArgs']]):
        pulumi.set(self, "notification_settings", value)

    @property
    @pulumi.getter
    def record(self) -> Optional[pulumi.Input['RuleGroupRuleRecordArgs']]:
        """
        Settings for a recording rule. Available since Grafana 11.2, requires feature flag 'grafanaManagedRecordingRules' to be enabled.
        """
        return pulumi.get(self, "record")

    @record.setter
    def record(self, value: Optional[pulumi.Input['RuleGroupRuleRecordArgs']]):
        pulumi.set(self, "record", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        The unique identifier of the alert rule.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)


if not MYPY:
    class RuleGroupRuleDataArgsDict(TypedDict):
        datasource_uid: pulumi.Input[str]
        """
        The UID of the datasource being queried, or "-100" if this stage is an expression stage.
        """
        model: pulumi.Input[str]
        """
        Custom JSON data to send to the specified datasource when querying.
        """
        ref_id: pulumi.Input[str]
        """
        A unique string to identify this query stage within a rule.
        """
        relative_time_range: pulumi.Input['RuleGroupRuleDataRelativeTimeRangeArgsDict']
        """
        The time range, relative to when the query is executed, across which to query.
        """
        query_type: NotRequired[pulumi.Input[str]]
        """
        An optional identifier for the type of query being executed. Defaults to ``.
        """
elif False:
    RuleGroupRuleDataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleDataArgs:
    def __init__(__self__, *,
                 datasource_uid: pulumi.Input[str],
                 model: pulumi.Input[str],
                 ref_id: pulumi.Input[str],
                 relative_time_range: pulumi.Input['RuleGroupRuleDataRelativeTimeRangeArgs'],
                 query_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] datasource_uid: The UID of the datasource being queried, or "-100" if this stage is an expression stage.
        :param pulumi.Input[str] model: Custom JSON data to send to the specified datasource when querying.
        :param pulumi.Input[str] ref_id: A unique string to identify this query stage within a rule.
        :param pulumi.Input['RuleGroupRuleDataRelativeTimeRangeArgs'] relative_time_range: The time range, relative to when the query is executed, across which to query.
        :param pulumi.Input[str] query_type: An optional identifier for the type of query being executed. Defaults to ``.
        """
        pulumi.set(__self__, "datasource_uid", datasource_uid)
        pulumi.set(__self__, "model", model)
        pulumi.set(__self__, "ref_id", ref_id)
        pulumi.set(__self__, "relative_time_range", relative_time_range)
        if query_type is not None:
            pulumi.set(__self__, "query_type", query_type)

    @property
    @pulumi.getter(name="datasourceUid")
    def datasource_uid(self) -> pulumi.Input[str]:
        """
        The UID of the datasource being queried, or "-100" if this stage is an expression stage.
        """
        return pulumi.get(self, "datasource_uid")

    @datasource_uid.setter
    def datasource_uid(self, value: pulumi.Input[str]):
        pulumi.set(self, "datasource_uid", value)

    @property
    @pulumi.getter
    def model(self) -> pulumi.Input[str]:
        """
        Custom JSON data to send to the specified datasource when querying.
        """
        return pulumi.get(self, "model")

    @model.setter
    def model(self, value: pulumi.Input[str]):
        pulumi.set(self, "model", value)

    @property
    @pulumi.getter(name="refId")
    def ref_id(self) -> pulumi.Input[str]:
        """
        A unique string to identify this query stage within a rule.
        """
        return pulumi.get(self, "ref_id")

    @ref_id.setter
    def ref_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "ref_id", value)

    @property
    @pulumi.getter(name="relativeTimeRange")
    def relative_time_range(self) -> pulumi.Input['RuleGroupRuleDataRelativeTimeRangeArgs']:
        """
        The time range, relative to when the query is executed, across which to query.
        """
        return pulumi.get(self, "relative_time_range")

    @relative_time_range.setter
    def relative_time_range(self, value: pulumi.Input['RuleGroupRuleDataRelativeTimeRangeArgs']):
        pulumi.set(self, "relative_time_range", value)

    @property
    @pulumi.getter(name="queryType")
    def query_type(self) -> Optional[pulumi.Input[str]]:
        """
        An optional identifier for the type of query being executed. Defaults to ``.
        """
        return pulumi.get(self, "query_type")

    @query_type.setter
    def query_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "query_type", value)


if not MYPY:
    class RuleGroupRuleDataRelativeTimeRangeArgsDict(TypedDict):
        from_: pulumi.Input[int]
        """
        The number of seconds in the past, relative to when the rule is evaluated, at which the time range begins.
        """
        to: pulumi.Input[int]
        """
        The number of seconds in the past, relative to when the rule is evaluated, at which the time range ends.
        """
elif False:
    RuleGroupRuleDataRelativeTimeRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleDataRelativeTimeRangeArgs:
    def __init__(__self__, *,
                 from_: pulumi.Input[int],
                 to: pulumi.Input[int]):
        """
        :param pulumi.Input[int] from_: The number of seconds in the past, relative to when the rule is evaluated, at which the time range begins.
        :param pulumi.Input[int] to: The number of seconds in the past, relative to when the rule is evaluated, at which the time range ends.
        """
        pulumi.set(__self__, "from_", from_)
        pulumi.set(__self__, "to", to)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> pulumi.Input[int]:
        """
        The number of seconds in the past, relative to when the rule is evaluated, at which the time range begins.
        """
        return pulumi.get(self, "from_")

    @from_.setter
    def from_(self, value: pulumi.Input[int]):
        pulumi.set(self, "from_", value)

    @property
    @pulumi.getter
    def to(self) -> pulumi.Input[int]:
        """
        The number of seconds in the past, relative to when the rule is evaluated, at which the time range ends.
        """
        return pulumi.get(self, "to")

    @to.setter
    def to(self, value: pulumi.Input[int]):
        pulumi.set(self, "to", value)


if not MYPY:
    class RuleGroupRuleNotificationSettingsArgsDict(TypedDict):
        contact_point: pulumi.Input[str]
        """
        The contact point to route notifications that match this rule to.
        """
        group_bies: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping. If empty, no grouping is used. If specified, requires labels 'alertname' and 'grafana_folder' to be included.
        """
        group_interval: NotRequired[pulumi.Input[str]]
        """
        Minimum time interval between two notifications for the same group. Default is 5 minutes.
        """
        group_wait: NotRequired[pulumi.Input[str]]
        """
        Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.
        """
        mute_timings: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of mute timing names to apply to alerts that match this policy.
        """
        repeat_interval: NotRequired[pulumi.Input[str]]
        """
        Minimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.
        """
elif False:
    RuleGroupRuleNotificationSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleNotificationSettingsArgs:
    def __init__(__self__, *,
                 contact_point: pulumi.Input[str],
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 group_interval: Optional[pulumi.Input[str]] = None,
                 group_wait: Optional[pulumi.Input[str]] = None,
                 mute_timings: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 repeat_interval: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] contact_point: The contact point to route notifications that match this rule to.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] group_bies: A list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping. If empty, no grouping is used. If specified, requires labels 'alertname' and 'grafana_folder' to be included.
        :param pulumi.Input[str] group_interval: Minimum time interval between two notifications for the same group. Default is 5 minutes.
        :param pulumi.Input[str] group_wait: Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] mute_timings: A list of mute timing names to apply to alerts that match this policy.
        :param pulumi.Input[str] repeat_interval: Minimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.
        """
        pulumi.set(__self__, "contact_point", contact_point)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if group_interval is not None:
            pulumi.set(__self__, "group_interval", group_interval)
        if group_wait is not None:
            pulumi.set(__self__, "group_wait", group_wait)
        if mute_timings is not None:
            pulumi.set(__self__, "mute_timings", mute_timings)
        if repeat_interval is not None:
            pulumi.set(__self__, "repeat_interval", repeat_interval)

    @property
    @pulumi.getter(name="contactPoint")
    def contact_point(self) -> pulumi.Input[str]:
        """
        The contact point to route notifications that match this rule to.
        """
        return pulumi.get(self, "contact_point")

    @contact_point.setter
    def contact_point(self, value: pulumi.Input[str]):
        pulumi.set(self, "contact_point", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping. If empty, no grouping is used. If specified, requires labels 'alertname' and 'grafana_folder' to be included.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="groupInterval")
    def group_interval(self) -> Optional[pulumi.Input[str]]:
        """
        Minimum time interval between two notifications for the same group. Default is 5 minutes.
        """
        return pulumi.get(self, "group_interval")

    @group_interval.setter
    def group_interval(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group_interval", value)

    @property
    @pulumi.getter(name="groupWait")
    def group_wait(self) -> Optional[pulumi.Input[str]]:
        """
        Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.
        """
        return pulumi.get(self, "group_wait")

    @group_wait.setter
    def group_wait(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group_wait", value)

    @property
    @pulumi.getter(name="muteTimings")
    def mute_timings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of mute timing names to apply to alerts that match this policy.
        """
        return pulumi.get(self, "mute_timings")

    @mute_timings.setter
    def mute_timings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "mute_timings", value)

    @property
    @pulumi.getter(name="repeatInterval")
    def repeat_interval(self) -> Optional[pulumi.Input[str]]:
        """
        Minimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.
        """
        return pulumi.get(self, "repeat_interval")

    @repeat_interval.setter
    def repeat_interval(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repeat_interval", value)


if not MYPY:
    class RuleGroupRuleRecordArgsDict(TypedDict):
        from_: pulumi.Input[str]
        """
        The ref id of the query node in the data field to use as the source of the metric.
        """
        metric: pulumi.Input[str]
        """
        The name of the metric to write to.
        """
elif False:
    RuleGroupRuleRecordArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleRecordArgs:
    def __init__(__self__, *,
                 from_: pulumi.Input[str],
                 metric: pulumi.Input[str]):
        """
        :param pulumi.Input[str] from_: The ref id of the query node in the data field to use as the source of the metric.
        :param pulumi.Input[str] metric: The name of the metric to write to.
        """
        pulumi.set(__self__, "from_", from_)
        pulumi.set(__self__, "metric", metric)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> pulumi.Input[str]:
        """
        The ref id of the query node in the data field to use as the source of the metric.
        """
        return pulumi.get(self, "from_")

    @from_.setter
    def from_(self, value: pulumi.Input[str]):
        pulumi.set(self, "from_", value)

    @property
    @pulumi.getter
    def metric(self) -> pulumi.Input[str]:
        """
        The name of the metric to write to.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric", value)


