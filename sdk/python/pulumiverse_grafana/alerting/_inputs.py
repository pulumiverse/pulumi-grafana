# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'AlertEnrichmentMetadataArgs',
    'AlertEnrichmentMetadataArgsDict',
    'AlertEnrichmentOptionsArgs',
    'AlertEnrichmentOptionsArgsDict',
    'AlertEnrichmentSpecArgs',
    'AlertEnrichmentSpecArgsDict',
    'AlertEnrichmentSpecAnnotationMatcherArgs',
    'AlertEnrichmentSpecAnnotationMatcherArgsDict',
    'AlertEnrichmentSpecLabelMatcherArgs',
    'AlertEnrichmentSpecLabelMatcherArgsDict',
    'AlertEnrichmentSpecStepArgs',
    'AlertEnrichmentSpecStepArgsDict',
    'AlertEnrichmentSpecStepAssertsArgs',
    'AlertEnrichmentSpecStepAssertsArgsDict',
    'AlertEnrichmentSpecStepAssignArgs',
    'AlertEnrichmentSpecStepAssignArgsDict',
    'AlertEnrichmentSpecStepAssistantInvestigationsArgs',
    'AlertEnrichmentSpecStepAssistantInvestigationsArgsDict',
    'AlertEnrichmentSpecStepConditionalArgs',
    'AlertEnrichmentSpecStepConditionalArgsDict',
    'AlertEnrichmentSpecStepConditionalElseArgs',
    'AlertEnrichmentSpecStepConditionalElseArgsDict',
    'AlertEnrichmentSpecStepConditionalElseStepArgs',
    'AlertEnrichmentSpecStepConditionalElseStepArgsDict',
    'AlertEnrichmentSpecStepConditionalElseStepAssertsArgs',
    'AlertEnrichmentSpecStepConditionalElseStepAssertsArgsDict',
    'AlertEnrichmentSpecStepConditionalElseStepAssignArgs',
    'AlertEnrichmentSpecStepConditionalElseStepAssignArgsDict',
    'AlertEnrichmentSpecStepConditionalElseStepAssistantInvestigationsArgs',
    'AlertEnrichmentSpecStepConditionalElseStepAssistantInvestigationsArgsDict',
    'AlertEnrichmentSpecStepConditionalElseStepDataSourceArgs',
    'AlertEnrichmentSpecStepConditionalElseStepDataSourceArgsDict',
    'AlertEnrichmentSpecStepConditionalElseStepDataSourceLogsQueryArgs',
    'AlertEnrichmentSpecStepConditionalElseStepDataSourceLogsQueryArgsDict',
    'AlertEnrichmentSpecStepConditionalElseStepDataSourceRawQueryArgs',
    'AlertEnrichmentSpecStepConditionalElseStepDataSourceRawQueryArgsDict',
    'AlertEnrichmentSpecStepConditionalElseStepExplainArgs',
    'AlertEnrichmentSpecStepConditionalElseStepExplainArgsDict',
    'AlertEnrichmentSpecStepConditionalElseStepExternalArgs',
    'AlertEnrichmentSpecStepConditionalElseStepExternalArgsDict',
    'AlertEnrichmentSpecStepConditionalElseStepSiftArgs',
    'AlertEnrichmentSpecStepConditionalElseStepSiftArgsDict',
    'AlertEnrichmentSpecStepConditionalIfArgs',
    'AlertEnrichmentSpecStepConditionalIfArgsDict',
    'AlertEnrichmentSpecStepConditionalIfAnnotationMatcherArgs',
    'AlertEnrichmentSpecStepConditionalIfAnnotationMatcherArgsDict',
    'AlertEnrichmentSpecStepConditionalIfDataSourceConditionArgs',
    'AlertEnrichmentSpecStepConditionalIfDataSourceConditionArgsDict',
    'AlertEnrichmentSpecStepConditionalIfLabelMatcherArgs',
    'AlertEnrichmentSpecStepConditionalIfLabelMatcherArgsDict',
    'AlertEnrichmentSpecStepConditionalThenArgs',
    'AlertEnrichmentSpecStepConditionalThenArgsDict',
    'AlertEnrichmentSpecStepConditionalThenStepArgs',
    'AlertEnrichmentSpecStepConditionalThenStepArgsDict',
    'AlertEnrichmentSpecStepConditionalThenStepAssertsArgs',
    'AlertEnrichmentSpecStepConditionalThenStepAssertsArgsDict',
    'AlertEnrichmentSpecStepConditionalThenStepAssignArgs',
    'AlertEnrichmentSpecStepConditionalThenStepAssignArgsDict',
    'AlertEnrichmentSpecStepConditionalThenStepAssistantInvestigationsArgs',
    'AlertEnrichmentSpecStepConditionalThenStepAssistantInvestigationsArgsDict',
    'AlertEnrichmentSpecStepConditionalThenStepDataSourceArgs',
    'AlertEnrichmentSpecStepConditionalThenStepDataSourceArgsDict',
    'AlertEnrichmentSpecStepConditionalThenStepDataSourceLogsQueryArgs',
    'AlertEnrichmentSpecStepConditionalThenStepDataSourceLogsQueryArgsDict',
    'AlertEnrichmentSpecStepConditionalThenStepDataSourceRawQueryArgs',
    'AlertEnrichmentSpecStepConditionalThenStepDataSourceRawQueryArgsDict',
    'AlertEnrichmentSpecStepConditionalThenStepExplainArgs',
    'AlertEnrichmentSpecStepConditionalThenStepExplainArgsDict',
    'AlertEnrichmentSpecStepConditionalThenStepExternalArgs',
    'AlertEnrichmentSpecStepConditionalThenStepExternalArgsDict',
    'AlertEnrichmentSpecStepConditionalThenStepSiftArgs',
    'AlertEnrichmentSpecStepConditionalThenStepSiftArgsDict',
    'AlertEnrichmentSpecStepDataSourceArgs',
    'AlertEnrichmentSpecStepDataSourceArgsDict',
    'AlertEnrichmentSpecStepDataSourceLogsQueryArgs',
    'AlertEnrichmentSpecStepDataSourceLogsQueryArgsDict',
    'AlertEnrichmentSpecStepDataSourceRawQueryArgs',
    'AlertEnrichmentSpecStepDataSourceRawQueryArgsDict',
    'AlertEnrichmentSpecStepExplainArgs',
    'AlertEnrichmentSpecStepExplainArgsDict',
    'AlertEnrichmentSpecStepExternalArgs',
    'AlertEnrichmentSpecStepExternalArgsDict',
    'AlertEnrichmentSpecStepSiftArgs',
    'AlertEnrichmentSpecStepSiftArgsDict',
    'AlertRuleV0Alpha1MetadataArgs',
    'AlertRuleV0Alpha1MetadataArgsDict',
    'AlertRuleV0Alpha1OptionsArgs',
    'AlertRuleV0Alpha1OptionsArgsDict',
    'AlertRuleV0Alpha1SpecArgs',
    'AlertRuleV0Alpha1SpecArgsDict',
    'AlertRuleV0Alpha1SpecNotificationSettingsArgs',
    'AlertRuleV0Alpha1SpecNotificationSettingsArgsDict',
    'AlertRuleV0Alpha1SpecTriggerArgs',
    'AlertRuleV0Alpha1SpecTriggerArgsDict',
    'ContactPointAlertmanagerArgs',
    'ContactPointAlertmanagerArgsDict',
    'ContactPointDingdingArgs',
    'ContactPointDingdingArgsDict',
    'ContactPointDiscordArgs',
    'ContactPointDiscordArgsDict',
    'ContactPointEmailArgs',
    'ContactPointEmailArgsDict',
    'ContactPointGooglechatArgs',
    'ContactPointGooglechatArgsDict',
    'ContactPointKafkaArgs',
    'ContactPointKafkaArgsDict',
    'ContactPointLineArgs',
    'ContactPointLineArgsDict',
    'ContactPointOncallArgs',
    'ContactPointOncallArgsDict',
    'ContactPointOpsgenyArgs',
    'ContactPointOpsgenyArgsDict',
    'ContactPointOpsgenyResponderArgs',
    'ContactPointOpsgenyResponderArgsDict',
    'ContactPointPagerdutyArgs',
    'ContactPointPagerdutyArgsDict',
    'ContactPointPushoverArgs',
    'ContactPointPushoverArgsDict',
    'ContactPointSensugoArgs',
    'ContactPointSensugoArgsDict',
    'ContactPointSlackArgs',
    'ContactPointSlackArgsDict',
    'ContactPointSnArgs',
    'ContactPointSnArgsDict',
    'ContactPointTeamArgs',
    'ContactPointTeamArgsDict',
    'ContactPointTelegramArgs',
    'ContactPointTelegramArgsDict',
    'ContactPointThreemaArgs',
    'ContactPointThreemaArgsDict',
    'ContactPointVictoropArgs',
    'ContactPointVictoropArgsDict',
    'ContactPointWebexArgs',
    'ContactPointWebexArgsDict',
    'ContactPointWebhookArgs',
    'ContactPointWebhookArgsDict',
    'ContactPointWebhookHmacConfigArgs',
    'ContactPointWebhookHmacConfigArgsDict',
    'ContactPointWebhookHttpConfigArgs',
    'ContactPointWebhookHttpConfigArgsDict',
    'ContactPointWebhookHttpConfigOauth2Args',
    'ContactPointWebhookHttpConfigOauth2ArgsDict',
    'ContactPointWebhookHttpConfigOauth2ProxyConfigArgs',
    'ContactPointWebhookHttpConfigOauth2ProxyConfigArgsDict',
    'ContactPointWebhookHttpConfigOauth2TlsConfigArgs',
    'ContactPointWebhookHttpConfigOauth2TlsConfigArgsDict',
    'ContactPointWebhookPayloadArgs',
    'ContactPointWebhookPayloadArgsDict',
    'ContactPointWecomArgs',
    'ContactPointWecomArgsDict',
    'MuteTimingIntervalArgs',
    'MuteTimingIntervalArgsDict',
    'MuteTimingIntervalTimeArgs',
    'MuteTimingIntervalTimeArgsDict',
    'NotificationPolicyPolicyArgs',
    'NotificationPolicyPolicyArgsDict',
    'NotificationPolicyPolicyMatcherArgs',
    'NotificationPolicyPolicyMatcherArgsDict',
    'NotificationPolicyPolicyPolicyArgs',
    'NotificationPolicyPolicyPolicyArgsDict',
    'NotificationPolicyPolicyPolicyMatcherArgs',
    'NotificationPolicyPolicyPolicyMatcherArgsDict',
    'NotificationPolicyPolicyPolicyPolicyArgs',
    'NotificationPolicyPolicyPolicyPolicyArgsDict',
    'NotificationPolicyPolicyPolicyPolicyMatcherArgs',
    'NotificationPolicyPolicyPolicyPolicyMatcherArgsDict',
    'NotificationPolicyPolicyPolicyPolicyPolicyArgs',
    'NotificationPolicyPolicyPolicyPolicyPolicyArgsDict',
    'NotificationPolicyPolicyPolicyPolicyPolicyMatcherArgs',
    'NotificationPolicyPolicyPolicyPolicyPolicyMatcherArgsDict',
    'RecordingRuleV0Alpha1MetadataArgs',
    'RecordingRuleV0Alpha1MetadataArgsDict',
    'RecordingRuleV0Alpha1OptionsArgs',
    'RecordingRuleV0Alpha1OptionsArgsDict',
    'RecordingRuleV0Alpha1SpecArgs',
    'RecordingRuleV0Alpha1SpecArgsDict',
    'RecordingRuleV0Alpha1SpecTriggerArgs',
    'RecordingRuleV0Alpha1SpecTriggerArgsDict',
    'RuleGroupRuleArgs',
    'RuleGroupRuleArgsDict',
    'RuleGroupRuleDataArgs',
    'RuleGroupRuleDataArgsDict',
    'RuleGroupRuleDataRelativeTimeRangeArgs',
    'RuleGroupRuleDataRelativeTimeRangeArgsDict',
    'RuleGroupRuleNotificationSettingsArgs',
    'RuleGroupRuleNotificationSettingsArgsDict',
    'RuleGroupRuleRecordArgs',
    'RuleGroupRuleRecordArgsDict',
]

MYPY = False

if not MYPY:
    class AlertEnrichmentMetadataArgsDict(TypedDict):
        uid: pulumi.Input[_builtins.str]
        """
        The unique identifier of the resource.
        """
        annotations: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Annotations of the resource.
        """
        folder_uid: NotRequired[pulumi.Input[_builtins.str]]
        """
        The UID of the folder to save the resource in.
        """
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        The full URL of the resource.
        """
        uuid: NotRequired[pulumi.Input[_builtins.str]]
        """
        The globally unique identifier of a resource, used by the API for tracking.
        """
        version: NotRequired[pulumi.Input[_builtins.str]]
        """
        The version of the resource.
        """
elif False:
    AlertEnrichmentMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertEnrichmentMetadataArgs:
    def __init__(__self__, *,
                 uid: pulumi.Input[_builtins.str],
                 annotations: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 folder_uid: Optional[pulumi.Input[_builtins.str]] = None,
                 url: Optional[pulumi.Input[_builtins.str]] = None,
                 uuid: Optional[pulumi.Input[_builtins.str]] = None,
                 version: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] uid: The unique identifier of the resource.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] annotations: Annotations of the resource.
        :param pulumi.Input[_builtins.str] folder_uid: The UID of the folder to save the resource in.
        :param pulumi.Input[_builtins.str] url: The full URL of the resource.
        :param pulumi.Input[_builtins.str] uuid: The globally unique identifier of a resource, used by the API for tracking.
        :param pulumi.Input[_builtins.str] version: The version of the resource.
        """
        pulumi.set(__self__, "uid", uid)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if folder_uid is not None:
            pulumi.set(__self__, "folder_uid", folder_uid)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def uid(self) -> pulumi.Input[_builtins.str]:
        """
        The unique identifier of the resource.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "uid", value)

    @_builtins.property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Annotations of the resource.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "annotations", value)

    @_builtins.property
    @pulumi.getter(name="folderUid")
    def folder_uid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The UID of the folder to save the resource in.
        """
        return pulumi.get(self, "folder_uid")

    @folder_uid.setter
    def folder_uid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "folder_uid", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The full URL of the resource.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The globally unique identifier of a resource, used by the API for tracking.
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uuid", value)

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The version of the resource.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class AlertEnrichmentOptionsArgsDict(TypedDict):
        overwrite: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Set to true if you want to overwrite existing resource with newer version, same resource title in folder or same resource uid.
        """
elif False:
    AlertEnrichmentOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertEnrichmentOptionsArgs:
    def __init__(__self__, *,
                 overwrite: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] overwrite: Set to true if you want to overwrite existing resource with newer version, same resource title in folder or same resource uid.
        """
        if overwrite is not None:
            pulumi.set(__self__, "overwrite", overwrite)

    @_builtins.property
    @pulumi.getter
    def overwrite(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Set to true if you want to overwrite existing resource with newer version, same resource title in folder or same resource uid.
        """
        return pulumi.get(self, "overwrite")

    @overwrite.setter
    def overwrite(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "overwrite", value)


if not MYPY:
    class AlertEnrichmentSpecArgsDict(TypedDict):
        title: pulumi.Input[_builtins.str]
        """
        The title of the alert enrichment.
        """
        alert_rule_uids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        UIDs of alert rules this enrichment applies to. If empty, applies to all alert rules.
        """
        annotation_matchers: NotRequired[pulumi.Input[Sequence[pulumi.Input['AlertEnrichmentSpecAnnotationMatcherArgsDict']]]]
        """
        Annotation matchers that an alert must satisfy for this enrichment to apply. Each matcher is an object with: 'type' (string, one of: =, !=, =~, !~), 'name' (string, annotation key to match), 'value' (string, annotation value to compare against, supports regex for =~/!~ operators).
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Description of the alert enrichment.
        """
        disable_provenance: NotRequired[pulumi.Input[_builtins.bool]]
        label_matchers: NotRequired[pulumi.Input[Sequence[pulumi.Input['AlertEnrichmentSpecLabelMatcherArgsDict']]]]
        """
        Label matchers that an alert must satisfy for this enrichment to apply. Each matcher is an object with: 'type' (string, one of: =, !=, =~, !~), 'name' (string, label key to match), 'value' (string, label value to compare against, supports regex for =~/!~ operators).
        """
        receivers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Receiver names to match. If empty, applies to all receivers.
        """
        steps: NotRequired[pulumi.Input[Sequence[pulumi.Input['AlertEnrichmentSpecStepArgsDict']]]]
        """
        Enrichment step. Can be repeated multiple times to define a sequence of steps. Each step must contain exactly one enrichment block.
        """
elif False:
    AlertEnrichmentSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertEnrichmentSpecArgs:
    def __init__(__self__, *,
                 title: pulumi.Input[_builtins.str],
                 alert_rule_uids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 annotation_matchers: Optional[pulumi.Input[Sequence[pulumi.Input['AlertEnrichmentSpecAnnotationMatcherArgs']]]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 disable_provenance: Optional[pulumi.Input[_builtins.bool]] = None,
                 label_matchers: Optional[pulumi.Input[Sequence[pulumi.Input['AlertEnrichmentSpecLabelMatcherArgs']]]] = None,
                 receivers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 steps: Optional[pulumi.Input[Sequence[pulumi.Input['AlertEnrichmentSpecStepArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] title: The title of the alert enrichment.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] alert_rule_uids: UIDs of alert rules this enrichment applies to. If empty, applies to all alert rules.
        :param pulumi.Input[Sequence[pulumi.Input['AlertEnrichmentSpecAnnotationMatcherArgs']]] annotation_matchers: Annotation matchers that an alert must satisfy for this enrichment to apply. Each matcher is an object with: 'type' (string, one of: =, !=, =~, !~), 'name' (string, annotation key to match), 'value' (string, annotation value to compare against, supports regex for =~/!~ operators).
        :param pulumi.Input[_builtins.str] description: Description of the alert enrichment.
        :param pulumi.Input[Sequence[pulumi.Input['AlertEnrichmentSpecLabelMatcherArgs']]] label_matchers: Label matchers that an alert must satisfy for this enrichment to apply. Each matcher is an object with: 'type' (string, one of: =, !=, =~, !~), 'name' (string, label key to match), 'value' (string, label value to compare against, supports regex for =~/!~ operators).
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] receivers: Receiver names to match. If empty, applies to all receivers.
        :param pulumi.Input[Sequence[pulumi.Input['AlertEnrichmentSpecStepArgs']]] steps: Enrichment step. Can be repeated multiple times to define a sequence of steps. Each step must contain exactly one enrichment block.
        """
        pulumi.set(__self__, "title", title)
        if alert_rule_uids is not None:
            pulumi.set(__self__, "alert_rule_uids", alert_rule_uids)
        if annotation_matchers is not None:
            pulumi.set(__self__, "annotation_matchers", annotation_matchers)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disable_provenance is not None:
            pulumi.set(__self__, "disable_provenance", disable_provenance)
        if label_matchers is not None:
            pulumi.set(__self__, "label_matchers", label_matchers)
        if receivers is not None:
            pulumi.set(__self__, "receivers", receivers)
        if steps is not None:
            pulumi.set(__self__, "steps", steps)

    @_builtins.property
    @pulumi.getter
    def title(self) -> pulumi.Input[_builtins.str]:
        """
        The title of the alert enrichment.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "title", value)

    @_builtins.property
    @pulumi.getter(name="alertRuleUids")
    def alert_rule_uids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        UIDs of alert rules this enrichment applies to. If empty, applies to all alert rules.
        """
        return pulumi.get(self, "alert_rule_uids")

    @alert_rule_uids.setter
    def alert_rule_uids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "alert_rule_uids", value)

    @_builtins.property
    @pulumi.getter(name="annotationMatchers")
    def annotation_matchers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AlertEnrichmentSpecAnnotationMatcherArgs']]]]:
        """
        Annotation matchers that an alert must satisfy for this enrichment to apply. Each matcher is an object with: 'type' (string, one of: =, !=, =~, !~), 'name' (string, annotation key to match), 'value' (string, annotation value to compare against, supports regex for =~/!~ operators).
        """
        return pulumi.get(self, "annotation_matchers")

    @annotation_matchers.setter
    def annotation_matchers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AlertEnrichmentSpecAnnotationMatcherArgs']]]]):
        pulumi.set(self, "annotation_matchers", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Description of the alert enrichment.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="disableProvenance")
    def disable_provenance(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "disable_provenance")

    @disable_provenance.setter
    def disable_provenance(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disable_provenance", value)

    @_builtins.property
    @pulumi.getter(name="labelMatchers")
    def label_matchers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AlertEnrichmentSpecLabelMatcherArgs']]]]:
        """
        Label matchers that an alert must satisfy for this enrichment to apply. Each matcher is an object with: 'type' (string, one of: =, !=, =~, !~), 'name' (string, label key to match), 'value' (string, label value to compare against, supports regex for =~/!~ operators).
        """
        return pulumi.get(self, "label_matchers")

    @label_matchers.setter
    def label_matchers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AlertEnrichmentSpecLabelMatcherArgs']]]]):
        pulumi.set(self, "label_matchers", value)

    @_builtins.property
    @pulumi.getter
    def receivers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Receiver names to match. If empty, applies to all receivers.
        """
        return pulumi.get(self, "receivers")

    @receivers.setter
    def receivers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "receivers", value)

    @_builtins.property
    @pulumi.getter
    def steps(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AlertEnrichmentSpecStepArgs']]]]:
        """
        Enrichment step. Can be repeated multiple times to define a sequence of steps. Each step must contain exactly one enrichment block.
        """
        return pulumi.get(self, "steps")

    @steps.setter
    def steps(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AlertEnrichmentSpecStepArgs']]]]):
        pulumi.set(self, "steps", value)


if not MYPY:
    class AlertEnrichmentSpecAnnotationMatcherArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        type: pulumi.Input[_builtins.str]
        value: pulumi.Input[_builtins.str]
elif False:
    AlertEnrichmentSpecAnnotationMatcherArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertEnrichmentSpecAnnotationMatcherArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class AlertEnrichmentSpecLabelMatcherArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        type: pulumi.Input[_builtins.str]
        value: pulumi.Input[_builtins.str]
elif False:
    AlertEnrichmentSpecLabelMatcherArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertEnrichmentSpecLabelMatcherArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class AlertEnrichmentSpecStepArgsDict(TypedDict):
        asserts: NotRequired[pulumi.Input['AlertEnrichmentSpecStepAssertsArgsDict']]
        """
        Integrate with Grafana Asserts for enrichment.
        """
        assign: NotRequired[pulumi.Input['AlertEnrichmentSpecStepAssignArgsDict']]
        """
        Assign annotations to an alert.
        """
        assistant_investigations: NotRequired[pulumi.Input['AlertEnrichmentSpecStepAssistantInvestigationsArgsDict']]
        """
        Use AI assistant to investigate alerts and add insights.
        """
        conditional: NotRequired[pulumi.Input['AlertEnrichmentSpecStepConditionalArgsDict']]
        """
        Conditional step with if/then/else.
        """
        data_source: NotRequired[pulumi.Input['AlertEnrichmentSpecStepDataSourceArgsDict']]
        """
        Query Grafana data sources and add results to alerts.
        """
        explain: NotRequired[pulumi.Input['AlertEnrichmentSpecStepExplainArgsDict']]
        """
        Generate AI explanation and store in an annotation.
        """
        external: NotRequired[pulumi.Input['AlertEnrichmentSpecStepExternalArgsDict']]
        """
        Call an external HTTP service for enrichment.
        """
        sift: NotRequired[pulumi.Input['AlertEnrichmentSpecStepSiftArgsDict']]
        """
        Analyze alerts for patterns and insights.
        """
elif False:
    AlertEnrichmentSpecStepArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertEnrichmentSpecStepArgs:
    def __init__(__self__, *,
                 asserts: Optional[pulumi.Input['AlertEnrichmentSpecStepAssertsArgs']] = None,
                 assign: Optional[pulumi.Input['AlertEnrichmentSpecStepAssignArgs']] = None,
                 assistant_investigations: Optional[pulumi.Input['AlertEnrichmentSpecStepAssistantInvestigationsArgs']] = None,
                 conditional: Optional[pulumi.Input['AlertEnrichmentSpecStepConditionalArgs']] = None,
                 data_source: Optional[pulumi.Input['AlertEnrichmentSpecStepDataSourceArgs']] = None,
                 explain: Optional[pulumi.Input['AlertEnrichmentSpecStepExplainArgs']] = None,
                 external: Optional[pulumi.Input['AlertEnrichmentSpecStepExternalArgs']] = None,
                 sift: Optional[pulumi.Input['AlertEnrichmentSpecStepSiftArgs']] = None):
        """
        :param pulumi.Input['AlertEnrichmentSpecStepAssertsArgs'] asserts: Integrate with Grafana Asserts for enrichment.
        :param pulumi.Input['AlertEnrichmentSpecStepAssignArgs'] assign: Assign annotations to an alert.
        :param pulumi.Input['AlertEnrichmentSpecStepAssistantInvestigationsArgs'] assistant_investigations: Use AI assistant to investigate alerts and add insights.
        :param pulumi.Input['AlertEnrichmentSpecStepConditionalArgs'] conditional: Conditional step with if/then/else.
        :param pulumi.Input['AlertEnrichmentSpecStepDataSourceArgs'] data_source: Query Grafana data sources and add results to alerts.
        :param pulumi.Input['AlertEnrichmentSpecStepExplainArgs'] explain: Generate AI explanation and store in an annotation.
        :param pulumi.Input['AlertEnrichmentSpecStepExternalArgs'] external: Call an external HTTP service for enrichment.
        :param pulumi.Input['AlertEnrichmentSpecStepSiftArgs'] sift: Analyze alerts for patterns and insights.
        """
        if asserts is not None:
            pulumi.set(__self__, "asserts", asserts)
        if assign is not None:
            pulumi.set(__self__, "assign", assign)
        if assistant_investigations is not None:
            pulumi.set(__self__, "assistant_investigations", assistant_investigations)
        if conditional is not None:
            pulumi.set(__self__, "conditional", conditional)
        if data_source is not None:
            pulumi.set(__self__, "data_source", data_source)
        if explain is not None:
            pulumi.set(__self__, "explain", explain)
        if external is not None:
            pulumi.set(__self__, "external", external)
        if sift is not None:
            pulumi.set(__self__, "sift", sift)

    @_builtins.property
    @pulumi.getter
    def asserts(self) -> Optional[pulumi.Input['AlertEnrichmentSpecStepAssertsArgs']]:
        """
        Integrate with Grafana Asserts for enrichment.
        """
        return pulumi.get(self, "asserts")

    @asserts.setter
    def asserts(self, value: Optional[pulumi.Input['AlertEnrichmentSpecStepAssertsArgs']]):
        pulumi.set(self, "asserts", value)

    @_builtins.property
    @pulumi.getter
    def assign(self) -> Optional[pulumi.Input['AlertEnrichmentSpecStepAssignArgs']]:
        """
        Assign annotations to an alert.
        """
        return pulumi.get(self, "assign")

    @assign.setter
    def assign(self, value: Optional[pulumi.Input['AlertEnrichmentSpecStepAssignArgs']]):
        pulumi.set(self, "assign", value)

    @_builtins.property
    @pulumi.getter(name="assistantInvestigations")
    def assistant_investigations(self) -> Optional[pulumi.Input['AlertEnrichmentSpecStepAssistantInvestigationsArgs']]:
        """
        Use AI assistant to investigate alerts and add insights.
        """
        return pulumi.get(self, "assistant_investigations")

    @assistant_investigations.setter
    def assistant_investigations(self, value: Optional[pulumi.Input['AlertEnrichmentSpecStepAssistantInvestigationsArgs']]):
        pulumi.set(self, "assistant_investigations", value)

    @_builtins.property
    @pulumi.getter
    def conditional(self) -> Optional[pulumi.Input['AlertEnrichmentSpecStepConditionalArgs']]:
        """
        Conditional step with if/then/else.
        """
        return pulumi.get(self, "conditional")

    @conditional.setter
    def conditional(self, value: Optional[pulumi.Input['AlertEnrichmentSpecStepConditionalArgs']]):
        pulumi.set(self, "conditional", value)

    @_builtins.property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> Optional[pulumi.Input['AlertEnrichmentSpecStepDataSourceArgs']]:
        """
        Query Grafana data sources and add results to alerts.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: Optional[pulumi.Input['AlertEnrichmentSpecStepDataSourceArgs']]):
        pulumi.set(self, "data_source", value)

    @_builtins.property
    @pulumi.getter
    def explain(self) -> Optional[pulumi.Input['AlertEnrichmentSpecStepExplainArgs']]:
        """
        Generate AI explanation and store in an annotation.
        """
        return pulumi.get(self, "explain")

    @explain.setter
    def explain(self, value: Optional[pulumi.Input['AlertEnrichmentSpecStepExplainArgs']]):
        pulumi.set(self, "explain", value)

    @_builtins.property
    @pulumi.getter
    def external(self) -> Optional[pulumi.Input['AlertEnrichmentSpecStepExternalArgs']]:
        """
        Call an external HTTP service for enrichment.
        """
        return pulumi.get(self, "external")

    @external.setter
    def external(self, value: Optional[pulumi.Input['AlertEnrichmentSpecStepExternalArgs']]):
        pulumi.set(self, "external", value)

    @_builtins.property
    @pulumi.getter
    def sift(self) -> Optional[pulumi.Input['AlertEnrichmentSpecStepSiftArgs']]:
        """
        Analyze alerts for patterns and insights.
        """
        return pulumi.get(self, "sift")

    @sift.setter
    def sift(self, value: Optional[pulumi.Input['AlertEnrichmentSpecStepSiftArgs']]):
        pulumi.set(self, "sift", value)


if not MYPY:
    class AlertEnrichmentSpecStepAssertsArgsDict(TypedDict):
        timeout: NotRequired[pulumi.Input[_builtins.str]]
        """
        Maximum execution time (e.g., '30s', '1m')
        """
elif False:
    AlertEnrichmentSpecStepAssertsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertEnrichmentSpecStepAssertsArgs:
    def __init__(__self__, *,
                 timeout: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] timeout: Maximum execution time (e.g., '30s', '1m')
        """
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Maximum execution time (e.g., '30s', '1m')
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "timeout", value)


if not MYPY:
    class AlertEnrichmentSpecStepAssignArgsDict(TypedDict):
        annotations: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Map of annotation names to values to set on matching alerts.
        """
        timeout: NotRequired[pulumi.Input[_builtins.str]]
        """
        Maximum execution time (e.g., '30s', '1m')
        """
elif False:
    AlertEnrichmentSpecStepAssignArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertEnrichmentSpecStepAssignArgs:
    def __init__(__self__, *,
                 annotations: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 timeout: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] annotations: Map of annotation names to values to set on matching alerts.
        :param pulumi.Input[_builtins.str] timeout: Maximum execution time (e.g., '30s', '1m')
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Map of annotation names to values to set on matching alerts.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "annotations", value)

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Maximum execution time (e.g., '30s', '1m')
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "timeout", value)


if not MYPY:
    class AlertEnrichmentSpecStepAssistantInvestigationsArgsDict(TypedDict):
        timeout: NotRequired[pulumi.Input[_builtins.str]]
        """
        Maximum execution time (e.g., '30s', '1m')
        """
elif False:
    AlertEnrichmentSpecStepAssistantInvestigationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertEnrichmentSpecStepAssistantInvestigationsArgs:
    def __init__(__self__, *,
                 timeout: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] timeout: Maximum execution time (e.g., '30s', '1m')
        """
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Maximum execution time (e.g., '30s', '1m')
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "timeout", value)


if not MYPY:
    class AlertEnrichmentSpecStepConditionalArgsDict(TypedDict):
        else_: NotRequired[pulumi.Input['AlertEnrichmentSpecStepConditionalElseArgsDict']]
        """
        Steps when condition is false.
        """
        if_: NotRequired[pulumi.Input['AlertEnrichmentSpecStepConditionalIfArgsDict']]
        """
        Condition to evaluate.
        """
        then: NotRequired[pulumi.Input['AlertEnrichmentSpecStepConditionalThenArgsDict']]
        """
        Steps when condition is true.
        """
        timeout: NotRequired[pulumi.Input[_builtins.str]]
        """
        Maximum execution time (e.g., '30s', '1m')
        """
elif False:
    AlertEnrichmentSpecStepConditionalArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertEnrichmentSpecStepConditionalArgs:
    def __init__(__self__, *,
                 else_: Optional[pulumi.Input['AlertEnrichmentSpecStepConditionalElseArgs']] = None,
                 if_: Optional[pulumi.Input['AlertEnrichmentSpecStepConditionalIfArgs']] = None,
                 then: Optional[pulumi.Input['AlertEnrichmentSpecStepConditionalThenArgs']] = None,
                 timeout: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['AlertEnrichmentSpecStepConditionalElseArgs'] else_: Steps when condition is false.
        :param pulumi.Input['AlertEnrichmentSpecStepConditionalIfArgs'] if_: Condition to evaluate.
        :param pulumi.Input['AlertEnrichmentSpecStepConditionalThenArgs'] then: Steps when condition is true.
        :param pulumi.Input[_builtins.str] timeout: Maximum execution time (e.g., '30s', '1m')
        """
        if else_ is not None:
            pulumi.set(__self__, "else_", else_)
        if if_ is not None:
            pulumi.set(__self__, "if_", if_)
        if then is not None:
            pulumi.set(__self__, "then", then)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter(name="else")
    def else_(self) -> Optional[pulumi.Input['AlertEnrichmentSpecStepConditionalElseArgs']]:
        """
        Steps when condition is false.
        """
        return pulumi.get(self, "else_")

    @else_.setter
    def else_(self, value: Optional[pulumi.Input['AlertEnrichmentSpecStepConditionalElseArgs']]):
        pulumi.set(self, "else_", value)

    @_builtins.property
    @pulumi.getter(name="if")
    def if_(self) -> Optional[pulumi.Input['AlertEnrichmentSpecStepConditionalIfArgs']]:
        """
        Condition to evaluate.
        """
        return pulumi.get(self, "if_")

    @if_.setter
    def if_(self, value: Optional[pulumi.Input['AlertEnrichmentSpecStepConditionalIfArgs']]):
        pulumi.set(self, "if_", value)

    @_builtins.property
    @pulumi.getter
    def then(self) -> Optional[pulumi.Input['AlertEnrichmentSpecStepConditionalThenArgs']]:
        """
        Steps when condition is true.
        """
        return pulumi.get(self, "then")

    @then.setter
    def then(self, value: Optional[pulumi.Input['AlertEnrichmentSpecStepConditionalThenArgs']]):
        pulumi.set(self, "then", value)

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Maximum execution time (e.g., '30s', '1m')
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "timeout", value)


if not MYPY:
    class AlertEnrichmentSpecStepConditionalElseArgsDict(TypedDict):
        steps: NotRequired[pulumi.Input[Sequence[pulumi.Input['AlertEnrichmentSpecStepConditionalElseStepArgsDict']]]]
elif False:
    AlertEnrichmentSpecStepConditionalElseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertEnrichmentSpecStepConditionalElseArgs:
    def __init__(__self__, *,
                 steps: Optional[pulumi.Input[Sequence[pulumi.Input['AlertEnrichmentSpecStepConditionalElseStepArgs']]]] = None):
        if steps is not None:
            pulumi.set(__self__, "steps", steps)

    @_builtins.property
    @pulumi.getter
    def steps(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AlertEnrichmentSpecStepConditionalElseStepArgs']]]]:
        return pulumi.get(self, "steps")

    @steps.setter
    def steps(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AlertEnrichmentSpecStepConditionalElseStepArgs']]]]):
        pulumi.set(self, "steps", value)


if not MYPY:
    class AlertEnrichmentSpecStepConditionalElseStepArgsDict(TypedDict):
        asserts: NotRequired[pulumi.Input['AlertEnrichmentSpecStepConditionalElseStepAssertsArgsDict']]
        """
        Integrate with Grafana Asserts for enrichment.
        """
        assign: NotRequired[pulumi.Input['AlertEnrichmentSpecStepConditionalElseStepAssignArgsDict']]
        """
        Assign annotations to an alert.
        """
        assistant_investigations: NotRequired[pulumi.Input['AlertEnrichmentSpecStepConditionalElseStepAssistantInvestigationsArgsDict']]
        """
        Use AI assistant to investigate alerts and add insights.
        """
        data_source: NotRequired[pulumi.Input['AlertEnrichmentSpecStepConditionalElseStepDataSourceArgsDict']]
        """
        Query Grafana data sources and add results to alerts.
        """
        explain: NotRequired[pulumi.Input['AlertEnrichmentSpecStepConditionalElseStepExplainArgsDict']]
        """
        Generate AI explanation and store in an annotation.
        """
        external: NotRequired[pulumi.Input['AlertEnrichmentSpecStepConditionalElseStepExternalArgsDict']]
        """
        Call an external HTTP service for enrichment.
        """
        sift: NotRequired[pulumi.Input['AlertEnrichmentSpecStepConditionalElseStepSiftArgsDict']]
        """
        Analyze alerts for patterns and insights.
        """
elif False:
    AlertEnrichmentSpecStepConditionalElseStepArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertEnrichmentSpecStepConditionalElseStepArgs:
    def __init__(__self__, *,
                 asserts: Optional[pulumi.Input['AlertEnrichmentSpecStepConditionalElseStepAssertsArgs']] = None,
                 assign: Optional[pulumi.Input['AlertEnrichmentSpecStepConditionalElseStepAssignArgs']] = None,
                 assistant_investigations: Optional[pulumi.Input['AlertEnrichmentSpecStepConditionalElseStepAssistantInvestigationsArgs']] = None,
                 data_source: Optional[pulumi.Input['AlertEnrichmentSpecStepConditionalElseStepDataSourceArgs']] = None,
                 explain: Optional[pulumi.Input['AlertEnrichmentSpecStepConditionalElseStepExplainArgs']] = None,
                 external: Optional[pulumi.Input['AlertEnrichmentSpecStepConditionalElseStepExternalArgs']] = None,
                 sift: Optional[pulumi.Input['AlertEnrichmentSpecStepConditionalElseStepSiftArgs']] = None):
        """
        :param pulumi.Input['AlertEnrichmentSpecStepConditionalElseStepAssertsArgs'] asserts: Integrate with Grafana Asserts for enrichment.
        :param pulumi.Input['AlertEnrichmentSpecStepConditionalElseStepAssignArgs'] assign: Assign annotations to an alert.
        :param pulumi.Input['AlertEnrichmentSpecStepConditionalElseStepAssistantInvestigationsArgs'] assistant_investigations: Use AI assistant to investigate alerts and add insights.
        :param pulumi.Input['AlertEnrichmentSpecStepConditionalElseStepDataSourceArgs'] data_source: Query Grafana data sources and add results to alerts.
        :param pulumi.Input['AlertEnrichmentSpecStepConditionalElseStepExplainArgs'] explain: Generate AI explanation and store in an annotation.
        :param pulumi.Input['AlertEnrichmentSpecStepConditionalElseStepExternalArgs'] external: Call an external HTTP service for enrichment.
        :param pulumi.Input['AlertEnrichmentSpecStepConditionalElseStepSiftArgs'] sift: Analyze alerts for patterns and insights.
        """
        if asserts is not None:
            pulumi.set(__self__, "asserts", asserts)
        if assign is not None:
            pulumi.set(__self__, "assign", assign)
        if assistant_investigations is not None:
            pulumi.set(__self__, "assistant_investigations", assistant_investigations)
        if data_source is not None:
            pulumi.set(__self__, "data_source", data_source)
        if explain is not None:
            pulumi.set(__self__, "explain", explain)
        if external is not None:
            pulumi.set(__self__, "external", external)
        if sift is not None:
            pulumi.set(__self__, "sift", sift)

    @_builtins.property
    @pulumi.getter
    def asserts(self) -> Optional[pulumi.Input['AlertEnrichmentSpecStepConditionalElseStepAssertsArgs']]:
        """
        Integrate with Grafana Asserts for enrichment.
        """
        return pulumi.get(self, "asserts")

    @asserts.setter
    def asserts(self, value: Optional[pulumi.Input['AlertEnrichmentSpecStepConditionalElseStepAssertsArgs']]):
        pulumi.set(self, "asserts", value)

    @_builtins.property
    @pulumi.getter
    def assign(self) -> Optional[pulumi.Input['AlertEnrichmentSpecStepConditionalElseStepAssignArgs']]:
        """
        Assign annotations to an alert.
        """
        return pulumi.get(self, "assign")

    @assign.setter
    def assign(self, value: Optional[pulumi.Input['AlertEnrichmentSpecStepConditionalElseStepAssignArgs']]):
        pulumi.set(self, "assign", value)

    @_builtins.property
    @pulumi.getter(name="assistantInvestigations")
    def assistant_investigations(self) -> Optional[pulumi.Input['AlertEnrichmentSpecStepConditionalElseStepAssistantInvestigationsArgs']]:
        """
        Use AI assistant to investigate alerts and add insights.
        """
        return pulumi.get(self, "assistant_investigations")

    @assistant_investigations.setter
    def assistant_investigations(self, value: Optional[pulumi.Input['AlertEnrichmentSpecStepConditionalElseStepAssistantInvestigationsArgs']]):
        pulumi.set(self, "assistant_investigations", value)

    @_builtins.property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> Optional[pulumi.Input['AlertEnrichmentSpecStepConditionalElseStepDataSourceArgs']]:
        """
        Query Grafana data sources and add results to alerts.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: Optional[pulumi.Input['AlertEnrichmentSpecStepConditionalElseStepDataSourceArgs']]):
        pulumi.set(self, "data_source", value)

    @_builtins.property
    @pulumi.getter
    def explain(self) -> Optional[pulumi.Input['AlertEnrichmentSpecStepConditionalElseStepExplainArgs']]:
        """
        Generate AI explanation and store in an annotation.
        """
        return pulumi.get(self, "explain")

    @explain.setter
    def explain(self, value: Optional[pulumi.Input['AlertEnrichmentSpecStepConditionalElseStepExplainArgs']]):
        pulumi.set(self, "explain", value)

    @_builtins.property
    @pulumi.getter
    def external(self) -> Optional[pulumi.Input['AlertEnrichmentSpecStepConditionalElseStepExternalArgs']]:
        """
        Call an external HTTP service for enrichment.
        """
        return pulumi.get(self, "external")

    @external.setter
    def external(self, value: Optional[pulumi.Input['AlertEnrichmentSpecStepConditionalElseStepExternalArgs']]):
        pulumi.set(self, "external", value)

    @_builtins.property
    @pulumi.getter
    def sift(self) -> Optional[pulumi.Input['AlertEnrichmentSpecStepConditionalElseStepSiftArgs']]:
        """
        Analyze alerts for patterns and insights.
        """
        return pulumi.get(self, "sift")

    @sift.setter
    def sift(self, value: Optional[pulumi.Input['AlertEnrichmentSpecStepConditionalElseStepSiftArgs']]):
        pulumi.set(self, "sift", value)


if not MYPY:
    class AlertEnrichmentSpecStepConditionalElseStepAssertsArgsDict(TypedDict):
        timeout: NotRequired[pulumi.Input[_builtins.str]]
        """
        Maximum execution time (e.g., '30s', '1m')
        """
elif False:
    AlertEnrichmentSpecStepConditionalElseStepAssertsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertEnrichmentSpecStepConditionalElseStepAssertsArgs:
    def __init__(__self__, *,
                 timeout: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] timeout: Maximum execution time (e.g., '30s', '1m')
        """
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Maximum execution time (e.g., '30s', '1m')
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "timeout", value)


if not MYPY:
    class AlertEnrichmentSpecStepConditionalElseStepAssignArgsDict(TypedDict):
        annotations: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Map of annotation names to values to set on matching alerts.
        """
        timeout: NotRequired[pulumi.Input[_builtins.str]]
        """
        Maximum execution time (e.g., '30s', '1m')
        """
elif False:
    AlertEnrichmentSpecStepConditionalElseStepAssignArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertEnrichmentSpecStepConditionalElseStepAssignArgs:
    def __init__(__self__, *,
                 annotations: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 timeout: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] annotations: Map of annotation names to values to set on matching alerts.
        :param pulumi.Input[_builtins.str] timeout: Maximum execution time (e.g., '30s', '1m')
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Map of annotation names to values to set on matching alerts.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "annotations", value)

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Maximum execution time (e.g., '30s', '1m')
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "timeout", value)


if not MYPY:
    class AlertEnrichmentSpecStepConditionalElseStepAssistantInvestigationsArgsDict(TypedDict):
        timeout: NotRequired[pulumi.Input[_builtins.str]]
        """
        Maximum execution time (e.g., '30s', '1m')
        """
elif False:
    AlertEnrichmentSpecStepConditionalElseStepAssistantInvestigationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertEnrichmentSpecStepConditionalElseStepAssistantInvestigationsArgs:
    def __init__(__self__, *,
                 timeout: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] timeout: Maximum execution time (e.g., '30s', '1m')
        """
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Maximum execution time (e.g., '30s', '1m')
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "timeout", value)


if not MYPY:
    class AlertEnrichmentSpecStepConditionalElseStepDataSourceArgsDict(TypedDict):
        logs_query: NotRequired[pulumi.Input['AlertEnrichmentSpecStepConditionalElseStepDataSourceLogsQueryArgsDict']]
        """
        Logs query configuration for querying log data sources.
        """
        raw_query: NotRequired[pulumi.Input['AlertEnrichmentSpecStepConditionalElseStepDataSourceRawQueryArgsDict']]
        """
        Raw query configuration for advanced data source queries.
        """
        timeout: NotRequired[pulumi.Input[_builtins.str]]
        """
        Maximum execution time (e.g., '30s', '1m')
        """
elif False:
    AlertEnrichmentSpecStepConditionalElseStepDataSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertEnrichmentSpecStepConditionalElseStepDataSourceArgs:
    def __init__(__self__, *,
                 logs_query: Optional[pulumi.Input['AlertEnrichmentSpecStepConditionalElseStepDataSourceLogsQueryArgs']] = None,
                 raw_query: Optional[pulumi.Input['AlertEnrichmentSpecStepConditionalElseStepDataSourceRawQueryArgs']] = None,
                 timeout: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['AlertEnrichmentSpecStepConditionalElseStepDataSourceLogsQueryArgs'] logs_query: Logs query configuration for querying log data sources.
        :param pulumi.Input['AlertEnrichmentSpecStepConditionalElseStepDataSourceRawQueryArgs'] raw_query: Raw query configuration for advanced data source queries.
        :param pulumi.Input[_builtins.str] timeout: Maximum execution time (e.g., '30s', '1m')
        """
        if logs_query is not None:
            pulumi.set(__self__, "logs_query", logs_query)
        if raw_query is not None:
            pulumi.set(__self__, "raw_query", raw_query)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter(name="logsQuery")
    def logs_query(self) -> Optional[pulumi.Input['AlertEnrichmentSpecStepConditionalElseStepDataSourceLogsQueryArgs']]:
        """
        Logs query configuration for querying log data sources.
        """
        return pulumi.get(self, "logs_query")

    @logs_query.setter
    def logs_query(self, value: Optional[pulumi.Input['AlertEnrichmentSpecStepConditionalElseStepDataSourceLogsQueryArgs']]):
        pulumi.set(self, "logs_query", value)

    @_builtins.property
    @pulumi.getter(name="rawQuery")
    def raw_query(self) -> Optional[pulumi.Input['AlertEnrichmentSpecStepConditionalElseStepDataSourceRawQueryArgs']]:
        """
        Raw query configuration for advanced data source queries.
        """
        return pulumi.get(self, "raw_query")

    @raw_query.setter
    def raw_query(self, value: Optional[pulumi.Input['AlertEnrichmentSpecStepConditionalElseStepDataSourceRawQueryArgs']]):
        pulumi.set(self, "raw_query", value)

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Maximum execution time (e.g., '30s', '1m')
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "timeout", value)


if not MYPY:
    class AlertEnrichmentSpecStepConditionalElseStepDataSourceLogsQueryArgsDict(TypedDict):
        data_source_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Data source type (e.g., 'loki').
        """
        data_source_uid: NotRequired[pulumi.Input[_builtins.str]]
        """
        UID of the data source to query.
        """
        expr: NotRequired[pulumi.Input[_builtins.str]]
        """
        Log query expression to execute.
        """
        max_lines: NotRequired[pulumi.Input[_builtins.int]]
        """
        Maximum number of log lines to include. Defaults to 3.
        """
elif False:
    AlertEnrichmentSpecStepConditionalElseStepDataSourceLogsQueryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertEnrichmentSpecStepConditionalElseStepDataSourceLogsQueryArgs:
    def __init__(__self__, *,
                 data_source_type: Optional[pulumi.Input[_builtins.str]] = None,
                 data_source_uid: Optional[pulumi.Input[_builtins.str]] = None,
                 expr: Optional[pulumi.Input[_builtins.str]] = None,
                 max_lines: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] data_source_type: Data source type (e.g., 'loki').
        :param pulumi.Input[_builtins.str] data_source_uid: UID of the data source to query.
        :param pulumi.Input[_builtins.str] expr: Log query expression to execute.
        :param pulumi.Input[_builtins.int] max_lines: Maximum number of log lines to include. Defaults to 3.
        """
        if data_source_type is not None:
            pulumi.set(__self__, "data_source_type", data_source_type)
        if data_source_uid is not None:
            pulumi.set(__self__, "data_source_uid", data_source_uid)
        if expr is not None:
            pulumi.set(__self__, "expr", expr)
        if max_lines is not None:
            pulumi.set(__self__, "max_lines", max_lines)

    @_builtins.property
    @pulumi.getter(name="dataSourceType")
    def data_source_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Data source type (e.g., 'loki').
        """
        return pulumi.get(self, "data_source_type")

    @data_source_type.setter
    def data_source_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "data_source_type", value)

    @_builtins.property
    @pulumi.getter(name="dataSourceUid")
    def data_source_uid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        UID of the data source to query.
        """
        return pulumi.get(self, "data_source_uid")

    @data_source_uid.setter
    def data_source_uid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "data_source_uid", value)

    @_builtins.property
    @pulumi.getter
    def expr(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Log query expression to execute.
        """
        return pulumi.get(self, "expr")

    @expr.setter
    def expr(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "expr", value)

    @_builtins.property
    @pulumi.getter(name="maxLines")
    def max_lines(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Maximum number of log lines to include. Defaults to 3.
        """
        return pulumi.get(self, "max_lines")

    @max_lines.setter
    def max_lines(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_lines", value)


if not MYPY:
    class AlertEnrichmentSpecStepConditionalElseStepDataSourceRawQueryArgsDict(TypedDict):
        ref_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Reference ID for correlating queries.
        """
        request: NotRequired[pulumi.Input[_builtins.str]]
        """
        Raw request payload for the data source query.
        """
elif False:
    AlertEnrichmentSpecStepConditionalElseStepDataSourceRawQueryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertEnrichmentSpecStepConditionalElseStepDataSourceRawQueryArgs:
    def __init__(__self__, *,
                 ref_id: Optional[pulumi.Input[_builtins.str]] = None,
                 request: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] ref_id: Reference ID for correlating queries.
        :param pulumi.Input[_builtins.str] request: Raw request payload for the data source query.
        """
        if ref_id is not None:
            pulumi.set(__self__, "ref_id", ref_id)
        if request is not None:
            pulumi.set(__self__, "request", request)

    @_builtins.property
    @pulumi.getter(name="refId")
    def ref_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Reference ID for correlating queries.
        """
        return pulumi.get(self, "ref_id")

    @ref_id.setter
    def ref_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ref_id", value)

    @_builtins.property
    @pulumi.getter
    def request(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Raw request payload for the data source query.
        """
        return pulumi.get(self, "request")

    @request.setter
    def request(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "request", value)


if not MYPY:
    class AlertEnrichmentSpecStepConditionalElseStepExplainArgsDict(TypedDict):
        annotation: NotRequired[pulumi.Input[_builtins.str]]
        """
        Annotation name to set the explanation in. Defaults to 'ai_explanation'.
        """
        timeout: NotRequired[pulumi.Input[_builtins.str]]
        """
        Maximum execution time (e.g., '30s', '1m')
        """
elif False:
    AlertEnrichmentSpecStepConditionalElseStepExplainArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertEnrichmentSpecStepConditionalElseStepExplainArgs:
    def __init__(__self__, *,
                 annotation: Optional[pulumi.Input[_builtins.str]] = None,
                 timeout: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] annotation: Annotation name to set the explanation in. Defaults to 'ai_explanation'.
        :param pulumi.Input[_builtins.str] timeout: Maximum execution time (e.g., '30s', '1m')
        """
        if annotation is not None:
            pulumi.set(__self__, "annotation", annotation)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def annotation(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Annotation name to set the explanation in. Defaults to 'ai_explanation'.
        """
        return pulumi.get(self, "annotation")

    @annotation.setter
    def annotation(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "annotation", value)

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Maximum execution time (e.g., '30s', '1m')
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "timeout", value)


if not MYPY:
    class AlertEnrichmentSpecStepConditionalElseStepExternalArgsDict(TypedDict):
        timeout: NotRequired[pulumi.Input[_builtins.str]]
        """
        Maximum execution time (e.g., '30s', '1m')
        """
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        HTTP endpoint URL to call for enrichment
        """
elif False:
    AlertEnrichmentSpecStepConditionalElseStepExternalArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertEnrichmentSpecStepConditionalElseStepExternalArgs:
    def __init__(__self__, *,
                 timeout: Optional[pulumi.Input[_builtins.str]] = None,
                 url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] timeout: Maximum execution time (e.g., '30s', '1m')
        :param pulumi.Input[_builtins.str] url: HTTP endpoint URL to call for enrichment
        """
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Maximum execution time (e.g., '30s', '1m')
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "timeout", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        HTTP endpoint URL to call for enrichment
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class AlertEnrichmentSpecStepConditionalElseStepSiftArgsDict(TypedDict):
        timeout: NotRequired[pulumi.Input[_builtins.str]]
        """
        Maximum execution time (e.g., '30s', '1m')
        """
elif False:
    AlertEnrichmentSpecStepConditionalElseStepSiftArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertEnrichmentSpecStepConditionalElseStepSiftArgs:
    def __init__(__self__, *,
                 timeout: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] timeout: Maximum execution time (e.g., '30s', '1m')
        """
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Maximum execution time (e.g., '30s', '1m')
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "timeout", value)


if not MYPY:
    class AlertEnrichmentSpecStepConditionalIfArgsDict(TypedDict):
        annotation_matchers: NotRequired[pulumi.Input[Sequence[pulumi.Input['AlertEnrichmentSpecStepConditionalIfAnnotationMatcherArgsDict']]]]
        """
        Annotation matchers for the condition.
        """
        data_source_condition: NotRequired[pulumi.Input['AlertEnrichmentSpecStepConditionalIfDataSourceConditionArgsDict']]
        """
        Data source condition.
        """
        label_matchers: NotRequired[pulumi.Input[Sequence[pulumi.Input['AlertEnrichmentSpecStepConditionalIfLabelMatcherArgsDict']]]]
        """
        Label matchers for the condition.
        """
elif False:
    AlertEnrichmentSpecStepConditionalIfArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertEnrichmentSpecStepConditionalIfArgs:
    def __init__(__self__, *,
                 annotation_matchers: Optional[pulumi.Input[Sequence[pulumi.Input['AlertEnrichmentSpecStepConditionalIfAnnotationMatcherArgs']]]] = None,
                 data_source_condition: Optional[pulumi.Input['AlertEnrichmentSpecStepConditionalIfDataSourceConditionArgs']] = None,
                 label_matchers: Optional[pulumi.Input[Sequence[pulumi.Input['AlertEnrichmentSpecStepConditionalIfLabelMatcherArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AlertEnrichmentSpecStepConditionalIfAnnotationMatcherArgs']]] annotation_matchers: Annotation matchers for the condition.
        :param pulumi.Input['AlertEnrichmentSpecStepConditionalIfDataSourceConditionArgs'] data_source_condition: Data source condition.
        :param pulumi.Input[Sequence[pulumi.Input['AlertEnrichmentSpecStepConditionalIfLabelMatcherArgs']]] label_matchers: Label matchers for the condition.
        """
        if annotation_matchers is not None:
            pulumi.set(__self__, "annotation_matchers", annotation_matchers)
        if data_source_condition is not None:
            pulumi.set(__self__, "data_source_condition", data_source_condition)
        if label_matchers is not None:
            pulumi.set(__self__, "label_matchers", label_matchers)

    @_builtins.property
    @pulumi.getter(name="annotationMatchers")
    def annotation_matchers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AlertEnrichmentSpecStepConditionalIfAnnotationMatcherArgs']]]]:
        """
        Annotation matchers for the condition.
        """
        return pulumi.get(self, "annotation_matchers")

    @annotation_matchers.setter
    def annotation_matchers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AlertEnrichmentSpecStepConditionalIfAnnotationMatcherArgs']]]]):
        pulumi.set(self, "annotation_matchers", value)

    @_builtins.property
    @pulumi.getter(name="dataSourceCondition")
    def data_source_condition(self) -> Optional[pulumi.Input['AlertEnrichmentSpecStepConditionalIfDataSourceConditionArgs']]:
        """
        Data source condition.
        """
        return pulumi.get(self, "data_source_condition")

    @data_source_condition.setter
    def data_source_condition(self, value: Optional[pulumi.Input['AlertEnrichmentSpecStepConditionalIfDataSourceConditionArgs']]):
        pulumi.set(self, "data_source_condition", value)

    @_builtins.property
    @pulumi.getter(name="labelMatchers")
    def label_matchers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AlertEnrichmentSpecStepConditionalIfLabelMatcherArgs']]]]:
        """
        Label matchers for the condition.
        """
        return pulumi.get(self, "label_matchers")

    @label_matchers.setter
    def label_matchers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AlertEnrichmentSpecStepConditionalIfLabelMatcherArgs']]]]):
        pulumi.set(self, "label_matchers", value)


if not MYPY:
    class AlertEnrichmentSpecStepConditionalIfAnnotationMatcherArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        type: pulumi.Input[_builtins.str]
        value: pulumi.Input[_builtins.str]
elif False:
    AlertEnrichmentSpecStepConditionalIfAnnotationMatcherArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertEnrichmentSpecStepConditionalIfAnnotationMatcherArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class AlertEnrichmentSpecStepConditionalIfDataSourceConditionArgsDict(TypedDict):
        request: NotRequired[pulumi.Input[_builtins.str]]
        """
        Data source request payload.
        """
elif False:
    AlertEnrichmentSpecStepConditionalIfDataSourceConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertEnrichmentSpecStepConditionalIfDataSourceConditionArgs:
    def __init__(__self__, *,
                 request: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] request: Data source request payload.
        """
        if request is not None:
            pulumi.set(__self__, "request", request)

    @_builtins.property
    @pulumi.getter
    def request(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Data source request payload.
        """
        return pulumi.get(self, "request")

    @request.setter
    def request(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "request", value)


if not MYPY:
    class AlertEnrichmentSpecStepConditionalIfLabelMatcherArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        type: pulumi.Input[_builtins.str]
        value: pulumi.Input[_builtins.str]
elif False:
    AlertEnrichmentSpecStepConditionalIfLabelMatcherArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertEnrichmentSpecStepConditionalIfLabelMatcherArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class AlertEnrichmentSpecStepConditionalThenArgsDict(TypedDict):
        steps: NotRequired[pulumi.Input[Sequence[pulumi.Input['AlertEnrichmentSpecStepConditionalThenStepArgsDict']]]]
elif False:
    AlertEnrichmentSpecStepConditionalThenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertEnrichmentSpecStepConditionalThenArgs:
    def __init__(__self__, *,
                 steps: Optional[pulumi.Input[Sequence[pulumi.Input['AlertEnrichmentSpecStepConditionalThenStepArgs']]]] = None):
        if steps is not None:
            pulumi.set(__self__, "steps", steps)

    @_builtins.property
    @pulumi.getter
    def steps(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AlertEnrichmentSpecStepConditionalThenStepArgs']]]]:
        return pulumi.get(self, "steps")

    @steps.setter
    def steps(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AlertEnrichmentSpecStepConditionalThenStepArgs']]]]):
        pulumi.set(self, "steps", value)


if not MYPY:
    class AlertEnrichmentSpecStepConditionalThenStepArgsDict(TypedDict):
        asserts: NotRequired[pulumi.Input['AlertEnrichmentSpecStepConditionalThenStepAssertsArgsDict']]
        """
        Integrate with Grafana Asserts for enrichment.
        """
        assign: NotRequired[pulumi.Input['AlertEnrichmentSpecStepConditionalThenStepAssignArgsDict']]
        """
        Assign annotations to an alert.
        """
        assistant_investigations: NotRequired[pulumi.Input['AlertEnrichmentSpecStepConditionalThenStepAssistantInvestigationsArgsDict']]
        """
        Use AI assistant to investigate alerts and add insights.
        """
        data_source: NotRequired[pulumi.Input['AlertEnrichmentSpecStepConditionalThenStepDataSourceArgsDict']]
        """
        Query Grafana data sources and add results to alerts.
        """
        explain: NotRequired[pulumi.Input['AlertEnrichmentSpecStepConditionalThenStepExplainArgsDict']]
        """
        Generate AI explanation and store in an annotation.
        """
        external: NotRequired[pulumi.Input['AlertEnrichmentSpecStepConditionalThenStepExternalArgsDict']]
        """
        Call an external HTTP service for enrichment.
        """
        sift: NotRequired[pulumi.Input['AlertEnrichmentSpecStepConditionalThenStepSiftArgsDict']]
        """
        Analyze alerts for patterns and insights.
        """
elif False:
    AlertEnrichmentSpecStepConditionalThenStepArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertEnrichmentSpecStepConditionalThenStepArgs:
    def __init__(__self__, *,
                 asserts: Optional[pulumi.Input['AlertEnrichmentSpecStepConditionalThenStepAssertsArgs']] = None,
                 assign: Optional[pulumi.Input['AlertEnrichmentSpecStepConditionalThenStepAssignArgs']] = None,
                 assistant_investigations: Optional[pulumi.Input['AlertEnrichmentSpecStepConditionalThenStepAssistantInvestigationsArgs']] = None,
                 data_source: Optional[pulumi.Input['AlertEnrichmentSpecStepConditionalThenStepDataSourceArgs']] = None,
                 explain: Optional[pulumi.Input['AlertEnrichmentSpecStepConditionalThenStepExplainArgs']] = None,
                 external: Optional[pulumi.Input['AlertEnrichmentSpecStepConditionalThenStepExternalArgs']] = None,
                 sift: Optional[pulumi.Input['AlertEnrichmentSpecStepConditionalThenStepSiftArgs']] = None):
        """
        :param pulumi.Input['AlertEnrichmentSpecStepConditionalThenStepAssertsArgs'] asserts: Integrate with Grafana Asserts for enrichment.
        :param pulumi.Input['AlertEnrichmentSpecStepConditionalThenStepAssignArgs'] assign: Assign annotations to an alert.
        :param pulumi.Input['AlertEnrichmentSpecStepConditionalThenStepAssistantInvestigationsArgs'] assistant_investigations: Use AI assistant to investigate alerts and add insights.
        :param pulumi.Input['AlertEnrichmentSpecStepConditionalThenStepDataSourceArgs'] data_source: Query Grafana data sources and add results to alerts.
        :param pulumi.Input['AlertEnrichmentSpecStepConditionalThenStepExplainArgs'] explain: Generate AI explanation and store in an annotation.
        :param pulumi.Input['AlertEnrichmentSpecStepConditionalThenStepExternalArgs'] external: Call an external HTTP service for enrichment.
        :param pulumi.Input['AlertEnrichmentSpecStepConditionalThenStepSiftArgs'] sift: Analyze alerts for patterns and insights.
        """
        if asserts is not None:
            pulumi.set(__self__, "asserts", asserts)
        if assign is not None:
            pulumi.set(__self__, "assign", assign)
        if assistant_investigations is not None:
            pulumi.set(__self__, "assistant_investigations", assistant_investigations)
        if data_source is not None:
            pulumi.set(__self__, "data_source", data_source)
        if explain is not None:
            pulumi.set(__self__, "explain", explain)
        if external is not None:
            pulumi.set(__self__, "external", external)
        if sift is not None:
            pulumi.set(__self__, "sift", sift)

    @_builtins.property
    @pulumi.getter
    def asserts(self) -> Optional[pulumi.Input['AlertEnrichmentSpecStepConditionalThenStepAssertsArgs']]:
        """
        Integrate with Grafana Asserts for enrichment.
        """
        return pulumi.get(self, "asserts")

    @asserts.setter
    def asserts(self, value: Optional[pulumi.Input['AlertEnrichmentSpecStepConditionalThenStepAssertsArgs']]):
        pulumi.set(self, "asserts", value)

    @_builtins.property
    @pulumi.getter
    def assign(self) -> Optional[pulumi.Input['AlertEnrichmentSpecStepConditionalThenStepAssignArgs']]:
        """
        Assign annotations to an alert.
        """
        return pulumi.get(self, "assign")

    @assign.setter
    def assign(self, value: Optional[pulumi.Input['AlertEnrichmentSpecStepConditionalThenStepAssignArgs']]):
        pulumi.set(self, "assign", value)

    @_builtins.property
    @pulumi.getter(name="assistantInvestigations")
    def assistant_investigations(self) -> Optional[pulumi.Input['AlertEnrichmentSpecStepConditionalThenStepAssistantInvestigationsArgs']]:
        """
        Use AI assistant to investigate alerts and add insights.
        """
        return pulumi.get(self, "assistant_investigations")

    @assistant_investigations.setter
    def assistant_investigations(self, value: Optional[pulumi.Input['AlertEnrichmentSpecStepConditionalThenStepAssistantInvestigationsArgs']]):
        pulumi.set(self, "assistant_investigations", value)

    @_builtins.property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> Optional[pulumi.Input['AlertEnrichmentSpecStepConditionalThenStepDataSourceArgs']]:
        """
        Query Grafana data sources and add results to alerts.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: Optional[pulumi.Input['AlertEnrichmentSpecStepConditionalThenStepDataSourceArgs']]):
        pulumi.set(self, "data_source", value)

    @_builtins.property
    @pulumi.getter
    def explain(self) -> Optional[pulumi.Input['AlertEnrichmentSpecStepConditionalThenStepExplainArgs']]:
        """
        Generate AI explanation and store in an annotation.
        """
        return pulumi.get(self, "explain")

    @explain.setter
    def explain(self, value: Optional[pulumi.Input['AlertEnrichmentSpecStepConditionalThenStepExplainArgs']]):
        pulumi.set(self, "explain", value)

    @_builtins.property
    @pulumi.getter
    def external(self) -> Optional[pulumi.Input['AlertEnrichmentSpecStepConditionalThenStepExternalArgs']]:
        """
        Call an external HTTP service for enrichment.
        """
        return pulumi.get(self, "external")

    @external.setter
    def external(self, value: Optional[pulumi.Input['AlertEnrichmentSpecStepConditionalThenStepExternalArgs']]):
        pulumi.set(self, "external", value)

    @_builtins.property
    @pulumi.getter
    def sift(self) -> Optional[pulumi.Input['AlertEnrichmentSpecStepConditionalThenStepSiftArgs']]:
        """
        Analyze alerts for patterns and insights.
        """
        return pulumi.get(self, "sift")

    @sift.setter
    def sift(self, value: Optional[pulumi.Input['AlertEnrichmentSpecStepConditionalThenStepSiftArgs']]):
        pulumi.set(self, "sift", value)


if not MYPY:
    class AlertEnrichmentSpecStepConditionalThenStepAssertsArgsDict(TypedDict):
        timeout: NotRequired[pulumi.Input[_builtins.str]]
        """
        Maximum execution time (e.g., '30s', '1m')
        """
elif False:
    AlertEnrichmentSpecStepConditionalThenStepAssertsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertEnrichmentSpecStepConditionalThenStepAssertsArgs:
    def __init__(__self__, *,
                 timeout: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] timeout: Maximum execution time (e.g., '30s', '1m')
        """
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Maximum execution time (e.g., '30s', '1m')
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "timeout", value)


if not MYPY:
    class AlertEnrichmentSpecStepConditionalThenStepAssignArgsDict(TypedDict):
        annotations: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Map of annotation names to values to set on matching alerts.
        """
        timeout: NotRequired[pulumi.Input[_builtins.str]]
        """
        Maximum execution time (e.g., '30s', '1m')
        """
elif False:
    AlertEnrichmentSpecStepConditionalThenStepAssignArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertEnrichmentSpecStepConditionalThenStepAssignArgs:
    def __init__(__self__, *,
                 annotations: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 timeout: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] annotations: Map of annotation names to values to set on matching alerts.
        :param pulumi.Input[_builtins.str] timeout: Maximum execution time (e.g., '30s', '1m')
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Map of annotation names to values to set on matching alerts.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "annotations", value)

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Maximum execution time (e.g., '30s', '1m')
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "timeout", value)


if not MYPY:
    class AlertEnrichmentSpecStepConditionalThenStepAssistantInvestigationsArgsDict(TypedDict):
        timeout: NotRequired[pulumi.Input[_builtins.str]]
        """
        Maximum execution time (e.g., '30s', '1m')
        """
elif False:
    AlertEnrichmentSpecStepConditionalThenStepAssistantInvestigationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertEnrichmentSpecStepConditionalThenStepAssistantInvestigationsArgs:
    def __init__(__self__, *,
                 timeout: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] timeout: Maximum execution time (e.g., '30s', '1m')
        """
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Maximum execution time (e.g., '30s', '1m')
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "timeout", value)


if not MYPY:
    class AlertEnrichmentSpecStepConditionalThenStepDataSourceArgsDict(TypedDict):
        logs_query: NotRequired[pulumi.Input['AlertEnrichmentSpecStepConditionalThenStepDataSourceLogsQueryArgsDict']]
        """
        Logs query configuration for querying log data sources.
        """
        raw_query: NotRequired[pulumi.Input['AlertEnrichmentSpecStepConditionalThenStepDataSourceRawQueryArgsDict']]
        """
        Raw query configuration for advanced data source queries.
        """
        timeout: NotRequired[pulumi.Input[_builtins.str]]
        """
        Maximum execution time (e.g., '30s', '1m')
        """
elif False:
    AlertEnrichmentSpecStepConditionalThenStepDataSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertEnrichmentSpecStepConditionalThenStepDataSourceArgs:
    def __init__(__self__, *,
                 logs_query: Optional[pulumi.Input['AlertEnrichmentSpecStepConditionalThenStepDataSourceLogsQueryArgs']] = None,
                 raw_query: Optional[pulumi.Input['AlertEnrichmentSpecStepConditionalThenStepDataSourceRawQueryArgs']] = None,
                 timeout: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['AlertEnrichmentSpecStepConditionalThenStepDataSourceLogsQueryArgs'] logs_query: Logs query configuration for querying log data sources.
        :param pulumi.Input['AlertEnrichmentSpecStepConditionalThenStepDataSourceRawQueryArgs'] raw_query: Raw query configuration for advanced data source queries.
        :param pulumi.Input[_builtins.str] timeout: Maximum execution time (e.g., '30s', '1m')
        """
        if logs_query is not None:
            pulumi.set(__self__, "logs_query", logs_query)
        if raw_query is not None:
            pulumi.set(__self__, "raw_query", raw_query)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter(name="logsQuery")
    def logs_query(self) -> Optional[pulumi.Input['AlertEnrichmentSpecStepConditionalThenStepDataSourceLogsQueryArgs']]:
        """
        Logs query configuration for querying log data sources.
        """
        return pulumi.get(self, "logs_query")

    @logs_query.setter
    def logs_query(self, value: Optional[pulumi.Input['AlertEnrichmentSpecStepConditionalThenStepDataSourceLogsQueryArgs']]):
        pulumi.set(self, "logs_query", value)

    @_builtins.property
    @pulumi.getter(name="rawQuery")
    def raw_query(self) -> Optional[pulumi.Input['AlertEnrichmentSpecStepConditionalThenStepDataSourceRawQueryArgs']]:
        """
        Raw query configuration for advanced data source queries.
        """
        return pulumi.get(self, "raw_query")

    @raw_query.setter
    def raw_query(self, value: Optional[pulumi.Input['AlertEnrichmentSpecStepConditionalThenStepDataSourceRawQueryArgs']]):
        pulumi.set(self, "raw_query", value)

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Maximum execution time (e.g., '30s', '1m')
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "timeout", value)


if not MYPY:
    class AlertEnrichmentSpecStepConditionalThenStepDataSourceLogsQueryArgsDict(TypedDict):
        data_source_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Data source type (e.g., 'loki').
        """
        data_source_uid: NotRequired[pulumi.Input[_builtins.str]]
        """
        UID of the data source to query.
        """
        expr: NotRequired[pulumi.Input[_builtins.str]]
        """
        Log query expression to execute.
        """
        max_lines: NotRequired[pulumi.Input[_builtins.int]]
        """
        Maximum number of log lines to include. Defaults to 3.
        """
elif False:
    AlertEnrichmentSpecStepConditionalThenStepDataSourceLogsQueryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertEnrichmentSpecStepConditionalThenStepDataSourceLogsQueryArgs:
    def __init__(__self__, *,
                 data_source_type: Optional[pulumi.Input[_builtins.str]] = None,
                 data_source_uid: Optional[pulumi.Input[_builtins.str]] = None,
                 expr: Optional[pulumi.Input[_builtins.str]] = None,
                 max_lines: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] data_source_type: Data source type (e.g., 'loki').
        :param pulumi.Input[_builtins.str] data_source_uid: UID of the data source to query.
        :param pulumi.Input[_builtins.str] expr: Log query expression to execute.
        :param pulumi.Input[_builtins.int] max_lines: Maximum number of log lines to include. Defaults to 3.
        """
        if data_source_type is not None:
            pulumi.set(__self__, "data_source_type", data_source_type)
        if data_source_uid is not None:
            pulumi.set(__self__, "data_source_uid", data_source_uid)
        if expr is not None:
            pulumi.set(__self__, "expr", expr)
        if max_lines is not None:
            pulumi.set(__self__, "max_lines", max_lines)

    @_builtins.property
    @pulumi.getter(name="dataSourceType")
    def data_source_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Data source type (e.g., 'loki').
        """
        return pulumi.get(self, "data_source_type")

    @data_source_type.setter
    def data_source_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "data_source_type", value)

    @_builtins.property
    @pulumi.getter(name="dataSourceUid")
    def data_source_uid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        UID of the data source to query.
        """
        return pulumi.get(self, "data_source_uid")

    @data_source_uid.setter
    def data_source_uid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "data_source_uid", value)

    @_builtins.property
    @pulumi.getter
    def expr(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Log query expression to execute.
        """
        return pulumi.get(self, "expr")

    @expr.setter
    def expr(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "expr", value)

    @_builtins.property
    @pulumi.getter(name="maxLines")
    def max_lines(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Maximum number of log lines to include. Defaults to 3.
        """
        return pulumi.get(self, "max_lines")

    @max_lines.setter
    def max_lines(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_lines", value)


if not MYPY:
    class AlertEnrichmentSpecStepConditionalThenStepDataSourceRawQueryArgsDict(TypedDict):
        ref_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Reference ID for correlating queries.
        """
        request: NotRequired[pulumi.Input[_builtins.str]]
        """
        Raw request payload for the data source query.
        """
elif False:
    AlertEnrichmentSpecStepConditionalThenStepDataSourceRawQueryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertEnrichmentSpecStepConditionalThenStepDataSourceRawQueryArgs:
    def __init__(__self__, *,
                 ref_id: Optional[pulumi.Input[_builtins.str]] = None,
                 request: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] ref_id: Reference ID for correlating queries.
        :param pulumi.Input[_builtins.str] request: Raw request payload for the data source query.
        """
        if ref_id is not None:
            pulumi.set(__self__, "ref_id", ref_id)
        if request is not None:
            pulumi.set(__self__, "request", request)

    @_builtins.property
    @pulumi.getter(name="refId")
    def ref_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Reference ID for correlating queries.
        """
        return pulumi.get(self, "ref_id")

    @ref_id.setter
    def ref_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ref_id", value)

    @_builtins.property
    @pulumi.getter
    def request(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Raw request payload for the data source query.
        """
        return pulumi.get(self, "request")

    @request.setter
    def request(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "request", value)


if not MYPY:
    class AlertEnrichmentSpecStepConditionalThenStepExplainArgsDict(TypedDict):
        annotation: NotRequired[pulumi.Input[_builtins.str]]
        """
        Annotation name to set the explanation in. Defaults to 'ai_explanation'.
        """
        timeout: NotRequired[pulumi.Input[_builtins.str]]
        """
        Maximum execution time (e.g., '30s', '1m')
        """
elif False:
    AlertEnrichmentSpecStepConditionalThenStepExplainArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertEnrichmentSpecStepConditionalThenStepExplainArgs:
    def __init__(__self__, *,
                 annotation: Optional[pulumi.Input[_builtins.str]] = None,
                 timeout: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] annotation: Annotation name to set the explanation in. Defaults to 'ai_explanation'.
        :param pulumi.Input[_builtins.str] timeout: Maximum execution time (e.g., '30s', '1m')
        """
        if annotation is not None:
            pulumi.set(__self__, "annotation", annotation)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def annotation(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Annotation name to set the explanation in. Defaults to 'ai_explanation'.
        """
        return pulumi.get(self, "annotation")

    @annotation.setter
    def annotation(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "annotation", value)

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Maximum execution time (e.g., '30s', '1m')
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "timeout", value)


if not MYPY:
    class AlertEnrichmentSpecStepConditionalThenStepExternalArgsDict(TypedDict):
        timeout: NotRequired[pulumi.Input[_builtins.str]]
        """
        Maximum execution time (e.g., '30s', '1m')
        """
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        HTTP endpoint URL to call for enrichment
        """
elif False:
    AlertEnrichmentSpecStepConditionalThenStepExternalArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertEnrichmentSpecStepConditionalThenStepExternalArgs:
    def __init__(__self__, *,
                 timeout: Optional[pulumi.Input[_builtins.str]] = None,
                 url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] timeout: Maximum execution time (e.g., '30s', '1m')
        :param pulumi.Input[_builtins.str] url: HTTP endpoint URL to call for enrichment
        """
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Maximum execution time (e.g., '30s', '1m')
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "timeout", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        HTTP endpoint URL to call for enrichment
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class AlertEnrichmentSpecStepConditionalThenStepSiftArgsDict(TypedDict):
        timeout: NotRequired[pulumi.Input[_builtins.str]]
        """
        Maximum execution time (e.g., '30s', '1m')
        """
elif False:
    AlertEnrichmentSpecStepConditionalThenStepSiftArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertEnrichmentSpecStepConditionalThenStepSiftArgs:
    def __init__(__self__, *,
                 timeout: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] timeout: Maximum execution time (e.g., '30s', '1m')
        """
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Maximum execution time (e.g., '30s', '1m')
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "timeout", value)


if not MYPY:
    class AlertEnrichmentSpecStepDataSourceArgsDict(TypedDict):
        logs_query: NotRequired[pulumi.Input['AlertEnrichmentSpecStepDataSourceLogsQueryArgsDict']]
        """
        Logs query configuration for querying log data sources.
        """
        raw_query: NotRequired[pulumi.Input['AlertEnrichmentSpecStepDataSourceRawQueryArgsDict']]
        """
        Raw query configuration for advanced data source queries.
        """
        timeout: NotRequired[pulumi.Input[_builtins.str]]
        """
        Maximum execution time (e.g., '30s', '1m')
        """
elif False:
    AlertEnrichmentSpecStepDataSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertEnrichmentSpecStepDataSourceArgs:
    def __init__(__self__, *,
                 logs_query: Optional[pulumi.Input['AlertEnrichmentSpecStepDataSourceLogsQueryArgs']] = None,
                 raw_query: Optional[pulumi.Input['AlertEnrichmentSpecStepDataSourceRawQueryArgs']] = None,
                 timeout: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['AlertEnrichmentSpecStepDataSourceLogsQueryArgs'] logs_query: Logs query configuration for querying log data sources.
        :param pulumi.Input['AlertEnrichmentSpecStepDataSourceRawQueryArgs'] raw_query: Raw query configuration for advanced data source queries.
        :param pulumi.Input[_builtins.str] timeout: Maximum execution time (e.g., '30s', '1m')
        """
        if logs_query is not None:
            pulumi.set(__self__, "logs_query", logs_query)
        if raw_query is not None:
            pulumi.set(__self__, "raw_query", raw_query)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter(name="logsQuery")
    def logs_query(self) -> Optional[pulumi.Input['AlertEnrichmentSpecStepDataSourceLogsQueryArgs']]:
        """
        Logs query configuration for querying log data sources.
        """
        return pulumi.get(self, "logs_query")

    @logs_query.setter
    def logs_query(self, value: Optional[pulumi.Input['AlertEnrichmentSpecStepDataSourceLogsQueryArgs']]):
        pulumi.set(self, "logs_query", value)

    @_builtins.property
    @pulumi.getter(name="rawQuery")
    def raw_query(self) -> Optional[pulumi.Input['AlertEnrichmentSpecStepDataSourceRawQueryArgs']]:
        """
        Raw query configuration for advanced data source queries.
        """
        return pulumi.get(self, "raw_query")

    @raw_query.setter
    def raw_query(self, value: Optional[pulumi.Input['AlertEnrichmentSpecStepDataSourceRawQueryArgs']]):
        pulumi.set(self, "raw_query", value)

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Maximum execution time (e.g., '30s', '1m')
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "timeout", value)


if not MYPY:
    class AlertEnrichmentSpecStepDataSourceLogsQueryArgsDict(TypedDict):
        data_source_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Data source type (e.g., 'loki').
        """
        data_source_uid: NotRequired[pulumi.Input[_builtins.str]]
        """
        UID of the data source to query.
        """
        expr: NotRequired[pulumi.Input[_builtins.str]]
        """
        Log query expression to execute.
        """
        max_lines: NotRequired[pulumi.Input[_builtins.int]]
        """
        Maximum number of log lines to include. Defaults to 3.
        """
elif False:
    AlertEnrichmentSpecStepDataSourceLogsQueryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertEnrichmentSpecStepDataSourceLogsQueryArgs:
    def __init__(__self__, *,
                 data_source_type: Optional[pulumi.Input[_builtins.str]] = None,
                 data_source_uid: Optional[pulumi.Input[_builtins.str]] = None,
                 expr: Optional[pulumi.Input[_builtins.str]] = None,
                 max_lines: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] data_source_type: Data source type (e.g., 'loki').
        :param pulumi.Input[_builtins.str] data_source_uid: UID of the data source to query.
        :param pulumi.Input[_builtins.str] expr: Log query expression to execute.
        :param pulumi.Input[_builtins.int] max_lines: Maximum number of log lines to include. Defaults to 3.
        """
        if data_source_type is not None:
            pulumi.set(__self__, "data_source_type", data_source_type)
        if data_source_uid is not None:
            pulumi.set(__self__, "data_source_uid", data_source_uid)
        if expr is not None:
            pulumi.set(__self__, "expr", expr)
        if max_lines is not None:
            pulumi.set(__self__, "max_lines", max_lines)

    @_builtins.property
    @pulumi.getter(name="dataSourceType")
    def data_source_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Data source type (e.g., 'loki').
        """
        return pulumi.get(self, "data_source_type")

    @data_source_type.setter
    def data_source_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "data_source_type", value)

    @_builtins.property
    @pulumi.getter(name="dataSourceUid")
    def data_source_uid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        UID of the data source to query.
        """
        return pulumi.get(self, "data_source_uid")

    @data_source_uid.setter
    def data_source_uid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "data_source_uid", value)

    @_builtins.property
    @pulumi.getter
    def expr(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Log query expression to execute.
        """
        return pulumi.get(self, "expr")

    @expr.setter
    def expr(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "expr", value)

    @_builtins.property
    @pulumi.getter(name="maxLines")
    def max_lines(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Maximum number of log lines to include. Defaults to 3.
        """
        return pulumi.get(self, "max_lines")

    @max_lines.setter
    def max_lines(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_lines", value)


if not MYPY:
    class AlertEnrichmentSpecStepDataSourceRawQueryArgsDict(TypedDict):
        ref_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Reference ID for correlating queries.
        """
        request: NotRequired[pulumi.Input[_builtins.str]]
        """
        Raw request payload for the data source query.
        """
elif False:
    AlertEnrichmentSpecStepDataSourceRawQueryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertEnrichmentSpecStepDataSourceRawQueryArgs:
    def __init__(__self__, *,
                 ref_id: Optional[pulumi.Input[_builtins.str]] = None,
                 request: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] ref_id: Reference ID for correlating queries.
        :param pulumi.Input[_builtins.str] request: Raw request payload for the data source query.
        """
        if ref_id is not None:
            pulumi.set(__self__, "ref_id", ref_id)
        if request is not None:
            pulumi.set(__self__, "request", request)

    @_builtins.property
    @pulumi.getter(name="refId")
    def ref_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Reference ID for correlating queries.
        """
        return pulumi.get(self, "ref_id")

    @ref_id.setter
    def ref_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ref_id", value)

    @_builtins.property
    @pulumi.getter
    def request(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Raw request payload for the data source query.
        """
        return pulumi.get(self, "request")

    @request.setter
    def request(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "request", value)


if not MYPY:
    class AlertEnrichmentSpecStepExplainArgsDict(TypedDict):
        annotation: NotRequired[pulumi.Input[_builtins.str]]
        """
        Annotation name to set the explanation in. Defaults to 'ai_explanation'.
        """
        timeout: NotRequired[pulumi.Input[_builtins.str]]
        """
        Maximum execution time (e.g., '30s', '1m')
        """
elif False:
    AlertEnrichmentSpecStepExplainArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertEnrichmentSpecStepExplainArgs:
    def __init__(__self__, *,
                 annotation: Optional[pulumi.Input[_builtins.str]] = None,
                 timeout: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] annotation: Annotation name to set the explanation in. Defaults to 'ai_explanation'.
        :param pulumi.Input[_builtins.str] timeout: Maximum execution time (e.g., '30s', '1m')
        """
        if annotation is not None:
            pulumi.set(__self__, "annotation", annotation)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def annotation(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Annotation name to set the explanation in. Defaults to 'ai_explanation'.
        """
        return pulumi.get(self, "annotation")

    @annotation.setter
    def annotation(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "annotation", value)

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Maximum execution time (e.g., '30s', '1m')
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "timeout", value)


if not MYPY:
    class AlertEnrichmentSpecStepExternalArgsDict(TypedDict):
        timeout: NotRequired[pulumi.Input[_builtins.str]]
        """
        Maximum execution time (e.g., '30s', '1m')
        """
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        HTTP endpoint URL to call for enrichment
        """
elif False:
    AlertEnrichmentSpecStepExternalArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertEnrichmentSpecStepExternalArgs:
    def __init__(__self__, *,
                 timeout: Optional[pulumi.Input[_builtins.str]] = None,
                 url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] timeout: Maximum execution time (e.g., '30s', '1m')
        :param pulumi.Input[_builtins.str] url: HTTP endpoint URL to call for enrichment
        """
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Maximum execution time (e.g., '30s', '1m')
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "timeout", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        HTTP endpoint URL to call for enrichment
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class AlertEnrichmentSpecStepSiftArgsDict(TypedDict):
        timeout: NotRequired[pulumi.Input[_builtins.str]]
        """
        Maximum execution time (e.g., '30s', '1m')
        """
elif False:
    AlertEnrichmentSpecStepSiftArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertEnrichmentSpecStepSiftArgs:
    def __init__(__self__, *,
                 timeout: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] timeout: Maximum execution time (e.g., '30s', '1m')
        """
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Maximum execution time (e.g., '30s', '1m')
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "timeout", value)


if not MYPY:
    class AlertRuleV0Alpha1MetadataArgsDict(TypedDict):
        uid: pulumi.Input[_builtins.str]
        """
        The unique identifier of the resource.
        """
        annotations: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Annotations of the resource.
        """
        folder_uid: NotRequired[pulumi.Input[_builtins.str]]
        """
        The UID of the folder to save the resource in.
        """
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        The full URL of the resource.
        """
        uuid: NotRequired[pulumi.Input[_builtins.str]]
        """
        The globally unique identifier of a resource, used by the API for tracking.
        """
        version: NotRequired[pulumi.Input[_builtins.str]]
        """
        The version of the resource.
        """
elif False:
    AlertRuleV0Alpha1MetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertRuleV0Alpha1MetadataArgs:
    def __init__(__self__, *,
                 uid: pulumi.Input[_builtins.str],
                 annotations: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 folder_uid: Optional[pulumi.Input[_builtins.str]] = None,
                 url: Optional[pulumi.Input[_builtins.str]] = None,
                 uuid: Optional[pulumi.Input[_builtins.str]] = None,
                 version: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] uid: The unique identifier of the resource.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] annotations: Annotations of the resource.
        :param pulumi.Input[_builtins.str] folder_uid: The UID of the folder to save the resource in.
        :param pulumi.Input[_builtins.str] url: The full URL of the resource.
        :param pulumi.Input[_builtins.str] uuid: The globally unique identifier of a resource, used by the API for tracking.
        :param pulumi.Input[_builtins.str] version: The version of the resource.
        """
        pulumi.set(__self__, "uid", uid)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if folder_uid is not None:
            pulumi.set(__self__, "folder_uid", folder_uid)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def uid(self) -> pulumi.Input[_builtins.str]:
        """
        The unique identifier of the resource.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "uid", value)

    @_builtins.property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Annotations of the resource.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "annotations", value)

    @_builtins.property
    @pulumi.getter(name="folderUid")
    def folder_uid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The UID of the folder to save the resource in.
        """
        return pulumi.get(self, "folder_uid")

    @folder_uid.setter
    def folder_uid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "folder_uid", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The full URL of the resource.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The globally unique identifier of a resource, used by the API for tracking.
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uuid", value)

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The version of the resource.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class AlertRuleV0Alpha1OptionsArgsDict(TypedDict):
        overwrite: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Set to true if you want to overwrite existing resource with newer version, same resource title in folder or same resource uid.
        """
elif False:
    AlertRuleV0Alpha1OptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertRuleV0Alpha1OptionsArgs:
    def __init__(__self__, *,
                 overwrite: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] overwrite: Set to true if you want to overwrite existing resource with newer version, same resource title in folder or same resource uid.
        """
        if overwrite is not None:
            pulumi.set(__self__, "overwrite", overwrite)

    @_builtins.property
    @pulumi.getter
    def overwrite(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Set to true if you want to overwrite existing resource with newer version, same resource title in folder or same resource uid.
        """
        return pulumi.get(self, "overwrite")

    @overwrite.setter
    def overwrite(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "overwrite", value)


if not MYPY:
    class AlertRuleV0Alpha1SpecArgsDict(TypedDict):
        exec_err_state: pulumi.Input[_builtins.str]
        """
        Describes what state to enter when the rule's query is invalid and the rule cannot be executed. Options are OK, Error, KeepLast, and Alerting.
        """
        expressions: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]
        """
        A sequence of stages that describe the contents of the rule. Each value is a JSON string representing an expression object.
        """
        no_data_state: pulumi.Input[_builtins.str]
        """
        Describes what state to enter when the rule's query returns No Data. Options are OK, NoData, KeepLast, and Alerting.
        """
        title: pulumi.Input[_builtins.str]
        """
        The title of the alert rule.
        """
        annotations: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Key-value pairs of metadata to attach to the alert rule. They add additional information, such as a `summary` or `runbook_url`, to help identify and investigate alerts.
        """
        for_: NotRequired[pulumi.Input[_builtins.str]]
        """
        The amount of time for which the rule must be breached for the rule to be considered to be Firing. Before this time has elapsed, the rule is only considered to be Pending.
        """
        keep_firing_for: NotRequired[pulumi.Input[_builtins.str]]
        """
        The amount of time for which the rule will considered to be Recovering after initially Firing. Before this time has elapsed, the rule will continue to fire once it's been triggered.
        """
        labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Key-value pairs to attach to the alert rule that can be used in matching, grouping, and routing.
        """
        missing_series_evals_to_resolve: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of missing series evaluations that must occur before the rule is considered to be resolved.
        """
        notification_settings: NotRequired[pulumi.Input['AlertRuleV0Alpha1SpecNotificationSettingsArgsDict']]
        """
        Notification settings for the rule. If specified, it overrides the notification policies.
        """
        panel_ref: NotRequired[Any]
        """
        Reference to a panel that this alert rule is associated with. Should be an object with 'dashboard*uid' (string) and 'panel*id' (number) fields.
        """
        paused: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Sets whether the rule should be paused or not.
        """
        trigger: NotRequired[pulumi.Input['AlertRuleV0Alpha1SpecTriggerArgsDict']]
        """
        The trigger configuration for the alert rule.
        """
elif False:
    AlertRuleV0Alpha1SpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertRuleV0Alpha1SpecArgs:
    def __init__(__self__, *,
                 exec_err_state: pulumi.Input[_builtins.str],
                 expressions: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]],
                 no_data_state: pulumi.Input[_builtins.str],
                 title: pulumi.Input[_builtins.str],
                 annotations: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 for_: Optional[pulumi.Input[_builtins.str]] = None,
                 keep_firing_for: Optional[pulumi.Input[_builtins.str]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 missing_series_evals_to_resolve: Optional[pulumi.Input[_builtins.int]] = None,
                 notification_settings: Optional[pulumi.Input['AlertRuleV0Alpha1SpecNotificationSettingsArgs']] = None,
                 panel_ref: Optional[Any] = None,
                 paused: Optional[pulumi.Input[_builtins.bool]] = None,
                 trigger: Optional[pulumi.Input['AlertRuleV0Alpha1SpecTriggerArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] exec_err_state: Describes what state to enter when the rule's query is invalid and the rule cannot be executed. Options are OK, Error, KeepLast, and Alerting.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] expressions: A sequence of stages that describe the contents of the rule. Each value is a JSON string representing an expression object.
        :param pulumi.Input[_builtins.str] no_data_state: Describes what state to enter when the rule's query returns No Data. Options are OK, NoData, KeepLast, and Alerting.
        :param pulumi.Input[_builtins.str] title: The title of the alert rule.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] annotations: Key-value pairs of metadata to attach to the alert rule. They add additional information, such as a `summary` or `runbook_url`, to help identify and investigate alerts.
        :param pulumi.Input[_builtins.str] for_: The amount of time for which the rule must be breached for the rule to be considered to be Firing. Before this time has elapsed, the rule is only considered to be Pending.
        :param pulumi.Input[_builtins.str] keep_firing_for: The amount of time for which the rule will considered to be Recovering after initially Firing. Before this time has elapsed, the rule will continue to fire once it's been triggered.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] labels: Key-value pairs to attach to the alert rule that can be used in matching, grouping, and routing.
        :param pulumi.Input[_builtins.int] missing_series_evals_to_resolve: The number of missing series evaluations that must occur before the rule is considered to be resolved.
        :param pulumi.Input['AlertRuleV0Alpha1SpecNotificationSettingsArgs'] notification_settings: Notification settings for the rule. If specified, it overrides the notification policies.
        :param Any panel_ref: Reference to a panel that this alert rule is associated with. Should be an object with 'dashboard*uid' (string) and 'panel*id' (number) fields.
        :param pulumi.Input[_builtins.bool] paused: Sets whether the rule should be paused or not.
        :param pulumi.Input['AlertRuleV0Alpha1SpecTriggerArgs'] trigger: The trigger configuration for the alert rule.
        """
        pulumi.set(__self__, "exec_err_state", exec_err_state)
        pulumi.set(__self__, "expressions", expressions)
        pulumi.set(__self__, "no_data_state", no_data_state)
        pulumi.set(__self__, "title", title)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if for_ is not None:
            pulumi.set(__self__, "for_", for_)
        if keep_firing_for is not None:
            pulumi.set(__self__, "keep_firing_for", keep_firing_for)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if missing_series_evals_to_resolve is not None:
            pulumi.set(__self__, "missing_series_evals_to_resolve", missing_series_evals_to_resolve)
        if notification_settings is not None:
            pulumi.set(__self__, "notification_settings", notification_settings)
        if panel_ref is not None:
            pulumi.set(__self__, "panel_ref", panel_ref)
        if paused is not None:
            pulumi.set(__self__, "paused", paused)
        if trigger is not None:
            pulumi.set(__self__, "trigger", trigger)

    @_builtins.property
    @pulumi.getter(name="execErrState")
    def exec_err_state(self) -> pulumi.Input[_builtins.str]:
        """
        Describes what state to enter when the rule's query is invalid and the rule cannot be executed. Options are OK, Error, KeepLast, and Alerting.
        """
        return pulumi.get(self, "exec_err_state")

    @exec_err_state.setter
    def exec_err_state(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "exec_err_state", value)

    @_builtins.property
    @pulumi.getter
    def expressions(self) -> pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]:
        """
        A sequence of stages that describe the contents of the rule. Each value is a JSON string representing an expression object.
        """
        return pulumi.get(self, "expressions")

    @expressions.setter
    def expressions(self, value: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "expressions", value)

    @_builtins.property
    @pulumi.getter(name="noDataState")
    def no_data_state(self) -> pulumi.Input[_builtins.str]:
        """
        Describes what state to enter when the rule's query returns No Data. Options are OK, NoData, KeepLast, and Alerting.
        """
        return pulumi.get(self, "no_data_state")

    @no_data_state.setter
    def no_data_state(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "no_data_state", value)

    @_builtins.property
    @pulumi.getter
    def title(self) -> pulumi.Input[_builtins.str]:
        """
        The title of the alert rule.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "title", value)

    @_builtins.property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Key-value pairs of metadata to attach to the alert rule. They add additional information, such as a `summary` or `runbook_url`, to help identify and investigate alerts.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "annotations", value)

    @_builtins.property
    @pulumi.getter(name="for")
    def for_(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The amount of time for which the rule must be breached for the rule to be considered to be Firing. Before this time has elapsed, the rule is only considered to be Pending.
        """
        return pulumi.get(self, "for_")

    @for_.setter
    def for_(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "for_", value)

    @_builtins.property
    @pulumi.getter(name="keepFiringFor")
    def keep_firing_for(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The amount of time for which the rule will considered to be Recovering after initially Firing. Before this time has elapsed, the rule will continue to fire once it's been triggered.
        """
        return pulumi.get(self, "keep_firing_for")

    @keep_firing_for.setter
    def keep_firing_for(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "keep_firing_for", value)

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Key-value pairs to attach to the alert rule that can be used in matching, grouping, and routing.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "labels", value)

    @_builtins.property
    @pulumi.getter(name="missingSeriesEvalsToResolve")
    def missing_series_evals_to_resolve(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of missing series evaluations that must occur before the rule is considered to be resolved.
        """
        return pulumi.get(self, "missing_series_evals_to_resolve")

    @missing_series_evals_to_resolve.setter
    def missing_series_evals_to_resolve(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "missing_series_evals_to_resolve", value)

    @_builtins.property
    @pulumi.getter(name="notificationSettings")
    def notification_settings(self) -> Optional[pulumi.Input['AlertRuleV0Alpha1SpecNotificationSettingsArgs']]:
        """
        Notification settings for the rule. If specified, it overrides the notification policies.
        """
        return pulumi.get(self, "notification_settings")

    @notification_settings.setter
    def notification_settings(self, value: Optional[pulumi.Input['AlertRuleV0Alpha1SpecNotificationSettingsArgs']]):
        pulumi.set(self, "notification_settings", value)

    @_builtins.property
    @pulumi.getter(name="panelRef")
    def panel_ref(self) -> Optional[Any]:
        """
        Reference to a panel that this alert rule is associated with. Should be an object with 'dashboard*uid' (string) and 'panel*id' (number) fields.
        """
        return pulumi.get(self, "panel_ref")

    @panel_ref.setter
    def panel_ref(self, value: Optional[Any]):
        pulumi.set(self, "panel_ref", value)

    @_builtins.property
    @pulumi.getter
    def paused(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Sets whether the rule should be paused or not.
        """
        return pulumi.get(self, "paused")

    @paused.setter
    def paused(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "paused", value)

    @_builtins.property
    @pulumi.getter
    def trigger(self) -> Optional[pulumi.Input['AlertRuleV0Alpha1SpecTriggerArgs']]:
        """
        The trigger configuration for the alert rule.
        """
        return pulumi.get(self, "trigger")

    @trigger.setter
    def trigger(self, value: Optional[pulumi.Input['AlertRuleV0Alpha1SpecTriggerArgs']]):
        pulumi.set(self, "trigger", value)


if not MYPY:
    class AlertRuleV0Alpha1SpecNotificationSettingsArgsDict(TypedDict):
        contact_point: pulumi.Input[_builtins.str]
        """
        The contact point to route notifications that match this rule to.
        """
        active_timings: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of time interval names to apply to alerts that match this policy to suppress them unless they are sent at the specified time.
        """
        group_bies: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of alert labels to group alerts into notifications by.
        """
        group_interval: NotRequired[pulumi.Input[_builtins.str]]
        """
        Minimum time interval between two notifications for the same group.
        """
        group_wait: NotRequired[pulumi.Input[_builtins.str]]
        """
        Time to wait to buffer alerts of the same group before sending a notification.
        """
        mute_timings: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of mute timing names to apply to alerts that match this policy.
        """
        repeat_interval: NotRequired[pulumi.Input[_builtins.str]]
        """
        Minimum time interval for re-sending a notification if an alert is still firing.
        """
elif False:
    AlertRuleV0Alpha1SpecNotificationSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertRuleV0Alpha1SpecNotificationSettingsArgs:
    def __init__(__self__, *,
                 contact_point: pulumi.Input[_builtins.str],
                 active_timings: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 group_interval: Optional[pulumi.Input[_builtins.str]] = None,
                 group_wait: Optional[pulumi.Input[_builtins.str]] = None,
                 mute_timings: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 repeat_interval: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] contact_point: The contact point to route notifications that match this rule to.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] active_timings: A list of time interval names to apply to alerts that match this policy to suppress them unless they are sent at the specified time.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] group_bies: A list of alert labels to group alerts into notifications by.
        :param pulumi.Input[_builtins.str] group_interval: Minimum time interval between two notifications for the same group.
        :param pulumi.Input[_builtins.str] group_wait: Time to wait to buffer alerts of the same group before sending a notification.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] mute_timings: A list of mute timing names to apply to alerts that match this policy.
        :param pulumi.Input[_builtins.str] repeat_interval: Minimum time interval for re-sending a notification if an alert is still firing.
        """
        pulumi.set(__self__, "contact_point", contact_point)
        if active_timings is not None:
            pulumi.set(__self__, "active_timings", active_timings)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if group_interval is not None:
            pulumi.set(__self__, "group_interval", group_interval)
        if group_wait is not None:
            pulumi.set(__self__, "group_wait", group_wait)
        if mute_timings is not None:
            pulumi.set(__self__, "mute_timings", mute_timings)
        if repeat_interval is not None:
            pulumi.set(__self__, "repeat_interval", repeat_interval)

    @_builtins.property
    @pulumi.getter(name="contactPoint")
    def contact_point(self) -> pulumi.Input[_builtins.str]:
        """
        The contact point to route notifications that match this rule to.
        """
        return pulumi.get(self, "contact_point")

    @contact_point.setter
    def contact_point(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "contact_point", value)

    @_builtins.property
    @pulumi.getter(name="activeTimings")
    def active_timings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of time interval names to apply to alerts that match this policy to suppress them unless they are sent at the specified time.
        """
        return pulumi.get(self, "active_timings")

    @active_timings.setter
    def active_timings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "active_timings", value)

    @_builtins.property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of alert labels to group alerts into notifications by.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "group_bies", value)

    @_builtins.property
    @pulumi.getter(name="groupInterval")
    def group_interval(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Minimum time interval between two notifications for the same group.
        """
        return pulumi.get(self, "group_interval")

    @group_interval.setter
    def group_interval(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "group_interval", value)

    @_builtins.property
    @pulumi.getter(name="groupWait")
    def group_wait(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Time to wait to buffer alerts of the same group before sending a notification.
        """
        return pulumi.get(self, "group_wait")

    @group_wait.setter
    def group_wait(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "group_wait", value)

    @_builtins.property
    @pulumi.getter(name="muteTimings")
    def mute_timings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of mute timing names to apply to alerts that match this policy.
        """
        return pulumi.get(self, "mute_timings")

    @mute_timings.setter
    def mute_timings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "mute_timings", value)

    @_builtins.property
    @pulumi.getter(name="repeatInterval")
    def repeat_interval(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Minimum time interval for re-sending a notification if an alert is still firing.
        """
        return pulumi.get(self, "repeat_interval")

    @repeat_interval.setter
    def repeat_interval(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "repeat_interval", value)


if not MYPY:
    class AlertRuleV0Alpha1SpecTriggerArgsDict(TypedDict):
        interval: pulumi.Input[_builtins.str]
        """
        The interval at which the alert rule should be evaluated.
        """
elif False:
    AlertRuleV0Alpha1SpecTriggerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertRuleV0Alpha1SpecTriggerArgs:
    def __init__(__self__, *,
                 interval: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] interval: The interval at which the alert rule should be evaluated.
        """
        pulumi.set(__self__, "interval", interval)

    @_builtins.property
    @pulumi.getter
    def interval(self) -> pulumi.Input[_builtins.str]:
        """
        The interval at which the alert rule should be evaluated.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "interval", value)


if not MYPY:
    class ContactPointAlertmanagerArgsDict(TypedDict):
        url: pulumi.Input[_builtins.str]
        """
        The URL of the Alertmanager instance.
        """
        basic_auth_password: NotRequired[pulumi.Input[_builtins.str]]
        """
        The password component of the basic auth credentials to use.
        """
        basic_auth_user: NotRequired[pulumi.Input[_builtins.str]]
        """
        The username component of the basic auth credentials to use.
        """
        disable_resolve_message: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        settings: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        uid: NotRequired[pulumi.Input[_builtins.str]]
        """
        The UID of the contact point.
        """
elif False:
    ContactPointAlertmanagerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContactPointAlertmanagerArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[_builtins.str],
                 basic_auth_password: Optional[pulumi.Input[_builtins.str]] = None,
                 basic_auth_user: Optional[pulumi.Input[_builtins.str]] = None,
                 disable_resolve_message: Optional[pulumi.Input[_builtins.bool]] = None,
                 settings: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 uid: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] url: The URL of the Alertmanager instance.
        :param pulumi.Input[_builtins.str] basic_auth_password: The password component of the basic auth credentials to use.
        :param pulumi.Input[_builtins.str] basic_auth_user: The username component of the basic auth credentials to use.
        :param pulumi.Input[_builtins.bool] disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param pulumi.Input[_builtins.str] uid: The UID of the contact point.
        """
        pulumi.set(__self__, "url", url)
        if basic_auth_password is not None:
            pulumi.set(__self__, "basic_auth_password", basic_auth_password)
        if basic_auth_user is not None:
            pulumi.set(__self__, "basic_auth_user", basic_auth_user)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        The URL of the Alertmanager instance.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="basicAuthPassword")
    def basic_auth_password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The password component of the basic auth credentials to use.
        """
        return pulumi.get(self, "basic_auth_password")

    @basic_auth_password.setter
    def basic_auth_password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "basic_auth_password", value)

    @_builtins.property
    @pulumi.getter(name="basicAuthUser")
    def basic_auth_user(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The username component of the basic auth credentials to use.
        """
        return pulumi.get(self, "basic_auth_user")

    @basic_auth_user.setter
    def basic_auth_user(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "basic_auth_user", value)

    @_builtins.property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @disable_resolve_message.setter
    def disable_resolve_message(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disable_resolve_message", value)

    @_builtins.property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "settings", value)

    @_builtins.property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uid", value)


if not MYPY:
    class ContactPointDingdingArgsDict(TypedDict):
        url: pulumi.Input[_builtins.str]
        """
        The DingDing webhook URL.
        """
        disable_resolve_message: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        message: NotRequired[pulumi.Input[_builtins.str]]
        """
        The templated content of the message.
        """
        message_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The format of message to send - either 'link' or 'actionCard'
        """
        settings: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        title: NotRequired[pulumi.Input[_builtins.str]]
        """
        The templated title of the message.
        """
        uid: NotRequired[pulumi.Input[_builtins.str]]
        """
        The UID of the contact point.
        """
elif False:
    ContactPointDingdingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContactPointDingdingArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[_builtins.str],
                 disable_resolve_message: Optional[pulumi.Input[_builtins.bool]] = None,
                 message: Optional[pulumi.Input[_builtins.str]] = None,
                 message_type: Optional[pulumi.Input[_builtins.str]] = None,
                 settings: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 title: Optional[pulumi.Input[_builtins.str]] = None,
                 uid: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] url: The DingDing webhook URL.
        :param pulumi.Input[_builtins.bool] disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param pulumi.Input[_builtins.str] message: The templated content of the message.
        :param pulumi.Input[_builtins.str] message_type: The format of message to send - either 'link' or 'actionCard'
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param pulumi.Input[_builtins.str] title: The templated title of the message.
        :param pulumi.Input[_builtins.str] uid: The UID of the contact point.
        """
        pulumi.set(__self__, "url", url)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if message_type is not None:
            pulumi.set(__self__, "message_type", message_type)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        The DingDing webhook URL.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @disable_resolve_message.setter
    def disable_resolve_message(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disable_resolve_message", value)

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The templated content of the message.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message", value)

    @_builtins.property
    @pulumi.getter(name="messageType")
    def message_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The format of message to send - either 'link' or 'actionCard'
        """
        return pulumi.get(self, "message_type")

    @message_type.setter
    def message_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message_type", value)

    @_builtins.property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "settings", value)

    @_builtins.property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The templated title of the message.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "title", value)

    @_builtins.property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uid", value)


if not MYPY:
    class ContactPointDiscordArgsDict(TypedDict):
        url: pulumi.Input[_builtins.str]
        """
        The discord webhook URL.
        """
        avatar_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL of a custom avatar image to use. Defaults to ``.
        """
        disable_resolve_message: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        message: NotRequired[pulumi.Input[_builtins.str]]
        """
        The templated content of the message. Defaults to ``.
        """
        settings: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        title: NotRequired[pulumi.Input[_builtins.str]]
        """
        The templated content of the title.
        """
        uid: NotRequired[pulumi.Input[_builtins.str]]
        """
        The UID of the contact point.
        """
        use_discord_username: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to use the bot account's plain username instead of "Grafana." Defaults to `false`.
        """
elif False:
    ContactPointDiscordArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContactPointDiscordArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[_builtins.str],
                 avatar_url: Optional[pulumi.Input[_builtins.str]] = None,
                 disable_resolve_message: Optional[pulumi.Input[_builtins.bool]] = None,
                 message: Optional[pulumi.Input[_builtins.str]] = None,
                 settings: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 title: Optional[pulumi.Input[_builtins.str]] = None,
                 uid: Optional[pulumi.Input[_builtins.str]] = None,
                 use_discord_username: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] url: The discord webhook URL.
        :param pulumi.Input[_builtins.str] avatar_url: The URL of a custom avatar image to use. Defaults to ``.
        :param pulumi.Input[_builtins.bool] disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param pulumi.Input[_builtins.str] message: The templated content of the message. Defaults to ``.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param pulumi.Input[_builtins.str] title: The templated content of the title.
        :param pulumi.Input[_builtins.str] uid: The UID of the contact point.
        :param pulumi.Input[_builtins.bool] use_discord_username: Whether to use the bot account's plain username instead of "Grafana." Defaults to `false`.
        """
        pulumi.set(__self__, "url", url)
        if avatar_url is not None:
            pulumi.set(__self__, "avatar_url", avatar_url)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)
        if use_discord_username is not None:
            pulumi.set(__self__, "use_discord_username", use_discord_username)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        The discord webhook URL.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="avatarUrl")
    def avatar_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL of a custom avatar image to use. Defaults to ``.
        """
        return pulumi.get(self, "avatar_url")

    @avatar_url.setter
    def avatar_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "avatar_url", value)

    @_builtins.property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @disable_resolve_message.setter
    def disable_resolve_message(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disable_resolve_message", value)

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The templated content of the message. Defaults to ``.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message", value)

    @_builtins.property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "settings", value)

    @_builtins.property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The templated content of the title.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "title", value)

    @_builtins.property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uid", value)

    @_builtins.property
    @pulumi.getter(name="useDiscordUsername")
    def use_discord_username(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to use the bot account's plain username instead of "Grafana." Defaults to `false`.
        """
        return pulumi.get(self, "use_discord_username")

    @use_discord_username.setter
    def use_discord_username(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_discord_username", value)


if not MYPY:
    class ContactPointEmailArgsDict(TypedDict):
        addresses: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        The addresses to send emails to.
        """
        disable_resolve_message: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        message: NotRequired[pulumi.Input[_builtins.str]]
        """
        The templated content of the email. Defaults to ``.
        """
        settings: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        single_email: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to send a single email CC'ing all addresses, rather than a separate email to each address. Defaults to `false`.
        """
        subject: NotRequired[pulumi.Input[_builtins.str]]
        """
        The templated subject line of the email. Defaults to ``.
        """
        uid: NotRequired[pulumi.Input[_builtins.str]]
        """
        The UID of the contact point.
        """
elif False:
    ContactPointEmailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContactPointEmailArgs:
    def __init__(__self__, *,
                 addresses: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 disable_resolve_message: Optional[pulumi.Input[_builtins.bool]] = None,
                 message: Optional[pulumi.Input[_builtins.str]] = None,
                 settings: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 single_email: Optional[pulumi.Input[_builtins.bool]] = None,
                 subject: Optional[pulumi.Input[_builtins.str]] = None,
                 uid: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] addresses: The addresses to send emails to.
        :param pulumi.Input[_builtins.bool] disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param pulumi.Input[_builtins.str] message: The templated content of the email. Defaults to ``.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param pulumi.Input[_builtins.bool] single_email: Whether to send a single email CC'ing all addresses, rather than a separate email to each address. Defaults to `false`.
        :param pulumi.Input[_builtins.str] subject: The templated subject line of the email. Defaults to ``.
        :param pulumi.Input[_builtins.str] uid: The UID of the contact point.
        """
        pulumi.set(__self__, "addresses", addresses)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if single_email is not None:
            pulumi.set(__self__, "single_email", single_email)
        if subject is not None:
            pulumi.set(__self__, "subject", subject)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @_builtins.property
    @pulumi.getter
    def addresses(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        The addresses to send emails to.
        """
        return pulumi.get(self, "addresses")

    @addresses.setter
    def addresses(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "addresses", value)

    @_builtins.property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @disable_resolve_message.setter
    def disable_resolve_message(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disable_resolve_message", value)

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The templated content of the email. Defaults to ``.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message", value)

    @_builtins.property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "settings", value)

    @_builtins.property
    @pulumi.getter(name="singleEmail")
    def single_email(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to send a single email CC'ing all addresses, rather than a separate email to each address. Defaults to `false`.
        """
        return pulumi.get(self, "single_email")

    @single_email.setter
    def single_email(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "single_email", value)

    @_builtins.property
    @pulumi.getter
    def subject(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The templated subject line of the email. Defaults to ``.
        """
        return pulumi.get(self, "subject")

    @subject.setter
    def subject(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subject", value)

    @_builtins.property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uid", value)


if not MYPY:
    class ContactPointGooglechatArgsDict(TypedDict):
        url: pulumi.Input[_builtins.str]
        """
        The Google Chat webhook URL.
        """
        disable_resolve_message: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        message: NotRequired[pulumi.Input[_builtins.str]]
        """
        The templated content of the message.
        """
        settings: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        title: NotRequired[pulumi.Input[_builtins.str]]
        """
        The templated content of the title.
        """
        uid: NotRequired[pulumi.Input[_builtins.str]]
        """
        The UID of the contact point.
        """
elif False:
    ContactPointGooglechatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContactPointGooglechatArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[_builtins.str],
                 disable_resolve_message: Optional[pulumi.Input[_builtins.bool]] = None,
                 message: Optional[pulumi.Input[_builtins.str]] = None,
                 settings: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 title: Optional[pulumi.Input[_builtins.str]] = None,
                 uid: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] url: The Google Chat webhook URL.
        :param pulumi.Input[_builtins.bool] disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param pulumi.Input[_builtins.str] message: The templated content of the message.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param pulumi.Input[_builtins.str] title: The templated content of the title.
        :param pulumi.Input[_builtins.str] uid: The UID of the contact point.
        """
        pulumi.set(__self__, "url", url)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        The Google Chat webhook URL.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @disable_resolve_message.setter
    def disable_resolve_message(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disable_resolve_message", value)

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The templated content of the message.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message", value)

    @_builtins.property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "settings", value)

    @_builtins.property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The templated content of the title.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "title", value)

    @_builtins.property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uid", value)


if not MYPY:
    class ContactPointKafkaArgsDict(TypedDict):
        rest_proxy_url: pulumi.Input[_builtins.str]
        """
        The URL of the Kafka REST proxy to send requests to.
        """
        topic: pulumi.Input[_builtins.str]
        """
        The name of the Kafka topic to publish to.
        """
        api_version: NotRequired[pulumi.Input[_builtins.str]]
        """
        The API version to use when contacting the Kafka REST Server. Supported: v2 (default) and v3. Defaults to `v2`.
        """
        cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Id of cluster to use when contacting the Kafka REST Server. Required api_version to be 'v3'
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        The templated description of the Kafka message.
        """
        details: NotRequired[pulumi.Input[_builtins.str]]
        """
        The templated details to include with the message.
        """
        disable_resolve_message: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        The password to use when making a call to the Kafka REST Proxy
        """
        settings: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        uid: NotRequired[pulumi.Input[_builtins.str]]
        """
        The UID of the contact point.
        """
        username: NotRequired[pulumi.Input[_builtins.str]]
        """
        The user name to use when making a call to the Kafka REST Proxy
        """
elif False:
    ContactPointKafkaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContactPointKafkaArgs:
    def __init__(__self__, *,
                 rest_proxy_url: pulumi.Input[_builtins.str],
                 topic: pulumi.Input[_builtins.str],
                 api_version: Optional[pulumi.Input[_builtins.str]] = None,
                 cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 details: Optional[pulumi.Input[_builtins.str]] = None,
                 disable_resolve_message: Optional[pulumi.Input[_builtins.bool]] = None,
                 password: Optional[pulumi.Input[_builtins.str]] = None,
                 settings: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 uid: Optional[pulumi.Input[_builtins.str]] = None,
                 username: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] rest_proxy_url: The URL of the Kafka REST proxy to send requests to.
        :param pulumi.Input[_builtins.str] topic: The name of the Kafka topic to publish to.
        :param pulumi.Input[_builtins.str] api_version: The API version to use when contacting the Kafka REST Server. Supported: v2 (default) and v3. Defaults to `v2`.
        :param pulumi.Input[_builtins.str] cluster_id: The Id of cluster to use when contacting the Kafka REST Server. Required api_version to be 'v3'
        :param pulumi.Input[_builtins.str] description: The templated description of the Kafka message.
        :param pulumi.Input[_builtins.str] details: The templated details to include with the message.
        :param pulumi.Input[_builtins.bool] disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param pulumi.Input[_builtins.str] password: The password to use when making a call to the Kafka REST Proxy
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param pulumi.Input[_builtins.str] uid: The UID of the contact point.
        :param pulumi.Input[_builtins.str] username: The user name to use when making a call to the Kafka REST Proxy
        """
        pulumi.set(__self__, "rest_proxy_url", rest_proxy_url)
        pulumi.set(__self__, "topic", topic)
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if cluster_id is not None:
            pulumi.set(__self__, "cluster_id", cluster_id)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if details is not None:
            pulumi.set(__self__, "details", details)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="restProxyUrl")
    def rest_proxy_url(self) -> pulumi.Input[_builtins.str]:
        """
        The URL of the Kafka REST proxy to send requests to.
        """
        return pulumi.get(self, "rest_proxy_url")

    @rest_proxy_url.setter
    def rest_proxy_url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "rest_proxy_url", value)

    @_builtins.property
    @pulumi.getter
    def topic(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the Kafka topic to publish to.
        """
        return pulumi.get(self, "topic")

    @topic.setter
    def topic(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "topic", value)

    @_builtins.property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The API version to use when contacting the Kafka REST Server. Supported: v2 (default) and v3. Defaults to `v2`.
        """
        return pulumi.get(self, "api_version")

    @api_version.setter
    def api_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "api_version", value)

    @_builtins.property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Id of cluster to use when contacting the Kafka REST Server. Required api_version to be 'v3'
        """
        return pulumi.get(self, "cluster_id")

    @cluster_id.setter
    def cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cluster_id", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The templated description of the Kafka message.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def details(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The templated details to include with the message.
        """
        return pulumi.get(self, "details")

    @details.setter
    def details(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "details", value)

    @_builtins.property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @disable_resolve_message.setter
    def disable_resolve_message(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disable_resolve_message", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The password to use when making a call to the Kafka REST Proxy
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "settings", value)

    @_builtins.property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uid", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The user name to use when making a call to the Kafka REST Proxy
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ContactPointLineArgsDict(TypedDict):
        token: pulumi.Input[_builtins.str]
        """
        The bearer token used to authorize the client.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        The templated description of the message.
        """
        disable_resolve_message: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        settings: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        title: NotRequired[pulumi.Input[_builtins.str]]
        """
        The templated title of the message.
        """
        uid: NotRequired[pulumi.Input[_builtins.str]]
        """
        The UID of the contact point.
        """
elif False:
    ContactPointLineArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContactPointLineArgs:
    def __init__(__self__, *,
                 token: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 disable_resolve_message: Optional[pulumi.Input[_builtins.bool]] = None,
                 settings: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 title: Optional[pulumi.Input[_builtins.str]] = None,
                 uid: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] token: The bearer token used to authorize the client.
        :param pulumi.Input[_builtins.str] description: The templated description of the message.
        :param pulumi.Input[_builtins.bool] disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param pulumi.Input[_builtins.str] title: The templated title of the message.
        :param pulumi.Input[_builtins.str] uid: The UID of the contact point.
        """
        pulumi.set(__self__, "token", token)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @_builtins.property
    @pulumi.getter
    def token(self) -> pulumi.Input[_builtins.str]:
        """
        The bearer token used to authorize the client.
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "token", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The templated description of the message.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @disable_resolve_message.setter
    def disable_resolve_message(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disable_resolve_message", value)

    @_builtins.property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "settings", value)

    @_builtins.property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The templated title of the message.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "title", value)

    @_builtins.property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uid", value)


if not MYPY:
    class ContactPointOncallArgsDict(TypedDict):
        url: pulumi.Input[_builtins.str]
        """
        The URL to send webhook requests to.
        """
        authorization_credentials: NotRequired[pulumi.Input[_builtins.str]]
        """
        Allows a custom authorization scheme - attaches an auth header with this value. Do not use in conjunction with basic auth parameters.
        """
        authorization_scheme: NotRequired[pulumi.Input[_builtins.str]]
        """
        Allows a custom authorization scheme - attaches an auth header with this name. Do not use in conjunction with basic auth parameters.
        """
        basic_auth_password: NotRequired[pulumi.Input[_builtins.str]]
        """
        The username to use in basic auth headers attached to the request. If omitted, basic auth will not be used.
        """
        basic_auth_user: NotRequired[pulumi.Input[_builtins.str]]
        """
        The username to use in basic auth headers attached to the request. If omitted, basic auth will not be used.
        """
        disable_resolve_message: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        http_method: NotRequired[pulumi.Input[_builtins.str]]
        """
        The HTTP method to use in the request. Defaults to `POST`.
        """
        max_alerts: NotRequired[pulumi.Input[_builtins.int]]
        """
        The maximum number of alerts to send in a single request. This can be helpful in limiting the size of the request body. The default is 0, which indicates no limit.
        """
        message: NotRequired[pulumi.Input[_builtins.str]]
        """
        Custom message. You can use template variables.
        """
        settings: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        title: NotRequired[pulumi.Input[_builtins.str]]
        """
        Templated title of the message.
        """
        uid: NotRequired[pulumi.Input[_builtins.str]]
        """
        The UID of the contact point.
        """
elif False:
    ContactPointOncallArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContactPointOncallArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[_builtins.str],
                 authorization_credentials: Optional[pulumi.Input[_builtins.str]] = None,
                 authorization_scheme: Optional[pulumi.Input[_builtins.str]] = None,
                 basic_auth_password: Optional[pulumi.Input[_builtins.str]] = None,
                 basic_auth_user: Optional[pulumi.Input[_builtins.str]] = None,
                 disable_resolve_message: Optional[pulumi.Input[_builtins.bool]] = None,
                 http_method: Optional[pulumi.Input[_builtins.str]] = None,
                 max_alerts: Optional[pulumi.Input[_builtins.int]] = None,
                 message: Optional[pulumi.Input[_builtins.str]] = None,
                 settings: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 title: Optional[pulumi.Input[_builtins.str]] = None,
                 uid: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] url: The URL to send webhook requests to.
        :param pulumi.Input[_builtins.str] authorization_credentials: Allows a custom authorization scheme - attaches an auth header with this value. Do not use in conjunction with basic auth parameters.
        :param pulumi.Input[_builtins.str] authorization_scheme: Allows a custom authorization scheme - attaches an auth header with this name. Do not use in conjunction with basic auth parameters.
        :param pulumi.Input[_builtins.str] basic_auth_password: The username to use in basic auth headers attached to the request. If omitted, basic auth will not be used.
        :param pulumi.Input[_builtins.str] basic_auth_user: The username to use in basic auth headers attached to the request. If omitted, basic auth will not be used.
        :param pulumi.Input[_builtins.bool] disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param pulumi.Input[_builtins.str] http_method: The HTTP method to use in the request. Defaults to `POST`.
        :param pulumi.Input[_builtins.int] max_alerts: The maximum number of alerts to send in a single request. This can be helpful in limiting the size of the request body. The default is 0, which indicates no limit.
        :param pulumi.Input[_builtins.str] message: Custom message. You can use template variables.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param pulumi.Input[_builtins.str] title: Templated title of the message.
        :param pulumi.Input[_builtins.str] uid: The UID of the contact point.
        """
        pulumi.set(__self__, "url", url)
        if authorization_credentials is not None:
            pulumi.set(__self__, "authorization_credentials", authorization_credentials)
        if authorization_scheme is not None:
            pulumi.set(__self__, "authorization_scheme", authorization_scheme)
        if basic_auth_password is not None:
            pulumi.set(__self__, "basic_auth_password", basic_auth_password)
        if basic_auth_user is not None:
            pulumi.set(__self__, "basic_auth_user", basic_auth_user)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if http_method is not None:
            pulumi.set(__self__, "http_method", http_method)
        if max_alerts is not None:
            pulumi.set(__self__, "max_alerts", max_alerts)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        The URL to send webhook requests to.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="authorizationCredentials")
    def authorization_credentials(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Allows a custom authorization scheme - attaches an auth header with this value. Do not use in conjunction with basic auth parameters.
        """
        return pulumi.get(self, "authorization_credentials")

    @authorization_credentials.setter
    def authorization_credentials(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "authorization_credentials", value)

    @_builtins.property
    @pulumi.getter(name="authorizationScheme")
    def authorization_scheme(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Allows a custom authorization scheme - attaches an auth header with this name. Do not use in conjunction with basic auth parameters.
        """
        return pulumi.get(self, "authorization_scheme")

    @authorization_scheme.setter
    def authorization_scheme(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "authorization_scheme", value)

    @_builtins.property
    @pulumi.getter(name="basicAuthPassword")
    def basic_auth_password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The username to use in basic auth headers attached to the request. If omitted, basic auth will not be used.
        """
        return pulumi.get(self, "basic_auth_password")

    @basic_auth_password.setter
    def basic_auth_password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "basic_auth_password", value)

    @_builtins.property
    @pulumi.getter(name="basicAuthUser")
    def basic_auth_user(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The username to use in basic auth headers attached to the request. If omitted, basic auth will not be used.
        """
        return pulumi.get(self, "basic_auth_user")

    @basic_auth_user.setter
    def basic_auth_user(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "basic_auth_user", value)

    @_builtins.property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @disable_resolve_message.setter
    def disable_resolve_message(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disable_resolve_message", value)

    @_builtins.property
    @pulumi.getter(name="httpMethod")
    def http_method(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The HTTP method to use in the request. Defaults to `POST`.
        """
        return pulumi.get(self, "http_method")

    @http_method.setter
    def http_method(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "http_method", value)

    @_builtins.property
    @pulumi.getter(name="maxAlerts")
    def max_alerts(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The maximum number of alerts to send in a single request. This can be helpful in limiting the size of the request body. The default is 0, which indicates no limit.
        """
        return pulumi.get(self, "max_alerts")

    @max_alerts.setter
    def max_alerts(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_alerts", value)

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Custom message. You can use template variables.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message", value)

    @_builtins.property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "settings", value)

    @_builtins.property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Templated title of the message.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "title", value)

    @_builtins.property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uid", value)


if not MYPY:
    class ContactPointOpsgenyArgsDict(TypedDict):
        api_key: pulumi.Input[_builtins.str]
        """
        The OpsGenie API key to use.
        """
        auto_close: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to auto-close alerts in OpsGenie when they resolve in the Alertmanager.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A templated high-level description to use for the alert.
        """
        disable_resolve_message: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        message: NotRequired[pulumi.Input[_builtins.str]]
        """
        The templated content of the message.
        """
        override_priority: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to allow the alert priority to be configured via the value of the `og_priority` annotation on the alert.
        """
        responders: NotRequired[pulumi.Input[Sequence[pulumi.Input['ContactPointOpsgenyResponderArgsDict']]]]
        """
        Teams, users, escalations and schedules that the alert will be routed to send notifications. If the API Key belongs to a team integration, this field will be overwritten with the owner team. This feature is available from Grafana 10.3+.
        """
        send_tags_as: NotRequired[pulumi.Input[_builtins.str]]
        """
        Whether to send annotations to OpsGenie as Tags, Details, or both. Supported values are `tags`, `details`, `both`, or empty to use the default behavior of Tags.
        """
        settings: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        uid: NotRequired[pulumi.Input[_builtins.str]]
        """
        The UID of the contact point.
        """
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        Allows customization of the OpsGenie API URL.
        """
elif False:
    ContactPointOpsgenyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContactPointOpsgenyArgs:
    def __init__(__self__, *,
                 api_key: pulumi.Input[_builtins.str],
                 auto_close: Optional[pulumi.Input[_builtins.bool]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 disable_resolve_message: Optional[pulumi.Input[_builtins.bool]] = None,
                 message: Optional[pulumi.Input[_builtins.str]] = None,
                 override_priority: Optional[pulumi.Input[_builtins.bool]] = None,
                 responders: Optional[pulumi.Input[Sequence[pulumi.Input['ContactPointOpsgenyResponderArgs']]]] = None,
                 send_tags_as: Optional[pulumi.Input[_builtins.str]] = None,
                 settings: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 uid: Optional[pulumi.Input[_builtins.str]] = None,
                 url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] api_key: The OpsGenie API key to use.
        :param pulumi.Input[_builtins.bool] auto_close: Whether to auto-close alerts in OpsGenie when they resolve in the Alertmanager.
        :param pulumi.Input[_builtins.str] description: A templated high-level description to use for the alert.
        :param pulumi.Input[_builtins.bool] disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param pulumi.Input[_builtins.str] message: The templated content of the message.
        :param pulumi.Input[_builtins.bool] override_priority: Whether to allow the alert priority to be configured via the value of the `og_priority` annotation on the alert.
        :param pulumi.Input[Sequence[pulumi.Input['ContactPointOpsgenyResponderArgs']]] responders: Teams, users, escalations and schedules that the alert will be routed to send notifications. If the API Key belongs to a team integration, this field will be overwritten with the owner team. This feature is available from Grafana 10.3+.
        :param pulumi.Input[_builtins.str] send_tags_as: Whether to send annotations to OpsGenie as Tags, Details, or both. Supported values are `tags`, `details`, `both`, or empty to use the default behavior of Tags.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param pulumi.Input[_builtins.str] uid: The UID of the contact point.
        :param pulumi.Input[_builtins.str] url: Allows customization of the OpsGenie API URL.
        """
        pulumi.set(__self__, "api_key", api_key)
        if auto_close is not None:
            pulumi.set(__self__, "auto_close", auto_close)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if override_priority is not None:
            pulumi.set(__self__, "override_priority", override_priority)
        if responders is not None:
            pulumi.set(__self__, "responders", responders)
        if send_tags_as is not None:
            pulumi.set(__self__, "send_tags_as", send_tags_as)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[_builtins.str]:
        """
        The OpsGenie API key to use.
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "api_key", value)

    @_builtins.property
    @pulumi.getter(name="autoClose")
    def auto_close(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to auto-close alerts in OpsGenie when they resolve in the Alertmanager.
        """
        return pulumi.get(self, "auto_close")

    @auto_close.setter
    def auto_close(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "auto_close", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A templated high-level description to use for the alert.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @disable_resolve_message.setter
    def disable_resolve_message(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disable_resolve_message", value)

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The templated content of the message.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message", value)

    @_builtins.property
    @pulumi.getter(name="overridePriority")
    def override_priority(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to allow the alert priority to be configured via the value of the `og_priority` annotation on the alert.
        """
        return pulumi.get(self, "override_priority")

    @override_priority.setter
    def override_priority(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "override_priority", value)

    @_builtins.property
    @pulumi.getter
    def responders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ContactPointOpsgenyResponderArgs']]]]:
        """
        Teams, users, escalations and schedules that the alert will be routed to send notifications. If the API Key belongs to a team integration, this field will be overwritten with the owner team. This feature is available from Grafana 10.3+.
        """
        return pulumi.get(self, "responders")

    @responders.setter
    def responders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ContactPointOpsgenyResponderArgs']]]]):
        pulumi.set(self, "responders", value)

    @_builtins.property
    @pulumi.getter(name="sendTagsAs")
    def send_tags_as(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Whether to send annotations to OpsGenie as Tags, Details, or both. Supported values are `tags`, `details`, `both`, or empty to use the default behavior of Tags.
        """
        return pulumi.get(self, "send_tags_as")

    @send_tags_as.setter
    def send_tags_as(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "send_tags_as", value)

    @_builtins.property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "settings", value)

    @_builtins.property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uid", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Allows customization of the OpsGenie API URL.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class ContactPointOpsgenyResponderArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Type of the responder. Supported: team, teams, user, escalation, schedule or a template that is expanded to one of these values.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the responder. Must be specified if name and username are empty.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the responder. Must be specified if username and id are empty.
        """
        username: NotRequired[pulumi.Input[_builtins.str]]
        """
        User name of the responder. Must be specified if name and id are empty.
        """
elif False:
    ContactPointOpsgenyResponderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContactPointOpsgenyResponderArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 username: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] type: Type of the responder. Supported: team, teams, user, escalation, schedule or a template that is expanded to one of these values.
        :param pulumi.Input[_builtins.str] id: ID of the responder. Must be specified if name and username are empty.
        :param pulumi.Input[_builtins.str] name: Name of the responder. Must be specified if username and id are empty.
        :param pulumi.Input[_builtins.str] username: User name of the responder. Must be specified if name and id are empty.
        """
        pulumi.set(__self__, "type", type)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Type of the responder. Supported: team, teams, user, escalation, schedule or a template that is expanded to one of these values.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the responder. Must be specified if name and username are empty.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the responder. Must be specified if username and id are empty.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        User name of the responder. Must be specified if name and id are empty.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ContactPointPagerdutyArgsDict(TypedDict):
        integration_key: pulumi.Input[_builtins.str]
        """
        The PagerDuty API key.
        """
        class_: NotRequired[pulumi.Input[_builtins.str]]
        """
        The class or type of event, for example `ping failure`.
        """
        client: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the monitoring client that is triggering this event.
        """
        client_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL of the monitoring client that is triggering this event.
        """
        component: NotRequired[pulumi.Input[_builtins.str]]
        """
        The component being affected by the event.
        """
        details: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        A set of arbitrary key/value pairs that provide further detail about the incident.
        """
        disable_resolve_message: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        group: NotRequired[pulumi.Input[_builtins.str]]
        """
        The group to which the provided component belongs to.
        """
        settings: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        severity: NotRequired[pulumi.Input[_builtins.str]]
        """
        The PagerDuty event severity level. Default is `critical`.
        """
        source: NotRequired[pulumi.Input[_builtins.str]]
        """
        The unique location of the affected system.
        """
        summary: NotRequired[pulumi.Input[_builtins.str]]
        """
        The templated summary message of the event.
        """
        uid: NotRequired[pulumi.Input[_builtins.str]]
        """
        The UID of the contact point.
        """
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL to send API requests to
        """
elif False:
    ContactPointPagerdutyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContactPointPagerdutyArgs:
    def __init__(__self__, *,
                 integration_key: pulumi.Input[_builtins.str],
                 class_: Optional[pulumi.Input[_builtins.str]] = None,
                 client: Optional[pulumi.Input[_builtins.str]] = None,
                 client_url: Optional[pulumi.Input[_builtins.str]] = None,
                 component: Optional[pulumi.Input[_builtins.str]] = None,
                 details: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 disable_resolve_message: Optional[pulumi.Input[_builtins.bool]] = None,
                 group: Optional[pulumi.Input[_builtins.str]] = None,
                 settings: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 severity: Optional[pulumi.Input[_builtins.str]] = None,
                 source: Optional[pulumi.Input[_builtins.str]] = None,
                 summary: Optional[pulumi.Input[_builtins.str]] = None,
                 uid: Optional[pulumi.Input[_builtins.str]] = None,
                 url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] integration_key: The PagerDuty API key.
        :param pulumi.Input[_builtins.str] class_: The class or type of event, for example `ping failure`.
        :param pulumi.Input[_builtins.str] client: The name of the monitoring client that is triggering this event.
        :param pulumi.Input[_builtins.str] client_url: The URL of the monitoring client that is triggering this event.
        :param pulumi.Input[_builtins.str] component: The component being affected by the event.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] details: A set of arbitrary key/value pairs that provide further detail about the incident.
        :param pulumi.Input[_builtins.bool] disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param pulumi.Input[_builtins.str] group: The group to which the provided component belongs to.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param pulumi.Input[_builtins.str] severity: The PagerDuty event severity level. Default is `critical`.
        :param pulumi.Input[_builtins.str] source: The unique location of the affected system.
        :param pulumi.Input[_builtins.str] summary: The templated summary message of the event.
        :param pulumi.Input[_builtins.str] uid: The UID of the contact point.
        :param pulumi.Input[_builtins.str] url: The URL to send API requests to
        """
        pulumi.set(__self__, "integration_key", integration_key)
        if class_ is not None:
            pulumi.set(__self__, "class_", class_)
        if client is not None:
            pulumi.set(__self__, "client", client)
        if client_url is not None:
            pulumi.set(__self__, "client_url", client_url)
        if component is not None:
            pulumi.set(__self__, "component", component)
        if details is not None:
            pulumi.set(__self__, "details", details)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if group is not None:
            pulumi.set(__self__, "group", group)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if summary is not None:
            pulumi.set(__self__, "summary", summary)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter(name="integrationKey")
    def integration_key(self) -> pulumi.Input[_builtins.str]:
        """
        The PagerDuty API key.
        """
        return pulumi.get(self, "integration_key")

    @integration_key.setter
    def integration_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "integration_key", value)

    @_builtins.property
    @pulumi.getter(name="class")
    def class_(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The class or type of event, for example `ping failure`.
        """
        return pulumi.get(self, "class_")

    @class_.setter
    def class_(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "class_", value)

    @_builtins.property
    @pulumi.getter
    def client(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the monitoring client that is triggering this event.
        """
        return pulumi.get(self, "client")

    @client.setter
    def client(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client", value)

    @_builtins.property
    @pulumi.getter(name="clientUrl")
    def client_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL of the monitoring client that is triggering this event.
        """
        return pulumi.get(self, "client_url")

    @client_url.setter
    def client_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_url", value)

    @_builtins.property
    @pulumi.getter
    def component(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The component being affected by the event.
        """
        return pulumi.get(self, "component")

    @component.setter
    def component(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "component", value)

    @_builtins.property
    @pulumi.getter
    def details(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        A set of arbitrary key/value pairs that provide further detail about the incident.
        """
        return pulumi.get(self, "details")

    @details.setter
    def details(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "details", value)

    @_builtins.property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @disable_resolve_message.setter
    def disable_resolve_message(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disable_resolve_message", value)

    @_builtins.property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The group to which the provided component belongs to.
        """
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "group", value)

    @_builtins.property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "settings", value)

    @_builtins.property
    @pulumi.getter
    def severity(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The PagerDuty event severity level. Default is `critical`.
        """
        return pulumi.get(self, "severity")

    @severity.setter
    def severity(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "severity", value)

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The unique location of the affected system.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source", value)

    @_builtins.property
    @pulumi.getter
    def summary(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The templated summary message of the event.
        """
        return pulumi.get(self, "summary")

    @summary.setter
    def summary(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "summary", value)

    @_builtins.property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uid", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL to send API requests to
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class ContactPointPushoverArgsDict(TypedDict):
        api_token: pulumi.Input[_builtins.str]
        """
        The Pushover API token.
        """
        user_key: pulumi.Input[_builtins.str]
        """
        The Pushover user key.
        """
        device: NotRequired[pulumi.Input[_builtins.str]]
        """
        Comma-separated list of devices to which the event is associated.
        """
        disable_resolve_message: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        expire: NotRequired[pulumi.Input[_builtins.int]]
        """
        How many seconds for which the notification will continue to be retried by Pushover.
        """
        message: NotRequired[pulumi.Input[_builtins.str]]
        """
        The templated notification message content.
        """
        ok_priority: NotRequired[pulumi.Input[_builtins.int]]
        """
        The priority level of the resolved event.
        """
        ok_sound: NotRequired[pulumi.Input[_builtins.str]]
        """
        The sound associated with the resolved notification.
        """
        priority: NotRequired[pulumi.Input[_builtins.int]]
        """
        The priority level of the event.
        """
        retry: NotRequired[pulumi.Input[_builtins.int]]
        """
        How often, in seconds, the Pushover servers will send the same notification to the user.
        """
        settings: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        sound: NotRequired[pulumi.Input[_builtins.str]]
        """
        The sound associated with the notification.
        """
        title: NotRequired[pulumi.Input[_builtins.str]]
        """
        The templated title of the message.
        """
        uid: NotRequired[pulumi.Input[_builtins.str]]
        """
        The UID of the contact point.
        """
        upload_image: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to send images in the notification or not. Default is true. Requires Grafana to be configured to send images in notifications.
        """
elif False:
    ContactPointPushoverArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContactPointPushoverArgs:
    def __init__(__self__, *,
                 api_token: pulumi.Input[_builtins.str],
                 user_key: pulumi.Input[_builtins.str],
                 device: Optional[pulumi.Input[_builtins.str]] = None,
                 disable_resolve_message: Optional[pulumi.Input[_builtins.bool]] = None,
                 expire: Optional[pulumi.Input[_builtins.int]] = None,
                 message: Optional[pulumi.Input[_builtins.str]] = None,
                 ok_priority: Optional[pulumi.Input[_builtins.int]] = None,
                 ok_sound: Optional[pulumi.Input[_builtins.str]] = None,
                 priority: Optional[pulumi.Input[_builtins.int]] = None,
                 retry: Optional[pulumi.Input[_builtins.int]] = None,
                 settings: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 sound: Optional[pulumi.Input[_builtins.str]] = None,
                 title: Optional[pulumi.Input[_builtins.str]] = None,
                 uid: Optional[pulumi.Input[_builtins.str]] = None,
                 upload_image: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] api_token: The Pushover API token.
        :param pulumi.Input[_builtins.str] user_key: The Pushover user key.
        :param pulumi.Input[_builtins.str] device: Comma-separated list of devices to which the event is associated.
        :param pulumi.Input[_builtins.bool] disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param pulumi.Input[_builtins.int] expire: How many seconds for which the notification will continue to be retried by Pushover.
        :param pulumi.Input[_builtins.str] message: The templated notification message content.
        :param pulumi.Input[_builtins.int] ok_priority: The priority level of the resolved event.
        :param pulumi.Input[_builtins.str] ok_sound: The sound associated with the resolved notification.
        :param pulumi.Input[_builtins.int] priority: The priority level of the event.
        :param pulumi.Input[_builtins.int] retry: How often, in seconds, the Pushover servers will send the same notification to the user.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param pulumi.Input[_builtins.str] sound: The sound associated with the notification.
        :param pulumi.Input[_builtins.str] title: The templated title of the message.
        :param pulumi.Input[_builtins.str] uid: The UID of the contact point.
        :param pulumi.Input[_builtins.bool] upload_image: Whether to send images in the notification or not. Default is true. Requires Grafana to be configured to send images in notifications.
        """
        pulumi.set(__self__, "api_token", api_token)
        pulumi.set(__self__, "user_key", user_key)
        if device is not None:
            pulumi.set(__self__, "device", device)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if expire is not None:
            pulumi.set(__self__, "expire", expire)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if ok_priority is not None:
            pulumi.set(__self__, "ok_priority", ok_priority)
        if ok_sound is not None:
            pulumi.set(__self__, "ok_sound", ok_sound)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if retry is not None:
            pulumi.set(__self__, "retry", retry)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if sound is not None:
            pulumi.set(__self__, "sound", sound)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)
        if upload_image is not None:
            pulumi.set(__self__, "upload_image", upload_image)

    @_builtins.property
    @pulumi.getter(name="apiToken")
    def api_token(self) -> pulumi.Input[_builtins.str]:
        """
        The Pushover API token.
        """
        return pulumi.get(self, "api_token")

    @api_token.setter
    def api_token(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "api_token", value)

    @_builtins.property
    @pulumi.getter(name="userKey")
    def user_key(self) -> pulumi.Input[_builtins.str]:
        """
        The Pushover user key.
        """
        return pulumi.get(self, "user_key")

    @user_key.setter
    def user_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "user_key", value)

    @_builtins.property
    @pulumi.getter
    def device(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Comma-separated list of devices to which the event is associated.
        """
        return pulumi.get(self, "device")

    @device.setter
    def device(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "device", value)

    @_builtins.property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @disable_resolve_message.setter
    def disable_resolve_message(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disable_resolve_message", value)

    @_builtins.property
    @pulumi.getter
    def expire(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        How many seconds for which the notification will continue to be retried by Pushover.
        """
        return pulumi.get(self, "expire")

    @expire.setter
    def expire(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "expire", value)

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The templated notification message content.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message", value)

    @_builtins.property
    @pulumi.getter(name="okPriority")
    def ok_priority(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The priority level of the resolved event.
        """
        return pulumi.get(self, "ok_priority")

    @ok_priority.setter
    def ok_priority(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "ok_priority", value)

    @_builtins.property
    @pulumi.getter(name="okSound")
    def ok_sound(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The sound associated with the resolved notification.
        """
        return pulumi.get(self, "ok_sound")

    @ok_sound.setter
    def ok_sound(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ok_sound", value)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The priority level of the event.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter
    def retry(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        How often, in seconds, the Pushover servers will send the same notification to the user.
        """
        return pulumi.get(self, "retry")

    @retry.setter
    def retry(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "retry", value)

    @_builtins.property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "settings", value)

    @_builtins.property
    @pulumi.getter
    def sound(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The sound associated with the notification.
        """
        return pulumi.get(self, "sound")

    @sound.setter
    def sound(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sound", value)

    @_builtins.property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The templated title of the message.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "title", value)

    @_builtins.property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uid", value)

    @_builtins.property
    @pulumi.getter(name="uploadImage")
    def upload_image(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to send images in the notification or not. Default is true. Requires Grafana to be configured to send images in notifications.
        """
        return pulumi.get(self, "upload_image")

    @upload_image.setter
    def upload_image(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "upload_image", value)


if not MYPY:
    class ContactPointSensugoArgsDict(TypedDict):
        api_key: pulumi.Input[_builtins.str]
        """
        The SensuGo API key.
        """
        url: pulumi.Input[_builtins.str]
        """
        The SensuGo URL to send requests to.
        """
        check: NotRequired[pulumi.Input[_builtins.str]]
        """
        The SensuGo check to which the event should be routed.
        """
        disable_resolve_message: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        entity: NotRequired[pulumi.Input[_builtins.str]]
        """
        The entity being monitored.
        """
        handler: NotRequired[pulumi.Input[_builtins.str]]
        """
        A custom handler to execute in addition to the check.
        """
        message: NotRequired[pulumi.Input[_builtins.str]]
        """
        Templated message content describing the alert.
        """
        namespace: NotRequired[pulumi.Input[_builtins.str]]
        """
        The namespace in which the check resides.
        """
        settings: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        uid: NotRequired[pulumi.Input[_builtins.str]]
        """
        The UID of the contact point.
        """
elif False:
    ContactPointSensugoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContactPointSensugoArgs:
    def __init__(__self__, *,
                 api_key: pulumi.Input[_builtins.str],
                 url: pulumi.Input[_builtins.str],
                 check: Optional[pulumi.Input[_builtins.str]] = None,
                 disable_resolve_message: Optional[pulumi.Input[_builtins.bool]] = None,
                 entity: Optional[pulumi.Input[_builtins.str]] = None,
                 handler: Optional[pulumi.Input[_builtins.str]] = None,
                 message: Optional[pulumi.Input[_builtins.str]] = None,
                 namespace: Optional[pulumi.Input[_builtins.str]] = None,
                 settings: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 uid: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] api_key: The SensuGo API key.
        :param pulumi.Input[_builtins.str] url: The SensuGo URL to send requests to.
        :param pulumi.Input[_builtins.str] check: The SensuGo check to which the event should be routed.
        :param pulumi.Input[_builtins.bool] disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param pulumi.Input[_builtins.str] entity: The entity being monitored.
        :param pulumi.Input[_builtins.str] handler: A custom handler to execute in addition to the check.
        :param pulumi.Input[_builtins.str] message: Templated message content describing the alert.
        :param pulumi.Input[_builtins.str] namespace: The namespace in which the check resides.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param pulumi.Input[_builtins.str] uid: The UID of the contact point.
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "url", url)
        if check is not None:
            pulumi.set(__self__, "check", check)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if entity is not None:
            pulumi.set(__self__, "entity", entity)
        if handler is not None:
            pulumi.set(__self__, "handler", handler)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[_builtins.str]:
        """
        The SensuGo API key.
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "api_key", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        The SensuGo URL to send requests to.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter
    def check(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The SensuGo check to which the event should be routed.
        """
        return pulumi.get(self, "check")

    @check.setter
    def check(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "check", value)

    @_builtins.property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @disable_resolve_message.setter
    def disable_resolve_message(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disable_resolve_message", value)

    @_builtins.property
    @pulumi.getter
    def entity(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The entity being monitored.
        """
        return pulumi.get(self, "entity")

    @entity.setter
    def entity(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "entity", value)

    @_builtins.property
    @pulumi.getter
    def handler(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A custom handler to execute in addition to the check.
        """
        return pulumi.get(self, "handler")

    @handler.setter
    def handler(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "handler", value)

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Templated message content describing the alert.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The namespace in which the check resides.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "namespace", value)

    @_builtins.property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "settings", value)

    @_builtins.property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uid", value)


if not MYPY:
    class ContactPointSlackArgsDict(TypedDict):
        color: NotRequired[pulumi.Input[_builtins.str]]
        """
        Templated color of the slack message.
        """
        disable_resolve_message: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        endpoint_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        Use this to override the Slack API endpoint URL to send requests to.
        """
        icon_emoji: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of a Slack workspace emoji to use as the bot icon.
        """
        icon_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        A URL of an image to use as the bot icon.
        """
        mention_channel: NotRequired[pulumi.Input[_builtins.str]]
        """
        Describes how to ping the slack channel that messages are being sent to. Options are `here` for an @here ping, `channel` for @channel, or empty for no ping.
        """
        mention_groups: NotRequired[pulumi.Input[_builtins.str]]
        """
        Comma-separated list of groups to mention in the message.
        """
        mention_users: NotRequired[pulumi.Input[_builtins.str]]
        """
        Comma-separated list of users to mention in the message.
        """
        recipient: NotRequired[pulumi.Input[_builtins.str]]
        """
        Channel, private group, or IM channel (can be an encoded ID or a name) to send messages to.
        """
        settings: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        text: NotRequired[pulumi.Input[_builtins.str]]
        """
        Templated content of the message.
        """
        title: NotRequired[pulumi.Input[_builtins.str]]
        """
        Templated title of the message.
        """
        token: NotRequired[pulumi.Input[_builtins.str]]
        """
        A Slack API token,for sending messages directly without the webhook method.
        """
        uid: NotRequired[pulumi.Input[_builtins.str]]
        """
        The UID of the contact point.
        """
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        A Slack webhook URL,for sending messages via the webhook method.
        """
        username: NotRequired[pulumi.Input[_builtins.str]]
        """
        Username for the bot to use.
        """
elif False:
    ContactPointSlackArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContactPointSlackArgs:
    def __init__(__self__, *,
                 color: Optional[pulumi.Input[_builtins.str]] = None,
                 disable_resolve_message: Optional[pulumi.Input[_builtins.bool]] = None,
                 endpoint_url: Optional[pulumi.Input[_builtins.str]] = None,
                 icon_emoji: Optional[pulumi.Input[_builtins.str]] = None,
                 icon_url: Optional[pulumi.Input[_builtins.str]] = None,
                 mention_channel: Optional[pulumi.Input[_builtins.str]] = None,
                 mention_groups: Optional[pulumi.Input[_builtins.str]] = None,
                 mention_users: Optional[pulumi.Input[_builtins.str]] = None,
                 recipient: Optional[pulumi.Input[_builtins.str]] = None,
                 settings: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 text: Optional[pulumi.Input[_builtins.str]] = None,
                 title: Optional[pulumi.Input[_builtins.str]] = None,
                 token: Optional[pulumi.Input[_builtins.str]] = None,
                 uid: Optional[pulumi.Input[_builtins.str]] = None,
                 url: Optional[pulumi.Input[_builtins.str]] = None,
                 username: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] color: Templated color of the slack message.
        :param pulumi.Input[_builtins.bool] disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param pulumi.Input[_builtins.str] endpoint_url: Use this to override the Slack API endpoint URL to send requests to.
        :param pulumi.Input[_builtins.str] icon_emoji: The name of a Slack workspace emoji to use as the bot icon.
        :param pulumi.Input[_builtins.str] icon_url: A URL of an image to use as the bot icon.
        :param pulumi.Input[_builtins.str] mention_channel: Describes how to ping the slack channel that messages are being sent to. Options are `here` for an @here ping, `channel` for @channel, or empty for no ping.
        :param pulumi.Input[_builtins.str] mention_groups: Comma-separated list of groups to mention in the message.
        :param pulumi.Input[_builtins.str] mention_users: Comma-separated list of users to mention in the message.
        :param pulumi.Input[_builtins.str] recipient: Channel, private group, or IM channel (can be an encoded ID or a name) to send messages to.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param pulumi.Input[_builtins.str] text: Templated content of the message.
        :param pulumi.Input[_builtins.str] title: Templated title of the message.
        :param pulumi.Input[_builtins.str] token: A Slack API token,for sending messages directly without the webhook method.
        :param pulumi.Input[_builtins.str] uid: The UID of the contact point.
        :param pulumi.Input[_builtins.str] url: A Slack webhook URL,for sending messages via the webhook method.
        :param pulumi.Input[_builtins.str] username: Username for the bot to use.
        """
        if color is not None:
            pulumi.set(__self__, "color", color)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if endpoint_url is not None:
            pulumi.set(__self__, "endpoint_url", endpoint_url)
        if icon_emoji is not None:
            pulumi.set(__self__, "icon_emoji", icon_emoji)
        if icon_url is not None:
            pulumi.set(__self__, "icon_url", icon_url)
        if mention_channel is not None:
            pulumi.set(__self__, "mention_channel", mention_channel)
        if mention_groups is not None:
            pulumi.set(__self__, "mention_groups", mention_groups)
        if mention_users is not None:
            pulumi.set(__self__, "mention_users", mention_users)
        if recipient is not None:
            pulumi.set(__self__, "recipient", recipient)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if text is not None:
            pulumi.set(__self__, "text", text)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if token is not None:
            pulumi.set(__self__, "token", token)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def color(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Templated color of the slack message.
        """
        return pulumi.get(self, "color")

    @color.setter
    def color(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "color", value)

    @_builtins.property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @disable_resolve_message.setter
    def disable_resolve_message(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disable_resolve_message", value)

    @_builtins.property
    @pulumi.getter(name="endpointUrl")
    def endpoint_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Use this to override the Slack API endpoint URL to send requests to.
        """
        return pulumi.get(self, "endpoint_url")

    @endpoint_url.setter
    def endpoint_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "endpoint_url", value)

    @_builtins.property
    @pulumi.getter(name="iconEmoji")
    def icon_emoji(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of a Slack workspace emoji to use as the bot icon.
        """
        return pulumi.get(self, "icon_emoji")

    @icon_emoji.setter
    def icon_emoji(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "icon_emoji", value)

    @_builtins.property
    @pulumi.getter(name="iconUrl")
    def icon_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A URL of an image to use as the bot icon.
        """
        return pulumi.get(self, "icon_url")

    @icon_url.setter
    def icon_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "icon_url", value)

    @_builtins.property
    @pulumi.getter(name="mentionChannel")
    def mention_channel(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Describes how to ping the slack channel that messages are being sent to. Options are `here` for an @here ping, `channel` for @channel, or empty for no ping.
        """
        return pulumi.get(self, "mention_channel")

    @mention_channel.setter
    def mention_channel(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mention_channel", value)

    @_builtins.property
    @pulumi.getter(name="mentionGroups")
    def mention_groups(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Comma-separated list of groups to mention in the message.
        """
        return pulumi.get(self, "mention_groups")

    @mention_groups.setter
    def mention_groups(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mention_groups", value)

    @_builtins.property
    @pulumi.getter(name="mentionUsers")
    def mention_users(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Comma-separated list of users to mention in the message.
        """
        return pulumi.get(self, "mention_users")

    @mention_users.setter
    def mention_users(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mention_users", value)

    @_builtins.property
    @pulumi.getter
    def recipient(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Channel, private group, or IM channel (can be an encoded ID or a name) to send messages to.
        """
        return pulumi.get(self, "recipient")

    @recipient.setter
    def recipient(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "recipient", value)

    @_builtins.property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "settings", value)

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Templated content of the message.
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "text", value)

    @_builtins.property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Templated title of the message.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "title", value)

    @_builtins.property
    @pulumi.getter
    def token(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A Slack API token,for sending messages directly without the webhook method.
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "token", value)

    @_builtins.property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uid", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A Slack webhook URL,for sending messages via the webhook method.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Username for the bot to use.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ContactPointSnArgsDict(TypedDict):
        topic: pulumi.Input[_builtins.str]
        """
        The Amazon SNS topic to send notifications to.
        """
        access_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        AWS access key ID used to authenticate with Amazon SNS.
        """
        assume_role_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Amazon Resource Name (ARN) of the role to assume to send notifications to Amazon SNS.
        """
        auth_provider: NotRequired[pulumi.Input[_builtins.str]]
        """
        The authentication provider to use. Valid values are `default`, `arn` and `keys`. Default is `default`. Defaults to `default`.
        """
        body: NotRequired[pulumi.Input[_builtins.str]]
        disable_resolve_message: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        external_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The external ID to use when assuming the role.
        """
        message_format: NotRequired[pulumi.Input[_builtins.str]]
        """
        The format of the message to send. Valid values are `text`, `body` and `json`. Default is `text`. Defaults to `text`.
        """
        secret_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        AWS secret access key used to authenticate with Amazon SNS.
        """
        settings: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        subject: NotRequired[pulumi.Input[_builtins.str]]
        uid: NotRequired[pulumi.Input[_builtins.str]]
        """
        The UID of the contact point.
        """
elif False:
    ContactPointSnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContactPointSnArgs:
    def __init__(__self__, *,
                 topic: pulumi.Input[_builtins.str],
                 access_key: Optional[pulumi.Input[_builtins.str]] = None,
                 assume_role_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 auth_provider: Optional[pulumi.Input[_builtins.str]] = None,
                 body: Optional[pulumi.Input[_builtins.str]] = None,
                 disable_resolve_message: Optional[pulumi.Input[_builtins.bool]] = None,
                 external_id: Optional[pulumi.Input[_builtins.str]] = None,
                 message_format: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_key: Optional[pulumi.Input[_builtins.str]] = None,
                 settings: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 subject: Optional[pulumi.Input[_builtins.str]] = None,
                 uid: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] topic: The Amazon SNS topic to send notifications to.
        :param pulumi.Input[_builtins.str] access_key: AWS access key ID used to authenticate with Amazon SNS.
        :param pulumi.Input[_builtins.str] assume_role_arn: The Amazon Resource Name (ARN) of the role to assume to send notifications to Amazon SNS.
        :param pulumi.Input[_builtins.str] auth_provider: The authentication provider to use. Valid values are `default`, `arn` and `keys`. Default is `default`. Defaults to `default`.
        :param pulumi.Input[_builtins.bool] disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param pulumi.Input[_builtins.str] external_id: The external ID to use when assuming the role.
        :param pulumi.Input[_builtins.str] message_format: The format of the message to send. Valid values are `text`, `body` and `json`. Default is `text`. Defaults to `text`.
        :param pulumi.Input[_builtins.str] secret_key: AWS secret access key used to authenticate with Amazon SNS.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param pulumi.Input[_builtins.str] uid: The UID of the contact point.
        """
        pulumi.set(__self__, "topic", topic)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if assume_role_arn is not None:
            pulumi.set(__self__, "assume_role_arn", assume_role_arn)
        if auth_provider is not None:
            pulumi.set(__self__, "auth_provider", auth_provider)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)
        if message_format is not None:
            pulumi.set(__self__, "message_format", message_format)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if subject is not None:
            pulumi.set(__self__, "subject", subject)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @_builtins.property
    @pulumi.getter
    def topic(self) -> pulumi.Input[_builtins.str]:
        """
        The Amazon SNS topic to send notifications to.
        """
        return pulumi.get(self, "topic")

    @topic.setter
    def topic(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "topic", value)

    @_builtins.property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        AWS access key ID used to authenticate with Amazon SNS.
        """
        return pulumi.get(self, "access_key")

    @access_key.setter
    def access_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_key", value)

    @_builtins.property
    @pulumi.getter(name="assumeRoleArn")
    def assume_role_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Amazon Resource Name (ARN) of the role to assume to send notifications to Amazon SNS.
        """
        return pulumi.get(self, "assume_role_arn")

    @assume_role_arn.setter
    def assume_role_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "assume_role_arn", value)

    @_builtins.property
    @pulumi.getter(name="authProvider")
    def auth_provider(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The authentication provider to use. Valid values are `default`, `arn` and `keys`. Default is `default`. Defaults to `default`.
        """
        return pulumi.get(self, "auth_provider")

    @auth_provider.setter
    def auth_provider(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "auth_provider", value)

    @_builtins.property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "body", value)

    @_builtins.property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @disable_resolve_message.setter
    def disable_resolve_message(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disable_resolve_message", value)

    @_builtins.property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The external ID to use when assuming the role.
        """
        return pulumi.get(self, "external_id")

    @external_id.setter
    def external_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "external_id", value)

    @_builtins.property
    @pulumi.getter(name="messageFormat")
    def message_format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The format of the message to send. Valid values are `text`, `body` and `json`. Default is `text`. Defaults to `text`.
        """
        return pulumi.get(self, "message_format")

    @message_format.setter
    def message_format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message_format", value)

    @_builtins.property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        AWS secret access key used to authenticate with Amazon SNS.
        """
        return pulumi.get(self, "secret_key")

    @secret_key.setter
    def secret_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_key", value)

    @_builtins.property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "settings", value)

    @_builtins.property
    @pulumi.getter
    def subject(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "subject")

    @subject.setter
    def subject(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subject", value)

    @_builtins.property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uid", value)


if not MYPY:
    class ContactPointTeamArgsDict(TypedDict):
        url: pulumi.Input[_builtins.str]
        """
        A Teams webhook URL.
        """
        disable_resolve_message: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        message: NotRequired[pulumi.Input[_builtins.str]]
        """
        The templated message content to send.
        """
        section_title: NotRequired[pulumi.Input[_builtins.str]]
        """
        The templated subtitle for each message section.
        """
        settings: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        title: NotRequired[pulumi.Input[_builtins.str]]
        """
        The templated title of the message.
        """
        uid: NotRequired[pulumi.Input[_builtins.str]]
        """
        The UID of the contact point.
        """
elif False:
    ContactPointTeamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContactPointTeamArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[_builtins.str],
                 disable_resolve_message: Optional[pulumi.Input[_builtins.bool]] = None,
                 message: Optional[pulumi.Input[_builtins.str]] = None,
                 section_title: Optional[pulumi.Input[_builtins.str]] = None,
                 settings: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 title: Optional[pulumi.Input[_builtins.str]] = None,
                 uid: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] url: A Teams webhook URL.
        :param pulumi.Input[_builtins.bool] disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param pulumi.Input[_builtins.str] message: The templated message content to send.
        :param pulumi.Input[_builtins.str] section_title: The templated subtitle for each message section.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param pulumi.Input[_builtins.str] title: The templated title of the message.
        :param pulumi.Input[_builtins.str] uid: The UID of the contact point.
        """
        pulumi.set(__self__, "url", url)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if section_title is not None:
            pulumi.set(__self__, "section_title", section_title)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        A Teams webhook URL.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @disable_resolve_message.setter
    def disable_resolve_message(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disable_resolve_message", value)

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The templated message content to send.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message", value)

    @_builtins.property
    @pulumi.getter(name="sectionTitle")
    def section_title(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The templated subtitle for each message section.
        """
        return pulumi.get(self, "section_title")

    @section_title.setter
    def section_title(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "section_title", value)

    @_builtins.property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "settings", value)

    @_builtins.property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The templated title of the message.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "title", value)

    @_builtins.property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uid", value)


if not MYPY:
    class ContactPointTelegramArgsDict(TypedDict):
        chat_id: pulumi.Input[_builtins.str]
        """
        The chat ID to send messages to.
        """
        token: pulumi.Input[_builtins.str]
        """
        The Telegram bot token.
        """
        disable_notifications: NotRequired[pulumi.Input[_builtins.bool]]
        """
        When set users will receive a notification with no sound.
        """
        disable_resolve_message: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        disable_web_page_preview: NotRequired[pulumi.Input[_builtins.bool]]
        """
        When set it disables link previews for links in the message.
        """
        message: NotRequired[pulumi.Input[_builtins.str]]
        """
        The templated content of the message.
        """
        message_thread_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the message thread to send the message to.
        """
        parse_mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        Mode for parsing entities in the message text. Supported: None, Markdown, MarkdownV2, and HTML. HTML is the default.
        """
        protect_content: NotRequired[pulumi.Input[_builtins.bool]]
        """
        When set it protects the contents of the message from forwarding and saving.
        """
        settings: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        uid: NotRequired[pulumi.Input[_builtins.str]]
        """
        The UID of the contact point.
        """
elif False:
    ContactPointTelegramArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContactPointTelegramArgs:
    def __init__(__self__, *,
                 chat_id: pulumi.Input[_builtins.str],
                 token: pulumi.Input[_builtins.str],
                 disable_notifications: Optional[pulumi.Input[_builtins.bool]] = None,
                 disable_resolve_message: Optional[pulumi.Input[_builtins.bool]] = None,
                 disable_web_page_preview: Optional[pulumi.Input[_builtins.bool]] = None,
                 message: Optional[pulumi.Input[_builtins.str]] = None,
                 message_thread_id: Optional[pulumi.Input[_builtins.str]] = None,
                 parse_mode: Optional[pulumi.Input[_builtins.str]] = None,
                 protect_content: Optional[pulumi.Input[_builtins.bool]] = None,
                 settings: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 uid: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] chat_id: The chat ID to send messages to.
        :param pulumi.Input[_builtins.str] token: The Telegram bot token.
        :param pulumi.Input[_builtins.bool] disable_notifications: When set users will receive a notification with no sound.
        :param pulumi.Input[_builtins.bool] disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param pulumi.Input[_builtins.bool] disable_web_page_preview: When set it disables link previews for links in the message.
        :param pulumi.Input[_builtins.str] message: The templated content of the message.
        :param pulumi.Input[_builtins.str] message_thread_id: The ID of the message thread to send the message to.
        :param pulumi.Input[_builtins.str] parse_mode: Mode for parsing entities in the message text. Supported: None, Markdown, MarkdownV2, and HTML. HTML is the default.
        :param pulumi.Input[_builtins.bool] protect_content: When set it protects the contents of the message from forwarding and saving.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param pulumi.Input[_builtins.str] uid: The UID of the contact point.
        """
        pulumi.set(__self__, "chat_id", chat_id)
        pulumi.set(__self__, "token", token)
        if disable_notifications is not None:
            pulumi.set(__self__, "disable_notifications", disable_notifications)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if disable_web_page_preview is not None:
            pulumi.set(__self__, "disable_web_page_preview", disable_web_page_preview)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if message_thread_id is not None:
            pulumi.set(__self__, "message_thread_id", message_thread_id)
        if parse_mode is not None:
            pulumi.set(__self__, "parse_mode", parse_mode)
        if protect_content is not None:
            pulumi.set(__self__, "protect_content", protect_content)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @_builtins.property
    @pulumi.getter(name="chatId")
    def chat_id(self) -> pulumi.Input[_builtins.str]:
        """
        The chat ID to send messages to.
        """
        return pulumi.get(self, "chat_id")

    @chat_id.setter
    def chat_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "chat_id", value)

    @_builtins.property
    @pulumi.getter
    def token(self) -> pulumi.Input[_builtins.str]:
        """
        The Telegram bot token.
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "token", value)

    @_builtins.property
    @pulumi.getter(name="disableNotifications")
    def disable_notifications(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        When set users will receive a notification with no sound.
        """
        return pulumi.get(self, "disable_notifications")

    @disable_notifications.setter
    def disable_notifications(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disable_notifications", value)

    @_builtins.property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @disable_resolve_message.setter
    def disable_resolve_message(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disable_resolve_message", value)

    @_builtins.property
    @pulumi.getter(name="disableWebPagePreview")
    def disable_web_page_preview(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        When set it disables link previews for links in the message.
        """
        return pulumi.get(self, "disable_web_page_preview")

    @disable_web_page_preview.setter
    def disable_web_page_preview(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disable_web_page_preview", value)

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The templated content of the message.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message", value)

    @_builtins.property
    @pulumi.getter(name="messageThreadId")
    def message_thread_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the message thread to send the message to.
        """
        return pulumi.get(self, "message_thread_id")

    @message_thread_id.setter
    def message_thread_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message_thread_id", value)

    @_builtins.property
    @pulumi.getter(name="parseMode")
    def parse_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Mode for parsing entities in the message text. Supported: None, Markdown, MarkdownV2, and HTML. HTML is the default.
        """
        return pulumi.get(self, "parse_mode")

    @parse_mode.setter
    def parse_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "parse_mode", value)

    @_builtins.property
    @pulumi.getter(name="protectContent")
    def protect_content(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        When set it protects the contents of the message from forwarding and saving.
        """
        return pulumi.get(self, "protect_content")

    @protect_content.setter
    def protect_content(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "protect_content", value)

    @_builtins.property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "settings", value)

    @_builtins.property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uid", value)


if not MYPY:
    class ContactPointThreemaArgsDict(TypedDict):
        api_secret: pulumi.Input[_builtins.str]
        """
        The Threema API key.
        """
        gateway_id: pulumi.Input[_builtins.str]
        """
        The Threema gateway ID.
        """
        recipient_id: pulumi.Input[_builtins.str]
        """
        The ID of the recipient of the message.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        The templated description of the message.
        """
        disable_resolve_message: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        settings: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        title: NotRequired[pulumi.Input[_builtins.str]]
        """
        The templated title of the message.
        """
        uid: NotRequired[pulumi.Input[_builtins.str]]
        """
        The UID of the contact point.
        """
elif False:
    ContactPointThreemaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContactPointThreemaArgs:
    def __init__(__self__, *,
                 api_secret: pulumi.Input[_builtins.str],
                 gateway_id: pulumi.Input[_builtins.str],
                 recipient_id: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 disable_resolve_message: Optional[pulumi.Input[_builtins.bool]] = None,
                 settings: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 title: Optional[pulumi.Input[_builtins.str]] = None,
                 uid: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] api_secret: The Threema API key.
        :param pulumi.Input[_builtins.str] gateway_id: The Threema gateway ID.
        :param pulumi.Input[_builtins.str] recipient_id: The ID of the recipient of the message.
        :param pulumi.Input[_builtins.str] description: The templated description of the message.
        :param pulumi.Input[_builtins.bool] disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param pulumi.Input[_builtins.str] title: The templated title of the message.
        :param pulumi.Input[_builtins.str] uid: The UID of the contact point.
        """
        pulumi.set(__self__, "api_secret", api_secret)
        pulumi.set(__self__, "gateway_id", gateway_id)
        pulumi.set(__self__, "recipient_id", recipient_id)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @_builtins.property
    @pulumi.getter(name="apiSecret")
    def api_secret(self) -> pulumi.Input[_builtins.str]:
        """
        The Threema API key.
        """
        return pulumi.get(self, "api_secret")

    @api_secret.setter
    def api_secret(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "api_secret", value)

    @_builtins.property
    @pulumi.getter(name="gatewayId")
    def gateway_id(self) -> pulumi.Input[_builtins.str]:
        """
        The Threema gateway ID.
        """
        return pulumi.get(self, "gateway_id")

    @gateway_id.setter
    def gateway_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "gateway_id", value)

    @_builtins.property
    @pulumi.getter(name="recipientId")
    def recipient_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the recipient of the message.
        """
        return pulumi.get(self, "recipient_id")

    @recipient_id.setter
    def recipient_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "recipient_id", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The templated description of the message.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @disable_resolve_message.setter
    def disable_resolve_message(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disable_resolve_message", value)

    @_builtins.property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "settings", value)

    @_builtins.property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The templated title of the message.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "title", value)

    @_builtins.property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uid", value)


if not MYPY:
    class ContactPointVictoropArgsDict(TypedDict):
        url: pulumi.Input[_builtins.str]
        """
        The VictorOps webhook URL.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Templated description of the message.
        """
        disable_resolve_message: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        message_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The VictorOps alert state - typically either `CRITICAL` or `RECOVERY`.
        """
        settings: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        title: NotRequired[pulumi.Input[_builtins.str]]
        """
        Templated title to display.
        """
        uid: NotRequired[pulumi.Input[_builtins.str]]
        """
        The UID of the contact point.
        """
elif False:
    ContactPointVictoropArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContactPointVictoropArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 disable_resolve_message: Optional[pulumi.Input[_builtins.bool]] = None,
                 message_type: Optional[pulumi.Input[_builtins.str]] = None,
                 settings: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 title: Optional[pulumi.Input[_builtins.str]] = None,
                 uid: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] url: The VictorOps webhook URL.
        :param pulumi.Input[_builtins.str] description: Templated description of the message.
        :param pulumi.Input[_builtins.bool] disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param pulumi.Input[_builtins.str] message_type: The VictorOps alert state - typically either `CRITICAL` or `RECOVERY`.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param pulumi.Input[_builtins.str] title: Templated title to display.
        :param pulumi.Input[_builtins.str] uid: The UID of the contact point.
        """
        pulumi.set(__self__, "url", url)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if message_type is not None:
            pulumi.set(__self__, "message_type", message_type)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        The VictorOps webhook URL.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Templated description of the message.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @disable_resolve_message.setter
    def disable_resolve_message(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disable_resolve_message", value)

    @_builtins.property
    @pulumi.getter(name="messageType")
    def message_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The VictorOps alert state - typically either `CRITICAL` or `RECOVERY`.
        """
        return pulumi.get(self, "message_type")

    @message_type.setter
    def message_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message_type", value)

    @_builtins.property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "settings", value)

    @_builtins.property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Templated title to display.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "title", value)

    @_builtins.property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uid", value)


if not MYPY:
    class ContactPointWebexArgsDict(TypedDict):
        room_id: pulumi.Input[_builtins.str]
        """
        ID of the Webex Teams room where to send the messages.
        """
        token: pulumi.Input[_builtins.str]
        """
        The bearer token used to authorize the client.
        """
        api_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL to send webhook requests to.
        """
        disable_resolve_message: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        message: NotRequired[pulumi.Input[_builtins.str]]
        """
        The templated title of the message to send.
        """
        settings: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        uid: NotRequired[pulumi.Input[_builtins.str]]
        """
        The UID of the contact point.
        """
elif False:
    ContactPointWebexArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContactPointWebexArgs:
    def __init__(__self__, *,
                 room_id: pulumi.Input[_builtins.str],
                 token: pulumi.Input[_builtins.str],
                 api_url: Optional[pulumi.Input[_builtins.str]] = None,
                 disable_resolve_message: Optional[pulumi.Input[_builtins.bool]] = None,
                 message: Optional[pulumi.Input[_builtins.str]] = None,
                 settings: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 uid: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] room_id: ID of the Webex Teams room where to send the messages.
        :param pulumi.Input[_builtins.str] token: The bearer token used to authorize the client.
        :param pulumi.Input[_builtins.str] api_url: The URL to send webhook requests to.
        :param pulumi.Input[_builtins.bool] disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param pulumi.Input[_builtins.str] message: The templated title of the message to send.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param pulumi.Input[_builtins.str] uid: The UID of the contact point.
        """
        pulumi.set(__self__, "room_id", room_id)
        pulumi.set(__self__, "token", token)
        if api_url is not None:
            pulumi.set(__self__, "api_url", api_url)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @_builtins.property
    @pulumi.getter(name="roomId")
    def room_id(self) -> pulumi.Input[_builtins.str]:
        """
        ID of the Webex Teams room where to send the messages.
        """
        return pulumi.get(self, "room_id")

    @room_id.setter
    def room_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "room_id", value)

    @_builtins.property
    @pulumi.getter
    def token(self) -> pulumi.Input[_builtins.str]:
        """
        The bearer token used to authorize the client.
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "token", value)

    @_builtins.property
    @pulumi.getter(name="apiUrl")
    def api_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL to send webhook requests to.
        """
        return pulumi.get(self, "api_url")

    @api_url.setter
    def api_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "api_url", value)

    @_builtins.property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @disable_resolve_message.setter
    def disable_resolve_message(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disable_resolve_message", value)

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The templated title of the message to send.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message", value)

    @_builtins.property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "settings", value)

    @_builtins.property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uid", value)


if not MYPY:
    class ContactPointWebhookArgsDict(TypedDict):
        url: pulumi.Input[_builtins.str]
        """
        The URL to send webhook requests to.
        """
        authorization_credentials: NotRequired[pulumi.Input[_builtins.str]]
        """
        Allows a custom authorization scheme - attaches an auth header with this value. Do not use in conjunction with basic auth parameters.
        """
        authorization_scheme: NotRequired[pulumi.Input[_builtins.str]]
        """
        Allows a custom authorization scheme - attaches an auth header with this name. Do not use in conjunction with basic auth parameters.
        """
        basic_auth_password: NotRequired[pulumi.Input[_builtins.str]]
        """
        The username to use in basic auth headers attached to the request. If omitted, basic auth will not be used.
        """
        basic_auth_user: NotRequired[pulumi.Input[_builtins.str]]
        """
        The username to use in basic auth headers attached to the request. If omitted, basic auth will not be used.
        """
        disable_resolve_message: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        headers: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Custom headers to attach to the request.
        """
        hmac_config: NotRequired[pulumi.Input['ContactPointWebhookHmacConfigArgsDict']]
        """
        HMAC signature configuration options.
        """
        http_config: NotRequired[pulumi.Input['ContactPointWebhookHttpConfigArgsDict']]
        """
        Common HTTP client options.
        """
        http_method: NotRequired[pulumi.Input[_builtins.str]]
        """
        The HTTP method to use in the request. Defaults to `POST`.
        """
        max_alerts: NotRequired[pulumi.Input[_builtins.int]]
        """
        The maximum number of alerts to send in a single request. This can be helpful in limiting the size of the request body. The default is 0, which indicates no limit.
        """
        message: NotRequired[pulumi.Input[_builtins.str]]
        """
        Custom message. You can use template variables.
        """
        payload: NotRequired[pulumi.Input['ContactPointWebhookPayloadArgsDict']]
        """
        Optionally provide a templated payload. Overrides 'Message' and 'Title' field.
        """
        settings: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        title: NotRequired[pulumi.Input[_builtins.str]]
        """
        Templated title of the message.
        """
        tls_config: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Allows configuring TLS for the webhook notifier.
        """
        uid: NotRequired[pulumi.Input[_builtins.str]]
        """
        The UID of the contact point.
        """
elif False:
    ContactPointWebhookArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContactPointWebhookArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[_builtins.str],
                 authorization_credentials: Optional[pulumi.Input[_builtins.str]] = None,
                 authorization_scheme: Optional[pulumi.Input[_builtins.str]] = None,
                 basic_auth_password: Optional[pulumi.Input[_builtins.str]] = None,
                 basic_auth_user: Optional[pulumi.Input[_builtins.str]] = None,
                 disable_resolve_message: Optional[pulumi.Input[_builtins.bool]] = None,
                 headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 hmac_config: Optional[pulumi.Input['ContactPointWebhookHmacConfigArgs']] = None,
                 http_config: Optional[pulumi.Input['ContactPointWebhookHttpConfigArgs']] = None,
                 http_method: Optional[pulumi.Input[_builtins.str]] = None,
                 max_alerts: Optional[pulumi.Input[_builtins.int]] = None,
                 message: Optional[pulumi.Input[_builtins.str]] = None,
                 payload: Optional[pulumi.Input['ContactPointWebhookPayloadArgs']] = None,
                 settings: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 title: Optional[pulumi.Input[_builtins.str]] = None,
                 tls_config: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 uid: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] url: The URL to send webhook requests to.
        :param pulumi.Input[_builtins.str] authorization_credentials: Allows a custom authorization scheme - attaches an auth header with this value. Do not use in conjunction with basic auth parameters.
        :param pulumi.Input[_builtins.str] authorization_scheme: Allows a custom authorization scheme - attaches an auth header with this name. Do not use in conjunction with basic auth parameters.
        :param pulumi.Input[_builtins.str] basic_auth_password: The username to use in basic auth headers attached to the request. If omitted, basic auth will not be used.
        :param pulumi.Input[_builtins.str] basic_auth_user: The username to use in basic auth headers attached to the request. If omitted, basic auth will not be used.
        :param pulumi.Input[_builtins.bool] disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] headers: Custom headers to attach to the request.
        :param pulumi.Input['ContactPointWebhookHmacConfigArgs'] hmac_config: HMAC signature configuration options.
        :param pulumi.Input['ContactPointWebhookHttpConfigArgs'] http_config: Common HTTP client options.
        :param pulumi.Input[_builtins.str] http_method: The HTTP method to use in the request. Defaults to `POST`.
        :param pulumi.Input[_builtins.int] max_alerts: The maximum number of alerts to send in a single request. This can be helpful in limiting the size of the request body. The default is 0, which indicates no limit.
        :param pulumi.Input[_builtins.str] message: Custom message. You can use template variables.
        :param pulumi.Input['ContactPointWebhookPayloadArgs'] payload: Optionally provide a templated payload. Overrides 'Message' and 'Title' field.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param pulumi.Input[_builtins.str] title: Templated title of the message.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tls_config: Allows configuring TLS for the webhook notifier.
        :param pulumi.Input[_builtins.str] uid: The UID of the contact point.
        """
        pulumi.set(__self__, "url", url)
        if authorization_credentials is not None:
            pulumi.set(__self__, "authorization_credentials", authorization_credentials)
        if authorization_scheme is not None:
            pulumi.set(__self__, "authorization_scheme", authorization_scheme)
        if basic_auth_password is not None:
            pulumi.set(__self__, "basic_auth_password", basic_auth_password)
        if basic_auth_user is not None:
            pulumi.set(__self__, "basic_auth_user", basic_auth_user)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if hmac_config is not None:
            pulumi.set(__self__, "hmac_config", hmac_config)
        if http_config is not None:
            pulumi.set(__self__, "http_config", http_config)
        if http_method is not None:
            pulumi.set(__self__, "http_method", http_method)
        if max_alerts is not None:
            pulumi.set(__self__, "max_alerts", max_alerts)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if payload is not None:
            pulumi.set(__self__, "payload", payload)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if tls_config is not None:
            pulumi.set(__self__, "tls_config", tls_config)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        The URL to send webhook requests to.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="authorizationCredentials")
    def authorization_credentials(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Allows a custom authorization scheme - attaches an auth header with this value. Do not use in conjunction with basic auth parameters.
        """
        return pulumi.get(self, "authorization_credentials")

    @authorization_credentials.setter
    def authorization_credentials(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "authorization_credentials", value)

    @_builtins.property
    @pulumi.getter(name="authorizationScheme")
    def authorization_scheme(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Allows a custom authorization scheme - attaches an auth header with this name. Do not use in conjunction with basic auth parameters.
        """
        return pulumi.get(self, "authorization_scheme")

    @authorization_scheme.setter
    def authorization_scheme(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "authorization_scheme", value)

    @_builtins.property
    @pulumi.getter(name="basicAuthPassword")
    def basic_auth_password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The username to use in basic auth headers attached to the request. If omitted, basic auth will not be used.
        """
        return pulumi.get(self, "basic_auth_password")

    @basic_auth_password.setter
    def basic_auth_password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "basic_auth_password", value)

    @_builtins.property
    @pulumi.getter(name="basicAuthUser")
    def basic_auth_user(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The username to use in basic auth headers attached to the request. If omitted, basic auth will not be used.
        """
        return pulumi.get(self, "basic_auth_user")

    @basic_auth_user.setter
    def basic_auth_user(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "basic_auth_user", value)

    @_builtins.property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @disable_resolve_message.setter
    def disable_resolve_message(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disable_resolve_message", value)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Custom headers to attach to the request.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "headers", value)

    @_builtins.property
    @pulumi.getter(name="hmacConfig")
    def hmac_config(self) -> Optional[pulumi.Input['ContactPointWebhookHmacConfigArgs']]:
        """
        HMAC signature configuration options.
        """
        return pulumi.get(self, "hmac_config")

    @hmac_config.setter
    def hmac_config(self, value: Optional[pulumi.Input['ContactPointWebhookHmacConfigArgs']]):
        pulumi.set(self, "hmac_config", value)

    @_builtins.property
    @pulumi.getter(name="httpConfig")
    def http_config(self) -> Optional[pulumi.Input['ContactPointWebhookHttpConfigArgs']]:
        """
        Common HTTP client options.
        """
        return pulumi.get(self, "http_config")

    @http_config.setter
    def http_config(self, value: Optional[pulumi.Input['ContactPointWebhookHttpConfigArgs']]):
        pulumi.set(self, "http_config", value)

    @_builtins.property
    @pulumi.getter(name="httpMethod")
    def http_method(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The HTTP method to use in the request. Defaults to `POST`.
        """
        return pulumi.get(self, "http_method")

    @http_method.setter
    def http_method(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "http_method", value)

    @_builtins.property
    @pulumi.getter(name="maxAlerts")
    def max_alerts(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The maximum number of alerts to send in a single request. This can be helpful in limiting the size of the request body. The default is 0, which indicates no limit.
        """
        return pulumi.get(self, "max_alerts")

    @max_alerts.setter
    def max_alerts(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_alerts", value)

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Custom message. You can use template variables.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message", value)

    @_builtins.property
    @pulumi.getter
    def payload(self) -> Optional[pulumi.Input['ContactPointWebhookPayloadArgs']]:
        """
        Optionally provide a templated payload. Overrides 'Message' and 'Title' field.
        """
        return pulumi.get(self, "payload")

    @payload.setter
    def payload(self, value: Optional[pulumi.Input['ContactPointWebhookPayloadArgs']]):
        pulumi.set(self, "payload", value)

    @_builtins.property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "settings", value)

    @_builtins.property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Templated title of the message.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "title", value)

    @_builtins.property
    @pulumi.getter(name="tlsConfig")
    def tls_config(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Allows configuring TLS for the webhook notifier.
        """
        return pulumi.get(self, "tls_config")

    @tls_config.setter
    def tls_config(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tls_config", value)

    @_builtins.property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uid", value)


if not MYPY:
    class ContactPointWebhookHmacConfigArgsDict(TypedDict):
        secret: pulumi.Input[_builtins.str]
        """
        The secret key used to generate the HMAC signature.
        """
        header: NotRequired[pulumi.Input[_builtins.str]]
        """
        The header in which the HMAC signature will be included. Defaults to `X-Grafana-Alerting-Signature`.
        """
        timestamp_header: NotRequired[pulumi.Input[_builtins.str]]
        """
        If set, the timestamp will be included in the HMAC signature. The value should be the name of the header to use.
        """
elif False:
    ContactPointWebhookHmacConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContactPointWebhookHmacConfigArgs:
    def __init__(__self__, *,
                 secret: pulumi.Input[_builtins.str],
                 header: Optional[pulumi.Input[_builtins.str]] = None,
                 timestamp_header: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] secret: The secret key used to generate the HMAC signature.
        :param pulumi.Input[_builtins.str] header: The header in which the HMAC signature will be included. Defaults to `X-Grafana-Alerting-Signature`.
        :param pulumi.Input[_builtins.str] timestamp_header: If set, the timestamp will be included in the HMAC signature. The value should be the name of the header to use.
        """
        pulumi.set(__self__, "secret", secret)
        if header is not None:
            pulumi.set(__self__, "header", header)
        if timestamp_header is not None:
            pulumi.set(__self__, "timestamp_header", timestamp_header)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> pulumi.Input[_builtins.str]:
        """
        The secret key used to generate the HMAC signature.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "secret", value)

    @_builtins.property
    @pulumi.getter
    def header(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The header in which the HMAC signature will be included. Defaults to `X-Grafana-Alerting-Signature`.
        """
        return pulumi.get(self, "header")

    @header.setter
    def header(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "header", value)

    @_builtins.property
    @pulumi.getter(name="timestampHeader")
    def timestamp_header(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        If set, the timestamp will be included in the HMAC signature. The value should be the name of the header to use.
        """
        return pulumi.get(self, "timestamp_header")

    @timestamp_header.setter
    def timestamp_header(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "timestamp_header", value)


if not MYPY:
    class ContactPointWebhookHttpConfigArgsDict(TypedDict):
        oauth2: NotRequired[pulumi.Input['ContactPointWebhookHttpConfigOauth2ArgsDict']]
        """
        OAuth2 configuration options.
        """
elif False:
    ContactPointWebhookHttpConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContactPointWebhookHttpConfigArgs:
    def __init__(__self__, *,
                 oauth2: Optional[pulumi.Input['ContactPointWebhookHttpConfigOauth2Args']] = None):
        """
        :param pulumi.Input['ContactPointWebhookHttpConfigOauth2Args'] oauth2: OAuth2 configuration options.
        """
        if oauth2 is not None:
            pulumi.set(__self__, "oauth2", oauth2)

    @_builtins.property
    @pulumi.getter
    def oauth2(self) -> Optional[pulumi.Input['ContactPointWebhookHttpConfigOauth2Args']]:
        """
        OAuth2 configuration options.
        """
        return pulumi.get(self, "oauth2")

    @oauth2.setter
    def oauth2(self, value: Optional[pulumi.Input['ContactPointWebhookHttpConfigOauth2Args']]):
        pulumi.set(self, "oauth2", value)


if not MYPY:
    class ContactPointWebhookHttpConfigOauth2ArgsDict(TypedDict):
        client_id: pulumi.Input[_builtins.str]
        """
        Client ID to use when authenticating.
        """
        client_secret: pulumi.Input[_builtins.str]
        """
        Client secret to use when authenticating.
        """
        token_url: pulumi.Input[_builtins.str]
        """
        URL for the access token endpoint.
        """
        endpoint_params: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Optional parameters to append to the access token request.
        """
        proxy_config: NotRequired[pulumi.Input['ContactPointWebhookHttpConfigOauth2ProxyConfigArgsDict']]
        """
        Optional proxy configuration for OAuth2 requests.
        """
        scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Optional scopes to request when obtaining an access token.
        """
        tls_config: NotRequired[pulumi.Input['ContactPointWebhookHttpConfigOauth2TlsConfigArgsDict']]
        """
        Optional TLS configuration options for OAuth2 requests.
        """
elif False:
    ContactPointWebhookHttpConfigOauth2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContactPointWebhookHttpConfigOauth2Args:
    def __init__(__self__, *,
                 client_id: pulumi.Input[_builtins.str],
                 client_secret: pulumi.Input[_builtins.str],
                 token_url: pulumi.Input[_builtins.str],
                 endpoint_params: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 proxy_config: Optional[pulumi.Input['ContactPointWebhookHttpConfigOauth2ProxyConfigArgs']] = None,
                 scopes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 tls_config: Optional[pulumi.Input['ContactPointWebhookHttpConfigOauth2TlsConfigArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] client_id: Client ID to use when authenticating.
        :param pulumi.Input[_builtins.str] client_secret: Client secret to use when authenticating.
        :param pulumi.Input[_builtins.str] token_url: URL for the access token endpoint.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] endpoint_params: Optional parameters to append to the access token request.
        :param pulumi.Input['ContactPointWebhookHttpConfigOauth2ProxyConfigArgs'] proxy_config: Optional proxy configuration for OAuth2 requests.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] scopes: Optional scopes to request when obtaining an access token.
        :param pulumi.Input['ContactPointWebhookHttpConfigOauth2TlsConfigArgs'] tls_config: Optional TLS configuration options for OAuth2 requests.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "token_url", token_url)
        if endpoint_params is not None:
            pulumi.set(__self__, "endpoint_params", endpoint_params)
        if proxy_config is not None:
            pulumi.set(__self__, "proxy_config", proxy_config)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if tls_config is not None:
            pulumi.set(__self__, "tls_config", tls_config)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[_builtins.str]:
        """
        Client ID to use when authenticating.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "client_id", value)

    @_builtins.property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> pulumi.Input[_builtins.str]:
        """
        Client secret to use when authenticating.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "client_secret", value)

    @_builtins.property
    @pulumi.getter(name="tokenUrl")
    def token_url(self) -> pulumi.Input[_builtins.str]:
        """
        URL for the access token endpoint.
        """
        return pulumi.get(self, "token_url")

    @token_url.setter
    def token_url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "token_url", value)

    @_builtins.property
    @pulumi.getter(name="endpointParams")
    def endpoint_params(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Optional parameters to append to the access token request.
        """
        return pulumi.get(self, "endpoint_params")

    @endpoint_params.setter
    def endpoint_params(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "endpoint_params", value)

    @_builtins.property
    @pulumi.getter(name="proxyConfig")
    def proxy_config(self) -> Optional[pulumi.Input['ContactPointWebhookHttpConfigOauth2ProxyConfigArgs']]:
        """
        Optional proxy configuration for OAuth2 requests.
        """
        return pulumi.get(self, "proxy_config")

    @proxy_config.setter
    def proxy_config(self, value: Optional[pulumi.Input['ContactPointWebhookHttpConfigOauth2ProxyConfigArgs']]):
        pulumi.set(self, "proxy_config", value)

    @_builtins.property
    @pulumi.getter
    def scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Optional scopes to request when obtaining an access token.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "scopes", value)

    @_builtins.property
    @pulumi.getter(name="tlsConfig")
    def tls_config(self) -> Optional[pulumi.Input['ContactPointWebhookHttpConfigOauth2TlsConfigArgs']]:
        """
        Optional TLS configuration options for OAuth2 requests.
        """
        return pulumi.get(self, "tls_config")

    @tls_config.setter
    def tls_config(self, value: Optional[pulumi.Input['ContactPointWebhookHttpConfigOauth2TlsConfigArgs']]):
        pulumi.set(self, "tls_config", value)


if not MYPY:
    class ContactPointWebhookHttpConfigOauth2ProxyConfigArgsDict(TypedDict):
        no_proxy: NotRequired[pulumi.Input[_builtins.str]]
        """
        Comma-separated list of addresses that should not use a proxy.
        """
        proxy_connect_header: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Optional headers to send to proxies during CONNECT requests.
        """
        proxy_from_environment: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Use environment HTTP*PROXY, HTTPS*PROXY and NO_PROXY to determine proxies. Defaults to `false`.
        """
        proxy_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        HTTP proxy server to use to connect to the targets.
        """
elif False:
    ContactPointWebhookHttpConfigOauth2ProxyConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContactPointWebhookHttpConfigOauth2ProxyConfigArgs:
    def __init__(__self__, *,
                 no_proxy: Optional[pulumi.Input[_builtins.str]] = None,
                 proxy_connect_header: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 proxy_from_environment: Optional[pulumi.Input[_builtins.bool]] = None,
                 proxy_url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] no_proxy: Comma-separated list of addresses that should not use a proxy.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] proxy_connect_header: Optional headers to send to proxies during CONNECT requests.
        :param pulumi.Input[_builtins.bool] proxy_from_environment: Use environment HTTP*PROXY, HTTPS*PROXY and NO_PROXY to determine proxies. Defaults to `false`.
        :param pulumi.Input[_builtins.str] proxy_url: HTTP proxy server to use to connect to the targets.
        """
        if no_proxy is not None:
            pulumi.set(__self__, "no_proxy", no_proxy)
        if proxy_connect_header is not None:
            pulumi.set(__self__, "proxy_connect_header", proxy_connect_header)
        if proxy_from_environment is not None:
            pulumi.set(__self__, "proxy_from_environment", proxy_from_environment)
        if proxy_url is not None:
            pulumi.set(__self__, "proxy_url", proxy_url)

    @_builtins.property
    @pulumi.getter(name="noProxy")
    def no_proxy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Comma-separated list of addresses that should not use a proxy.
        """
        return pulumi.get(self, "no_proxy")

    @no_proxy.setter
    def no_proxy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "no_proxy", value)

    @_builtins.property
    @pulumi.getter(name="proxyConnectHeader")
    def proxy_connect_header(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Optional headers to send to proxies during CONNECT requests.
        """
        return pulumi.get(self, "proxy_connect_header")

    @proxy_connect_header.setter
    def proxy_connect_header(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "proxy_connect_header", value)

    @_builtins.property
    @pulumi.getter(name="proxyFromEnvironment")
    def proxy_from_environment(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Use environment HTTP*PROXY, HTTPS*PROXY and NO_PROXY to determine proxies. Defaults to `false`.
        """
        return pulumi.get(self, "proxy_from_environment")

    @proxy_from_environment.setter
    def proxy_from_environment(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "proxy_from_environment", value)

    @_builtins.property
    @pulumi.getter(name="proxyUrl")
    def proxy_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        HTTP proxy server to use to connect to the targets.
        """
        return pulumi.get(self, "proxy_url")

    @proxy_url.setter
    def proxy_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_url", value)


if not MYPY:
    class ContactPointWebhookHttpConfigOauth2TlsConfigArgsDict(TypedDict):
        ca_certificate: NotRequired[pulumi.Input[_builtins.str]]
        """
        Certificate in PEM format to use when verifying the server's certificate chain.
        """
        client_certificate: NotRequired[pulumi.Input[_builtins.str]]
        """
        Client certificate in PEM format to use when connecting to the server.
        """
        client_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Client key in PEM format to use when connecting to the server.
        """
        insecure_skip_verify: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Do not verify the server's certificate chain and host name. Defaults to `false`.
        """
elif False:
    ContactPointWebhookHttpConfigOauth2TlsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContactPointWebhookHttpConfigOauth2TlsConfigArgs:
    def __init__(__self__, *,
                 ca_certificate: Optional[pulumi.Input[_builtins.str]] = None,
                 client_certificate: Optional[pulumi.Input[_builtins.str]] = None,
                 client_key: Optional[pulumi.Input[_builtins.str]] = None,
                 insecure_skip_verify: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] ca_certificate: Certificate in PEM format to use when verifying the server's certificate chain.
        :param pulumi.Input[_builtins.str] client_certificate: Client certificate in PEM format to use when connecting to the server.
        :param pulumi.Input[_builtins.str] client_key: Client key in PEM format to use when connecting to the server.
        :param pulumi.Input[_builtins.bool] insecure_skip_verify: Do not verify the server's certificate chain and host name. Defaults to `false`.
        """
        if ca_certificate is not None:
            pulumi.set(__self__, "ca_certificate", ca_certificate)
        if client_certificate is not None:
            pulumi.set(__self__, "client_certificate", client_certificate)
        if client_key is not None:
            pulumi.set(__self__, "client_key", client_key)
        if insecure_skip_verify is not None:
            pulumi.set(__self__, "insecure_skip_verify", insecure_skip_verify)

    @_builtins.property
    @pulumi.getter(name="caCertificate")
    def ca_certificate(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Certificate in PEM format to use when verifying the server's certificate chain.
        """
        return pulumi.get(self, "ca_certificate")

    @ca_certificate.setter
    def ca_certificate(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ca_certificate", value)

    @_builtins.property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Client certificate in PEM format to use when connecting to the server.
        """
        return pulumi.get(self, "client_certificate")

    @client_certificate.setter
    def client_certificate(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_certificate", value)

    @_builtins.property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Client key in PEM format to use when connecting to the server.
        """
        return pulumi.get(self, "client_key")

    @client_key.setter
    def client_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_key", value)

    @_builtins.property
    @pulumi.getter(name="insecureSkipVerify")
    def insecure_skip_verify(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Do not verify the server's certificate chain and host name. Defaults to `false`.
        """
        return pulumi.get(self, "insecure_skip_verify")

    @insecure_skip_verify.setter
    def insecure_skip_verify(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "insecure_skip_verify", value)


if not MYPY:
    class ContactPointWebhookPayloadArgsDict(TypedDict):
        template: pulumi.Input[_builtins.str]
        """
        Custom payload template.
        """
        vars: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Optionally provide a variables to be used in the payload template. They will be available in the template as `.Vars.<variable_name>`.
        """
elif False:
    ContactPointWebhookPayloadArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContactPointWebhookPayloadArgs:
    def __init__(__self__, *,
                 template: pulumi.Input[_builtins.str],
                 vars: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] template: Custom payload template.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] vars: Optionally provide a variables to be used in the payload template. They will be available in the template as `.Vars.<variable_name>`.
        """
        pulumi.set(__self__, "template", template)
        if vars is not None:
            pulumi.set(__self__, "vars", vars)

    @_builtins.property
    @pulumi.getter
    def template(self) -> pulumi.Input[_builtins.str]:
        """
        Custom payload template.
        """
        return pulumi.get(self, "template")

    @template.setter
    def template(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "template", value)

    @_builtins.property
    @pulumi.getter
    def vars(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Optionally provide a variables to be used in the payload template. They will be available in the template as `.Vars.<variable_name>`.
        """
        return pulumi.get(self, "vars")

    @vars.setter
    def vars(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "vars", value)


if not MYPY:
    class ContactPointWecomArgsDict(TypedDict):
        agent_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Agent ID added to the request payload when using APIAPP.
        """
        corp_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Corp ID used to get token when using APIAPP.
        """
        disable_resolve_message: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        message: NotRequired[pulumi.Input[_builtins.str]]
        """
        The templated content of the message to send.
        """
        msg_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of them message. Supported: markdown, text. Default: text.
        """
        secret: NotRequired[pulumi.Input[_builtins.str]]
        """
        The secret key required to obtain access token when using APIAPP. See https://work.weixin.qq.com/wework_admin/frame#apps to create APIAPP.
        """
        settings: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        title: NotRequired[pulumi.Input[_builtins.str]]
        """
        The templated title of the message to send.
        """
        to_user: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of user that should receive the message. Multiple entries should be separated by '|'. Default: @all.
        """
        uid: NotRequired[pulumi.Input[_builtins.str]]
        """
        The UID of the contact point.
        """
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        The WeCom webhook URL. Required if using GroupRobot.
        """
elif False:
    ContactPointWecomArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContactPointWecomArgs:
    def __init__(__self__, *,
                 agent_id: Optional[pulumi.Input[_builtins.str]] = None,
                 corp_id: Optional[pulumi.Input[_builtins.str]] = None,
                 disable_resolve_message: Optional[pulumi.Input[_builtins.bool]] = None,
                 message: Optional[pulumi.Input[_builtins.str]] = None,
                 msg_type: Optional[pulumi.Input[_builtins.str]] = None,
                 secret: Optional[pulumi.Input[_builtins.str]] = None,
                 settings: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 title: Optional[pulumi.Input[_builtins.str]] = None,
                 to_user: Optional[pulumi.Input[_builtins.str]] = None,
                 uid: Optional[pulumi.Input[_builtins.str]] = None,
                 url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] agent_id: Agent ID added to the request payload when using APIAPP.
        :param pulumi.Input[_builtins.str] corp_id: Corp ID used to get token when using APIAPP.
        :param pulumi.Input[_builtins.bool] disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param pulumi.Input[_builtins.str] message: The templated content of the message to send.
        :param pulumi.Input[_builtins.str] msg_type: The type of them message. Supported: markdown, text. Default: text.
        :param pulumi.Input[_builtins.str] secret: The secret key required to obtain access token when using APIAPP. See https://work.weixin.qq.com/wework_admin/frame#apps to create APIAPP.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param pulumi.Input[_builtins.str] title: The templated title of the message to send.
        :param pulumi.Input[_builtins.str] to_user: The ID of user that should receive the message. Multiple entries should be separated by '|'. Default: @all.
        :param pulumi.Input[_builtins.str] uid: The UID of the contact point.
        :param pulumi.Input[_builtins.str] url: The WeCom webhook URL. Required if using GroupRobot.
        """
        if agent_id is not None:
            pulumi.set(__self__, "agent_id", agent_id)
        if corp_id is not None:
            pulumi.set(__self__, "corp_id", corp_id)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if msg_type is not None:
            pulumi.set(__self__, "msg_type", msg_type)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if to_user is not None:
            pulumi.set(__self__, "to_user", to_user)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter(name="agentId")
    def agent_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Agent ID added to the request payload when using APIAPP.
        """
        return pulumi.get(self, "agent_id")

    @agent_id.setter
    def agent_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "agent_id", value)

    @_builtins.property
    @pulumi.getter(name="corpId")
    def corp_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Corp ID used to get token when using APIAPP.
        """
        return pulumi.get(self, "corp_id")

    @corp_id.setter
    def corp_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "corp_id", value)

    @_builtins.property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @disable_resolve_message.setter
    def disable_resolve_message(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disable_resolve_message", value)

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The templated content of the message to send.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message", value)

    @_builtins.property
    @pulumi.getter(name="msgType")
    def msg_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of them message. Supported: markdown, text. Default: text.
        """
        return pulumi.get(self, "msg_type")

    @msg_type.setter
    def msg_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "msg_type", value)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The secret key required to obtain access token when using APIAPP. See https://work.weixin.qq.com/wework_admin/frame#apps to create APIAPP.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret", value)

    @_builtins.property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "settings", value)

    @_builtins.property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The templated title of the message to send.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "title", value)

    @_builtins.property
    @pulumi.getter(name="toUser")
    def to_user(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of user that should receive the message. Multiple entries should be separated by '|'. Default: @all.
        """
        return pulumi.get(self, "to_user")

    @to_user.setter
    def to_user(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "to_user", value)

    @_builtins.property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uid", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The WeCom webhook URL. Required if using GroupRobot.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class MuteTimingIntervalArgsDict(TypedDict):
        days_of_months: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        An inclusive range of days, 1-31, within a month, e.g. "1" or "14:16". Negative values can be used to represent days counting from the end of a month, e.g. "-1".
        """
        location: NotRequired[pulumi.Input[_builtins.str]]
        """
        Provides the time zone for the time interval. Must be a location in the IANA time zone database, e.g "America/New_York"
        """
        months: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        An inclusive range of months, either numerical or full calendar month, e.g. "1:3", "december", or "may:august".
        """
        times: NotRequired[pulumi.Input[Sequence[pulumi.Input['MuteTimingIntervalTimeArgsDict']]]]
        """
        The time ranges, represented in minutes, during which to mute in a given day.
        """
        weekdays: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        An inclusive range of weekdays, e.g. "monday" or "tuesday:thursday".
        """
        years: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A positive inclusive range of years, e.g. "2030" or "2025:2026".
        """
elif False:
    MuteTimingIntervalArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MuteTimingIntervalArgs:
    def __init__(__self__, *,
                 days_of_months: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 location: Optional[pulumi.Input[_builtins.str]] = None,
                 months: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 times: Optional[pulumi.Input[Sequence[pulumi.Input['MuteTimingIntervalTimeArgs']]]] = None,
                 weekdays: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 years: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] days_of_months: An inclusive range of days, 1-31, within a month, e.g. "1" or "14:16". Negative values can be used to represent days counting from the end of a month, e.g. "-1".
        :param pulumi.Input[_builtins.str] location: Provides the time zone for the time interval. Must be a location in the IANA time zone database, e.g "America/New_York"
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] months: An inclusive range of months, either numerical or full calendar month, e.g. "1:3", "december", or "may:august".
        :param pulumi.Input[Sequence[pulumi.Input['MuteTimingIntervalTimeArgs']]] times: The time ranges, represented in minutes, during which to mute in a given day.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] weekdays: An inclusive range of weekdays, e.g. "monday" or "tuesday:thursday".
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] years: A positive inclusive range of years, e.g. "2030" or "2025:2026".
        """
        if days_of_months is not None:
            pulumi.set(__self__, "days_of_months", days_of_months)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if months is not None:
            pulumi.set(__self__, "months", months)
        if times is not None:
            pulumi.set(__self__, "times", times)
        if weekdays is not None:
            pulumi.set(__self__, "weekdays", weekdays)
        if years is not None:
            pulumi.set(__self__, "years", years)

    @_builtins.property
    @pulumi.getter(name="daysOfMonths")
    def days_of_months(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        An inclusive range of days, 1-31, within a month, e.g. "1" or "14:16". Negative values can be used to represent days counting from the end of a month, e.g. "-1".
        """
        return pulumi.get(self, "days_of_months")

    @days_of_months.setter
    def days_of_months(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "days_of_months", value)

    @_builtins.property
    @pulumi.getter
    def location(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Provides the time zone for the time interval. Must be a location in the IANA time zone database, e.g "America/New_York"
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "location", value)

    @_builtins.property
    @pulumi.getter
    def months(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        An inclusive range of months, either numerical or full calendar month, e.g. "1:3", "december", or "may:august".
        """
        return pulumi.get(self, "months")

    @months.setter
    def months(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "months", value)

    @_builtins.property
    @pulumi.getter
    def times(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MuteTimingIntervalTimeArgs']]]]:
        """
        The time ranges, represented in minutes, during which to mute in a given day.
        """
        return pulumi.get(self, "times")

    @times.setter
    def times(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MuteTimingIntervalTimeArgs']]]]):
        pulumi.set(self, "times", value)

    @_builtins.property
    @pulumi.getter
    def weekdays(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        An inclusive range of weekdays, e.g. "monday" or "tuesday:thursday".
        """
        return pulumi.get(self, "weekdays")

    @weekdays.setter
    def weekdays(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "weekdays", value)

    @_builtins.property
    @pulumi.getter
    def years(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A positive inclusive range of years, e.g. "2030" or "2025:2026".
        """
        return pulumi.get(self, "years")

    @years.setter
    def years(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "years", value)


if not MYPY:
    class MuteTimingIntervalTimeArgsDict(TypedDict):
        end: pulumi.Input[_builtins.str]
        """
        The time, in hh:mm format, of when the interval should end exclusively.
        """
        start: pulumi.Input[_builtins.str]
        """
        The time, in hh:mm format, of when the interval should begin inclusively.
        """
elif False:
    MuteTimingIntervalTimeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MuteTimingIntervalTimeArgs:
    def __init__(__self__, *,
                 end: pulumi.Input[_builtins.str],
                 start: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] end: The time, in hh:mm format, of when the interval should end exclusively.
        :param pulumi.Input[_builtins.str] start: The time, in hh:mm format, of when the interval should begin inclusively.
        """
        pulumi.set(__self__, "end", end)
        pulumi.set(__self__, "start", start)

    @_builtins.property
    @pulumi.getter
    def end(self) -> pulumi.Input[_builtins.str]:
        """
        The time, in hh:mm format, of when the interval should end exclusively.
        """
        return pulumi.get(self, "end")

    @end.setter
    def end(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "end", value)

    @_builtins.property
    @pulumi.getter
    def start(self) -> pulumi.Input[_builtins.str]:
        """
        The time, in hh:mm format, of when the interval should begin inclusively.
        """
        return pulumi.get(self, "start")

    @start.setter
    def start(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "start", value)


if not MYPY:
    class NotificationPolicyPolicyArgsDict(TypedDict):
        active_timings: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of time interval names to apply to alerts that match this policy to suppress them unless they are sent at the specified time. Supported in Grafana 12.1.0 and later
        """
        contact_point: NotRequired[pulumi.Input[_builtins.str]]
        """
        The contact point to route notifications that match this rule to.
        """
        continue_: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to continue matching subsequent rules if an alert matches the current rule. Otherwise, the rule will be 'consumed' by the first policy to match it.
        """
        group_bies: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping. Required for root policy only. If empty, the parent grouping is used.
        """
        group_interval: NotRequired[pulumi.Input[_builtins.str]]
        """
        Minimum time interval between two notifications for the same group. Default is 5 minutes.
        """
        group_wait: NotRequired[pulumi.Input[_builtins.str]]
        """
        Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.
        """
        matchers: NotRequired[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyMatcherArgsDict']]]]
        """
        Describes which labels this rule should match. When multiple matchers are supplied, an alert must match ALL matchers to be accepted by this policy. When no matchers are supplied, the rule will match all alert instances.
        """
        mute_timings: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of time intervals to apply to alerts that match this policy to mute them for the specified time.
        """
        policies: NotRequired[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyArgsDict']]]]
        """
        Routing rules for specific label sets.
        """
        repeat_interval: NotRequired[pulumi.Input[_builtins.str]]
        """
        Minimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.
        """
elif False:
    NotificationPolicyPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NotificationPolicyPolicyArgs:
    def __init__(__self__, *,
                 active_timings: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 contact_point: Optional[pulumi.Input[_builtins.str]] = None,
                 continue_: Optional[pulumi.Input[_builtins.bool]] = None,
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 group_interval: Optional[pulumi.Input[_builtins.str]] = None,
                 group_wait: Optional[pulumi.Input[_builtins.str]] = None,
                 matchers: Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyMatcherArgs']]]] = None,
                 mute_timings: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 policies: Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyArgs']]]] = None,
                 repeat_interval: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] active_timings: A list of time interval names to apply to alerts that match this policy to suppress them unless they are sent at the specified time. Supported in Grafana 12.1.0 and later
        :param pulumi.Input[_builtins.str] contact_point: The contact point to route notifications that match this rule to.
        :param pulumi.Input[_builtins.bool] continue_: Whether to continue matching subsequent rules if an alert matches the current rule. Otherwise, the rule will be 'consumed' by the first policy to match it.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] group_bies: A list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping. Required for root policy only. If empty, the parent grouping is used.
        :param pulumi.Input[_builtins.str] group_interval: Minimum time interval between two notifications for the same group. Default is 5 minutes.
        :param pulumi.Input[_builtins.str] group_wait: Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.
        :param pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyMatcherArgs']]] matchers: Describes which labels this rule should match. When multiple matchers are supplied, an alert must match ALL matchers to be accepted by this policy. When no matchers are supplied, the rule will match all alert instances.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] mute_timings: A list of time intervals to apply to alerts that match this policy to mute them for the specified time.
        :param pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyArgs']]] policies: Routing rules for specific label sets.
        :param pulumi.Input[_builtins.str] repeat_interval: Minimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.
        """
        if active_timings is not None:
            pulumi.set(__self__, "active_timings", active_timings)
        if contact_point is not None:
            pulumi.set(__self__, "contact_point", contact_point)
        if continue_ is not None:
            pulumi.set(__self__, "continue_", continue_)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if group_interval is not None:
            pulumi.set(__self__, "group_interval", group_interval)
        if group_wait is not None:
            pulumi.set(__self__, "group_wait", group_wait)
        if matchers is not None:
            pulumi.set(__self__, "matchers", matchers)
        if mute_timings is not None:
            pulumi.set(__self__, "mute_timings", mute_timings)
        if policies is not None:
            pulumi.set(__self__, "policies", policies)
        if repeat_interval is not None:
            pulumi.set(__self__, "repeat_interval", repeat_interval)

    @_builtins.property
    @pulumi.getter(name="activeTimings")
    def active_timings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of time interval names to apply to alerts that match this policy to suppress them unless they are sent at the specified time. Supported in Grafana 12.1.0 and later
        """
        return pulumi.get(self, "active_timings")

    @active_timings.setter
    def active_timings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "active_timings", value)

    @_builtins.property
    @pulumi.getter(name="contactPoint")
    def contact_point(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The contact point to route notifications that match this rule to.
        """
        return pulumi.get(self, "contact_point")

    @contact_point.setter
    def contact_point(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "contact_point", value)

    @_builtins.property
    @pulumi.getter(name="continue")
    def continue_(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to continue matching subsequent rules if an alert matches the current rule. Otherwise, the rule will be 'consumed' by the first policy to match it.
        """
        return pulumi.get(self, "continue_")

    @continue_.setter
    def continue_(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "continue_", value)

    @_builtins.property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping. Required for root policy only. If empty, the parent grouping is used.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "group_bies", value)

    @_builtins.property
    @pulumi.getter(name="groupInterval")
    def group_interval(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Minimum time interval between two notifications for the same group. Default is 5 minutes.
        """
        return pulumi.get(self, "group_interval")

    @group_interval.setter
    def group_interval(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "group_interval", value)

    @_builtins.property
    @pulumi.getter(name="groupWait")
    def group_wait(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.
        """
        return pulumi.get(self, "group_wait")

    @group_wait.setter
    def group_wait(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "group_wait", value)

    @_builtins.property
    @pulumi.getter
    def matchers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyMatcherArgs']]]]:
        """
        Describes which labels this rule should match. When multiple matchers are supplied, an alert must match ALL matchers to be accepted by this policy. When no matchers are supplied, the rule will match all alert instances.
        """
        return pulumi.get(self, "matchers")

    @matchers.setter
    def matchers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyMatcherArgs']]]]):
        pulumi.set(self, "matchers", value)

    @_builtins.property
    @pulumi.getter(name="muteTimings")
    def mute_timings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of time intervals to apply to alerts that match this policy to mute them for the specified time.
        """
        return pulumi.get(self, "mute_timings")

    @mute_timings.setter
    def mute_timings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "mute_timings", value)

    @_builtins.property
    @pulumi.getter
    def policies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyArgs']]]]:
        """
        Routing rules for specific label sets.
        """
        return pulumi.get(self, "policies")

    @policies.setter
    def policies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyArgs']]]]):
        pulumi.set(self, "policies", value)

    @_builtins.property
    @pulumi.getter(name="repeatInterval")
    def repeat_interval(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Minimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.
        """
        return pulumi.get(self, "repeat_interval")

    @repeat_interval.setter
    def repeat_interval(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "repeat_interval", value)


if not MYPY:
    class NotificationPolicyPolicyMatcherArgsDict(TypedDict):
        label: pulumi.Input[_builtins.str]
        """
        The name of the label to match against.
        """
        match: pulumi.Input[_builtins.str]
        """
        The operator to apply when matching values of the given label. Allowed operators are `=` for equality, `!=` for negated equality, `=~` for regex equality, and `!~` for negated regex equality.
        """
        value: pulumi.Input[_builtins.str]
        """
        The label value to match against.
        """
elif False:
    NotificationPolicyPolicyMatcherArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NotificationPolicyPolicyMatcherArgs:
    def __init__(__self__, *,
                 label: pulumi.Input[_builtins.str],
                 match: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] label: The name of the label to match against.
        :param pulumi.Input[_builtins.str] match: The operator to apply when matching values of the given label. Allowed operators are `=` for equality, `!=` for negated equality, `=~` for regex equality, and `!~` for negated regex equality.
        :param pulumi.Input[_builtins.str] value: The label value to match against.
        """
        pulumi.set(__self__, "label", label)
        pulumi.set(__self__, "match", match)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def label(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the label to match against.
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "label", value)

    @_builtins.property
    @pulumi.getter
    def match(self) -> pulumi.Input[_builtins.str]:
        """
        The operator to apply when matching values of the given label. Allowed operators are `=` for equality, `!=` for negated equality, `=~` for regex equality, and `!~` for negated regex equality.
        """
        return pulumi.get(self, "match")

    @match.setter
    def match(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        The label value to match against.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NotificationPolicyPolicyPolicyArgsDict(TypedDict):
        active_timings: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of time interval names to apply to alerts that match this policy to suppress them unless they are sent at the specified time. Supported in Grafana 12.1.0 and later
        """
        contact_point: NotRequired[pulumi.Input[_builtins.str]]
        """
        The contact point to route notifications that match this rule to.
        """
        continue_: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to continue matching subsequent rules if an alert matches the current rule. Otherwise, the rule will be 'consumed' by the first policy to match it.
        """
        group_bies: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping. Required for root policy only. If empty, the parent grouping is used.
        """
        group_interval: NotRequired[pulumi.Input[_builtins.str]]
        """
        Minimum time interval between two notifications for the same group. Default is 5 minutes.
        """
        group_wait: NotRequired[pulumi.Input[_builtins.str]]
        """
        Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.
        """
        matchers: NotRequired[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyMatcherArgsDict']]]]
        """
        Describes which labels this rule should match. When multiple matchers are supplied, an alert must match ALL matchers to be accepted by this policy. When no matchers are supplied, the rule will match all alert instances.
        """
        mute_timings: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of time intervals to apply to alerts that match this policy to mute them for the specified time.
        """
        policies: NotRequired[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyPolicyArgsDict']]]]
        """
        Routing rules for specific label sets.
        """
        repeat_interval: NotRequired[pulumi.Input[_builtins.str]]
        """
        Minimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.
        """
elif False:
    NotificationPolicyPolicyPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NotificationPolicyPolicyPolicyArgs:
    def __init__(__self__, *,
                 active_timings: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 contact_point: Optional[pulumi.Input[_builtins.str]] = None,
                 continue_: Optional[pulumi.Input[_builtins.bool]] = None,
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 group_interval: Optional[pulumi.Input[_builtins.str]] = None,
                 group_wait: Optional[pulumi.Input[_builtins.str]] = None,
                 matchers: Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyMatcherArgs']]]] = None,
                 mute_timings: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 policies: Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyPolicyArgs']]]] = None,
                 repeat_interval: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] active_timings: A list of time interval names to apply to alerts that match this policy to suppress them unless they are sent at the specified time. Supported in Grafana 12.1.0 and later
        :param pulumi.Input[_builtins.str] contact_point: The contact point to route notifications that match this rule to.
        :param pulumi.Input[_builtins.bool] continue_: Whether to continue matching subsequent rules if an alert matches the current rule. Otherwise, the rule will be 'consumed' by the first policy to match it.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] group_bies: A list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping. Required for root policy only. If empty, the parent grouping is used.
        :param pulumi.Input[_builtins.str] group_interval: Minimum time interval between two notifications for the same group. Default is 5 minutes.
        :param pulumi.Input[_builtins.str] group_wait: Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.
        :param pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyMatcherArgs']]] matchers: Describes which labels this rule should match. When multiple matchers are supplied, an alert must match ALL matchers to be accepted by this policy. When no matchers are supplied, the rule will match all alert instances.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] mute_timings: A list of time intervals to apply to alerts that match this policy to mute them for the specified time.
        :param pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyPolicyArgs']]] policies: Routing rules for specific label sets.
        :param pulumi.Input[_builtins.str] repeat_interval: Minimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.
        """
        if active_timings is not None:
            pulumi.set(__self__, "active_timings", active_timings)
        if contact_point is not None:
            pulumi.set(__self__, "contact_point", contact_point)
        if continue_ is not None:
            pulumi.set(__self__, "continue_", continue_)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if group_interval is not None:
            pulumi.set(__self__, "group_interval", group_interval)
        if group_wait is not None:
            pulumi.set(__self__, "group_wait", group_wait)
        if matchers is not None:
            pulumi.set(__self__, "matchers", matchers)
        if mute_timings is not None:
            pulumi.set(__self__, "mute_timings", mute_timings)
        if policies is not None:
            pulumi.set(__self__, "policies", policies)
        if repeat_interval is not None:
            pulumi.set(__self__, "repeat_interval", repeat_interval)

    @_builtins.property
    @pulumi.getter(name="activeTimings")
    def active_timings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of time interval names to apply to alerts that match this policy to suppress them unless they are sent at the specified time. Supported in Grafana 12.1.0 and later
        """
        return pulumi.get(self, "active_timings")

    @active_timings.setter
    def active_timings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "active_timings", value)

    @_builtins.property
    @pulumi.getter(name="contactPoint")
    def contact_point(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The contact point to route notifications that match this rule to.
        """
        return pulumi.get(self, "contact_point")

    @contact_point.setter
    def contact_point(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "contact_point", value)

    @_builtins.property
    @pulumi.getter(name="continue")
    def continue_(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to continue matching subsequent rules if an alert matches the current rule. Otherwise, the rule will be 'consumed' by the first policy to match it.
        """
        return pulumi.get(self, "continue_")

    @continue_.setter
    def continue_(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "continue_", value)

    @_builtins.property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping. Required for root policy only. If empty, the parent grouping is used.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "group_bies", value)

    @_builtins.property
    @pulumi.getter(name="groupInterval")
    def group_interval(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Minimum time interval between two notifications for the same group. Default is 5 minutes.
        """
        return pulumi.get(self, "group_interval")

    @group_interval.setter
    def group_interval(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "group_interval", value)

    @_builtins.property
    @pulumi.getter(name="groupWait")
    def group_wait(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.
        """
        return pulumi.get(self, "group_wait")

    @group_wait.setter
    def group_wait(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "group_wait", value)

    @_builtins.property
    @pulumi.getter
    def matchers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyMatcherArgs']]]]:
        """
        Describes which labels this rule should match. When multiple matchers are supplied, an alert must match ALL matchers to be accepted by this policy. When no matchers are supplied, the rule will match all alert instances.
        """
        return pulumi.get(self, "matchers")

    @matchers.setter
    def matchers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyMatcherArgs']]]]):
        pulumi.set(self, "matchers", value)

    @_builtins.property
    @pulumi.getter(name="muteTimings")
    def mute_timings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of time intervals to apply to alerts that match this policy to mute them for the specified time.
        """
        return pulumi.get(self, "mute_timings")

    @mute_timings.setter
    def mute_timings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "mute_timings", value)

    @_builtins.property
    @pulumi.getter
    def policies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyPolicyArgs']]]]:
        """
        Routing rules for specific label sets.
        """
        return pulumi.get(self, "policies")

    @policies.setter
    def policies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyPolicyArgs']]]]):
        pulumi.set(self, "policies", value)

    @_builtins.property
    @pulumi.getter(name="repeatInterval")
    def repeat_interval(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Minimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.
        """
        return pulumi.get(self, "repeat_interval")

    @repeat_interval.setter
    def repeat_interval(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "repeat_interval", value)


if not MYPY:
    class NotificationPolicyPolicyPolicyMatcherArgsDict(TypedDict):
        label: pulumi.Input[_builtins.str]
        """
        The name of the label to match against.
        """
        match: pulumi.Input[_builtins.str]
        """
        The operator to apply when matching values of the given label. Allowed operators are `=` for equality, `!=` for negated equality, `=~` for regex equality, and `!~` for negated regex equality.
        """
        value: pulumi.Input[_builtins.str]
        """
        The label value to match against.
        """
elif False:
    NotificationPolicyPolicyPolicyMatcherArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NotificationPolicyPolicyPolicyMatcherArgs:
    def __init__(__self__, *,
                 label: pulumi.Input[_builtins.str],
                 match: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] label: The name of the label to match against.
        :param pulumi.Input[_builtins.str] match: The operator to apply when matching values of the given label. Allowed operators are `=` for equality, `!=` for negated equality, `=~` for regex equality, and `!~` for negated regex equality.
        :param pulumi.Input[_builtins.str] value: The label value to match against.
        """
        pulumi.set(__self__, "label", label)
        pulumi.set(__self__, "match", match)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def label(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the label to match against.
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "label", value)

    @_builtins.property
    @pulumi.getter
    def match(self) -> pulumi.Input[_builtins.str]:
        """
        The operator to apply when matching values of the given label. Allowed operators are `=` for equality, `!=` for negated equality, `=~` for regex equality, and `!~` for negated regex equality.
        """
        return pulumi.get(self, "match")

    @match.setter
    def match(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        The label value to match against.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NotificationPolicyPolicyPolicyPolicyArgsDict(TypedDict):
        active_timings: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of time interval names to apply to alerts that match this policy to suppress them unless they are sent at the specified time. Supported in Grafana 12.1.0 and later
        """
        contact_point: NotRequired[pulumi.Input[_builtins.str]]
        """
        The contact point to route notifications that match this rule to.
        """
        continue_: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to continue matching subsequent rules if an alert matches the current rule. Otherwise, the rule will be 'consumed' by the first policy to match it.
        """
        group_bies: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping. Required for root policy only. If empty, the parent grouping is used.
        """
        group_interval: NotRequired[pulumi.Input[_builtins.str]]
        """
        Minimum time interval between two notifications for the same group. Default is 5 minutes.
        """
        group_wait: NotRequired[pulumi.Input[_builtins.str]]
        """
        Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.
        """
        matchers: NotRequired[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyPolicyMatcherArgsDict']]]]
        """
        Describes which labels this rule should match. When multiple matchers are supplied, an alert must match ALL matchers to be accepted by this policy. When no matchers are supplied, the rule will match all alert instances.
        """
        mute_timings: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of time intervals to apply to alerts that match this policy to mute them for the specified time.
        """
        policies: NotRequired[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyPolicyPolicyArgsDict']]]]
        """
        Routing rules for specific label sets.
        """
        repeat_interval: NotRequired[pulumi.Input[_builtins.str]]
        """
        Minimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.
        """
elif False:
    NotificationPolicyPolicyPolicyPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NotificationPolicyPolicyPolicyPolicyArgs:
    def __init__(__self__, *,
                 active_timings: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 contact_point: Optional[pulumi.Input[_builtins.str]] = None,
                 continue_: Optional[pulumi.Input[_builtins.bool]] = None,
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 group_interval: Optional[pulumi.Input[_builtins.str]] = None,
                 group_wait: Optional[pulumi.Input[_builtins.str]] = None,
                 matchers: Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyPolicyMatcherArgs']]]] = None,
                 mute_timings: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 policies: Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyPolicyPolicyArgs']]]] = None,
                 repeat_interval: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] active_timings: A list of time interval names to apply to alerts that match this policy to suppress them unless they are sent at the specified time. Supported in Grafana 12.1.0 and later
        :param pulumi.Input[_builtins.str] contact_point: The contact point to route notifications that match this rule to.
        :param pulumi.Input[_builtins.bool] continue_: Whether to continue matching subsequent rules if an alert matches the current rule. Otherwise, the rule will be 'consumed' by the first policy to match it.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] group_bies: A list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping. Required for root policy only. If empty, the parent grouping is used.
        :param pulumi.Input[_builtins.str] group_interval: Minimum time interval between two notifications for the same group. Default is 5 minutes.
        :param pulumi.Input[_builtins.str] group_wait: Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.
        :param pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyPolicyMatcherArgs']]] matchers: Describes which labels this rule should match. When multiple matchers are supplied, an alert must match ALL matchers to be accepted by this policy. When no matchers are supplied, the rule will match all alert instances.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] mute_timings: A list of time intervals to apply to alerts that match this policy to mute them for the specified time.
        :param pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyPolicyPolicyArgs']]] policies: Routing rules for specific label sets.
        :param pulumi.Input[_builtins.str] repeat_interval: Minimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.
        """
        if active_timings is not None:
            pulumi.set(__self__, "active_timings", active_timings)
        if contact_point is not None:
            pulumi.set(__self__, "contact_point", contact_point)
        if continue_ is not None:
            pulumi.set(__self__, "continue_", continue_)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if group_interval is not None:
            pulumi.set(__self__, "group_interval", group_interval)
        if group_wait is not None:
            pulumi.set(__self__, "group_wait", group_wait)
        if matchers is not None:
            pulumi.set(__self__, "matchers", matchers)
        if mute_timings is not None:
            pulumi.set(__self__, "mute_timings", mute_timings)
        if policies is not None:
            pulumi.set(__self__, "policies", policies)
        if repeat_interval is not None:
            pulumi.set(__self__, "repeat_interval", repeat_interval)

    @_builtins.property
    @pulumi.getter(name="activeTimings")
    def active_timings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of time interval names to apply to alerts that match this policy to suppress them unless they are sent at the specified time. Supported in Grafana 12.1.0 and later
        """
        return pulumi.get(self, "active_timings")

    @active_timings.setter
    def active_timings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "active_timings", value)

    @_builtins.property
    @pulumi.getter(name="contactPoint")
    def contact_point(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The contact point to route notifications that match this rule to.
        """
        return pulumi.get(self, "contact_point")

    @contact_point.setter
    def contact_point(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "contact_point", value)

    @_builtins.property
    @pulumi.getter(name="continue")
    def continue_(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to continue matching subsequent rules if an alert matches the current rule. Otherwise, the rule will be 'consumed' by the first policy to match it.
        """
        return pulumi.get(self, "continue_")

    @continue_.setter
    def continue_(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "continue_", value)

    @_builtins.property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping. Required for root policy only. If empty, the parent grouping is used.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "group_bies", value)

    @_builtins.property
    @pulumi.getter(name="groupInterval")
    def group_interval(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Minimum time interval between two notifications for the same group. Default is 5 minutes.
        """
        return pulumi.get(self, "group_interval")

    @group_interval.setter
    def group_interval(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "group_interval", value)

    @_builtins.property
    @pulumi.getter(name="groupWait")
    def group_wait(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.
        """
        return pulumi.get(self, "group_wait")

    @group_wait.setter
    def group_wait(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "group_wait", value)

    @_builtins.property
    @pulumi.getter
    def matchers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyPolicyMatcherArgs']]]]:
        """
        Describes which labels this rule should match. When multiple matchers are supplied, an alert must match ALL matchers to be accepted by this policy. When no matchers are supplied, the rule will match all alert instances.
        """
        return pulumi.get(self, "matchers")

    @matchers.setter
    def matchers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyPolicyMatcherArgs']]]]):
        pulumi.set(self, "matchers", value)

    @_builtins.property
    @pulumi.getter(name="muteTimings")
    def mute_timings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of time intervals to apply to alerts that match this policy to mute them for the specified time.
        """
        return pulumi.get(self, "mute_timings")

    @mute_timings.setter
    def mute_timings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "mute_timings", value)

    @_builtins.property
    @pulumi.getter
    def policies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyPolicyPolicyArgs']]]]:
        """
        Routing rules for specific label sets.
        """
        return pulumi.get(self, "policies")

    @policies.setter
    def policies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyPolicyPolicyArgs']]]]):
        pulumi.set(self, "policies", value)

    @_builtins.property
    @pulumi.getter(name="repeatInterval")
    def repeat_interval(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Minimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.
        """
        return pulumi.get(self, "repeat_interval")

    @repeat_interval.setter
    def repeat_interval(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "repeat_interval", value)


if not MYPY:
    class NotificationPolicyPolicyPolicyPolicyMatcherArgsDict(TypedDict):
        label: pulumi.Input[_builtins.str]
        """
        The name of the label to match against.
        """
        match: pulumi.Input[_builtins.str]
        """
        The operator to apply when matching values of the given label. Allowed operators are `=` for equality, `!=` for negated equality, `=~` for regex equality, and `!~` for negated regex equality.
        """
        value: pulumi.Input[_builtins.str]
        """
        The label value to match against.
        """
elif False:
    NotificationPolicyPolicyPolicyPolicyMatcherArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NotificationPolicyPolicyPolicyPolicyMatcherArgs:
    def __init__(__self__, *,
                 label: pulumi.Input[_builtins.str],
                 match: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] label: The name of the label to match against.
        :param pulumi.Input[_builtins.str] match: The operator to apply when matching values of the given label. Allowed operators are `=` for equality, `!=` for negated equality, `=~` for regex equality, and `!~` for negated regex equality.
        :param pulumi.Input[_builtins.str] value: The label value to match against.
        """
        pulumi.set(__self__, "label", label)
        pulumi.set(__self__, "match", match)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def label(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the label to match against.
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "label", value)

    @_builtins.property
    @pulumi.getter
    def match(self) -> pulumi.Input[_builtins.str]:
        """
        The operator to apply when matching values of the given label. Allowed operators are `=` for equality, `!=` for negated equality, `=~` for regex equality, and `!~` for negated regex equality.
        """
        return pulumi.get(self, "match")

    @match.setter
    def match(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        The label value to match against.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NotificationPolicyPolicyPolicyPolicyPolicyArgsDict(TypedDict):
        group_bies: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        A list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping. Required for root policy only. If empty, the parent grouping is used.
        """
        active_timings: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of time interval names to apply to alerts that match this policy to suppress them unless they are sent at the specified time. Supported in Grafana 12.1.0 and later
        """
        contact_point: NotRequired[pulumi.Input[_builtins.str]]
        """
        The contact point to route notifications that match this rule to.
        """
        continue_: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to continue matching subsequent rules if an alert matches the current rule. Otherwise, the rule will be 'consumed' by the first policy to match it.
        """
        group_interval: NotRequired[pulumi.Input[_builtins.str]]
        """
        Minimum time interval between two notifications for the same group. Default is 5 minutes.
        """
        group_wait: NotRequired[pulumi.Input[_builtins.str]]
        """
        Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.
        """
        matchers: NotRequired[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyPolicyPolicyMatcherArgsDict']]]]
        """
        Describes which labels this rule should match. When multiple matchers are supplied, an alert must match ALL matchers to be accepted by this policy. When no matchers are supplied, the rule will match all alert instances.
        """
        mute_timings: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of time intervals to apply to alerts that match this policy to mute them for the specified time.
        """
        repeat_interval: NotRequired[pulumi.Input[_builtins.str]]
        """
        Minimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.
        """
elif False:
    NotificationPolicyPolicyPolicyPolicyPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NotificationPolicyPolicyPolicyPolicyPolicyArgs:
    def __init__(__self__, *,
                 group_bies: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 active_timings: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 contact_point: Optional[pulumi.Input[_builtins.str]] = None,
                 continue_: Optional[pulumi.Input[_builtins.bool]] = None,
                 group_interval: Optional[pulumi.Input[_builtins.str]] = None,
                 group_wait: Optional[pulumi.Input[_builtins.str]] = None,
                 matchers: Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyPolicyPolicyMatcherArgs']]]] = None,
                 mute_timings: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 repeat_interval: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] group_bies: A list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping. Required for root policy only. If empty, the parent grouping is used.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] active_timings: A list of time interval names to apply to alerts that match this policy to suppress them unless they are sent at the specified time. Supported in Grafana 12.1.0 and later
        :param pulumi.Input[_builtins.str] contact_point: The contact point to route notifications that match this rule to.
        :param pulumi.Input[_builtins.bool] continue_: Whether to continue matching subsequent rules if an alert matches the current rule. Otherwise, the rule will be 'consumed' by the first policy to match it.
        :param pulumi.Input[_builtins.str] group_interval: Minimum time interval between two notifications for the same group. Default is 5 minutes.
        :param pulumi.Input[_builtins.str] group_wait: Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.
        :param pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyPolicyPolicyMatcherArgs']]] matchers: Describes which labels this rule should match. When multiple matchers are supplied, an alert must match ALL matchers to be accepted by this policy. When no matchers are supplied, the rule will match all alert instances.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] mute_timings: A list of time intervals to apply to alerts that match this policy to mute them for the specified time.
        :param pulumi.Input[_builtins.str] repeat_interval: Minimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.
        """
        pulumi.set(__self__, "group_bies", group_bies)
        if active_timings is not None:
            pulumi.set(__self__, "active_timings", active_timings)
        if contact_point is not None:
            pulumi.set(__self__, "contact_point", contact_point)
        if continue_ is not None:
            pulumi.set(__self__, "continue_", continue_)
        if group_interval is not None:
            pulumi.set(__self__, "group_interval", group_interval)
        if group_wait is not None:
            pulumi.set(__self__, "group_wait", group_wait)
        if matchers is not None:
            pulumi.set(__self__, "matchers", matchers)
        if mute_timings is not None:
            pulumi.set(__self__, "mute_timings", mute_timings)
        if repeat_interval is not None:
            pulumi.set(__self__, "repeat_interval", repeat_interval)

    @_builtins.property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        A list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping. Required for root policy only. If empty, the parent grouping is used.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "group_bies", value)

    @_builtins.property
    @pulumi.getter(name="activeTimings")
    def active_timings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of time interval names to apply to alerts that match this policy to suppress them unless they are sent at the specified time. Supported in Grafana 12.1.0 and later
        """
        return pulumi.get(self, "active_timings")

    @active_timings.setter
    def active_timings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "active_timings", value)

    @_builtins.property
    @pulumi.getter(name="contactPoint")
    def contact_point(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The contact point to route notifications that match this rule to.
        """
        return pulumi.get(self, "contact_point")

    @contact_point.setter
    def contact_point(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "contact_point", value)

    @_builtins.property
    @pulumi.getter(name="continue")
    def continue_(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to continue matching subsequent rules if an alert matches the current rule. Otherwise, the rule will be 'consumed' by the first policy to match it.
        """
        return pulumi.get(self, "continue_")

    @continue_.setter
    def continue_(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "continue_", value)

    @_builtins.property
    @pulumi.getter(name="groupInterval")
    def group_interval(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Minimum time interval between two notifications for the same group. Default is 5 minutes.
        """
        return pulumi.get(self, "group_interval")

    @group_interval.setter
    def group_interval(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "group_interval", value)

    @_builtins.property
    @pulumi.getter(name="groupWait")
    def group_wait(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.
        """
        return pulumi.get(self, "group_wait")

    @group_wait.setter
    def group_wait(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "group_wait", value)

    @_builtins.property
    @pulumi.getter
    def matchers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyPolicyPolicyMatcherArgs']]]]:
        """
        Describes which labels this rule should match. When multiple matchers are supplied, an alert must match ALL matchers to be accepted by this policy. When no matchers are supplied, the rule will match all alert instances.
        """
        return pulumi.get(self, "matchers")

    @matchers.setter
    def matchers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyPolicyPolicyMatcherArgs']]]]):
        pulumi.set(self, "matchers", value)

    @_builtins.property
    @pulumi.getter(name="muteTimings")
    def mute_timings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of time intervals to apply to alerts that match this policy to mute them for the specified time.
        """
        return pulumi.get(self, "mute_timings")

    @mute_timings.setter
    def mute_timings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "mute_timings", value)

    @_builtins.property
    @pulumi.getter(name="repeatInterval")
    def repeat_interval(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Minimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.
        """
        return pulumi.get(self, "repeat_interval")

    @repeat_interval.setter
    def repeat_interval(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "repeat_interval", value)


if not MYPY:
    class NotificationPolicyPolicyPolicyPolicyPolicyMatcherArgsDict(TypedDict):
        label: pulumi.Input[_builtins.str]
        """
        The name of the label to match against.
        """
        match: pulumi.Input[_builtins.str]
        """
        The operator to apply when matching values of the given label. Allowed operators are `=` for equality, `!=` for negated equality, `=~` for regex equality, and `!~` for negated regex equality.
        """
        value: pulumi.Input[_builtins.str]
        """
        The label value to match against.
        """
elif False:
    NotificationPolicyPolicyPolicyPolicyPolicyMatcherArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NotificationPolicyPolicyPolicyPolicyPolicyMatcherArgs:
    def __init__(__self__, *,
                 label: pulumi.Input[_builtins.str],
                 match: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] label: The name of the label to match against.
        :param pulumi.Input[_builtins.str] match: The operator to apply when matching values of the given label. Allowed operators are `=` for equality, `!=` for negated equality, `=~` for regex equality, and `!~` for negated regex equality.
        :param pulumi.Input[_builtins.str] value: The label value to match against.
        """
        pulumi.set(__self__, "label", label)
        pulumi.set(__self__, "match", match)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def label(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the label to match against.
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "label", value)

    @_builtins.property
    @pulumi.getter
    def match(self) -> pulumi.Input[_builtins.str]:
        """
        The operator to apply when matching values of the given label. Allowed operators are `=` for equality, `!=` for negated equality, `=~` for regex equality, and `!~` for negated regex equality.
        """
        return pulumi.get(self, "match")

    @match.setter
    def match(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        The label value to match against.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class RecordingRuleV0Alpha1MetadataArgsDict(TypedDict):
        uid: pulumi.Input[_builtins.str]
        """
        The unique identifier of the resource.
        """
        annotations: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Annotations of the resource.
        """
        folder_uid: NotRequired[pulumi.Input[_builtins.str]]
        """
        The UID of the folder to save the resource in.
        """
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        The full URL of the resource.
        """
        uuid: NotRequired[pulumi.Input[_builtins.str]]
        """
        The globally unique identifier of a resource, used by the API for tracking.
        """
        version: NotRequired[pulumi.Input[_builtins.str]]
        """
        The version of the resource.
        """
elif False:
    RecordingRuleV0Alpha1MetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecordingRuleV0Alpha1MetadataArgs:
    def __init__(__self__, *,
                 uid: pulumi.Input[_builtins.str],
                 annotations: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 folder_uid: Optional[pulumi.Input[_builtins.str]] = None,
                 url: Optional[pulumi.Input[_builtins.str]] = None,
                 uuid: Optional[pulumi.Input[_builtins.str]] = None,
                 version: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] uid: The unique identifier of the resource.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] annotations: Annotations of the resource.
        :param pulumi.Input[_builtins.str] folder_uid: The UID of the folder to save the resource in.
        :param pulumi.Input[_builtins.str] url: The full URL of the resource.
        :param pulumi.Input[_builtins.str] uuid: The globally unique identifier of a resource, used by the API for tracking.
        :param pulumi.Input[_builtins.str] version: The version of the resource.
        """
        pulumi.set(__self__, "uid", uid)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if folder_uid is not None:
            pulumi.set(__self__, "folder_uid", folder_uid)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def uid(self) -> pulumi.Input[_builtins.str]:
        """
        The unique identifier of the resource.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "uid", value)

    @_builtins.property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Annotations of the resource.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "annotations", value)

    @_builtins.property
    @pulumi.getter(name="folderUid")
    def folder_uid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The UID of the folder to save the resource in.
        """
        return pulumi.get(self, "folder_uid")

    @folder_uid.setter
    def folder_uid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "folder_uid", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The full URL of the resource.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The globally unique identifier of a resource, used by the API for tracking.
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uuid", value)

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The version of the resource.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class RecordingRuleV0Alpha1OptionsArgsDict(TypedDict):
        overwrite: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Set to true if you want to overwrite existing resource with newer version, same resource title in folder or same resource uid.
        """
elif False:
    RecordingRuleV0Alpha1OptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecordingRuleV0Alpha1OptionsArgs:
    def __init__(__self__, *,
                 overwrite: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] overwrite: Set to true if you want to overwrite existing resource with newer version, same resource title in folder or same resource uid.
        """
        if overwrite is not None:
            pulumi.set(__self__, "overwrite", overwrite)

    @_builtins.property
    @pulumi.getter
    def overwrite(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Set to true if you want to overwrite existing resource with newer version, same resource title in folder or same resource uid.
        """
        return pulumi.get(self, "overwrite")

    @overwrite.setter
    def overwrite(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "overwrite", value)


if not MYPY:
    class RecordingRuleV0Alpha1SpecArgsDict(TypedDict):
        expressions: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]
        """
        A sequence of stages that describe the contents of the rule. Each value is a JSON string representing an expression object.
        """
        metric: pulumi.Input[_builtins.str]
        """
        The name of the metric to write to.
        """
        target_datasource_uid: pulumi.Input[_builtins.str]
        """
        The UID of the datasource to write the metric to.
        """
        title: pulumi.Input[_builtins.str]
        """
        The title of the recording rule.
        """
        labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Key-value pairs to attach to the recorded metric.
        """
        paused: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Sets whether the recording rule should be paused or not.
        """
        trigger: NotRequired[pulumi.Input['RecordingRuleV0Alpha1SpecTriggerArgsDict']]
        """
        The trigger configuration for the recording rule.
        """
elif False:
    RecordingRuleV0Alpha1SpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecordingRuleV0Alpha1SpecArgs:
    def __init__(__self__, *,
                 expressions: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]],
                 metric: pulumi.Input[_builtins.str],
                 target_datasource_uid: pulumi.Input[_builtins.str],
                 title: pulumi.Input[_builtins.str],
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 paused: Optional[pulumi.Input[_builtins.bool]] = None,
                 trigger: Optional[pulumi.Input['RecordingRuleV0Alpha1SpecTriggerArgs']] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] expressions: A sequence of stages that describe the contents of the rule. Each value is a JSON string representing an expression object.
        :param pulumi.Input[_builtins.str] metric: The name of the metric to write to.
        :param pulumi.Input[_builtins.str] target_datasource_uid: The UID of the datasource to write the metric to.
        :param pulumi.Input[_builtins.str] title: The title of the recording rule.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] labels: Key-value pairs to attach to the recorded metric.
        :param pulumi.Input[_builtins.bool] paused: Sets whether the recording rule should be paused or not.
        :param pulumi.Input['RecordingRuleV0Alpha1SpecTriggerArgs'] trigger: The trigger configuration for the recording rule.
        """
        pulumi.set(__self__, "expressions", expressions)
        pulumi.set(__self__, "metric", metric)
        pulumi.set(__self__, "target_datasource_uid", target_datasource_uid)
        pulumi.set(__self__, "title", title)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if paused is not None:
            pulumi.set(__self__, "paused", paused)
        if trigger is not None:
            pulumi.set(__self__, "trigger", trigger)

    @_builtins.property
    @pulumi.getter
    def expressions(self) -> pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]:
        """
        A sequence of stages that describe the contents of the rule. Each value is a JSON string representing an expression object.
        """
        return pulumi.get(self, "expressions")

    @expressions.setter
    def expressions(self, value: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "expressions", value)

    @_builtins.property
    @pulumi.getter
    def metric(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the metric to write to.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "metric", value)

    @_builtins.property
    @pulumi.getter(name="targetDatasourceUid")
    def target_datasource_uid(self) -> pulumi.Input[_builtins.str]:
        """
        The UID of the datasource to write the metric to.
        """
        return pulumi.get(self, "target_datasource_uid")

    @target_datasource_uid.setter
    def target_datasource_uid(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "target_datasource_uid", value)

    @_builtins.property
    @pulumi.getter
    def title(self) -> pulumi.Input[_builtins.str]:
        """
        The title of the recording rule.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "title", value)

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Key-value pairs to attach to the recorded metric.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "labels", value)

    @_builtins.property
    @pulumi.getter
    def paused(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Sets whether the recording rule should be paused or not.
        """
        return pulumi.get(self, "paused")

    @paused.setter
    def paused(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "paused", value)

    @_builtins.property
    @pulumi.getter
    def trigger(self) -> Optional[pulumi.Input['RecordingRuleV0Alpha1SpecTriggerArgs']]:
        """
        The trigger configuration for the recording rule.
        """
        return pulumi.get(self, "trigger")

    @trigger.setter
    def trigger(self, value: Optional[pulumi.Input['RecordingRuleV0Alpha1SpecTriggerArgs']]):
        pulumi.set(self, "trigger", value)


if not MYPY:
    class RecordingRuleV0Alpha1SpecTriggerArgsDict(TypedDict):
        interval: pulumi.Input[_builtins.str]
        """
        The interval at which the recording rule should be evaluated.
        """
elif False:
    RecordingRuleV0Alpha1SpecTriggerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecordingRuleV0Alpha1SpecTriggerArgs:
    def __init__(__self__, *,
                 interval: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] interval: The interval at which the recording rule should be evaluated.
        """
        pulumi.set(__self__, "interval", interval)

    @_builtins.property
    @pulumi.getter
    def interval(self) -> pulumi.Input[_builtins.str]:
        """
        The interval at which the recording rule should be evaluated.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "interval", value)


if not MYPY:
    class RuleGroupRuleArgsDict(TypedDict):
        datas: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleDataArgsDict']]]
        """
        A sequence of stages that describe the contents of the rule.
        """
        name: pulumi.Input[_builtins.str]
        """
        The name of the alert rule.
        """
        annotations: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Key-value pairs of metadata to attach to the alert rule. They add additional information, such as a `summary` or `runbook_url`, to help identify and investigate alerts. The `__dashboardUid__` and `__panelId__` annotations, which link alerts to a panel, must be set together. Defaults to `map[]`.
        """
        condition: NotRequired[pulumi.Input[_builtins.str]]
        """
        The `ref_id` of the query node in the `data` field to use as the alert condition.
        """
        exec_err_state: NotRequired[pulumi.Input[_builtins.str]]
        """
        Describes what state to enter when the rule's query is invalid and the rule cannot be executed. Options are OK, Error, KeepLast, and Alerting.  Defaults to Alerting if not set.
        """
        for_: NotRequired[pulumi.Input[_builtins.str]]
        """
        The amount of time for which the rule must be breached for the rule to be considered to be Firing. Before this time has elapsed, the rule is only considered to be Pending. Defaults to `0`.
        """
        is_paused: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Sets whether the alert should be paused or not. Defaults to `false`.
        """
        keep_firing_for: NotRequired[pulumi.Input[_builtins.str]]
        """
        The amount of time for which the rule will considered to be Recovering after initially Firing. Before this time has elapsed, the rule will continue to fire once it's been triggered.
        """
        labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Key-value pairs to attach to the alert rule that can be used in matching, grouping, and routing. Defaults to `map[]`.
        """
        missing_series_evals_to_resolve: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of missing series evaluations that must occur before the rule is considered to be resolved.
        """
        no_data_state: NotRequired[pulumi.Input[_builtins.str]]
        """
        Describes what state to enter when the rule's query returns No Data. Options are OK, NoData, KeepLast, and Alerting. Defaults to NoData if not set.
        """
        notification_settings: NotRequired[pulumi.Input['RuleGroupRuleNotificationSettingsArgsDict']]
        """
        Notification settings for the rule. If specified, it overrides the notification policies. Available since Grafana 10.4, requires feature flag 'alertingSimplifiedRouting' to be enabled.
        """
        record: NotRequired[pulumi.Input['RuleGroupRuleRecordArgsDict']]
        """
        Settings for a recording rule. Available since Grafana 11.2, requires feature flag 'grafanaManagedRecordingRules' to be enabled.
        """
        uid: NotRequired[pulumi.Input[_builtins.str]]
        """
        The unique identifier of the alert rule.
        """
elif False:
    RuleGroupRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleArgs:
    def __init__(__self__, *,
                 datas: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleDataArgs']]],
                 name: pulumi.Input[_builtins.str],
                 annotations: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 condition: Optional[pulumi.Input[_builtins.str]] = None,
                 exec_err_state: Optional[pulumi.Input[_builtins.str]] = None,
                 for_: Optional[pulumi.Input[_builtins.str]] = None,
                 is_paused: Optional[pulumi.Input[_builtins.bool]] = None,
                 keep_firing_for: Optional[pulumi.Input[_builtins.str]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 missing_series_evals_to_resolve: Optional[pulumi.Input[_builtins.int]] = None,
                 no_data_state: Optional[pulumi.Input[_builtins.str]] = None,
                 notification_settings: Optional[pulumi.Input['RuleGroupRuleNotificationSettingsArgs']] = None,
                 record: Optional[pulumi.Input['RuleGroupRuleRecordArgs']] = None,
                 uid: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleDataArgs']]] datas: A sequence of stages that describe the contents of the rule.
        :param pulumi.Input[_builtins.str] name: The name of the alert rule.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] annotations: Key-value pairs of metadata to attach to the alert rule. They add additional information, such as a `summary` or `runbook_url`, to help identify and investigate alerts. The `__dashboardUid__` and `__panelId__` annotations, which link alerts to a panel, must be set together. Defaults to `map[]`.
        :param pulumi.Input[_builtins.str] condition: The `ref_id` of the query node in the `data` field to use as the alert condition.
        :param pulumi.Input[_builtins.str] exec_err_state: Describes what state to enter when the rule's query is invalid and the rule cannot be executed. Options are OK, Error, KeepLast, and Alerting.  Defaults to Alerting if not set.
        :param pulumi.Input[_builtins.str] for_: The amount of time for which the rule must be breached for the rule to be considered to be Firing. Before this time has elapsed, the rule is only considered to be Pending. Defaults to `0`.
        :param pulumi.Input[_builtins.bool] is_paused: Sets whether the alert should be paused or not. Defaults to `false`.
        :param pulumi.Input[_builtins.str] keep_firing_for: The amount of time for which the rule will considered to be Recovering after initially Firing. Before this time has elapsed, the rule will continue to fire once it's been triggered.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] labels: Key-value pairs to attach to the alert rule that can be used in matching, grouping, and routing. Defaults to `map[]`.
        :param pulumi.Input[_builtins.int] missing_series_evals_to_resolve: The number of missing series evaluations that must occur before the rule is considered to be resolved.
        :param pulumi.Input[_builtins.str] no_data_state: Describes what state to enter when the rule's query returns No Data. Options are OK, NoData, KeepLast, and Alerting. Defaults to NoData if not set.
        :param pulumi.Input['RuleGroupRuleNotificationSettingsArgs'] notification_settings: Notification settings for the rule. If specified, it overrides the notification policies. Available since Grafana 10.4, requires feature flag 'alertingSimplifiedRouting' to be enabled.
        :param pulumi.Input['RuleGroupRuleRecordArgs'] record: Settings for a recording rule. Available since Grafana 11.2, requires feature flag 'grafanaManagedRecordingRules' to be enabled.
        :param pulumi.Input[_builtins.str] uid: The unique identifier of the alert rule.
        """
        pulumi.set(__self__, "datas", datas)
        pulumi.set(__self__, "name", name)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if exec_err_state is not None:
            pulumi.set(__self__, "exec_err_state", exec_err_state)
        if for_ is not None:
            pulumi.set(__self__, "for_", for_)
        if is_paused is not None:
            pulumi.set(__self__, "is_paused", is_paused)
        if keep_firing_for is not None:
            pulumi.set(__self__, "keep_firing_for", keep_firing_for)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if missing_series_evals_to_resolve is not None:
            pulumi.set(__self__, "missing_series_evals_to_resolve", missing_series_evals_to_resolve)
        if no_data_state is not None:
            pulumi.set(__self__, "no_data_state", no_data_state)
        if notification_settings is not None:
            pulumi.set(__self__, "notification_settings", notification_settings)
        if record is not None:
            pulumi.set(__self__, "record", record)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @_builtins.property
    @pulumi.getter
    def datas(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleDataArgs']]]:
        """
        A sequence of stages that describe the contents of the rule.
        """
        return pulumi.get(self, "datas")

    @datas.setter
    def datas(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleDataArgs']]]):
        pulumi.set(self, "datas", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the alert rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Key-value pairs of metadata to attach to the alert rule. They add additional information, such as a `summary` or `runbook_url`, to help identify and investigate alerts. The `__dashboardUid__` and `__panelId__` annotations, which link alerts to a panel, must be set together. Defaults to `map[]`.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "annotations", value)

    @_builtins.property
    @pulumi.getter
    def condition(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The `ref_id` of the query node in the `data` field to use as the alert condition.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "condition", value)

    @_builtins.property
    @pulumi.getter(name="execErrState")
    def exec_err_state(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Describes what state to enter when the rule's query is invalid and the rule cannot be executed. Options are OK, Error, KeepLast, and Alerting.  Defaults to Alerting if not set.
        """
        return pulumi.get(self, "exec_err_state")

    @exec_err_state.setter
    def exec_err_state(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "exec_err_state", value)

    @_builtins.property
    @pulumi.getter(name="for")
    def for_(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The amount of time for which the rule must be breached for the rule to be considered to be Firing. Before this time has elapsed, the rule is only considered to be Pending. Defaults to `0`.
        """
        return pulumi.get(self, "for_")

    @for_.setter
    def for_(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "for_", value)

    @_builtins.property
    @pulumi.getter(name="isPaused")
    def is_paused(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Sets whether the alert should be paused or not. Defaults to `false`.
        """
        return pulumi.get(self, "is_paused")

    @is_paused.setter
    def is_paused(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_paused", value)

    @_builtins.property
    @pulumi.getter(name="keepFiringFor")
    def keep_firing_for(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The amount of time for which the rule will considered to be Recovering after initially Firing. Before this time has elapsed, the rule will continue to fire once it's been triggered.
        """
        return pulumi.get(self, "keep_firing_for")

    @keep_firing_for.setter
    def keep_firing_for(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "keep_firing_for", value)

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Key-value pairs to attach to the alert rule that can be used in matching, grouping, and routing. Defaults to `map[]`.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "labels", value)

    @_builtins.property
    @pulumi.getter(name="missingSeriesEvalsToResolve")
    def missing_series_evals_to_resolve(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of missing series evaluations that must occur before the rule is considered to be resolved.
        """
        return pulumi.get(self, "missing_series_evals_to_resolve")

    @missing_series_evals_to_resolve.setter
    def missing_series_evals_to_resolve(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "missing_series_evals_to_resolve", value)

    @_builtins.property
    @pulumi.getter(name="noDataState")
    def no_data_state(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Describes what state to enter when the rule's query returns No Data. Options are OK, NoData, KeepLast, and Alerting. Defaults to NoData if not set.
        """
        return pulumi.get(self, "no_data_state")

    @no_data_state.setter
    def no_data_state(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "no_data_state", value)

    @_builtins.property
    @pulumi.getter(name="notificationSettings")
    def notification_settings(self) -> Optional[pulumi.Input['RuleGroupRuleNotificationSettingsArgs']]:
        """
        Notification settings for the rule. If specified, it overrides the notification policies. Available since Grafana 10.4, requires feature flag 'alertingSimplifiedRouting' to be enabled.
        """
        return pulumi.get(self, "notification_settings")

    @notification_settings.setter
    def notification_settings(self, value: Optional[pulumi.Input['RuleGroupRuleNotificationSettingsArgs']]):
        pulumi.set(self, "notification_settings", value)

    @_builtins.property
    @pulumi.getter
    def record(self) -> Optional[pulumi.Input['RuleGroupRuleRecordArgs']]:
        """
        Settings for a recording rule. Available since Grafana 11.2, requires feature flag 'grafanaManagedRecordingRules' to be enabled.
        """
        return pulumi.get(self, "record")

    @record.setter
    def record(self, value: Optional[pulumi.Input['RuleGroupRuleRecordArgs']]):
        pulumi.set(self, "record", value)

    @_builtins.property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The unique identifier of the alert rule.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uid", value)


if not MYPY:
    class RuleGroupRuleDataArgsDict(TypedDict):
        datasource_uid: pulumi.Input[_builtins.str]
        """
        The UID of the datasource being queried, or "-100" if this stage is an expression stage.
        """
        model: pulumi.Input[_builtins.str]
        """
        Custom JSON data to send to the specified datasource when querying.
        """
        ref_id: pulumi.Input[_builtins.str]
        """
        A unique string to identify this query stage within a rule.
        """
        relative_time_range: pulumi.Input['RuleGroupRuleDataRelativeTimeRangeArgsDict']
        """
        The time range, relative to when the query is executed, across which to query.
        """
        query_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        An optional identifier for the type of query being executed. Defaults to ``.
        """
elif False:
    RuleGroupRuleDataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleDataArgs:
    def __init__(__self__, *,
                 datasource_uid: pulumi.Input[_builtins.str],
                 model: pulumi.Input[_builtins.str],
                 ref_id: pulumi.Input[_builtins.str],
                 relative_time_range: pulumi.Input['RuleGroupRuleDataRelativeTimeRangeArgs'],
                 query_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] datasource_uid: The UID of the datasource being queried, or "-100" if this stage is an expression stage.
        :param pulumi.Input[_builtins.str] model: Custom JSON data to send to the specified datasource when querying.
        :param pulumi.Input[_builtins.str] ref_id: A unique string to identify this query stage within a rule.
        :param pulumi.Input['RuleGroupRuleDataRelativeTimeRangeArgs'] relative_time_range: The time range, relative to when the query is executed, across which to query.
        :param pulumi.Input[_builtins.str] query_type: An optional identifier for the type of query being executed. Defaults to ``.
        """
        pulumi.set(__self__, "datasource_uid", datasource_uid)
        pulumi.set(__self__, "model", model)
        pulumi.set(__self__, "ref_id", ref_id)
        pulumi.set(__self__, "relative_time_range", relative_time_range)
        if query_type is not None:
            pulumi.set(__self__, "query_type", query_type)

    @_builtins.property
    @pulumi.getter(name="datasourceUid")
    def datasource_uid(self) -> pulumi.Input[_builtins.str]:
        """
        The UID of the datasource being queried, or "-100" if this stage is an expression stage.
        """
        return pulumi.get(self, "datasource_uid")

    @datasource_uid.setter
    def datasource_uid(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "datasource_uid", value)

    @_builtins.property
    @pulumi.getter
    def model(self) -> pulumi.Input[_builtins.str]:
        """
        Custom JSON data to send to the specified datasource when querying.
        """
        return pulumi.get(self, "model")

    @model.setter
    def model(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "model", value)

    @_builtins.property
    @pulumi.getter(name="refId")
    def ref_id(self) -> pulumi.Input[_builtins.str]:
        """
        A unique string to identify this query stage within a rule.
        """
        return pulumi.get(self, "ref_id")

    @ref_id.setter
    def ref_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ref_id", value)

    @_builtins.property
    @pulumi.getter(name="relativeTimeRange")
    def relative_time_range(self) -> pulumi.Input['RuleGroupRuleDataRelativeTimeRangeArgs']:
        """
        The time range, relative to when the query is executed, across which to query.
        """
        return pulumi.get(self, "relative_time_range")

    @relative_time_range.setter
    def relative_time_range(self, value: pulumi.Input['RuleGroupRuleDataRelativeTimeRangeArgs']):
        pulumi.set(self, "relative_time_range", value)

    @_builtins.property
    @pulumi.getter(name="queryType")
    def query_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        An optional identifier for the type of query being executed. Defaults to ``.
        """
        return pulumi.get(self, "query_type")

    @query_type.setter
    def query_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "query_type", value)


if not MYPY:
    class RuleGroupRuleDataRelativeTimeRangeArgsDict(TypedDict):
        from_: pulumi.Input[_builtins.int]
        """
        The number of seconds in the past, relative to when the rule is evaluated, at which the time range begins.
        """
        to: pulumi.Input[_builtins.int]
        """
        The number of seconds in the past, relative to when the rule is evaluated, at which the time range ends.
        """
elif False:
    RuleGroupRuleDataRelativeTimeRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleDataRelativeTimeRangeArgs:
    def __init__(__self__, *,
                 from_: pulumi.Input[_builtins.int],
                 to: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.int] from_: The number of seconds in the past, relative to when the rule is evaluated, at which the time range begins.
        :param pulumi.Input[_builtins.int] to: The number of seconds in the past, relative to when the rule is evaluated, at which the time range ends.
        """
        pulumi.set(__self__, "from_", from_)
        pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> pulumi.Input[_builtins.int]:
        """
        The number of seconds in the past, relative to when the rule is evaluated, at which the time range begins.
        """
        return pulumi.get(self, "from_")

    @from_.setter
    def from_(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "from_", value)

    @_builtins.property
    @pulumi.getter
    def to(self) -> pulumi.Input[_builtins.int]:
        """
        The number of seconds in the past, relative to when the rule is evaluated, at which the time range ends.
        """
        return pulumi.get(self, "to")

    @to.setter
    def to(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "to", value)


if not MYPY:
    class RuleGroupRuleNotificationSettingsArgsDict(TypedDict):
        contact_point: pulumi.Input[_builtins.str]
        """
        The contact point to route notifications that match this rule to.
        """
        active_timings: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of time interval names to apply to alerts that match this policy to suppress them unless they are sent at the specified time. Supported in Grafana 12.1.0 and later
        """
        group_bies: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping. If empty, no grouping is used. If specified, requires labels 'alertname' and 'grafana_folder' to be included.
        """
        group_interval: NotRequired[pulumi.Input[_builtins.str]]
        """
        Minimum time interval between two notifications for the same group. Default is 5 minutes.
        """
        group_wait: NotRequired[pulumi.Input[_builtins.str]]
        """
        Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.
        """
        mute_timings: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of mute timing names to apply to alerts that match this policy.
        """
        repeat_interval: NotRequired[pulumi.Input[_builtins.str]]
        """
        Minimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.
        """
elif False:
    RuleGroupRuleNotificationSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleNotificationSettingsArgs:
    def __init__(__self__, *,
                 contact_point: pulumi.Input[_builtins.str],
                 active_timings: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 group_interval: Optional[pulumi.Input[_builtins.str]] = None,
                 group_wait: Optional[pulumi.Input[_builtins.str]] = None,
                 mute_timings: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 repeat_interval: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] contact_point: The contact point to route notifications that match this rule to.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] active_timings: A list of time interval names to apply to alerts that match this policy to suppress them unless they are sent at the specified time. Supported in Grafana 12.1.0 and later
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] group_bies: A list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping. If empty, no grouping is used. If specified, requires labels 'alertname' and 'grafana_folder' to be included.
        :param pulumi.Input[_builtins.str] group_interval: Minimum time interval between two notifications for the same group. Default is 5 minutes.
        :param pulumi.Input[_builtins.str] group_wait: Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] mute_timings: A list of mute timing names to apply to alerts that match this policy.
        :param pulumi.Input[_builtins.str] repeat_interval: Minimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.
        """
        pulumi.set(__self__, "contact_point", contact_point)
        if active_timings is not None:
            pulumi.set(__self__, "active_timings", active_timings)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if group_interval is not None:
            pulumi.set(__self__, "group_interval", group_interval)
        if group_wait is not None:
            pulumi.set(__self__, "group_wait", group_wait)
        if mute_timings is not None:
            pulumi.set(__self__, "mute_timings", mute_timings)
        if repeat_interval is not None:
            pulumi.set(__self__, "repeat_interval", repeat_interval)

    @_builtins.property
    @pulumi.getter(name="contactPoint")
    def contact_point(self) -> pulumi.Input[_builtins.str]:
        """
        The contact point to route notifications that match this rule to.
        """
        return pulumi.get(self, "contact_point")

    @contact_point.setter
    def contact_point(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "contact_point", value)

    @_builtins.property
    @pulumi.getter(name="activeTimings")
    def active_timings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of time interval names to apply to alerts that match this policy to suppress them unless they are sent at the specified time. Supported in Grafana 12.1.0 and later
        """
        return pulumi.get(self, "active_timings")

    @active_timings.setter
    def active_timings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "active_timings", value)

    @_builtins.property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping. If empty, no grouping is used. If specified, requires labels 'alertname' and 'grafana_folder' to be included.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "group_bies", value)

    @_builtins.property
    @pulumi.getter(name="groupInterval")
    def group_interval(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Minimum time interval between two notifications for the same group. Default is 5 minutes.
        """
        return pulumi.get(self, "group_interval")

    @group_interval.setter
    def group_interval(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "group_interval", value)

    @_builtins.property
    @pulumi.getter(name="groupWait")
    def group_wait(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.
        """
        return pulumi.get(self, "group_wait")

    @group_wait.setter
    def group_wait(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "group_wait", value)

    @_builtins.property
    @pulumi.getter(name="muteTimings")
    def mute_timings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of mute timing names to apply to alerts that match this policy.
        """
        return pulumi.get(self, "mute_timings")

    @mute_timings.setter
    def mute_timings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "mute_timings", value)

    @_builtins.property
    @pulumi.getter(name="repeatInterval")
    def repeat_interval(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Minimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.
        """
        return pulumi.get(self, "repeat_interval")

    @repeat_interval.setter
    def repeat_interval(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "repeat_interval", value)


if not MYPY:
    class RuleGroupRuleRecordArgsDict(TypedDict):
        from_: pulumi.Input[_builtins.str]
        """
        The ref id of the query node in the data field to use as the source of the metric.
        """
        metric: pulumi.Input[_builtins.str]
        """
        The name of the metric to write to.
        """
        target_datasource_uid: NotRequired[pulumi.Input[_builtins.str]]
        """
        The UID of the datasource to write the metric to.
        """
elif False:
    RuleGroupRuleRecordArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleRecordArgs:
    def __init__(__self__, *,
                 from_: pulumi.Input[_builtins.str],
                 metric: pulumi.Input[_builtins.str],
                 target_datasource_uid: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] from_: The ref id of the query node in the data field to use as the source of the metric.
        :param pulumi.Input[_builtins.str] metric: The name of the metric to write to.
        :param pulumi.Input[_builtins.str] target_datasource_uid: The UID of the datasource to write the metric to.
        """
        pulumi.set(__self__, "from_", from_)
        pulumi.set(__self__, "metric", metric)
        if target_datasource_uid is not None:
            pulumi.set(__self__, "target_datasource_uid", target_datasource_uid)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> pulumi.Input[_builtins.str]:
        """
        The ref id of the query node in the data field to use as the source of the metric.
        """
        return pulumi.get(self, "from_")

    @from_.setter
    def from_(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "from_", value)

    @_builtins.property
    @pulumi.getter
    def metric(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the metric to write to.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "metric", value)

    @_builtins.property
    @pulumi.getter(name="targetDatasourceUid")
    def target_datasource_uid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The UID of the datasource to write the metric to.
        """
        return pulumi.get(self, "target_datasource_uid")

    @target_datasource_uid.setter
    def target_datasource_uid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "target_datasource_uid", value)


