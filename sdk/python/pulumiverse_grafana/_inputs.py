# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities

__all__ = [
    'CloudAccessPolicyRealmArgs',
    'CloudAccessPolicyRealmLabelPolicyArgs',
    'ContactPointAlertmanagerArgs',
    'ContactPointDingdingArgs',
    'ContactPointDiscordArgs',
    'ContactPointEmailArgs',
    'ContactPointGooglechatArgs',
    'ContactPointKafkaArgs',
    'ContactPointLineArgs',
    'ContactPointOncallArgs',
    'ContactPointOpsgenyArgs',
    'ContactPointOpsgenyResponderArgs',
    'ContactPointPagerdutyArgs',
    'ContactPointPushoverArgs',
    'ContactPointSensugoArgs',
    'ContactPointSlackArgs',
    'ContactPointSnArgs',
    'ContactPointTeamArgs',
    'ContactPointTelegramArgs',
    'ContactPointThreemaArgs',
    'ContactPointVictoropArgs',
    'ContactPointWebexArgs',
    'ContactPointWebhookArgs',
    'ContactPointWecomArgs',
    'DashboardPermissionPermissionArgs',
    'DataSourcePermissionPermissionArgs',
    'FolderPermissionPermissionArgs',
    'MachineLearningHolidayCustomPeriodArgs',
    'MachineLearningOutlierDetectorAlgorithmArgs',
    'MachineLearningOutlierDetectorAlgorithmConfigArgs',
    'MuteTimingIntervalArgs',
    'MuteTimingIntervalTimeArgs',
    'NotificationPolicyPolicyArgs',
    'NotificationPolicyPolicyMatcherArgs',
    'NotificationPolicyPolicyPolicyArgs',
    'NotificationPolicyPolicyPolicyMatcherArgs',
    'NotificationPolicyPolicyPolicyPolicyArgs',
    'NotificationPolicyPolicyPolicyPolicyMatcherArgs',
    'NotificationPolicyPolicyPolicyPolicyPolicyArgs',
    'NotificationPolicyPolicyPolicyPolicyPolicyMatcherArgs',
    'OncallIntegrationDefaultRouteArgs',
    'OncallIntegrationDefaultRouteMsteamsArgs',
    'OncallIntegrationDefaultRouteSlackArgs',
    'OncallIntegrationDefaultRouteTelegramArgs',
    'OncallIntegrationTemplatesArgs',
    'OncallIntegrationTemplatesEmailArgs',
    'OncallIntegrationTemplatesMicrosoftTeamsArgs',
    'OncallIntegrationTemplatesPhoneCallArgs',
    'OncallIntegrationTemplatesSlackArgs',
    'OncallIntegrationTemplatesSmsArgs',
    'OncallIntegrationTemplatesTelegramArgs',
    'OncallIntegrationTemplatesWebArgs',
    'OncallRouteMsteamsArgs',
    'OncallRouteSlackArgs',
    'OncallRouteTelegramArgs',
    'OncallScheduleSlackArgs',
    'PlaylistItemArgs',
    'ReportDashboardArgs',
    'ReportDashboardTimeRangeArgs',
    'ReportScheduleArgs',
    'ReportTimeRangeArgs',
    'RolePermissionArgs',
    'RuleGroupRuleArgs',
    'RuleGroupRuleDataArgs',
    'RuleGroupRuleDataRelativeTimeRangeArgs',
    'RuleGroupRuleNotificationSettingsArgs',
    'SLOAlertingArgs',
    'SLOAlertingAnnotationArgs',
    'SLOAlertingFastburnArgs',
    'SLOAlertingFastburnAnnotationArgs',
    'SLOAlertingFastburnLabelArgs',
    'SLOAlertingLabelArgs',
    'SLOAlertingSlowburnArgs',
    'SLOAlertingSlowburnAnnotationArgs',
    'SLOAlertingSlowburnLabelArgs',
    'SLODestinationDatasourceArgs',
    'SLOLabelArgs',
    'SLOObjectiveArgs',
    'SLOQueryArgs',
    'SLOQueryFreeformArgs',
    'SLOQueryRatioArgs',
    'ServiceAccountPermissionPermissionArgs',
    'SsoSettingsOauth2SettingsArgs',
    'SyntheticMonitoringCheckSettingsArgs',
    'SyntheticMonitoringCheckSettingsDnsArgs',
    'SyntheticMonitoringCheckSettingsDnsValidateAdditionalRrArgs',
    'SyntheticMonitoringCheckSettingsDnsValidateAnswerRrsArgs',
    'SyntheticMonitoringCheckSettingsDnsValidateAuthorityRrsArgs',
    'SyntheticMonitoringCheckSettingsHttpArgs',
    'SyntheticMonitoringCheckSettingsHttpBasicAuthArgs',
    'SyntheticMonitoringCheckSettingsHttpFailIfHeaderMatchesRegexpArgs',
    'SyntheticMonitoringCheckSettingsHttpFailIfHeaderNotMatchesRegexpArgs',
    'SyntheticMonitoringCheckSettingsHttpTlsConfigArgs',
    'SyntheticMonitoringCheckSettingsMultihttpArgs',
    'SyntheticMonitoringCheckSettingsMultihttpEntryArgs',
    'SyntheticMonitoringCheckSettingsMultihttpEntryAssertionArgs',
    'SyntheticMonitoringCheckSettingsMultihttpEntryRequestArgs',
    'SyntheticMonitoringCheckSettingsMultihttpEntryRequestBodyArgs',
    'SyntheticMonitoringCheckSettingsMultihttpEntryRequestHeaderArgs',
    'SyntheticMonitoringCheckSettingsMultihttpEntryRequestQueryFieldArgs',
    'SyntheticMonitoringCheckSettingsMultihttpEntryVariableArgs',
    'SyntheticMonitoringCheckSettingsPingArgs',
    'SyntheticMonitoringCheckSettingsTcpArgs',
    'SyntheticMonitoringCheckSettingsTcpQueryResponseArgs',
    'SyntheticMonitoringCheckSettingsTcpTlsConfigArgs',
    'SyntheticMonitoringCheckSettingsTracerouteArgs',
    'TeamPreferencesArgs',
    'TeamTeamSyncArgs',
]

@pulumi.input_type
class CloudAccessPolicyRealmArgs:
    def __init__(__self__, *,
                 identifier: pulumi.Input[str],
                 type: pulumi.Input[str],
                 label_policies: Optional[pulumi.Input[Sequence[pulumi.Input['CloudAccessPolicyRealmLabelPolicyArgs']]]] = None):
        """
        :param pulumi.Input[str] identifier: The identifier of the org or stack. For orgs, this is the slug, for stacks, this is the stack ID.
        :param pulumi.Input[str] type: Whether a policy applies to a Cloud org or a specific stack. Should be one of `org` or `stack`.
        """
        pulumi.set(__self__, "identifier", identifier)
        pulumi.set(__self__, "type", type)
        if label_policies is not None:
            pulumi.set(__self__, "label_policies", label_policies)

    @property
    @pulumi.getter
    def identifier(self) -> pulumi.Input[str]:
        """
        The identifier of the org or stack. For orgs, this is the slug, for stacks, this is the stack ID.
        """
        return pulumi.get(self, "identifier")

    @identifier.setter
    def identifier(self, value: pulumi.Input[str]):
        pulumi.set(self, "identifier", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Whether a policy applies to a Cloud org or a specific stack. Should be one of `org` or `stack`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="labelPolicies")
    def label_policies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CloudAccessPolicyRealmLabelPolicyArgs']]]]:
        return pulumi.get(self, "label_policies")

    @label_policies.setter
    def label_policies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CloudAccessPolicyRealmLabelPolicyArgs']]]]):
        pulumi.set(self, "label_policies", value)


@pulumi.input_type
class CloudAccessPolicyRealmLabelPolicyArgs:
    def __init__(__self__, *,
                 selector: pulumi.Input[str]):
        """
        :param pulumi.Input[str] selector: The label selector to match in metrics or logs query. Should be in PromQL or LogQL format.
        """
        pulumi.set(__self__, "selector", selector)

    @property
    @pulumi.getter
    def selector(self) -> pulumi.Input[str]:
        """
        The label selector to match in metrics or logs query. Should be in PromQL or LogQL format.
        """
        return pulumi.get(self, "selector")

    @selector.setter
    def selector(self, value: pulumi.Input[str]):
        pulumi.set(self, "selector", value)


@pulumi.input_type
class ContactPointAlertmanagerArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 basic_auth_password: Optional[pulumi.Input[str]] = None,
                 basic_auth_user: Optional[pulumi.Input[str]] = None,
                 disable_resolve_message: Optional[pulumi.Input[bool]] = None,
                 settings: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 uid: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] url: The URL of the Alertmanager instance.
        :param pulumi.Input[str] basic_auth_password: The password component of the basic auth credentials to use.
        :param pulumi.Input[str] basic_auth_user: The username component of the basic auth credentials to use.
        :param pulumi.Input[bool] disable_resolve_message: Whether to disable sending resolve messages.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] settings: Additional custom properties to attach to the notifier.
        :param pulumi.Input[str] uid: The UID of the contact point.
        """
        pulumi.set(__self__, "url", url)
        if basic_auth_password is not None:
            pulumi.set(__self__, "basic_auth_password", basic_auth_password)
        if basic_auth_user is not None:
            pulumi.set(__self__, "basic_auth_user", basic_auth_user)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        The URL of the Alertmanager instance.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="basicAuthPassword")
    def basic_auth_password(self) -> Optional[pulumi.Input[str]]:
        """
        The password component of the basic auth credentials to use.
        """
        return pulumi.get(self, "basic_auth_password")

    @basic_auth_password.setter
    def basic_auth_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "basic_auth_password", value)

    @property
    @pulumi.getter(name="basicAuthUser")
    def basic_auth_user(self) -> Optional[pulumi.Input[str]]:
        """
        The username component of the basic auth credentials to use.
        """
        return pulumi.get(self, "basic_auth_user")

    @basic_auth_user.setter
    def basic_auth_user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "basic_auth_user", value)

    @property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to disable sending resolve messages.
        """
        return pulumi.get(self, "disable_resolve_message")

    @disable_resolve_message.setter
    def disable_resolve_message(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_resolve_message", value)

    @property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Additional custom properties to attach to the notifier.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "settings", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)


@pulumi.input_type
class ContactPointDingdingArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 disable_resolve_message: Optional[pulumi.Input[bool]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 message_type: Optional[pulumi.Input[str]] = None,
                 settings: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 uid: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] url: The DingDing webhook URL.
        :param pulumi.Input[bool] disable_resolve_message: Whether to disable sending resolve messages.
        :param pulumi.Input[str] message: The templated content of the message.
        :param pulumi.Input[str] message_type: The format of message to send - either 'link' or 'actionCard'
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] settings: Additional custom properties to attach to the notifier.
        :param pulumi.Input[str] title: The templated title of the message.
        :param pulumi.Input[str] uid: The UID of the contact point.
        """
        pulumi.set(__self__, "url", url)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if message_type is not None:
            pulumi.set(__self__, "message_type", message_type)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        The DingDing webhook URL.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to disable sending resolve messages.
        """
        return pulumi.get(self, "disable_resolve_message")

    @disable_resolve_message.setter
    def disable_resolve_message(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_resolve_message", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        The templated content of the message.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter(name="messageType")
    def message_type(self) -> Optional[pulumi.Input[str]]:
        """
        The format of message to send - either 'link' or 'actionCard'
        """
        return pulumi.get(self, "message_type")

    @message_type.setter
    def message_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message_type", value)

    @property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Additional custom properties to attach to the notifier.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "settings", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        The templated title of the message.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)


@pulumi.input_type
class ContactPointDiscordArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 avatar_url: Optional[pulumi.Input[str]] = None,
                 disable_resolve_message: Optional[pulumi.Input[bool]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 settings: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 uid: Optional[pulumi.Input[str]] = None,
                 use_discord_username: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] url: The discord webhook URL.
        :param pulumi.Input[str] avatar_url: The URL of a custom avatar image to use.
        :param pulumi.Input[bool] disable_resolve_message: Whether to disable sending resolve messages.
        :param pulumi.Input[str] message: The templated content of the message.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] settings: Additional custom properties to attach to the notifier.
        :param pulumi.Input[str] title: The templated content of the title.
        :param pulumi.Input[str] uid: The UID of the contact point.
        :param pulumi.Input[bool] use_discord_username: Whether to use the bot account's plain username instead of "Grafana."
        """
        pulumi.set(__self__, "url", url)
        if avatar_url is not None:
            pulumi.set(__self__, "avatar_url", avatar_url)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)
        if use_discord_username is not None:
            pulumi.set(__self__, "use_discord_username", use_discord_username)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        The discord webhook URL.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="avatarUrl")
    def avatar_url(self) -> Optional[pulumi.Input[str]]:
        """
        The URL of a custom avatar image to use.
        """
        return pulumi.get(self, "avatar_url")

    @avatar_url.setter
    def avatar_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "avatar_url", value)

    @property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to disable sending resolve messages.
        """
        return pulumi.get(self, "disable_resolve_message")

    @disable_resolve_message.setter
    def disable_resolve_message(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_resolve_message", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        The templated content of the message.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Additional custom properties to attach to the notifier.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "settings", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        The templated content of the title.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)

    @property
    @pulumi.getter(name="useDiscordUsername")
    def use_discord_username(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to use the bot account's plain username instead of "Grafana."
        """
        return pulumi.get(self, "use_discord_username")

    @use_discord_username.setter
    def use_discord_username(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_discord_username", value)


@pulumi.input_type
class ContactPointEmailArgs:
    def __init__(__self__, *,
                 addresses: pulumi.Input[Sequence[pulumi.Input[str]]],
                 disable_resolve_message: Optional[pulumi.Input[bool]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 settings: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 single_email: Optional[pulumi.Input[bool]] = None,
                 subject: Optional[pulumi.Input[str]] = None,
                 uid: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] addresses: The addresses to send emails to.
        :param pulumi.Input[bool] disable_resolve_message: Whether to disable sending resolve messages.
        :param pulumi.Input[str] message: The templated content of the email.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] settings: Additional custom properties to attach to the notifier.
        :param pulumi.Input[bool] single_email: Whether to send a single email CC'ing all addresses, rather than a separate email to each address.
        :param pulumi.Input[str] subject: The templated subject line of the email.
        :param pulumi.Input[str] uid: The UID of the contact point.
        """
        pulumi.set(__self__, "addresses", addresses)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if single_email is not None:
            pulumi.set(__self__, "single_email", single_email)
        if subject is not None:
            pulumi.set(__self__, "subject", subject)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter
    def addresses(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The addresses to send emails to.
        """
        return pulumi.get(self, "addresses")

    @addresses.setter
    def addresses(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "addresses", value)

    @property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to disable sending resolve messages.
        """
        return pulumi.get(self, "disable_resolve_message")

    @disable_resolve_message.setter
    def disable_resolve_message(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_resolve_message", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        The templated content of the email.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Additional custom properties to attach to the notifier.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "settings", value)

    @property
    @pulumi.getter(name="singleEmail")
    def single_email(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to send a single email CC'ing all addresses, rather than a separate email to each address.
        """
        return pulumi.get(self, "single_email")

    @single_email.setter
    def single_email(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "single_email", value)

    @property
    @pulumi.getter
    def subject(self) -> Optional[pulumi.Input[str]]:
        """
        The templated subject line of the email.
        """
        return pulumi.get(self, "subject")

    @subject.setter
    def subject(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subject", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)


@pulumi.input_type
class ContactPointGooglechatArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 disable_resolve_message: Optional[pulumi.Input[bool]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 settings: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 uid: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] url: The Google Chat webhook URL.
        :param pulumi.Input[bool] disable_resolve_message: Whether to disable sending resolve messages.
        :param pulumi.Input[str] message: The templated content of the message.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] settings: Additional custom properties to attach to the notifier.
        :param pulumi.Input[str] title: The templated content of the title.
        :param pulumi.Input[str] uid: The UID of the contact point.
        """
        pulumi.set(__self__, "url", url)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        The Google Chat webhook URL.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to disable sending resolve messages.
        """
        return pulumi.get(self, "disable_resolve_message")

    @disable_resolve_message.setter
    def disable_resolve_message(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_resolve_message", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        The templated content of the message.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Additional custom properties to attach to the notifier.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "settings", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        The templated content of the title.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)


@pulumi.input_type
class ContactPointKafkaArgs:
    def __init__(__self__, *,
                 rest_proxy_url: pulumi.Input[str],
                 topic: pulumi.Input[str],
                 api_version: Optional[pulumi.Input[str]] = None,
                 cluster_id: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 details: Optional[pulumi.Input[str]] = None,
                 disable_resolve_message: Optional[pulumi.Input[bool]] = None,
                 password: Optional[pulumi.Input[str]] = None,
                 settings: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 uid: Optional[pulumi.Input[str]] = None,
                 username: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] rest_proxy_url: The URL of the Kafka REST proxy to send requests to.
        :param pulumi.Input[str] topic: The name of the Kafka topic to publish to.
        :param pulumi.Input[str] api_version: The API version to use when contacting the Kafka REST Server. Supported: v2 (default) and v3.
        :param pulumi.Input[str] cluster_id: The Id of cluster to use when contacting the Kafka REST Server. Required api_version to be 'v3'
        :param pulumi.Input[str] description: The templated description of the Kafka message.
        :param pulumi.Input[str] details: The templated details to include with the message.
        :param pulumi.Input[bool] disable_resolve_message: Whether to disable sending resolve messages.
        :param pulumi.Input[str] password: The password to use when making a call to the Kafka REST Proxy
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] settings: Additional custom properties to attach to the notifier.
        :param pulumi.Input[str] uid: The UID of the contact point.
        :param pulumi.Input[str] username: The user name to use when making a call to the Kafka REST Proxy
        """
        pulumi.set(__self__, "rest_proxy_url", rest_proxy_url)
        pulumi.set(__self__, "topic", topic)
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if cluster_id is not None:
            pulumi.set(__self__, "cluster_id", cluster_id)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if details is not None:
            pulumi.set(__self__, "details", details)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="restProxyUrl")
    def rest_proxy_url(self) -> pulumi.Input[str]:
        """
        The URL of the Kafka REST proxy to send requests to.
        """
        return pulumi.get(self, "rest_proxy_url")

    @rest_proxy_url.setter
    def rest_proxy_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "rest_proxy_url", value)

    @property
    @pulumi.getter
    def topic(self) -> pulumi.Input[str]:
        """
        The name of the Kafka topic to publish to.
        """
        return pulumi.get(self, "topic")

    @topic.setter
    def topic(self, value: pulumi.Input[str]):
        pulumi.set(self, "topic", value)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[pulumi.Input[str]]:
        """
        The API version to use when contacting the Kafka REST Server. Supported: v2 (default) and v3.
        """
        return pulumi.get(self, "api_version")

    @api_version.setter
    def api_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_version", value)

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Id of cluster to use when contacting the Kafka REST Server. Required api_version to be 'v3'
        """
        return pulumi.get(self, "cluster_id")

    @cluster_id.setter
    def cluster_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_id", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The templated description of the Kafka message.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def details(self) -> Optional[pulumi.Input[str]]:
        """
        The templated details to include with the message.
        """
        return pulumi.get(self, "details")

    @details.setter
    def details(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "details", value)

    @property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to disable sending resolve messages.
        """
        return pulumi.get(self, "disable_resolve_message")

    @disable_resolve_message.setter
    def disable_resolve_message(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_resolve_message", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        The password to use when making a call to the Kafka REST Proxy
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Additional custom properties to attach to the notifier.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "settings", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        The user name to use when making a call to the Kafka REST Proxy
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class ContactPointLineArgs:
    def __init__(__self__, *,
                 token: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None,
                 disable_resolve_message: Optional[pulumi.Input[bool]] = None,
                 settings: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 uid: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] token: The bearer token used to authorize the client.
        :param pulumi.Input[str] description: The templated description of the message.
        :param pulumi.Input[bool] disable_resolve_message: Whether to disable sending resolve messages.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] settings: Additional custom properties to attach to the notifier.
        :param pulumi.Input[str] title: The templated title of the message.
        :param pulumi.Input[str] uid: The UID of the contact point.
        """
        pulumi.set(__self__, "token", token)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter
    def token(self) -> pulumi.Input[str]:
        """
        The bearer token used to authorize the client.
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: pulumi.Input[str]):
        pulumi.set(self, "token", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The templated description of the message.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to disable sending resolve messages.
        """
        return pulumi.get(self, "disable_resolve_message")

    @disable_resolve_message.setter
    def disable_resolve_message(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_resolve_message", value)

    @property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Additional custom properties to attach to the notifier.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "settings", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        The templated title of the message.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)


@pulumi.input_type
class ContactPointOncallArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 authorization_credentials: Optional[pulumi.Input[str]] = None,
                 authorization_scheme: Optional[pulumi.Input[str]] = None,
                 basic_auth_password: Optional[pulumi.Input[str]] = None,
                 basic_auth_user: Optional[pulumi.Input[str]] = None,
                 disable_resolve_message: Optional[pulumi.Input[bool]] = None,
                 http_method: Optional[pulumi.Input[str]] = None,
                 max_alerts: Optional[pulumi.Input[int]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 settings: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 uid: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] url: The URL to send webhook requests to.
        :param pulumi.Input[str] authorization_credentials: Allows a custom authorization scheme - attaches an auth header with this value. Do not use in conjunction with basic auth parameters.
        :param pulumi.Input[str] authorization_scheme: Allows a custom authorization scheme - attaches an auth header with this name. Do not use in conjunction with basic auth parameters.
        :param pulumi.Input[str] basic_auth_password: The username to use in basic auth headers attached to the request. If omitted, basic auth will not be used.
        :param pulumi.Input[str] basic_auth_user: The username to use in basic auth headers attached to the request. If omitted, basic auth will not be used.
        :param pulumi.Input[bool] disable_resolve_message: Whether to disable sending resolve messages.
        :param pulumi.Input[str] http_method: The HTTP method to use in the request. Defaults to `POST`.
        :param pulumi.Input[int] max_alerts: The maximum number of alerts to send in a single request. This can be helpful in limiting the size of the request body. The default is 0, which indicates no limit.
        :param pulumi.Input[str] message: Custom message. You can use template variables.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] settings: Additional custom properties to attach to the notifier.
        :param pulumi.Input[str] title: Templated title of the message.
        :param pulumi.Input[str] uid: The UID of the contact point.
        """
        pulumi.set(__self__, "url", url)
        if authorization_credentials is not None:
            pulumi.set(__self__, "authorization_credentials", authorization_credentials)
        if authorization_scheme is not None:
            pulumi.set(__self__, "authorization_scheme", authorization_scheme)
        if basic_auth_password is not None:
            pulumi.set(__self__, "basic_auth_password", basic_auth_password)
        if basic_auth_user is not None:
            pulumi.set(__self__, "basic_auth_user", basic_auth_user)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if http_method is not None:
            pulumi.set(__self__, "http_method", http_method)
        if max_alerts is not None:
            pulumi.set(__self__, "max_alerts", max_alerts)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        The URL to send webhook requests to.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="authorizationCredentials")
    def authorization_credentials(self) -> Optional[pulumi.Input[str]]:
        """
        Allows a custom authorization scheme - attaches an auth header with this value. Do not use in conjunction with basic auth parameters.
        """
        return pulumi.get(self, "authorization_credentials")

    @authorization_credentials.setter
    def authorization_credentials(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "authorization_credentials", value)

    @property
    @pulumi.getter(name="authorizationScheme")
    def authorization_scheme(self) -> Optional[pulumi.Input[str]]:
        """
        Allows a custom authorization scheme - attaches an auth header with this name. Do not use in conjunction with basic auth parameters.
        """
        return pulumi.get(self, "authorization_scheme")

    @authorization_scheme.setter
    def authorization_scheme(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "authorization_scheme", value)

    @property
    @pulumi.getter(name="basicAuthPassword")
    def basic_auth_password(self) -> Optional[pulumi.Input[str]]:
        """
        The username to use in basic auth headers attached to the request. If omitted, basic auth will not be used.
        """
        return pulumi.get(self, "basic_auth_password")

    @basic_auth_password.setter
    def basic_auth_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "basic_auth_password", value)

    @property
    @pulumi.getter(name="basicAuthUser")
    def basic_auth_user(self) -> Optional[pulumi.Input[str]]:
        """
        The username to use in basic auth headers attached to the request. If omitted, basic auth will not be used.
        """
        return pulumi.get(self, "basic_auth_user")

    @basic_auth_user.setter
    def basic_auth_user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "basic_auth_user", value)

    @property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to disable sending resolve messages.
        """
        return pulumi.get(self, "disable_resolve_message")

    @disable_resolve_message.setter
    def disable_resolve_message(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_resolve_message", value)

    @property
    @pulumi.getter(name="httpMethod")
    def http_method(self) -> Optional[pulumi.Input[str]]:
        """
        The HTTP method to use in the request. Defaults to `POST`.
        """
        return pulumi.get(self, "http_method")

    @http_method.setter
    def http_method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "http_method", value)

    @property
    @pulumi.getter(name="maxAlerts")
    def max_alerts(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of alerts to send in a single request. This can be helpful in limiting the size of the request body. The default is 0, which indicates no limit.
        """
        return pulumi.get(self, "max_alerts")

    @max_alerts.setter
    def max_alerts(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_alerts", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        Custom message. You can use template variables.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Additional custom properties to attach to the notifier.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "settings", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        Templated title of the message.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)


@pulumi.input_type
class ContactPointOpsgenyArgs:
    def __init__(__self__, *,
                 api_key: pulumi.Input[str],
                 auto_close: Optional[pulumi.Input[bool]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 disable_resolve_message: Optional[pulumi.Input[bool]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 override_priority: Optional[pulumi.Input[bool]] = None,
                 responders: Optional[pulumi.Input[Sequence[pulumi.Input['ContactPointOpsgenyResponderArgs']]]] = None,
                 send_tags_as: Optional[pulumi.Input[str]] = None,
                 settings: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 uid: Optional[pulumi.Input[str]] = None,
                 url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] api_key: The OpsGenie API key to use.
        :param pulumi.Input[bool] auto_close: Whether to auto-close alerts in OpsGenie when they resolve in the Alertmanager.
        :param pulumi.Input[str] description: A templated high-level description to use for the alert.
        :param pulumi.Input[bool] disable_resolve_message: Whether to disable sending resolve messages.
        :param pulumi.Input[str] message: The templated content of the message.
        :param pulumi.Input[bool] override_priority: Whether to allow the alert priority to be configured via the value of the `og_priority` annotation on the alert.
        :param pulumi.Input[Sequence[pulumi.Input['ContactPointOpsgenyResponderArgs']]] responders: Teams, users, escalations and schedules that the alert will be routed to send notifications. If the API Key belongs to a team integration, this field will be overwritten with the owner team. This feature is available from Grafana 10.3+.
        :param pulumi.Input[str] send_tags_as: Whether to send annotations to OpsGenie as Tags, Details, or both. Supported values are `tags`, `details`, `both`, or empty to use the default behavior of Tags.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] settings: Additional custom properties to attach to the notifier.
        :param pulumi.Input[str] uid: The UID of the contact point.
        :param pulumi.Input[str] url: Allows customization of the OpsGenie API URL.
        """
        pulumi.set(__self__, "api_key", api_key)
        if auto_close is not None:
            pulumi.set(__self__, "auto_close", auto_close)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if override_priority is not None:
            pulumi.set(__self__, "override_priority", override_priority)
        if responders is not None:
            pulumi.set(__self__, "responders", responders)
        if send_tags_as is not None:
            pulumi.set(__self__, "send_tags_as", send_tags_as)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[str]:
        """
        The OpsGenie API key to use.
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_key", value)

    @property
    @pulumi.getter(name="autoClose")
    def auto_close(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to auto-close alerts in OpsGenie when they resolve in the Alertmanager.
        """
        return pulumi.get(self, "auto_close")

    @auto_close.setter
    def auto_close(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "auto_close", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        A templated high-level description to use for the alert.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to disable sending resolve messages.
        """
        return pulumi.get(self, "disable_resolve_message")

    @disable_resolve_message.setter
    def disable_resolve_message(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_resolve_message", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        The templated content of the message.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter(name="overridePriority")
    def override_priority(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to allow the alert priority to be configured via the value of the `og_priority` annotation on the alert.
        """
        return pulumi.get(self, "override_priority")

    @override_priority.setter
    def override_priority(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "override_priority", value)

    @property
    @pulumi.getter
    def responders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ContactPointOpsgenyResponderArgs']]]]:
        """
        Teams, users, escalations and schedules that the alert will be routed to send notifications. If the API Key belongs to a team integration, this field will be overwritten with the owner team. This feature is available from Grafana 10.3+.
        """
        return pulumi.get(self, "responders")

    @responders.setter
    def responders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ContactPointOpsgenyResponderArgs']]]]):
        pulumi.set(self, "responders", value)

    @property
    @pulumi.getter(name="sendTagsAs")
    def send_tags_as(self) -> Optional[pulumi.Input[str]]:
        """
        Whether to send annotations to OpsGenie as Tags, Details, or both. Supported values are `tags`, `details`, `both`, or empty to use the default behavior of Tags.
        """
        return pulumi.get(self, "send_tags_as")

    @send_tags_as.setter
    def send_tags_as(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "send_tags_as", value)

    @property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Additional custom properties to attach to the notifier.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "settings", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)

    @property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[str]]:
        """
        Allows customization of the OpsGenie API URL.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "url", value)


@pulumi.input_type
class ContactPointOpsgenyResponderArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 username: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: Type of the responder. Supported: team, teams, user, escalation, schedule or a template that is expanded to one of these values.
        :param pulumi.Input[str] id: ID of the responder. Must be specified if name and username are empty.
        :param pulumi.Input[str] name: Name of the responder. Must be specified if username and id are empty.
        :param pulumi.Input[str] username: User name of the responder. Must be specified if name and id are empty.
        """
        pulumi.set(__self__, "type", type)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of the responder. Supported: team, teams, user, escalation, schedule or a template that is expanded to one of these values.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the responder. Must be specified if name and username are empty.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the responder. Must be specified if username and id are empty.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        User name of the responder. Must be specified if name and id are empty.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class ContactPointPagerdutyArgs:
    def __init__(__self__, *,
                 integration_key: pulumi.Input[str],
                 class_: Optional[pulumi.Input[str]] = None,
                 client: Optional[pulumi.Input[str]] = None,
                 client_url: Optional[pulumi.Input[str]] = None,
                 component: Optional[pulumi.Input[str]] = None,
                 details: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 disable_resolve_message: Optional[pulumi.Input[bool]] = None,
                 group: Optional[pulumi.Input[str]] = None,
                 settings: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 severity: Optional[pulumi.Input[str]] = None,
                 source: Optional[pulumi.Input[str]] = None,
                 summary: Optional[pulumi.Input[str]] = None,
                 uid: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] integration_key: The PagerDuty API key.
        :param pulumi.Input[str] class_: The class or type of event, for example `ping failure`.
        :param pulumi.Input[str] client: The name of the monitoring client that is triggering this event.
        :param pulumi.Input[str] client_url: The URL of the monitoring client that is triggering this event.
        :param pulumi.Input[str] component: The component being affected by the event.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] details: A set of arbitrary key/value pairs that provide further detail about the incident.
        :param pulumi.Input[bool] disable_resolve_message: Whether to disable sending resolve messages.
        :param pulumi.Input[str] group: The group to which the provided component belongs to.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] settings: Additional custom properties to attach to the notifier.
        :param pulumi.Input[str] severity: The PagerDuty event severity level. Default is `critical`.
        :param pulumi.Input[str] source: The unique location of the affected system.
        :param pulumi.Input[str] summary: The templated summary message of the event.
        :param pulumi.Input[str] uid: The UID of the contact point.
        """
        pulumi.set(__self__, "integration_key", integration_key)
        if class_ is not None:
            pulumi.set(__self__, "class_", class_)
        if client is not None:
            pulumi.set(__self__, "client", client)
        if client_url is not None:
            pulumi.set(__self__, "client_url", client_url)
        if component is not None:
            pulumi.set(__self__, "component", component)
        if details is not None:
            pulumi.set(__self__, "details", details)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if group is not None:
            pulumi.set(__self__, "group", group)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if summary is not None:
            pulumi.set(__self__, "summary", summary)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="integrationKey")
    def integration_key(self) -> pulumi.Input[str]:
        """
        The PagerDuty API key.
        """
        return pulumi.get(self, "integration_key")

    @integration_key.setter
    def integration_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "integration_key", value)

    @property
    @pulumi.getter(name="class")
    def class_(self) -> Optional[pulumi.Input[str]]:
        """
        The class or type of event, for example `ping failure`.
        """
        return pulumi.get(self, "class_")

    @class_.setter
    def class_(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "class_", value)

    @property
    @pulumi.getter
    def client(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the monitoring client that is triggering this event.
        """
        return pulumi.get(self, "client")

    @client.setter
    def client(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client", value)

    @property
    @pulumi.getter(name="clientUrl")
    def client_url(self) -> Optional[pulumi.Input[str]]:
        """
        The URL of the monitoring client that is triggering this event.
        """
        return pulumi.get(self, "client_url")

    @client_url.setter
    def client_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_url", value)

    @property
    @pulumi.getter
    def component(self) -> Optional[pulumi.Input[str]]:
        """
        The component being affected by the event.
        """
        return pulumi.get(self, "component")

    @component.setter
    def component(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "component", value)

    @property
    @pulumi.getter
    def details(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A set of arbitrary key/value pairs that provide further detail about the incident.
        """
        return pulumi.get(self, "details")

    @details.setter
    def details(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "details", value)

    @property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to disable sending resolve messages.
        """
        return pulumi.get(self, "disable_resolve_message")

    @disable_resolve_message.setter
    def disable_resolve_message(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_resolve_message", value)

    @property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input[str]]:
        """
        The group to which the provided component belongs to.
        """
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group", value)

    @property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Additional custom properties to attach to the notifier.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "settings", value)

    @property
    @pulumi.getter
    def severity(self) -> Optional[pulumi.Input[str]]:
        """
        The PagerDuty event severity level. Default is `critical`.
        """
        return pulumi.get(self, "severity")

    @severity.setter
    def severity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "severity", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[str]]:
        """
        The unique location of the affected system.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter
    def summary(self) -> Optional[pulumi.Input[str]]:
        """
        The templated summary message of the event.
        """
        return pulumi.get(self, "summary")

    @summary.setter
    def summary(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "summary", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)


@pulumi.input_type
class ContactPointPushoverArgs:
    def __init__(__self__, *,
                 api_token: pulumi.Input[str],
                 user_key: pulumi.Input[str],
                 device: Optional[pulumi.Input[str]] = None,
                 disable_resolve_message: Optional[pulumi.Input[bool]] = None,
                 expire: Optional[pulumi.Input[int]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 ok_priority: Optional[pulumi.Input[int]] = None,
                 ok_sound: Optional[pulumi.Input[str]] = None,
                 priority: Optional[pulumi.Input[int]] = None,
                 retry: Optional[pulumi.Input[int]] = None,
                 settings: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 sound: Optional[pulumi.Input[str]] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 uid: Optional[pulumi.Input[str]] = None,
                 upload_image: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] api_token: The Pushover API token.
        :param pulumi.Input[str] user_key: The Pushover user key.
        :param pulumi.Input[str] device: Comma-separated list of devices to which the event is associated.
        :param pulumi.Input[bool] disable_resolve_message: Whether to disable sending resolve messages.
        :param pulumi.Input[int] expire: How many seconds for which the notification will continue to be retried by Pushover.
        :param pulumi.Input[str] message: The templated notification message content.
        :param pulumi.Input[int] ok_priority: The priority level of the resolved event.
        :param pulumi.Input[str] ok_sound: The sound associated with the resolved notification.
        :param pulumi.Input[int] priority: The priority level of the event.
        :param pulumi.Input[int] retry: How often, in seconds, the Pushover servers will send the same notification to the user.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] settings: Additional custom properties to attach to the notifier.
        :param pulumi.Input[str] sound: The sound associated with the notification.
        :param pulumi.Input[str] title: The templated title of the message.
        :param pulumi.Input[str] uid: The UID of the contact point.
        :param pulumi.Input[bool] upload_image: Whether to send images in the notification or not. Default is true. Requires Grafana to be configured to send images in notifications.
        """
        pulumi.set(__self__, "api_token", api_token)
        pulumi.set(__self__, "user_key", user_key)
        if device is not None:
            pulumi.set(__self__, "device", device)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if expire is not None:
            pulumi.set(__self__, "expire", expire)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if ok_priority is not None:
            pulumi.set(__self__, "ok_priority", ok_priority)
        if ok_sound is not None:
            pulumi.set(__self__, "ok_sound", ok_sound)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if retry is not None:
            pulumi.set(__self__, "retry", retry)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if sound is not None:
            pulumi.set(__self__, "sound", sound)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)
        if upload_image is not None:
            pulumi.set(__self__, "upload_image", upload_image)

    @property
    @pulumi.getter(name="apiToken")
    def api_token(self) -> pulumi.Input[str]:
        """
        The Pushover API token.
        """
        return pulumi.get(self, "api_token")

    @api_token.setter
    def api_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_token", value)

    @property
    @pulumi.getter(name="userKey")
    def user_key(self) -> pulumi.Input[str]:
        """
        The Pushover user key.
        """
        return pulumi.get(self, "user_key")

    @user_key.setter
    def user_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "user_key", value)

    @property
    @pulumi.getter
    def device(self) -> Optional[pulumi.Input[str]]:
        """
        Comma-separated list of devices to which the event is associated.
        """
        return pulumi.get(self, "device")

    @device.setter
    def device(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "device", value)

    @property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to disable sending resolve messages.
        """
        return pulumi.get(self, "disable_resolve_message")

    @disable_resolve_message.setter
    def disable_resolve_message(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_resolve_message", value)

    @property
    @pulumi.getter
    def expire(self) -> Optional[pulumi.Input[int]]:
        """
        How many seconds for which the notification will continue to be retried by Pushover.
        """
        return pulumi.get(self, "expire")

    @expire.setter
    def expire(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "expire", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        The templated notification message content.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter(name="okPriority")
    def ok_priority(self) -> Optional[pulumi.Input[int]]:
        """
        The priority level of the resolved event.
        """
        return pulumi.get(self, "ok_priority")

    @ok_priority.setter
    def ok_priority(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ok_priority", value)

    @property
    @pulumi.getter(name="okSound")
    def ok_sound(self) -> Optional[pulumi.Input[str]]:
        """
        The sound associated with the resolved notification.
        """
        return pulumi.get(self, "ok_sound")

    @ok_sound.setter
    def ok_sound(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ok_sound", value)

    @property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[int]]:
        """
        The priority level of the event.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def retry(self) -> Optional[pulumi.Input[int]]:
        """
        How often, in seconds, the Pushover servers will send the same notification to the user.
        """
        return pulumi.get(self, "retry")

    @retry.setter
    def retry(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "retry", value)

    @property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Additional custom properties to attach to the notifier.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "settings", value)

    @property
    @pulumi.getter
    def sound(self) -> Optional[pulumi.Input[str]]:
        """
        The sound associated with the notification.
        """
        return pulumi.get(self, "sound")

    @sound.setter
    def sound(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sound", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        The templated title of the message.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)

    @property
    @pulumi.getter(name="uploadImage")
    def upload_image(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to send images in the notification or not. Default is true. Requires Grafana to be configured to send images in notifications.
        """
        return pulumi.get(self, "upload_image")

    @upload_image.setter
    def upload_image(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "upload_image", value)


@pulumi.input_type
class ContactPointSensugoArgs:
    def __init__(__self__, *,
                 api_key: pulumi.Input[str],
                 url: pulumi.Input[str],
                 check: Optional[pulumi.Input[str]] = None,
                 disable_resolve_message: Optional[pulumi.Input[bool]] = None,
                 entity: Optional[pulumi.Input[str]] = None,
                 handler: Optional[pulumi.Input[str]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 namespace: Optional[pulumi.Input[str]] = None,
                 settings: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 uid: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] api_key: The SensuGo API key.
        :param pulumi.Input[str] url: The SensuGo URL to send requests to.
        :param pulumi.Input[str] check: The SensuGo check to which the event should be routed.
        :param pulumi.Input[bool] disable_resolve_message: Whether to disable sending resolve messages.
        :param pulumi.Input[str] entity: The entity being monitored.
        :param pulumi.Input[str] handler: A custom handler to execute in addition to the check.
        :param pulumi.Input[str] message: Templated message content describing the alert.
        :param pulumi.Input[str] namespace: The namespace in which the check resides.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] settings: Additional custom properties to attach to the notifier.
        :param pulumi.Input[str] uid: The UID of the contact point.
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "url", url)
        if check is not None:
            pulumi.set(__self__, "check", check)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if entity is not None:
            pulumi.set(__self__, "entity", entity)
        if handler is not None:
            pulumi.set(__self__, "handler", handler)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[str]:
        """
        The SensuGo API key.
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_key", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        The SensuGo URL to send requests to.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter
    def check(self) -> Optional[pulumi.Input[str]]:
        """
        The SensuGo check to which the event should be routed.
        """
        return pulumi.get(self, "check")

    @check.setter
    def check(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "check", value)

    @property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to disable sending resolve messages.
        """
        return pulumi.get(self, "disable_resolve_message")

    @disable_resolve_message.setter
    def disable_resolve_message(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_resolve_message", value)

    @property
    @pulumi.getter
    def entity(self) -> Optional[pulumi.Input[str]]:
        """
        The entity being monitored.
        """
        return pulumi.get(self, "entity")

    @entity.setter
    def entity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "entity", value)

    @property
    @pulumi.getter
    def handler(self) -> Optional[pulumi.Input[str]]:
        """
        A custom handler to execute in addition to the check.
        """
        return pulumi.get(self, "handler")

    @handler.setter
    def handler(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "handler", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        Templated message content describing the alert.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        """
        The namespace in which the check resides.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Additional custom properties to attach to the notifier.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "settings", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)


@pulumi.input_type
class ContactPointSlackArgs:
    def __init__(__self__, *,
                 disable_resolve_message: Optional[pulumi.Input[bool]] = None,
                 endpoint_url: Optional[pulumi.Input[str]] = None,
                 icon_emoji: Optional[pulumi.Input[str]] = None,
                 icon_url: Optional[pulumi.Input[str]] = None,
                 mention_channel: Optional[pulumi.Input[str]] = None,
                 mention_groups: Optional[pulumi.Input[str]] = None,
                 mention_users: Optional[pulumi.Input[str]] = None,
                 recipient: Optional[pulumi.Input[str]] = None,
                 settings: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 text: Optional[pulumi.Input[str]] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 token: Optional[pulumi.Input[str]] = None,
                 uid: Optional[pulumi.Input[str]] = None,
                 url: Optional[pulumi.Input[str]] = None,
                 username: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] disable_resolve_message: Whether to disable sending resolve messages.
        :param pulumi.Input[str] endpoint_url: Use this to override the Slack API endpoint URL to send requests to.
        :param pulumi.Input[str] icon_emoji: The name of a Slack workspace emoji to use as the bot icon.
        :param pulumi.Input[str] icon_url: A URL of an image to use as the bot icon.
        :param pulumi.Input[str] mention_channel: Describes how to ping the slack channel that messages are being sent to. Options are `here` for an @here ping, `channel` for @channel, or empty for no ping.
        :param pulumi.Input[str] mention_groups: Comma-separated list of groups to mention in the message.
        :param pulumi.Input[str] mention_users: Comma-separated list of users to mention in the message.
        :param pulumi.Input[str] recipient: Channel, private group, or IM channel (can be an encoded ID or a name) to send messages to.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] settings: Additional custom properties to attach to the notifier.
        :param pulumi.Input[str] text: Templated content of the message.
        :param pulumi.Input[str] title: Templated title of the message.
        :param pulumi.Input[str] token: A Slack API token,for sending messages directly without the webhook method.
        :param pulumi.Input[str] uid: The UID of the contact point.
        :param pulumi.Input[str] url: A Slack webhook URL,for sending messages via the webhook method.
        :param pulumi.Input[str] username: Username for the bot to use.
        """
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if endpoint_url is not None:
            pulumi.set(__self__, "endpoint_url", endpoint_url)
        if icon_emoji is not None:
            pulumi.set(__self__, "icon_emoji", icon_emoji)
        if icon_url is not None:
            pulumi.set(__self__, "icon_url", icon_url)
        if mention_channel is not None:
            pulumi.set(__self__, "mention_channel", mention_channel)
        if mention_groups is not None:
            pulumi.set(__self__, "mention_groups", mention_groups)
        if mention_users is not None:
            pulumi.set(__self__, "mention_users", mention_users)
        if recipient is not None:
            pulumi.set(__self__, "recipient", recipient)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if text is not None:
            pulumi.set(__self__, "text", text)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if token is not None:
            pulumi.set(__self__, "token", token)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to disable sending resolve messages.
        """
        return pulumi.get(self, "disable_resolve_message")

    @disable_resolve_message.setter
    def disable_resolve_message(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_resolve_message", value)

    @property
    @pulumi.getter(name="endpointUrl")
    def endpoint_url(self) -> Optional[pulumi.Input[str]]:
        """
        Use this to override the Slack API endpoint URL to send requests to.
        """
        return pulumi.get(self, "endpoint_url")

    @endpoint_url.setter
    def endpoint_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "endpoint_url", value)

    @property
    @pulumi.getter(name="iconEmoji")
    def icon_emoji(self) -> Optional[pulumi.Input[str]]:
        """
        The name of a Slack workspace emoji to use as the bot icon.
        """
        return pulumi.get(self, "icon_emoji")

    @icon_emoji.setter
    def icon_emoji(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "icon_emoji", value)

    @property
    @pulumi.getter(name="iconUrl")
    def icon_url(self) -> Optional[pulumi.Input[str]]:
        """
        A URL of an image to use as the bot icon.
        """
        return pulumi.get(self, "icon_url")

    @icon_url.setter
    def icon_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "icon_url", value)

    @property
    @pulumi.getter(name="mentionChannel")
    def mention_channel(self) -> Optional[pulumi.Input[str]]:
        """
        Describes how to ping the slack channel that messages are being sent to. Options are `here` for an @here ping, `channel` for @channel, or empty for no ping.
        """
        return pulumi.get(self, "mention_channel")

    @mention_channel.setter
    def mention_channel(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mention_channel", value)

    @property
    @pulumi.getter(name="mentionGroups")
    def mention_groups(self) -> Optional[pulumi.Input[str]]:
        """
        Comma-separated list of groups to mention in the message.
        """
        return pulumi.get(self, "mention_groups")

    @mention_groups.setter
    def mention_groups(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mention_groups", value)

    @property
    @pulumi.getter(name="mentionUsers")
    def mention_users(self) -> Optional[pulumi.Input[str]]:
        """
        Comma-separated list of users to mention in the message.
        """
        return pulumi.get(self, "mention_users")

    @mention_users.setter
    def mention_users(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mention_users", value)

    @property
    @pulumi.getter
    def recipient(self) -> Optional[pulumi.Input[str]]:
        """
        Channel, private group, or IM channel (can be an encoded ID or a name) to send messages to.
        """
        return pulumi.get(self, "recipient")

    @recipient.setter
    def recipient(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "recipient", value)

    @property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Additional custom properties to attach to the notifier.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "settings", value)

    @property
    @pulumi.getter
    def text(self) -> Optional[pulumi.Input[str]]:
        """
        Templated content of the message.
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "text", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        Templated title of the message.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def token(self) -> Optional[pulumi.Input[str]]:
        """
        A Slack API token,for sending messages directly without the webhook method.
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "token", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)

    @property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[str]]:
        """
        A Slack webhook URL,for sending messages via the webhook method.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        Username for the bot to use.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class ContactPointSnArgs:
    def __init__(__self__, *,
                 topic: pulumi.Input[str],
                 access_key: Optional[pulumi.Input[str]] = None,
                 assume_role_arn: Optional[pulumi.Input[str]] = None,
                 auth_provider: Optional[pulumi.Input[str]] = None,
                 body: Optional[pulumi.Input[str]] = None,
                 disable_resolve_message: Optional[pulumi.Input[bool]] = None,
                 external_id: Optional[pulumi.Input[str]] = None,
                 message_format: Optional[pulumi.Input[str]] = None,
                 secret_key: Optional[pulumi.Input[str]] = None,
                 settings: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 subject: Optional[pulumi.Input[str]] = None,
                 uid: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] topic: The Amazon SNS topic to send notifications to.
        :param pulumi.Input[str] access_key: AWS access key ID used to authenticate with Amazon SNS.
        :param pulumi.Input[str] assume_role_arn: The Amazon Resource Name (ARN) of the role to assume to send notifications to Amazon SNS.
        :param pulumi.Input[str] auth_provider: The authentication provider to use. Valid values are `default`, `arn` and `keys`. Default is `default`.
        :param pulumi.Input[bool] disable_resolve_message: Whether to disable sending resolve messages.
        :param pulumi.Input[str] external_id: The external ID to use when assuming the role.
        :param pulumi.Input[str] message_format: The format of the message to send. Valid values are `text`, `body` and `json`. Default is `text`.
        :param pulumi.Input[str] secret_key: AWS secret access key used to authenticate with Amazon SNS.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] settings: Additional custom properties to attach to the notifier.
        :param pulumi.Input[str] uid: The UID of the contact point.
        """
        pulumi.set(__self__, "topic", topic)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if assume_role_arn is not None:
            pulumi.set(__self__, "assume_role_arn", assume_role_arn)
        if auth_provider is not None:
            pulumi.set(__self__, "auth_provider", auth_provider)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)
        if message_format is not None:
            pulumi.set(__self__, "message_format", message_format)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if subject is not None:
            pulumi.set(__self__, "subject", subject)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter
    def topic(self) -> pulumi.Input[str]:
        """
        The Amazon SNS topic to send notifications to.
        """
        return pulumi.get(self, "topic")

    @topic.setter
    def topic(self, value: pulumi.Input[str]):
        pulumi.set(self, "topic", value)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[pulumi.Input[str]]:
        """
        AWS access key ID used to authenticate with Amazon SNS.
        """
        return pulumi.get(self, "access_key")

    @access_key.setter
    def access_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_key", value)

    @property
    @pulumi.getter(name="assumeRoleArn")
    def assume_role_arn(self) -> Optional[pulumi.Input[str]]:
        """
        The Amazon Resource Name (ARN) of the role to assume to send notifications to Amazon SNS.
        """
        return pulumi.get(self, "assume_role_arn")

    @assume_role_arn.setter
    def assume_role_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "assume_role_arn", value)

    @property
    @pulumi.getter(name="authProvider")
    def auth_provider(self) -> Optional[pulumi.Input[str]]:
        """
        The authentication provider to use. Valid values are `default`, `arn` and `keys`. Default is `default`.
        """
        return pulumi.get(self, "auth_provider")

    @auth_provider.setter
    def auth_provider(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auth_provider", value)

    @property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "body", value)

    @property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to disable sending resolve messages.
        """
        return pulumi.get(self, "disable_resolve_message")

    @disable_resolve_message.setter
    def disable_resolve_message(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_resolve_message", value)

    @property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[pulumi.Input[str]]:
        """
        The external ID to use when assuming the role.
        """
        return pulumi.get(self, "external_id")

    @external_id.setter
    def external_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "external_id", value)

    @property
    @pulumi.getter(name="messageFormat")
    def message_format(self) -> Optional[pulumi.Input[str]]:
        """
        The format of the message to send. Valid values are `text`, `body` and `json`. Default is `text`.
        """
        return pulumi.get(self, "message_format")

    @message_format.setter
    def message_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message_format", value)

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[pulumi.Input[str]]:
        """
        AWS secret access key used to authenticate with Amazon SNS.
        """
        return pulumi.get(self, "secret_key")

    @secret_key.setter
    def secret_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret_key", value)

    @property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Additional custom properties to attach to the notifier.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "settings", value)

    @property
    @pulumi.getter
    def subject(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "subject")

    @subject.setter
    def subject(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subject", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)


@pulumi.input_type
class ContactPointTeamArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 disable_resolve_message: Optional[pulumi.Input[bool]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 section_title: Optional[pulumi.Input[str]] = None,
                 settings: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 uid: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] url: A Teams webhook URL.
        :param pulumi.Input[bool] disable_resolve_message: Whether to disable sending resolve messages.
        :param pulumi.Input[str] message: The templated message content to send.
        :param pulumi.Input[str] section_title: The templated subtitle for each message section.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] settings: Additional custom properties to attach to the notifier.
        :param pulumi.Input[str] title: The templated title of the message.
        :param pulumi.Input[str] uid: The UID of the contact point.
        """
        pulumi.set(__self__, "url", url)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if section_title is not None:
            pulumi.set(__self__, "section_title", section_title)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        A Teams webhook URL.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to disable sending resolve messages.
        """
        return pulumi.get(self, "disable_resolve_message")

    @disable_resolve_message.setter
    def disable_resolve_message(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_resolve_message", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        The templated message content to send.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter(name="sectionTitle")
    def section_title(self) -> Optional[pulumi.Input[str]]:
        """
        The templated subtitle for each message section.
        """
        return pulumi.get(self, "section_title")

    @section_title.setter
    def section_title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "section_title", value)

    @property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Additional custom properties to attach to the notifier.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "settings", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        The templated title of the message.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)


@pulumi.input_type
class ContactPointTelegramArgs:
    def __init__(__self__, *,
                 chat_id: pulumi.Input[str],
                 token: pulumi.Input[str],
                 disable_notifications: Optional[pulumi.Input[bool]] = None,
                 disable_resolve_message: Optional[pulumi.Input[bool]] = None,
                 disable_web_page_preview: Optional[pulumi.Input[bool]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 parse_mode: Optional[pulumi.Input[str]] = None,
                 protect_content: Optional[pulumi.Input[bool]] = None,
                 settings: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 uid: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] chat_id: The chat ID to send messages to.
        :param pulumi.Input[str] token: The Telegram bot token.
        :param pulumi.Input[bool] disable_notifications: When set users will receive a notification with no sound.
        :param pulumi.Input[bool] disable_resolve_message: Whether to disable sending resolve messages.
        :param pulumi.Input[bool] disable_web_page_preview: When set it disables link previews for links in the message.
        :param pulumi.Input[str] message: The templated content of the message.
        :param pulumi.Input[str] parse_mode: Mode for parsing entities in the message text. Supported: None, Markdown, MarkdownV2, and HTML. HTML is the default.
        :param pulumi.Input[bool] protect_content: When set it protects the contents of the message from forwarding and saving.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] settings: Additional custom properties to attach to the notifier.
        :param pulumi.Input[str] uid: The UID of the contact point.
        """
        pulumi.set(__self__, "chat_id", chat_id)
        pulumi.set(__self__, "token", token)
        if disable_notifications is not None:
            pulumi.set(__self__, "disable_notifications", disable_notifications)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if disable_web_page_preview is not None:
            pulumi.set(__self__, "disable_web_page_preview", disable_web_page_preview)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if parse_mode is not None:
            pulumi.set(__self__, "parse_mode", parse_mode)
        if protect_content is not None:
            pulumi.set(__self__, "protect_content", protect_content)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="chatId")
    def chat_id(self) -> pulumi.Input[str]:
        """
        The chat ID to send messages to.
        """
        return pulumi.get(self, "chat_id")

    @chat_id.setter
    def chat_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "chat_id", value)

    @property
    @pulumi.getter
    def token(self) -> pulumi.Input[str]:
        """
        The Telegram bot token.
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: pulumi.Input[str]):
        pulumi.set(self, "token", value)

    @property
    @pulumi.getter(name="disableNotifications")
    def disable_notifications(self) -> Optional[pulumi.Input[bool]]:
        """
        When set users will receive a notification with no sound.
        """
        return pulumi.get(self, "disable_notifications")

    @disable_notifications.setter
    def disable_notifications(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_notifications", value)

    @property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to disable sending resolve messages.
        """
        return pulumi.get(self, "disable_resolve_message")

    @disable_resolve_message.setter
    def disable_resolve_message(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_resolve_message", value)

    @property
    @pulumi.getter(name="disableWebPagePreview")
    def disable_web_page_preview(self) -> Optional[pulumi.Input[bool]]:
        """
        When set it disables link previews for links in the message.
        """
        return pulumi.get(self, "disable_web_page_preview")

    @disable_web_page_preview.setter
    def disable_web_page_preview(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_web_page_preview", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        The templated content of the message.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter(name="parseMode")
    def parse_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Mode for parsing entities in the message text. Supported: None, Markdown, MarkdownV2, and HTML. HTML is the default.
        """
        return pulumi.get(self, "parse_mode")

    @parse_mode.setter
    def parse_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "parse_mode", value)

    @property
    @pulumi.getter(name="protectContent")
    def protect_content(self) -> Optional[pulumi.Input[bool]]:
        """
        When set it protects the contents of the message from forwarding and saving.
        """
        return pulumi.get(self, "protect_content")

    @protect_content.setter
    def protect_content(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "protect_content", value)

    @property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Additional custom properties to attach to the notifier.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "settings", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)


@pulumi.input_type
class ContactPointThreemaArgs:
    def __init__(__self__, *,
                 api_secret: pulumi.Input[str],
                 gateway_id: pulumi.Input[str],
                 recipient_id: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None,
                 disable_resolve_message: Optional[pulumi.Input[bool]] = None,
                 settings: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 uid: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] api_secret: The Threema API key.
        :param pulumi.Input[str] gateway_id: The Threema gateway ID.
        :param pulumi.Input[str] recipient_id: The ID of the recipient of the message.
        :param pulumi.Input[str] description: The templated description of the message.
        :param pulumi.Input[bool] disable_resolve_message: Whether to disable sending resolve messages.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] settings: Additional custom properties to attach to the notifier.
        :param pulumi.Input[str] title: The templated title of the message.
        :param pulumi.Input[str] uid: The UID of the contact point.
        """
        pulumi.set(__self__, "api_secret", api_secret)
        pulumi.set(__self__, "gateway_id", gateway_id)
        pulumi.set(__self__, "recipient_id", recipient_id)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="apiSecret")
    def api_secret(self) -> pulumi.Input[str]:
        """
        The Threema API key.
        """
        return pulumi.get(self, "api_secret")

    @api_secret.setter
    def api_secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_secret", value)

    @property
    @pulumi.getter(name="gatewayId")
    def gateway_id(self) -> pulumi.Input[str]:
        """
        The Threema gateway ID.
        """
        return pulumi.get(self, "gateway_id")

    @gateway_id.setter
    def gateway_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "gateway_id", value)

    @property
    @pulumi.getter(name="recipientId")
    def recipient_id(self) -> pulumi.Input[str]:
        """
        The ID of the recipient of the message.
        """
        return pulumi.get(self, "recipient_id")

    @recipient_id.setter
    def recipient_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "recipient_id", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The templated description of the message.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to disable sending resolve messages.
        """
        return pulumi.get(self, "disable_resolve_message")

    @disable_resolve_message.setter
    def disable_resolve_message(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_resolve_message", value)

    @property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Additional custom properties to attach to the notifier.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "settings", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        The templated title of the message.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)


@pulumi.input_type
class ContactPointVictoropArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None,
                 disable_resolve_message: Optional[pulumi.Input[bool]] = None,
                 message_type: Optional[pulumi.Input[str]] = None,
                 settings: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 uid: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] url: The VictorOps webhook URL.
        :param pulumi.Input[str] description: Templated description of the message.
        :param pulumi.Input[bool] disable_resolve_message: Whether to disable sending resolve messages.
        :param pulumi.Input[str] message_type: The VictorOps alert state - typically either `CRITICAL` or `RECOVERY`.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] settings: Additional custom properties to attach to the notifier.
        :param pulumi.Input[str] title: Templated title to display.
        :param pulumi.Input[str] uid: The UID of the contact point.
        """
        pulumi.set(__self__, "url", url)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if message_type is not None:
            pulumi.set(__self__, "message_type", message_type)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        The VictorOps webhook URL.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Templated description of the message.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to disable sending resolve messages.
        """
        return pulumi.get(self, "disable_resolve_message")

    @disable_resolve_message.setter
    def disable_resolve_message(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_resolve_message", value)

    @property
    @pulumi.getter(name="messageType")
    def message_type(self) -> Optional[pulumi.Input[str]]:
        """
        The VictorOps alert state - typically either `CRITICAL` or `RECOVERY`.
        """
        return pulumi.get(self, "message_type")

    @message_type.setter
    def message_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message_type", value)

    @property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Additional custom properties to attach to the notifier.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "settings", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        Templated title to display.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)


@pulumi.input_type
class ContactPointWebexArgs:
    def __init__(__self__, *,
                 api_url: Optional[pulumi.Input[str]] = None,
                 disable_resolve_message: Optional[pulumi.Input[bool]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 room_id: Optional[pulumi.Input[str]] = None,
                 settings: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 token: Optional[pulumi.Input[str]] = None,
                 uid: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] api_url: The URL to send webhook requests to.
        :param pulumi.Input[bool] disable_resolve_message: Whether to disable sending resolve messages.
        :param pulumi.Input[str] message: The templated title of the message to send.
        :param pulumi.Input[str] room_id: ID of the Webex Teams room where to send the messages.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] settings: Additional custom properties to attach to the notifier.
        :param pulumi.Input[str] token: The bearer token used to authorize the client.
        :param pulumi.Input[str] uid: The UID of the contact point.
        """
        if api_url is not None:
            pulumi.set(__self__, "api_url", api_url)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if room_id is not None:
            pulumi.set(__self__, "room_id", room_id)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if token is not None:
            pulumi.set(__self__, "token", token)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="apiUrl")
    def api_url(self) -> Optional[pulumi.Input[str]]:
        """
        The URL to send webhook requests to.
        """
        return pulumi.get(self, "api_url")

    @api_url.setter
    def api_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_url", value)

    @property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to disable sending resolve messages.
        """
        return pulumi.get(self, "disable_resolve_message")

    @disable_resolve_message.setter
    def disable_resolve_message(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_resolve_message", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        The templated title of the message to send.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter(name="roomId")
    def room_id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the Webex Teams room where to send the messages.
        """
        return pulumi.get(self, "room_id")

    @room_id.setter
    def room_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "room_id", value)

    @property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Additional custom properties to attach to the notifier.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "settings", value)

    @property
    @pulumi.getter
    def token(self) -> Optional[pulumi.Input[str]]:
        """
        The bearer token used to authorize the client.
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "token", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)


@pulumi.input_type
class ContactPointWebhookArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 authorization_credentials: Optional[pulumi.Input[str]] = None,
                 authorization_scheme: Optional[pulumi.Input[str]] = None,
                 basic_auth_password: Optional[pulumi.Input[str]] = None,
                 basic_auth_user: Optional[pulumi.Input[str]] = None,
                 disable_resolve_message: Optional[pulumi.Input[bool]] = None,
                 http_method: Optional[pulumi.Input[str]] = None,
                 max_alerts: Optional[pulumi.Input[int]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 settings: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 uid: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] url: The URL to send webhook requests to.
        :param pulumi.Input[str] authorization_credentials: Allows a custom authorization scheme - attaches an auth header with this value. Do not use in conjunction with basic auth parameters.
        :param pulumi.Input[str] authorization_scheme: Allows a custom authorization scheme - attaches an auth header with this name. Do not use in conjunction with basic auth parameters.
        :param pulumi.Input[str] basic_auth_password: The username to use in basic auth headers attached to the request. If omitted, basic auth will not be used.
        :param pulumi.Input[str] basic_auth_user: The username to use in basic auth headers attached to the request. If omitted, basic auth will not be used.
        :param pulumi.Input[bool] disable_resolve_message: Whether to disable sending resolve messages.
        :param pulumi.Input[str] http_method: The HTTP method to use in the request. Defaults to `POST`.
        :param pulumi.Input[int] max_alerts: The maximum number of alerts to send in a single request. This can be helpful in limiting the size of the request body. The default is 0, which indicates no limit.
        :param pulumi.Input[str] message: Custom message. You can use template variables.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] settings: Additional custom properties to attach to the notifier.
        :param pulumi.Input[str] title: Templated title of the message.
        :param pulumi.Input[str] uid: The UID of the contact point.
        """
        pulumi.set(__self__, "url", url)
        if authorization_credentials is not None:
            pulumi.set(__self__, "authorization_credentials", authorization_credentials)
        if authorization_scheme is not None:
            pulumi.set(__self__, "authorization_scheme", authorization_scheme)
        if basic_auth_password is not None:
            pulumi.set(__self__, "basic_auth_password", basic_auth_password)
        if basic_auth_user is not None:
            pulumi.set(__self__, "basic_auth_user", basic_auth_user)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if http_method is not None:
            pulumi.set(__self__, "http_method", http_method)
        if max_alerts is not None:
            pulumi.set(__self__, "max_alerts", max_alerts)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        The URL to send webhook requests to.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="authorizationCredentials")
    def authorization_credentials(self) -> Optional[pulumi.Input[str]]:
        """
        Allows a custom authorization scheme - attaches an auth header with this value. Do not use in conjunction with basic auth parameters.
        """
        return pulumi.get(self, "authorization_credentials")

    @authorization_credentials.setter
    def authorization_credentials(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "authorization_credentials", value)

    @property
    @pulumi.getter(name="authorizationScheme")
    def authorization_scheme(self) -> Optional[pulumi.Input[str]]:
        """
        Allows a custom authorization scheme - attaches an auth header with this name. Do not use in conjunction with basic auth parameters.
        """
        return pulumi.get(self, "authorization_scheme")

    @authorization_scheme.setter
    def authorization_scheme(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "authorization_scheme", value)

    @property
    @pulumi.getter(name="basicAuthPassword")
    def basic_auth_password(self) -> Optional[pulumi.Input[str]]:
        """
        The username to use in basic auth headers attached to the request. If omitted, basic auth will not be used.
        """
        return pulumi.get(self, "basic_auth_password")

    @basic_auth_password.setter
    def basic_auth_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "basic_auth_password", value)

    @property
    @pulumi.getter(name="basicAuthUser")
    def basic_auth_user(self) -> Optional[pulumi.Input[str]]:
        """
        The username to use in basic auth headers attached to the request. If omitted, basic auth will not be used.
        """
        return pulumi.get(self, "basic_auth_user")

    @basic_auth_user.setter
    def basic_auth_user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "basic_auth_user", value)

    @property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to disable sending resolve messages.
        """
        return pulumi.get(self, "disable_resolve_message")

    @disable_resolve_message.setter
    def disable_resolve_message(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_resolve_message", value)

    @property
    @pulumi.getter(name="httpMethod")
    def http_method(self) -> Optional[pulumi.Input[str]]:
        """
        The HTTP method to use in the request. Defaults to `POST`.
        """
        return pulumi.get(self, "http_method")

    @http_method.setter
    def http_method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "http_method", value)

    @property
    @pulumi.getter(name="maxAlerts")
    def max_alerts(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of alerts to send in a single request. This can be helpful in limiting the size of the request body. The default is 0, which indicates no limit.
        """
        return pulumi.get(self, "max_alerts")

    @max_alerts.setter
    def max_alerts(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_alerts", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        Custom message. You can use template variables.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Additional custom properties to attach to the notifier.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "settings", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        Templated title of the message.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)


@pulumi.input_type
class ContactPointWecomArgs:
    def __init__(__self__, *,
                 agent_id: Optional[pulumi.Input[str]] = None,
                 corp_id: Optional[pulumi.Input[str]] = None,
                 disable_resolve_message: Optional[pulumi.Input[bool]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 msg_type: Optional[pulumi.Input[str]] = None,
                 secret: Optional[pulumi.Input[str]] = None,
                 settings: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 to_user: Optional[pulumi.Input[str]] = None,
                 uid: Optional[pulumi.Input[str]] = None,
                 url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] agent_id: Agent ID added to the request payload when using APIAPP.
        :param pulumi.Input[str] corp_id: Corp ID used to get token when using APIAPP.
        :param pulumi.Input[bool] disable_resolve_message: Whether to disable sending resolve messages.
        :param pulumi.Input[str] message: The templated content of the message to send.
        :param pulumi.Input[str] msg_type: The type of them message. Supported: markdown, text. Default: text.
        :param pulumi.Input[str] secret: The secret key required to obtain access token when using APIAPP. See https://work.weixin.qq.com/wework_admin/frame#apps to create APIAPP.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] settings: Additional custom properties to attach to the notifier.
        :param pulumi.Input[str] title: The templated title of the message to send.
        :param pulumi.Input[str] to_user: The ID of user that should receive the message. Multiple entries should be separated by '|'. Default: @all.
        :param pulumi.Input[str] uid: The UID of the contact point.
        :param pulumi.Input[str] url: The WeCom webhook URL. Required if using GroupRobot.
        """
        if agent_id is not None:
            pulumi.set(__self__, "agent_id", agent_id)
        if corp_id is not None:
            pulumi.set(__self__, "corp_id", corp_id)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if msg_type is not None:
            pulumi.set(__self__, "msg_type", msg_type)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if to_user is not None:
            pulumi.set(__self__, "to_user", to_user)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter(name="agentId")
    def agent_id(self) -> Optional[pulumi.Input[str]]:
        """
        Agent ID added to the request payload when using APIAPP.
        """
        return pulumi.get(self, "agent_id")

    @agent_id.setter
    def agent_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "agent_id", value)

    @property
    @pulumi.getter(name="corpId")
    def corp_id(self) -> Optional[pulumi.Input[str]]:
        """
        Corp ID used to get token when using APIAPP.
        """
        return pulumi.get(self, "corp_id")

    @corp_id.setter
    def corp_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "corp_id", value)

    @property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to disable sending resolve messages.
        """
        return pulumi.get(self, "disable_resolve_message")

    @disable_resolve_message.setter
    def disable_resolve_message(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_resolve_message", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        The templated content of the message to send.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter(name="msgType")
    def msg_type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of them message. Supported: markdown, text. Default: text.
        """
        return pulumi.get(self, "msg_type")

    @msg_type.setter
    def msg_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "msg_type", value)

    @property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input[str]]:
        """
        The secret key required to obtain access token when using APIAPP. See https://work.weixin.qq.com/wework_admin/frame#apps to create APIAPP.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret", value)

    @property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Additional custom properties to attach to the notifier.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "settings", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        The templated title of the message to send.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter(name="toUser")
    def to_user(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of user that should receive the message. Multiple entries should be separated by '|'. Default: @all.
        """
        return pulumi.get(self, "to_user")

    @to_user.setter
    def to_user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "to_user", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)

    @property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[str]]:
        """
        The WeCom webhook URL. Required if using GroupRobot.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "url", value)


@pulumi.input_type
class DashboardPermissionPermissionArgs:
    def __init__(__self__, *,
                 permission: pulumi.Input[str],
                 role: Optional[pulumi.Input[str]] = None,
                 team_id: Optional[pulumi.Input[str]] = None,
                 user_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] permission: Permission to associate with item. Must be one of `View`, `Edit`, or `Admin`.
        :param pulumi.Input[str] role: Manage permissions for `Viewer` or `Editor` roles.
        :param pulumi.Input[str] team_id: ID of the team to manage permissions for.
        :param pulumi.Input[str] user_id: ID of the user or service account to manage permissions for.
        """
        pulumi.set(__self__, "permission", permission)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if team_id is not None:
            pulumi.set(__self__, "team_id", team_id)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)

    @property
    @pulumi.getter
    def permission(self) -> pulumi.Input[str]:
        """
        Permission to associate with item. Must be one of `View`, `Edit`, or `Admin`.
        """
        return pulumi.get(self, "permission")

    @permission.setter
    def permission(self, value: pulumi.Input[str]):
        pulumi.set(self, "permission", value)

    @property
    @pulumi.getter
    def role(self) -> Optional[pulumi.Input[str]]:
        """
        Manage permissions for `Viewer` or `Editor` roles.
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role", value)

    @property
    @pulumi.getter(name="teamId")
    def team_id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the team to manage permissions for.
        """
        return pulumi.get(self, "team_id")

    @team_id.setter
    def team_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "team_id", value)

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the user or service account to manage permissions for.
        """
        return pulumi.get(self, "user_id")

    @user_id.setter
    def user_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_id", value)


@pulumi.input_type
class DataSourcePermissionPermissionArgs:
    def __init__(__self__, *,
                 permission: pulumi.Input[str],
                 built_in_role: Optional[pulumi.Input[str]] = None,
                 team_id: Optional[pulumi.Input[str]] = None,
                 user_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] permission: Permission to associate with item. Options: `Query`, `Edit` or `Admin` (`Admin` can only be used with Grafana v10.3.0+).
        :param pulumi.Input[str] built_in_role: Name of the basic role to manage permissions for. Options: `Viewer`, `Editor` or `Admin`. Can only be set from Grafana v9.2.3+.
        :param pulumi.Input[str] team_id: ID of the team to manage permissions for.
        :param pulumi.Input[str] user_id: ID of the user or service account to manage permissions for.
        """
        pulumi.set(__self__, "permission", permission)
        if built_in_role is not None:
            pulumi.set(__self__, "built_in_role", built_in_role)
        if team_id is not None:
            pulumi.set(__self__, "team_id", team_id)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)

    @property
    @pulumi.getter
    def permission(self) -> pulumi.Input[str]:
        """
        Permission to associate with item. Options: `Query`, `Edit` or `Admin` (`Admin` can only be used with Grafana v10.3.0+).
        """
        return pulumi.get(self, "permission")

    @permission.setter
    def permission(self, value: pulumi.Input[str]):
        pulumi.set(self, "permission", value)

    @property
    @pulumi.getter(name="builtInRole")
    def built_in_role(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the basic role to manage permissions for. Options: `Viewer`, `Editor` or `Admin`. Can only be set from Grafana v9.2.3+.
        """
        return pulumi.get(self, "built_in_role")

    @built_in_role.setter
    def built_in_role(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "built_in_role", value)

    @property
    @pulumi.getter(name="teamId")
    def team_id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the team to manage permissions for.
        """
        return pulumi.get(self, "team_id")

    @team_id.setter
    def team_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "team_id", value)

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the user or service account to manage permissions for.
        """
        return pulumi.get(self, "user_id")

    @user_id.setter
    def user_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_id", value)


@pulumi.input_type
class FolderPermissionPermissionArgs:
    def __init__(__self__, *,
                 permission: pulumi.Input[str],
                 role: Optional[pulumi.Input[str]] = None,
                 team_id: Optional[pulumi.Input[str]] = None,
                 user_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] permission: Permission to associate with item. Must be one of `View`, `Edit`, or `Admin`.
        :param pulumi.Input[str] role: Manage permissions for `Viewer` or `Editor` roles.
        :param pulumi.Input[str] team_id: ID of the team to manage permissions for.
        :param pulumi.Input[str] user_id: ID of the user or service account to manage permissions for.
        """
        pulumi.set(__self__, "permission", permission)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if team_id is not None:
            pulumi.set(__self__, "team_id", team_id)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)

    @property
    @pulumi.getter
    def permission(self) -> pulumi.Input[str]:
        """
        Permission to associate with item. Must be one of `View`, `Edit`, or `Admin`.
        """
        return pulumi.get(self, "permission")

    @permission.setter
    def permission(self, value: pulumi.Input[str]):
        pulumi.set(self, "permission", value)

    @property
    @pulumi.getter
    def role(self) -> Optional[pulumi.Input[str]]:
        """
        Manage permissions for `Viewer` or `Editor` roles.
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role", value)

    @property
    @pulumi.getter(name="teamId")
    def team_id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the team to manage permissions for.
        """
        return pulumi.get(self, "team_id")

    @team_id.setter
    def team_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "team_id", value)

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the user or service account to manage permissions for.
        """
        return pulumi.get(self, "user_id")

    @user_id.setter
    def user_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_id", value)


@pulumi.input_type
class MachineLearningHolidayCustomPeriodArgs:
    def __init__(__self__, *,
                 end_time: pulumi.Input[str],
                 start_time: pulumi.Input[str],
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the custom period.
        """
        pulumi.set(__self__, "end_time", end_time)
        pulumi.set(__self__, "start_time", start_time)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> pulumi.Input[str]:
        return pulumi.get(self, "end_time")

    @end_time.setter
    def end_time(self, value: pulumi.Input[str]):
        pulumi.set(self, "end_time", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> pulumi.Input[str]:
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_time", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the custom period.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class MachineLearningOutlierDetectorAlgorithmArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 sensitivity: pulumi.Input[float],
                 config: Optional[pulumi.Input['MachineLearningOutlierDetectorAlgorithmConfigArgs']] = None):
        """
        :param pulumi.Input[str] name: The name of the algorithm to use ('mad' or 'dbscan').
        :param pulumi.Input[float] sensitivity: Specify the sensitivity of the detector (in range [0,1]).
        :param pulumi.Input['MachineLearningOutlierDetectorAlgorithmConfigArgs'] config: For DBSCAN only, specify the configuration map
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "sensitivity", sensitivity)
        if config is not None:
            pulumi.set(__self__, "config", config)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the algorithm to use ('mad' or 'dbscan').
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def sensitivity(self) -> pulumi.Input[float]:
        """
        Specify the sensitivity of the detector (in range [0,1]).
        """
        return pulumi.get(self, "sensitivity")

    @sensitivity.setter
    def sensitivity(self, value: pulumi.Input[float]):
        pulumi.set(self, "sensitivity", value)

    @property
    @pulumi.getter
    def config(self) -> Optional[pulumi.Input['MachineLearningOutlierDetectorAlgorithmConfigArgs']]:
        """
        For DBSCAN only, specify the configuration map
        """
        return pulumi.get(self, "config")

    @config.setter
    def config(self, value: Optional[pulumi.Input['MachineLearningOutlierDetectorAlgorithmConfigArgs']]):
        pulumi.set(self, "config", value)


@pulumi.input_type
class MachineLearningOutlierDetectorAlgorithmConfigArgs:
    def __init__(__self__, *,
                 epsilon: pulumi.Input[float]):
        """
        :param pulumi.Input[float] epsilon: Specify the epsilon parameter (positive float)
        """
        pulumi.set(__self__, "epsilon", epsilon)

    @property
    @pulumi.getter
    def epsilon(self) -> pulumi.Input[float]:
        """
        Specify the epsilon parameter (positive float)
        """
        return pulumi.get(self, "epsilon")

    @epsilon.setter
    def epsilon(self, value: pulumi.Input[float]):
        pulumi.set(self, "epsilon", value)


@pulumi.input_type
class MuteTimingIntervalArgs:
    def __init__(__self__, *,
                 days_of_months: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 location: Optional[pulumi.Input[str]] = None,
                 months: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 times: Optional[pulumi.Input[Sequence[pulumi.Input['MuteTimingIntervalTimeArgs']]]] = None,
                 weekdays: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 years: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] days_of_months: An inclusive range of days, 1-31, within a month, e.g. "1" or "14:16". Negative values can be used to represent days counting from the end of a month, e.g. "-1".
        :param pulumi.Input[str] location: Provides the time zone for the time interval. Must be a location in the IANA time zone database, e.g "America/New_York"
        :param pulumi.Input[Sequence[pulumi.Input[str]]] months: An inclusive range of months, either numerical or full calendar month, e.g. "1:3", "december", or "may:august".
        :param pulumi.Input[Sequence[pulumi.Input['MuteTimingIntervalTimeArgs']]] times: The time ranges, represented in minutes, during which to mute in a given day.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] weekdays: An inclusive range of weekdays, e.g. "monday" or "tuesday:thursday".
        :param pulumi.Input[Sequence[pulumi.Input[str]]] years: A positive inclusive range of years, e.g. "2030" or "2025:2026".
        """
        if days_of_months is not None:
            pulumi.set(__self__, "days_of_months", days_of_months)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if months is not None:
            pulumi.set(__self__, "months", months)
        if times is not None:
            pulumi.set(__self__, "times", times)
        if weekdays is not None:
            pulumi.set(__self__, "weekdays", weekdays)
        if years is not None:
            pulumi.set(__self__, "years", years)

    @property
    @pulumi.getter(name="daysOfMonths")
    def days_of_months(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An inclusive range of days, 1-31, within a month, e.g. "1" or "14:16". Negative values can be used to represent days counting from the end of a month, e.g. "-1".
        """
        return pulumi.get(self, "days_of_months")

    @days_of_months.setter
    def days_of_months(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "days_of_months", value)

    @property
    @pulumi.getter
    def location(self) -> Optional[pulumi.Input[str]]:
        """
        Provides the time zone for the time interval. Must be a location in the IANA time zone database, e.g "America/New_York"
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "location", value)

    @property
    @pulumi.getter
    def months(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An inclusive range of months, either numerical or full calendar month, e.g. "1:3", "december", or "may:august".
        """
        return pulumi.get(self, "months")

    @months.setter
    def months(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "months", value)

    @property
    @pulumi.getter
    def times(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MuteTimingIntervalTimeArgs']]]]:
        """
        The time ranges, represented in minutes, during which to mute in a given day.
        """
        return pulumi.get(self, "times")

    @times.setter
    def times(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MuteTimingIntervalTimeArgs']]]]):
        pulumi.set(self, "times", value)

    @property
    @pulumi.getter
    def weekdays(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An inclusive range of weekdays, e.g. "monday" or "tuesday:thursday".
        """
        return pulumi.get(self, "weekdays")

    @weekdays.setter
    def weekdays(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "weekdays", value)

    @property
    @pulumi.getter
    def years(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A positive inclusive range of years, e.g. "2030" or "2025:2026".
        """
        return pulumi.get(self, "years")

    @years.setter
    def years(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "years", value)


@pulumi.input_type
class MuteTimingIntervalTimeArgs:
    def __init__(__self__, *,
                 end: pulumi.Input[str],
                 start: pulumi.Input[str]):
        """
        :param pulumi.Input[str] end: The time, in hh:mm format, of when the interval should end exclusively.
        :param pulumi.Input[str] start: The time, in hh:mm format, of when the interval should begin inclusively.
        """
        pulumi.set(__self__, "end", end)
        pulumi.set(__self__, "start", start)

    @property
    @pulumi.getter
    def end(self) -> pulumi.Input[str]:
        """
        The time, in hh:mm format, of when the interval should end exclusively.
        """
        return pulumi.get(self, "end")

    @end.setter
    def end(self, value: pulumi.Input[str]):
        pulumi.set(self, "end", value)

    @property
    @pulumi.getter
    def start(self) -> pulumi.Input[str]:
        """
        The time, in hh:mm format, of when the interval should begin inclusively.
        """
        return pulumi.get(self, "start")

    @start.setter
    def start(self, value: pulumi.Input[str]):
        pulumi.set(self, "start", value)


@pulumi.input_type
class NotificationPolicyPolicyArgs:
    def __init__(__self__, *,
                 contact_point: pulumi.Input[str],
                 continue_: Optional[pulumi.Input[bool]] = None,
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 group_interval: Optional[pulumi.Input[str]] = None,
                 group_wait: Optional[pulumi.Input[str]] = None,
                 matchers: Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyMatcherArgs']]]] = None,
                 mute_timings: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 policies: Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyArgs']]]] = None,
                 repeat_interval: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] contact_point: The contact point to route notifications that match this rule to.
        :param pulumi.Input[bool] continue_: Whether to continue matching subsequent rules if an alert matches the current rule. Otherwise, the rule will be 'consumed' by the first policy to match it.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] group_bies: A list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping. Required for root policy only. If empty, the parent grouping is used.
        :param pulumi.Input[str] group_interval: Minimum time interval between two notifications for the same group. Default is 5 minutes.
        :param pulumi.Input[str] group_wait: Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.
        :param pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyMatcherArgs']]] matchers: Describes which labels this rule should match. When multiple matchers are supplied, an alert must match ALL matchers to be accepted by this policy. When no matchers are supplied, the rule will match all alert instances.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] mute_timings: A list of mute timing names to apply to alerts that match this policy.
        :param pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyArgs']]] policies: Routing rules for specific label sets.
        :param pulumi.Input[str] repeat_interval: Minimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.
        """
        pulumi.set(__self__, "contact_point", contact_point)
        if continue_ is not None:
            pulumi.set(__self__, "continue_", continue_)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if group_interval is not None:
            pulumi.set(__self__, "group_interval", group_interval)
        if group_wait is not None:
            pulumi.set(__self__, "group_wait", group_wait)
        if matchers is not None:
            pulumi.set(__self__, "matchers", matchers)
        if mute_timings is not None:
            pulumi.set(__self__, "mute_timings", mute_timings)
        if policies is not None:
            pulumi.set(__self__, "policies", policies)
        if repeat_interval is not None:
            pulumi.set(__self__, "repeat_interval", repeat_interval)

    @property
    @pulumi.getter(name="contactPoint")
    def contact_point(self) -> pulumi.Input[str]:
        """
        The contact point to route notifications that match this rule to.
        """
        return pulumi.get(self, "contact_point")

    @contact_point.setter
    def contact_point(self, value: pulumi.Input[str]):
        pulumi.set(self, "contact_point", value)

    @property
    @pulumi.getter(name="continue")
    def continue_(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to continue matching subsequent rules if an alert matches the current rule. Otherwise, the rule will be 'consumed' by the first policy to match it.
        """
        return pulumi.get(self, "continue_")

    @continue_.setter
    def continue_(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "continue_", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping. Required for root policy only. If empty, the parent grouping is used.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="groupInterval")
    def group_interval(self) -> Optional[pulumi.Input[str]]:
        """
        Minimum time interval between two notifications for the same group. Default is 5 minutes.
        """
        return pulumi.get(self, "group_interval")

    @group_interval.setter
    def group_interval(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group_interval", value)

    @property
    @pulumi.getter(name="groupWait")
    def group_wait(self) -> Optional[pulumi.Input[str]]:
        """
        Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.
        """
        return pulumi.get(self, "group_wait")

    @group_wait.setter
    def group_wait(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group_wait", value)

    @property
    @pulumi.getter
    def matchers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyMatcherArgs']]]]:
        """
        Describes which labels this rule should match. When multiple matchers are supplied, an alert must match ALL matchers to be accepted by this policy. When no matchers are supplied, the rule will match all alert instances.
        """
        return pulumi.get(self, "matchers")

    @matchers.setter
    def matchers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyMatcherArgs']]]]):
        pulumi.set(self, "matchers", value)

    @property
    @pulumi.getter(name="muteTimings")
    def mute_timings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of mute timing names to apply to alerts that match this policy.
        """
        return pulumi.get(self, "mute_timings")

    @mute_timings.setter
    def mute_timings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "mute_timings", value)

    @property
    @pulumi.getter
    def policies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyArgs']]]]:
        """
        Routing rules for specific label sets.
        """
        return pulumi.get(self, "policies")

    @policies.setter
    def policies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyArgs']]]]):
        pulumi.set(self, "policies", value)

    @property
    @pulumi.getter(name="repeatInterval")
    def repeat_interval(self) -> Optional[pulumi.Input[str]]:
        """
        Minimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.
        """
        return pulumi.get(self, "repeat_interval")

    @repeat_interval.setter
    def repeat_interval(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repeat_interval", value)


@pulumi.input_type
class NotificationPolicyPolicyMatcherArgs:
    def __init__(__self__, *,
                 label: pulumi.Input[str],
                 match: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] label: The name of the label to match against.
        :param pulumi.Input[str] match: The operator to apply when matching values of the given label. Allowed operators are `=` for equality, `!=` for negated equality, `=~` for regex equality, and `!~` for negated regex equality.
        :param pulumi.Input[str] value: The label value to match against.
        """
        pulumi.set(__self__, "label", label)
        pulumi.set(__self__, "match", match)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def label(self) -> pulumi.Input[str]:
        """
        The name of the label to match against.
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: pulumi.Input[str]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def match(self) -> pulumi.Input[str]:
        """
        The operator to apply when matching values of the given label. Allowed operators are `=` for equality, `!=` for negated equality, `=~` for regex equality, and `!~` for negated regex equality.
        """
        return pulumi.get(self, "match")

    @match.setter
    def match(self, value: pulumi.Input[str]):
        pulumi.set(self, "match", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The label value to match against.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class NotificationPolicyPolicyPolicyArgs:
    def __init__(__self__, *,
                 contact_point: pulumi.Input[str],
                 continue_: Optional[pulumi.Input[bool]] = None,
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 group_interval: Optional[pulumi.Input[str]] = None,
                 group_wait: Optional[pulumi.Input[str]] = None,
                 matchers: Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyMatcherArgs']]]] = None,
                 mute_timings: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 policies: Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyPolicyArgs']]]] = None,
                 repeat_interval: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] contact_point: The contact point to route notifications that match this rule to.
        :param pulumi.Input[bool] continue_: Whether to continue matching subsequent rules if an alert matches the current rule. Otherwise, the rule will be 'consumed' by the first policy to match it.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] group_bies: A list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping. Required for root policy only. If empty, the parent grouping is used.
        :param pulumi.Input[str] group_interval: Minimum time interval between two notifications for the same group. Default is 5 minutes.
        :param pulumi.Input[str] group_wait: Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.
        :param pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyMatcherArgs']]] matchers: Describes which labels this rule should match. When multiple matchers are supplied, an alert must match ALL matchers to be accepted by this policy. When no matchers are supplied, the rule will match all alert instances.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] mute_timings: A list of mute timing names to apply to alerts that match this policy.
        :param pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyPolicyArgs']]] policies: Routing rules for specific label sets.
        :param pulumi.Input[str] repeat_interval: Minimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.
        """
        pulumi.set(__self__, "contact_point", contact_point)
        if continue_ is not None:
            pulumi.set(__self__, "continue_", continue_)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if group_interval is not None:
            pulumi.set(__self__, "group_interval", group_interval)
        if group_wait is not None:
            pulumi.set(__self__, "group_wait", group_wait)
        if matchers is not None:
            pulumi.set(__self__, "matchers", matchers)
        if mute_timings is not None:
            pulumi.set(__self__, "mute_timings", mute_timings)
        if policies is not None:
            pulumi.set(__self__, "policies", policies)
        if repeat_interval is not None:
            pulumi.set(__self__, "repeat_interval", repeat_interval)

    @property
    @pulumi.getter(name="contactPoint")
    def contact_point(self) -> pulumi.Input[str]:
        """
        The contact point to route notifications that match this rule to.
        """
        return pulumi.get(self, "contact_point")

    @contact_point.setter
    def contact_point(self, value: pulumi.Input[str]):
        pulumi.set(self, "contact_point", value)

    @property
    @pulumi.getter(name="continue")
    def continue_(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to continue matching subsequent rules if an alert matches the current rule. Otherwise, the rule will be 'consumed' by the first policy to match it.
        """
        return pulumi.get(self, "continue_")

    @continue_.setter
    def continue_(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "continue_", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping. Required for root policy only. If empty, the parent grouping is used.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="groupInterval")
    def group_interval(self) -> Optional[pulumi.Input[str]]:
        """
        Minimum time interval between two notifications for the same group. Default is 5 minutes.
        """
        return pulumi.get(self, "group_interval")

    @group_interval.setter
    def group_interval(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group_interval", value)

    @property
    @pulumi.getter(name="groupWait")
    def group_wait(self) -> Optional[pulumi.Input[str]]:
        """
        Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.
        """
        return pulumi.get(self, "group_wait")

    @group_wait.setter
    def group_wait(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group_wait", value)

    @property
    @pulumi.getter
    def matchers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyMatcherArgs']]]]:
        """
        Describes which labels this rule should match. When multiple matchers are supplied, an alert must match ALL matchers to be accepted by this policy. When no matchers are supplied, the rule will match all alert instances.
        """
        return pulumi.get(self, "matchers")

    @matchers.setter
    def matchers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyMatcherArgs']]]]):
        pulumi.set(self, "matchers", value)

    @property
    @pulumi.getter(name="muteTimings")
    def mute_timings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of mute timing names to apply to alerts that match this policy.
        """
        return pulumi.get(self, "mute_timings")

    @mute_timings.setter
    def mute_timings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "mute_timings", value)

    @property
    @pulumi.getter
    def policies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyPolicyArgs']]]]:
        """
        Routing rules for specific label sets.
        """
        return pulumi.get(self, "policies")

    @policies.setter
    def policies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyPolicyArgs']]]]):
        pulumi.set(self, "policies", value)

    @property
    @pulumi.getter(name="repeatInterval")
    def repeat_interval(self) -> Optional[pulumi.Input[str]]:
        """
        Minimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.
        """
        return pulumi.get(self, "repeat_interval")

    @repeat_interval.setter
    def repeat_interval(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repeat_interval", value)


@pulumi.input_type
class NotificationPolicyPolicyPolicyMatcherArgs:
    def __init__(__self__, *,
                 label: pulumi.Input[str],
                 match: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] label: The name of the label to match against.
        :param pulumi.Input[str] match: The operator to apply when matching values of the given label. Allowed operators are `=` for equality, `!=` for negated equality, `=~` for regex equality, and `!~` for negated regex equality.
        :param pulumi.Input[str] value: The label value to match against.
        """
        pulumi.set(__self__, "label", label)
        pulumi.set(__self__, "match", match)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def label(self) -> pulumi.Input[str]:
        """
        The name of the label to match against.
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: pulumi.Input[str]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def match(self) -> pulumi.Input[str]:
        """
        The operator to apply when matching values of the given label. Allowed operators are `=` for equality, `!=` for negated equality, `=~` for regex equality, and `!~` for negated regex equality.
        """
        return pulumi.get(self, "match")

    @match.setter
    def match(self, value: pulumi.Input[str]):
        pulumi.set(self, "match", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The label value to match against.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class NotificationPolicyPolicyPolicyPolicyArgs:
    def __init__(__self__, *,
                 contact_point: pulumi.Input[str],
                 continue_: Optional[pulumi.Input[bool]] = None,
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 group_interval: Optional[pulumi.Input[str]] = None,
                 group_wait: Optional[pulumi.Input[str]] = None,
                 matchers: Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyPolicyMatcherArgs']]]] = None,
                 mute_timings: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 policies: Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyPolicyPolicyArgs']]]] = None,
                 repeat_interval: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] contact_point: The contact point to route notifications that match this rule to.
        :param pulumi.Input[bool] continue_: Whether to continue matching subsequent rules if an alert matches the current rule. Otherwise, the rule will be 'consumed' by the first policy to match it.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] group_bies: A list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping. Required for root policy only. If empty, the parent grouping is used.
        :param pulumi.Input[str] group_interval: Minimum time interval between two notifications for the same group. Default is 5 minutes.
        :param pulumi.Input[str] group_wait: Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.
        :param pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyPolicyMatcherArgs']]] matchers: Describes which labels this rule should match. When multiple matchers are supplied, an alert must match ALL matchers to be accepted by this policy. When no matchers are supplied, the rule will match all alert instances.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] mute_timings: A list of mute timing names to apply to alerts that match this policy.
        :param pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyPolicyPolicyArgs']]] policies: Routing rules for specific label sets.
        :param pulumi.Input[str] repeat_interval: Minimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.
        """
        pulumi.set(__self__, "contact_point", contact_point)
        if continue_ is not None:
            pulumi.set(__self__, "continue_", continue_)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if group_interval is not None:
            pulumi.set(__self__, "group_interval", group_interval)
        if group_wait is not None:
            pulumi.set(__self__, "group_wait", group_wait)
        if matchers is not None:
            pulumi.set(__self__, "matchers", matchers)
        if mute_timings is not None:
            pulumi.set(__self__, "mute_timings", mute_timings)
        if policies is not None:
            pulumi.set(__self__, "policies", policies)
        if repeat_interval is not None:
            pulumi.set(__self__, "repeat_interval", repeat_interval)

    @property
    @pulumi.getter(name="contactPoint")
    def contact_point(self) -> pulumi.Input[str]:
        """
        The contact point to route notifications that match this rule to.
        """
        return pulumi.get(self, "contact_point")

    @contact_point.setter
    def contact_point(self, value: pulumi.Input[str]):
        pulumi.set(self, "contact_point", value)

    @property
    @pulumi.getter(name="continue")
    def continue_(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to continue matching subsequent rules if an alert matches the current rule. Otherwise, the rule will be 'consumed' by the first policy to match it.
        """
        return pulumi.get(self, "continue_")

    @continue_.setter
    def continue_(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "continue_", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping. Required for root policy only. If empty, the parent grouping is used.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="groupInterval")
    def group_interval(self) -> Optional[pulumi.Input[str]]:
        """
        Minimum time interval between two notifications for the same group. Default is 5 minutes.
        """
        return pulumi.get(self, "group_interval")

    @group_interval.setter
    def group_interval(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group_interval", value)

    @property
    @pulumi.getter(name="groupWait")
    def group_wait(self) -> Optional[pulumi.Input[str]]:
        """
        Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.
        """
        return pulumi.get(self, "group_wait")

    @group_wait.setter
    def group_wait(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group_wait", value)

    @property
    @pulumi.getter
    def matchers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyPolicyMatcherArgs']]]]:
        """
        Describes which labels this rule should match. When multiple matchers are supplied, an alert must match ALL matchers to be accepted by this policy. When no matchers are supplied, the rule will match all alert instances.
        """
        return pulumi.get(self, "matchers")

    @matchers.setter
    def matchers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyPolicyMatcherArgs']]]]):
        pulumi.set(self, "matchers", value)

    @property
    @pulumi.getter(name="muteTimings")
    def mute_timings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of mute timing names to apply to alerts that match this policy.
        """
        return pulumi.get(self, "mute_timings")

    @mute_timings.setter
    def mute_timings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "mute_timings", value)

    @property
    @pulumi.getter
    def policies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyPolicyPolicyArgs']]]]:
        """
        Routing rules for specific label sets.
        """
        return pulumi.get(self, "policies")

    @policies.setter
    def policies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyPolicyPolicyArgs']]]]):
        pulumi.set(self, "policies", value)

    @property
    @pulumi.getter(name="repeatInterval")
    def repeat_interval(self) -> Optional[pulumi.Input[str]]:
        """
        Minimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.
        """
        return pulumi.get(self, "repeat_interval")

    @repeat_interval.setter
    def repeat_interval(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repeat_interval", value)


@pulumi.input_type
class NotificationPolicyPolicyPolicyPolicyMatcherArgs:
    def __init__(__self__, *,
                 label: pulumi.Input[str],
                 match: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] label: The name of the label to match against.
        :param pulumi.Input[str] match: The operator to apply when matching values of the given label. Allowed operators are `=` for equality, `!=` for negated equality, `=~` for regex equality, and `!~` for negated regex equality.
        :param pulumi.Input[str] value: The label value to match against.
        """
        pulumi.set(__self__, "label", label)
        pulumi.set(__self__, "match", match)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def label(self) -> pulumi.Input[str]:
        """
        The name of the label to match against.
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: pulumi.Input[str]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def match(self) -> pulumi.Input[str]:
        """
        The operator to apply when matching values of the given label. Allowed operators are `=` for equality, `!=` for negated equality, `=~` for regex equality, and `!~` for negated regex equality.
        """
        return pulumi.get(self, "match")

    @match.setter
    def match(self, value: pulumi.Input[str]):
        pulumi.set(self, "match", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The label value to match against.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class NotificationPolicyPolicyPolicyPolicyPolicyArgs:
    def __init__(__self__, *,
                 contact_point: pulumi.Input[str],
                 group_bies: pulumi.Input[Sequence[pulumi.Input[str]]],
                 continue_: Optional[pulumi.Input[bool]] = None,
                 group_interval: Optional[pulumi.Input[str]] = None,
                 group_wait: Optional[pulumi.Input[str]] = None,
                 matchers: Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyPolicyPolicyMatcherArgs']]]] = None,
                 mute_timings: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 repeat_interval: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] contact_point: The contact point to route notifications that match this rule to.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] group_bies: A list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping. Required for root policy only. If empty, the parent grouping is used.
        :param pulumi.Input[bool] continue_: Whether to continue matching subsequent rules if an alert matches the current rule. Otherwise, the rule will be 'consumed' by the first policy to match it.
        :param pulumi.Input[str] group_interval: Minimum time interval between two notifications for the same group. Default is 5 minutes.
        :param pulumi.Input[str] group_wait: Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.
        :param pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyPolicyPolicyMatcherArgs']]] matchers: Describes which labels this rule should match. When multiple matchers are supplied, an alert must match ALL matchers to be accepted by this policy. When no matchers are supplied, the rule will match all alert instances.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] mute_timings: A list of mute timing names to apply to alerts that match this policy.
        :param pulumi.Input[str] repeat_interval: Minimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.
        """
        pulumi.set(__self__, "contact_point", contact_point)
        pulumi.set(__self__, "group_bies", group_bies)
        if continue_ is not None:
            pulumi.set(__self__, "continue_", continue_)
        if group_interval is not None:
            pulumi.set(__self__, "group_interval", group_interval)
        if group_wait is not None:
            pulumi.set(__self__, "group_wait", group_wait)
        if matchers is not None:
            pulumi.set(__self__, "matchers", matchers)
        if mute_timings is not None:
            pulumi.set(__self__, "mute_timings", mute_timings)
        if repeat_interval is not None:
            pulumi.set(__self__, "repeat_interval", repeat_interval)

    @property
    @pulumi.getter(name="contactPoint")
    def contact_point(self) -> pulumi.Input[str]:
        """
        The contact point to route notifications that match this rule to.
        """
        return pulumi.get(self, "contact_point")

    @contact_point.setter
    def contact_point(self, value: pulumi.Input[str]):
        pulumi.set(self, "contact_point", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping. Required for root policy only. If empty, the parent grouping is used.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="continue")
    def continue_(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to continue matching subsequent rules if an alert matches the current rule. Otherwise, the rule will be 'consumed' by the first policy to match it.
        """
        return pulumi.get(self, "continue_")

    @continue_.setter
    def continue_(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "continue_", value)

    @property
    @pulumi.getter(name="groupInterval")
    def group_interval(self) -> Optional[pulumi.Input[str]]:
        """
        Minimum time interval between two notifications for the same group. Default is 5 minutes.
        """
        return pulumi.get(self, "group_interval")

    @group_interval.setter
    def group_interval(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group_interval", value)

    @property
    @pulumi.getter(name="groupWait")
    def group_wait(self) -> Optional[pulumi.Input[str]]:
        """
        Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.
        """
        return pulumi.get(self, "group_wait")

    @group_wait.setter
    def group_wait(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group_wait", value)

    @property
    @pulumi.getter
    def matchers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyPolicyPolicyMatcherArgs']]]]:
        """
        Describes which labels this rule should match. When multiple matchers are supplied, an alert must match ALL matchers to be accepted by this policy. When no matchers are supplied, the rule will match all alert instances.
        """
        return pulumi.get(self, "matchers")

    @matchers.setter
    def matchers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyPolicyPolicyMatcherArgs']]]]):
        pulumi.set(self, "matchers", value)

    @property
    @pulumi.getter(name="muteTimings")
    def mute_timings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of mute timing names to apply to alerts that match this policy.
        """
        return pulumi.get(self, "mute_timings")

    @mute_timings.setter
    def mute_timings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "mute_timings", value)

    @property
    @pulumi.getter(name="repeatInterval")
    def repeat_interval(self) -> Optional[pulumi.Input[str]]:
        """
        Minimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.
        """
        return pulumi.get(self, "repeat_interval")

    @repeat_interval.setter
    def repeat_interval(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repeat_interval", value)


@pulumi.input_type
class NotificationPolicyPolicyPolicyPolicyPolicyMatcherArgs:
    def __init__(__self__, *,
                 label: pulumi.Input[str],
                 match: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] label: The name of the label to match against.
        :param pulumi.Input[str] match: The operator to apply when matching values of the given label. Allowed operators are `=` for equality, `!=` for negated equality, `=~` for regex equality, and `!~` for negated regex equality.
        :param pulumi.Input[str] value: The label value to match against.
        """
        pulumi.set(__self__, "label", label)
        pulumi.set(__self__, "match", match)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def label(self) -> pulumi.Input[str]:
        """
        The name of the label to match against.
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: pulumi.Input[str]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def match(self) -> pulumi.Input[str]:
        """
        The operator to apply when matching values of the given label. Allowed operators are `=` for equality, `!=` for negated equality, `=~` for regex equality, and `!~` for negated regex equality.
        """
        return pulumi.get(self, "match")

    @match.setter
    def match(self, value: pulumi.Input[str]):
        pulumi.set(self, "match", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The label value to match against.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class OncallIntegrationDefaultRouteArgs:
    def __init__(__self__, *,
                 escalation_chain_id: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 msteams: Optional[pulumi.Input['OncallIntegrationDefaultRouteMsteamsArgs']] = None,
                 slack: Optional[pulumi.Input['OncallIntegrationDefaultRouteSlackArgs']] = None,
                 telegram: Optional[pulumi.Input['OncallIntegrationDefaultRouteTelegramArgs']] = None):
        """
        :param pulumi.Input[str] escalation_chain_id: The ID of the escalation chain.
        :param pulumi.Input['OncallIntegrationDefaultRouteMsteamsArgs'] msteams: MS teams-specific settings for a route.
        :param pulumi.Input['OncallIntegrationDefaultRouteSlackArgs'] slack: Slack-specific settings for a route.
        :param pulumi.Input['OncallIntegrationDefaultRouteTelegramArgs'] telegram: Telegram-specific settings for a route.
        """
        if escalation_chain_id is not None:
            pulumi.set(__self__, "escalation_chain_id", escalation_chain_id)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if msteams is not None:
            pulumi.set(__self__, "msteams", msteams)
        if slack is not None:
            pulumi.set(__self__, "slack", slack)
        if telegram is not None:
            pulumi.set(__self__, "telegram", telegram)

    @property
    @pulumi.getter(name="escalationChainId")
    def escalation_chain_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the escalation chain.
        """
        return pulumi.get(self, "escalation_chain_id")

    @escalation_chain_id.setter
    def escalation_chain_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "escalation_chain_id", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def msteams(self) -> Optional[pulumi.Input['OncallIntegrationDefaultRouteMsteamsArgs']]:
        """
        MS teams-specific settings for a route.
        """
        return pulumi.get(self, "msteams")

    @msteams.setter
    def msteams(self, value: Optional[pulumi.Input['OncallIntegrationDefaultRouteMsteamsArgs']]):
        pulumi.set(self, "msteams", value)

    @property
    @pulumi.getter
    def slack(self) -> Optional[pulumi.Input['OncallIntegrationDefaultRouteSlackArgs']]:
        """
        Slack-specific settings for a route.
        """
        return pulumi.get(self, "slack")

    @slack.setter
    def slack(self, value: Optional[pulumi.Input['OncallIntegrationDefaultRouteSlackArgs']]):
        pulumi.set(self, "slack", value)

    @property
    @pulumi.getter
    def telegram(self) -> Optional[pulumi.Input['OncallIntegrationDefaultRouteTelegramArgs']]:
        """
        Telegram-specific settings for a route.
        """
        return pulumi.get(self, "telegram")

    @telegram.setter
    def telegram(self, value: Optional[pulumi.Input['OncallIntegrationDefaultRouteTelegramArgs']]):
        pulumi.set(self, "telegram", value)


@pulumi.input_type
class OncallIntegrationDefaultRouteMsteamsArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Enable notification in MS teams.
        :param pulumi.Input[str] id: MS teams channel id. Alerts will be directed to this channel in Microsoft teams.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable notification in MS teams.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        MS teams channel id. Alerts will be directed to this channel in Microsoft teams.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


@pulumi.input_type
class OncallIntegrationDefaultRouteSlackArgs:
    def __init__(__self__, *,
                 channel_id: Optional[pulumi.Input[str]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] channel_id: Slack channel id. Alerts will be directed to this channel in Slack.
        :param pulumi.Input[bool] enabled: Enable notification in Slack.
        """
        if channel_id is not None:
            pulumi.set(__self__, "channel_id", channel_id)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="channelId")
    def channel_id(self) -> Optional[pulumi.Input[str]]:
        """
        Slack channel id. Alerts will be directed to this channel in Slack.
        """
        return pulumi.get(self, "channel_id")

    @channel_id.setter
    def channel_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "channel_id", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable notification in Slack.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class OncallIntegrationDefaultRouteTelegramArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Enable notification in Telegram.
        :param pulumi.Input[str] id: Telegram channel id. Alerts will be directed to this channel in Telegram.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable notification in Telegram.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Telegram channel id. Alerts will be directed to this channel in Telegram.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


@pulumi.input_type
class OncallIntegrationTemplatesArgs:
    def __init__(__self__, *,
                 acknowledge_signal: Optional[pulumi.Input[str]] = None,
                 email: Optional[pulumi.Input['OncallIntegrationTemplatesEmailArgs']] = None,
                 grouping_key: Optional[pulumi.Input[str]] = None,
                 microsoft_teams: Optional[pulumi.Input['OncallIntegrationTemplatesMicrosoftTeamsArgs']] = None,
                 phone_call: Optional[pulumi.Input['OncallIntegrationTemplatesPhoneCallArgs']] = None,
                 resolve_signal: Optional[pulumi.Input[str]] = None,
                 slack: Optional[pulumi.Input['OncallIntegrationTemplatesSlackArgs']] = None,
                 sms: Optional[pulumi.Input['OncallIntegrationTemplatesSmsArgs']] = None,
                 source_link: Optional[pulumi.Input[str]] = None,
                 telegram: Optional[pulumi.Input['OncallIntegrationTemplatesTelegramArgs']] = None,
                 web: Optional[pulumi.Input['OncallIntegrationTemplatesWebArgs']] = None):
        """
        :param pulumi.Input[str] acknowledge_signal: Template for sending a signal to acknowledge the Incident.
        :param pulumi.Input['OncallIntegrationTemplatesEmailArgs'] email: Templates for Email.
        :param pulumi.Input[str] grouping_key: Template for the key by which alerts are grouped.
        :param pulumi.Input['OncallIntegrationTemplatesMicrosoftTeamsArgs'] microsoft_teams: Templates for Microsoft Teams.
        :param pulumi.Input['OncallIntegrationTemplatesPhoneCallArgs'] phone_call: Templates for Phone Call.
        :param pulumi.Input[str] resolve_signal: Template for sending a signal to resolve the Incident.
        :param pulumi.Input['OncallIntegrationTemplatesSlackArgs'] slack: Templates for Slack.
        :param pulumi.Input['OncallIntegrationTemplatesSmsArgs'] sms: Templates for SMS.
        :param pulumi.Input[str] source_link: Template for a source link.
        :param pulumi.Input['OncallIntegrationTemplatesTelegramArgs'] telegram: Templates for Telegram.
        :param pulumi.Input['OncallIntegrationTemplatesWebArgs'] web: Templates for Web.
        """
        if acknowledge_signal is not None:
            pulumi.set(__self__, "acknowledge_signal", acknowledge_signal)
        if email is not None:
            pulumi.set(__self__, "email", email)
        if grouping_key is not None:
            pulumi.set(__self__, "grouping_key", grouping_key)
        if microsoft_teams is not None:
            pulumi.set(__self__, "microsoft_teams", microsoft_teams)
        if phone_call is not None:
            pulumi.set(__self__, "phone_call", phone_call)
        if resolve_signal is not None:
            pulumi.set(__self__, "resolve_signal", resolve_signal)
        if slack is not None:
            pulumi.set(__self__, "slack", slack)
        if sms is not None:
            pulumi.set(__self__, "sms", sms)
        if source_link is not None:
            pulumi.set(__self__, "source_link", source_link)
        if telegram is not None:
            pulumi.set(__self__, "telegram", telegram)
        if web is not None:
            pulumi.set(__self__, "web", web)

    @property
    @pulumi.getter(name="acknowledgeSignal")
    def acknowledge_signal(self) -> Optional[pulumi.Input[str]]:
        """
        Template for sending a signal to acknowledge the Incident.
        """
        return pulumi.get(self, "acknowledge_signal")

    @acknowledge_signal.setter
    def acknowledge_signal(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "acknowledge_signal", value)

    @property
    @pulumi.getter
    def email(self) -> Optional[pulumi.Input['OncallIntegrationTemplatesEmailArgs']]:
        """
        Templates for Email.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: Optional[pulumi.Input['OncallIntegrationTemplatesEmailArgs']]):
        pulumi.set(self, "email", value)

    @property
    @pulumi.getter(name="groupingKey")
    def grouping_key(self) -> Optional[pulumi.Input[str]]:
        """
        Template for the key by which alerts are grouped.
        """
        return pulumi.get(self, "grouping_key")

    @grouping_key.setter
    def grouping_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "grouping_key", value)

    @property
    @pulumi.getter(name="microsoftTeams")
    def microsoft_teams(self) -> Optional[pulumi.Input['OncallIntegrationTemplatesMicrosoftTeamsArgs']]:
        """
        Templates for Microsoft Teams.
        """
        return pulumi.get(self, "microsoft_teams")

    @microsoft_teams.setter
    def microsoft_teams(self, value: Optional[pulumi.Input['OncallIntegrationTemplatesMicrosoftTeamsArgs']]):
        pulumi.set(self, "microsoft_teams", value)

    @property
    @pulumi.getter(name="phoneCall")
    def phone_call(self) -> Optional[pulumi.Input['OncallIntegrationTemplatesPhoneCallArgs']]:
        """
        Templates for Phone Call.
        """
        return pulumi.get(self, "phone_call")

    @phone_call.setter
    def phone_call(self, value: Optional[pulumi.Input['OncallIntegrationTemplatesPhoneCallArgs']]):
        pulumi.set(self, "phone_call", value)

    @property
    @pulumi.getter(name="resolveSignal")
    def resolve_signal(self) -> Optional[pulumi.Input[str]]:
        """
        Template for sending a signal to resolve the Incident.
        """
        return pulumi.get(self, "resolve_signal")

    @resolve_signal.setter
    def resolve_signal(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resolve_signal", value)

    @property
    @pulumi.getter
    def slack(self) -> Optional[pulumi.Input['OncallIntegrationTemplatesSlackArgs']]:
        """
        Templates for Slack.
        """
        return pulumi.get(self, "slack")

    @slack.setter
    def slack(self, value: Optional[pulumi.Input['OncallIntegrationTemplatesSlackArgs']]):
        pulumi.set(self, "slack", value)

    @property
    @pulumi.getter
    def sms(self) -> Optional[pulumi.Input['OncallIntegrationTemplatesSmsArgs']]:
        """
        Templates for SMS.
        """
        return pulumi.get(self, "sms")

    @sms.setter
    def sms(self, value: Optional[pulumi.Input['OncallIntegrationTemplatesSmsArgs']]):
        pulumi.set(self, "sms", value)

    @property
    @pulumi.getter(name="sourceLink")
    def source_link(self) -> Optional[pulumi.Input[str]]:
        """
        Template for a source link.
        """
        return pulumi.get(self, "source_link")

    @source_link.setter
    def source_link(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_link", value)

    @property
    @pulumi.getter
    def telegram(self) -> Optional[pulumi.Input['OncallIntegrationTemplatesTelegramArgs']]:
        """
        Templates for Telegram.
        """
        return pulumi.get(self, "telegram")

    @telegram.setter
    def telegram(self, value: Optional[pulumi.Input['OncallIntegrationTemplatesTelegramArgs']]):
        pulumi.set(self, "telegram", value)

    @property
    @pulumi.getter
    def web(self) -> Optional[pulumi.Input['OncallIntegrationTemplatesWebArgs']]:
        """
        Templates for Web.
        """
        return pulumi.get(self, "web")

    @web.setter
    def web(self, value: Optional[pulumi.Input['OncallIntegrationTemplatesWebArgs']]):
        pulumi.set(self, "web", value)


@pulumi.input_type
class OncallIntegrationTemplatesEmailArgs:
    def __init__(__self__, *,
                 message: Optional[pulumi.Input[str]] = None,
                 title: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] message: Template for Alert message.
        :param pulumi.Input[str] title: Template for Alert title.
        """
        if message is not None:
            pulumi.set(__self__, "message", message)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        Template for Alert message.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        Template for Alert title.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)


@pulumi.input_type
class OncallIntegrationTemplatesMicrosoftTeamsArgs:
    def __init__(__self__, *,
                 image_url: Optional[pulumi.Input[str]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 title: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] image_url: Template for Alert image url.
        :param pulumi.Input[str] message: Template for Alert message.
        :param pulumi.Input[str] title: Template for Alert title.
        """
        if image_url is not None:
            pulumi.set(__self__, "image_url", image_url)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[pulumi.Input[str]]:
        """
        Template for Alert image url.
        """
        return pulumi.get(self, "image_url")

    @image_url.setter
    def image_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image_url", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        Template for Alert message.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        Template for Alert title.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)


@pulumi.input_type
class OncallIntegrationTemplatesPhoneCallArgs:
    def __init__(__self__, *,
                 title: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] title: Template for Alert title.
        """
        if title is not None:
            pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        Template for Alert title.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)


@pulumi.input_type
class OncallIntegrationTemplatesSlackArgs:
    def __init__(__self__, *,
                 image_url: Optional[pulumi.Input[str]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 title: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] image_url: Template for Alert image url.
        :param pulumi.Input[str] message: Template for Alert message.
        :param pulumi.Input[str] title: Template for Alert title.
        """
        if image_url is not None:
            pulumi.set(__self__, "image_url", image_url)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[pulumi.Input[str]]:
        """
        Template for Alert image url.
        """
        return pulumi.get(self, "image_url")

    @image_url.setter
    def image_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image_url", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        Template for Alert message.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        Template for Alert title.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)


@pulumi.input_type
class OncallIntegrationTemplatesSmsArgs:
    def __init__(__self__, *,
                 title: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] title: Template for Alert title.
        """
        if title is not None:
            pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        Template for Alert title.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)


@pulumi.input_type
class OncallIntegrationTemplatesTelegramArgs:
    def __init__(__self__, *,
                 image_url: Optional[pulumi.Input[str]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 title: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] image_url: Template for Alert image url.
        :param pulumi.Input[str] message: Template for Alert message.
        :param pulumi.Input[str] title: Template for Alert title.
        """
        if image_url is not None:
            pulumi.set(__self__, "image_url", image_url)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[pulumi.Input[str]]:
        """
        Template for Alert image url.
        """
        return pulumi.get(self, "image_url")

    @image_url.setter
    def image_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image_url", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        Template for Alert message.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        Template for Alert title.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)


@pulumi.input_type
class OncallIntegrationTemplatesWebArgs:
    def __init__(__self__, *,
                 image_url: Optional[pulumi.Input[str]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 title: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] image_url: Template for Alert image url.
        :param pulumi.Input[str] message: Template for Alert message.
        :param pulumi.Input[str] title: Template for Alert title.
        """
        if image_url is not None:
            pulumi.set(__self__, "image_url", image_url)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[pulumi.Input[str]]:
        """
        Template for Alert image url.
        """
        return pulumi.get(self, "image_url")

    @image_url.setter
    def image_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image_url", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        Template for Alert message.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        Template for Alert title.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)


@pulumi.input_type
class OncallRouteMsteamsArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Enable notification in MS teams.
        :param pulumi.Input[str] id: MS teams channel id. Alerts will be directed to this channel in Microsoft teams.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable notification in MS teams.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        MS teams channel id. Alerts will be directed to this channel in Microsoft teams.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


@pulumi.input_type
class OncallRouteSlackArgs:
    def __init__(__self__, *,
                 channel_id: Optional[pulumi.Input[str]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] channel_id: Slack channel id. Alerts will be directed to this channel in Slack.
        :param pulumi.Input[bool] enabled: Enable notification in Slack.
        """
        if channel_id is not None:
            pulumi.set(__self__, "channel_id", channel_id)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="channelId")
    def channel_id(self) -> Optional[pulumi.Input[str]]:
        """
        Slack channel id. Alerts will be directed to this channel in Slack.
        """
        return pulumi.get(self, "channel_id")

    @channel_id.setter
    def channel_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "channel_id", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable notification in Slack.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class OncallRouteTelegramArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Enable notification in Telegram.
        :param pulumi.Input[str] id: Telegram channel id. Alerts will be directed to this channel in Telegram.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable notification in Telegram.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Telegram channel id. Alerts will be directed to this channel in Telegram.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


@pulumi.input_type
class OncallScheduleSlackArgs:
    def __init__(__self__, *,
                 channel_id: Optional[pulumi.Input[str]] = None,
                 user_group_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] channel_id: Slack channel id. Reminder about schedule shifts will be directed to this channel in Slack.
        :param pulumi.Input[str] user_group_id: Slack user group id. Members of user group will be updated when on-call users change.
        """
        if channel_id is not None:
            pulumi.set(__self__, "channel_id", channel_id)
        if user_group_id is not None:
            pulumi.set(__self__, "user_group_id", user_group_id)

    @property
    @pulumi.getter(name="channelId")
    def channel_id(self) -> Optional[pulumi.Input[str]]:
        """
        Slack channel id. Reminder about schedule shifts will be directed to this channel in Slack.
        """
        return pulumi.get(self, "channel_id")

    @channel_id.setter
    def channel_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "channel_id", value)

    @property
    @pulumi.getter(name="userGroupId")
    def user_group_id(self) -> Optional[pulumi.Input[str]]:
        """
        Slack user group id. Members of user group will be updated when on-call users change.
        """
        return pulumi.get(self, "user_group_id")

    @user_group_id.setter
    def user_group_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_group_id", value)


@pulumi.input_type
class PlaylistItemArgs:
    def __init__(__self__, *,
                 order: pulumi.Input[int],
                 title: pulumi.Input[str],
                 id: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "order", order)
        pulumi.set(__self__, "title", title)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[int]:
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[int]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def title(self) -> pulumi.Input[str]:
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[str]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class ReportDashboardArgs:
    def __init__(__self__, *,
                 uid: pulumi.Input[str],
                 report_variables: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 time_range: Optional[pulumi.Input['ReportDashboardTimeRangeArgs']] = None):
        """
        :param pulumi.Input[str] uid: Dashboard uid.
        :param pulumi.Input[Mapping[str, Any]] report_variables: Add report variables to the dashboard. Values should be separated by commas.
        :param pulumi.Input['ReportDashboardTimeRangeArgs'] time_range: Time range of the report.
        """
        pulumi.set(__self__, "uid", uid)
        if report_variables is not None:
            pulumi.set(__self__, "report_variables", report_variables)
        if time_range is not None:
            pulumi.set(__self__, "time_range", time_range)

    @property
    @pulumi.getter
    def uid(self) -> pulumi.Input[str]:
        """
        Dashboard uid.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: pulumi.Input[str]):
        pulumi.set(self, "uid", value)

    @property
    @pulumi.getter(name="reportVariables")
    def report_variables(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Add report variables to the dashboard. Values should be separated by commas.
        """
        return pulumi.get(self, "report_variables")

    @report_variables.setter
    def report_variables(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "report_variables", value)

    @property
    @pulumi.getter(name="timeRange")
    def time_range(self) -> Optional[pulumi.Input['ReportDashboardTimeRangeArgs']]:
        """
        Time range of the report.
        """
        return pulumi.get(self, "time_range")

    @time_range.setter
    def time_range(self, value: Optional[pulumi.Input['ReportDashboardTimeRangeArgs']]):
        pulumi.set(self, "time_range", value)


@pulumi.input_type
class ReportDashboardTimeRangeArgs:
    def __init__(__self__, *,
                 from_: Optional[pulumi.Input[str]] = None,
                 to: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] from_: Start of the time range.
        :param pulumi.Input[str] to: End of the time range.
        """
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[pulumi.Input[str]]:
        """
        Start of the time range.
        """
        return pulumi.get(self, "from_")

    @from_.setter
    def from_(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "from_", value)

    @property
    @pulumi.getter
    def to(self) -> Optional[pulumi.Input[str]]:
        """
        End of the time range.
        """
        return pulumi.get(self, "to")

    @to.setter
    def to(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "to", value)


@pulumi.input_type
class ReportScheduleArgs:
    def __init__(__self__, *,
                 frequency: pulumi.Input[str],
                 custom_interval: Optional[pulumi.Input[str]] = None,
                 end_time: Optional[pulumi.Input[str]] = None,
                 last_day_of_month: Optional[pulumi.Input[bool]] = None,
                 start_time: Optional[pulumi.Input[str]] = None,
                 timezone: Optional[pulumi.Input[str]] = None,
                 workdays_only: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] frequency: Frequency of the report. Allowed values: `never`, `once`, `hourly`, `daily`, `weekly`, `monthly`, `custom`.
        :param pulumi.Input[str] custom_interval: Custom interval of the report.
               **Note:** This field is only available when frequency is set to `custom`.
        :param pulumi.Input[str] end_time: End time of the report. If empty, the report will be sent indefinitely (according to frequency). Note that times will be saved as UTC in Grafana. Use 2006-01-02T15:04:05 format if you want to set a custom timezone
        :param pulumi.Input[bool] last_day_of_month: Send the report on the last day of the month
        :param pulumi.Input[str] start_time: Start time of the report. If empty, the start date will be set to the creation time. Note that times will be saved as UTC in Grafana. Use 2006-01-02T15:04:05 format if you want to set a custom timezone
        :param pulumi.Input[str] timezone: Set the report time zone.
        :param pulumi.Input[bool] workdays_only: Whether to send the report only on work days.
        """
        pulumi.set(__self__, "frequency", frequency)
        if custom_interval is not None:
            pulumi.set(__self__, "custom_interval", custom_interval)
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if last_day_of_month is not None:
            pulumi.set(__self__, "last_day_of_month", last_day_of_month)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)
        if timezone is not None:
            pulumi.set(__self__, "timezone", timezone)
        if workdays_only is not None:
            pulumi.set(__self__, "workdays_only", workdays_only)

    @property
    @pulumi.getter
    def frequency(self) -> pulumi.Input[str]:
        """
        Frequency of the report. Allowed values: `never`, `once`, `hourly`, `daily`, `weekly`, `monthly`, `custom`.
        """
        return pulumi.get(self, "frequency")

    @frequency.setter
    def frequency(self, value: pulumi.Input[str]):
        pulumi.set(self, "frequency", value)

    @property
    @pulumi.getter(name="customInterval")
    def custom_interval(self) -> Optional[pulumi.Input[str]]:
        """
        Custom interval of the report.
        **Note:** This field is only available when frequency is set to `custom`.
        """
        return pulumi.get(self, "custom_interval")

    @custom_interval.setter
    def custom_interval(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_interval", value)

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[pulumi.Input[str]]:
        """
        End time of the report. If empty, the report will be sent indefinitely (according to frequency). Note that times will be saved as UTC in Grafana. Use 2006-01-02T15:04:05 format if you want to set a custom timezone
        """
        return pulumi.get(self, "end_time")

    @end_time.setter
    def end_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "end_time", value)

    @property
    @pulumi.getter(name="lastDayOfMonth")
    def last_day_of_month(self) -> Optional[pulumi.Input[bool]]:
        """
        Send the report on the last day of the month
        """
        return pulumi.get(self, "last_day_of_month")

    @last_day_of_month.setter
    def last_day_of_month(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "last_day_of_month", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input[str]]:
        """
        Start time of the report. If empty, the start date will be set to the creation time. Note that times will be saved as UTC in Grafana. Use 2006-01-02T15:04:05 format if you want to set a custom timezone
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_time", value)

    @property
    @pulumi.getter
    def timezone(self) -> Optional[pulumi.Input[str]]:
        """
        Set the report time zone.
        """
        return pulumi.get(self, "timezone")

    @timezone.setter
    def timezone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timezone", value)

    @property
    @pulumi.getter(name="workdaysOnly")
    def workdays_only(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to send the report only on work days.
        """
        return pulumi.get(self, "workdays_only")

    @workdays_only.setter
    def workdays_only(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "workdays_only", value)


@pulumi.input_type
class ReportTimeRangeArgs:
    def __init__(__self__, *,
                 from_: Optional[pulumi.Input[str]] = None,
                 to: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] from_: Start of the time range.
        :param pulumi.Input[str] to: End of the time range.
        """
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[pulumi.Input[str]]:
        """
        Start of the time range.
        """
        return pulumi.get(self, "from_")

    @from_.setter
    def from_(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "from_", value)

    @property
    @pulumi.getter
    def to(self) -> Optional[pulumi.Input[str]]:
        """
        End of the time range.
        """
        return pulumi.get(self, "to")

    @to.setter
    def to(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "to", value)


@pulumi.input_type
class RolePermissionArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[str],
                 scope: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] action: Specific action users granted with the role will be allowed to perform (for example: `users:read`)
        :param pulumi.Input[str] scope: Scope to restrict the action to a set of resources (for example: `users:*` or `roles:customrole1`)
        """
        pulumi.set(__self__, "action", action)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input[str]:
        """
        Specific action users granted with the role will be allowed to perform (for example: `users:read`)
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[str]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def scope(self) -> Optional[pulumi.Input[str]]:
        """
        Scope to restrict the action to a set of resources (for example: `users:*` or `roles:customrole1`)
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scope", value)


@pulumi.input_type
class RuleGroupRuleArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 datas: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleDataArgs']]],
                 name: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 exec_err_state: Optional[pulumi.Input[str]] = None,
                 for_: Optional[pulumi.Input[str]] = None,
                 is_paused: Optional[pulumi.Input[bool]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 no_data_state: Optional[pulumi.Input[str]] = None,
                 notification_settings: Optional[pulumi.Input['RuleGroupRuleNotificationSettingsArgs']] = None,
                 uid: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] condition: The `ref_id` of the query node in the `data` field to use as the alert condition.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleDataArgs']]] datas: A sequence of stages that describe the contents of the rule.
        :param pulumi.Input[str] name: The name of the alert rule.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] annotations: Key-value pairs of metadata to attach to the alert rule that may add user-defined context, but cannot be used for matching, grouping, or routing.
        :param pulumi.Input[str] exec_err_state: Describes what state to enter when the rule's query is invalid and the rule cannot be executed. Options are OK, Error, and Alerting.
        :param pulumi.Input[str] for_: The amount of time for which the rule must be breached for the rule to be considered to be Firing. Before this time has elapsed, the rule is only considered to be Pending.
        :param pulumi.Input[bool] is_paused: Sets whether the alert should be paused or not.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] labels: Key-value pairs to attach to the alert rule that can be used in matching, grouping, and routing.
        :param pulumi.Input[str] no_data_state: Describes what state to enter when the rule's query returns No Data. Options are OK, NoData, and Alerting.
        :param pulumi.Input['RuleGroupRuleNotificationSettingsArgs'] notification_settings: Notification settings for the rule. If specified, it overrides the notification policies. Available since Grafana 10.4, requires feature flag 'alertingSimplifiedRouting' enabled.
        :param pulumi.Input[str] uid: The unique identifier of the alert rule.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "datas", datas)
        pulumi.set(__self__, "name", name)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if exec_err_state is not None:
            pulumi.set(__self__, "exec_err_state", exec_err_state)
        if for_ is not None:
            pulumi.set(__self__, "for_", for_)
        if is_paused is not None:
            pulumi.set(__self__, "is_paused", is_paused)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if no_data_state is not None:
            pulumi.set(__self__, "no_data_state", no_data_state)
        if notification_settings is not None:
            pulumi.set(__self__, "notification_settings", notification_settings)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        The `ref_id` of the query node in the `data` field to use as the alert condition.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def datas(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleDataArgs']]]:
        """
        A sequence of stages that describe the contents of the rule.
        """
        return pulumi.get(self, "datas")

    @datas.setter
    def datas(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleDataArgs']]]):
        pulumi.set(self, "datas", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the alert rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Key-value pairs of metadata to attach to the alert rule that may add user-defined context, but cannot be used for matching, grouping, or routing.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="execErrState")
    def exec_err_state(self) -> Optional[pulumi.Input[str]]:
        """
        Describes what state to enter when the rule's query is invalid and the rule cannot be executed. Options are OK, Error, and Alerting.
        """
        return pulumi.get(self, "exec_err_state")

    @exec_err_state.setter
    def exec_err_state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exec_err_state", value)

    @property
    @pulumi.getter(name="for")
    def for_(self) -> Optional[pulumi.Input[str]]:
        """
        The amount of time for which the rule must be breached for the rule to be considered to be Firing. Before this time has elapsed, the rule is only considered to be Pending.
        """
        return pulumi.get(self, "for_")

    @for_.setter
    def for_(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "for_", value)

    @property
    @pulumi.getter(name="isPaused")
    def is_paused(self) -> Optional[pulumi.Input[bool]]:
        """
        Sets whether the alert should be paused or not.
        """
        return pulumi.get(self, "is_paused")

    @is_paused.setter
    def is_paused(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_paused", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Key-value pairs to attach to the alert rule that can be used in matching, grouping, and routing.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "labels", value)

    @property
    @pulumi.getter(name="noDataState")
    def no_data_state(self) -> Optional[pulumi.Input[str]]:
        """
        Describes what state to enter when the rule's query returns No Data. Options are OK, NoData, and Alerting.
        """
        return pulumi.get(self, "no_data_state")

    @no_data_state.setter
    def no_data_state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "no_data_state", value)

    @property
    @pulumi.getter(name="notificationSettings")
    def notification_settings(self) -> Optional[pulumi.Input['RuleGroupRuleNotificationSettingsArgs']]:
        """
        Notification settings for the rule. If specified, it overrides the notification policies. Available since Grafana 10.4, requires feature flag 'alertingSimplifiedRouting' enabled.
        """
        return pulumi.get(self, "notification_settings")

    @notification_settings.setter
    def notification_settings(self, value: Optional[pulumi.Input['RuleGroupRuleNotificationSettingsArgs']]):
        pulumi.set(self, "notification_settings", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        The unique identifier of the alert rule.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)


@pulumi.input_type
class RuleGroupRuleDataArgs:
    def __init__(__self__, *,
                 datasource_uid: pulumi.Input[str],
                 model: pulumi.Input[str],
                 ref_id: pulumi.Input[str],
                 relative_time_range: pulumi.Input['RuleGroupRuleDataRelativeTimeRangeArgs'],
                 query_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] datasource_uid: The UID of the datasource being queried, or "-100" if this stage is an expression stage.
        :param pulumi.Input[str] model: Custom JSON data to send to the specified datasource when querying.
        :param pulumi.Input[str] ref_id: A unique string to identify this query stage within a rule.
        :param pulumi.Input['RuleGroupRuleDataRelativeTimeRangeArgs'] relative_time_range: The time range, relative to when the query is executed, across which to query.
        :param pulumi.Input[str] query_type: An optional identifier for the type of query being executed.
        """
        pulumi.set(__self__, "datasource_uid", datasource_uid)
        pulumi.set(__self__, "model", model)
        pulumi.set(__self__, "ref_id", ref_id)
        pulumi.set(__self__, "relative_time_range", relative_time_range)
        if query_type is not None:
            pulumi.set(__self__, "query_type", query_type)

    @property
    @pulumi.getter(name="datasourceUid")
    def datasource_uid(self) -> pulumi.Input[str]:
        """
        The UID of the datasource being queried, or "-100" if this stage is an expression stage.
        """
        return pulumi.get(self, "datasource_uid")

    @datasource_uid.setter
    def datasource_uid(self, value: pulumi.Input[str]):
        pulumi.set(self, "datasource_uid", value)

    @property
    @pulumi.getter
    def model(self) -> pulumi.Input[str]:
        """
        Custom JSON data to send to the specified datasource when querying.
        """
        return pulumi.get(self, "model")

    @model.setter
    def model(self, value: pulumi.Input[str]):
        pulumi.set(self, "model", value)

    @property
    @pulumi.getter(name="refId")
    def ref_id(self) -> pulumi.Input[str]:
        """
        A unique string to identify this query stage within a rule.
        """
        return pulumi.get(self, "ref_id")

    @ref_id.setter
    def ref_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "ref_id", value)

    @property
    @pulumi.getter(name="relativeTimeRange")
    def relative_time_range(self) -> pulumi.Input['RuleGroupRuleDataRelativeTimeRangeArgs']:
        """
        The time range, relative to when the query is executed, across which to query.
        """
        return pulumi.get(self, "relative_time_range")

    @relative_time_range.setter
    def relative_time_range(self, value: pulumi.Input['RuleGroupRuleDataRelativeTimeRangeArgs']):
        pulumi.set(self, "relative_time_range", value)

    @property
    @pulumi.getter(name="queryType")
    def query_type(self) -> Optional[pulumi.Input[str]]:
        """
        An optional identifier for the type of query being executed.
        """
        return pulumi.get(self, "query_type")

    @query_type.setter
    def query_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "query_type", value)


@pulumi.input_type
class RuleGroupRuleDataRelativeTimeRangeArgs:
    def __init__(__self__, *,
                 from_: pulumi.Input[int],
                 to: pulumi.Input[int]):
        """
        :param pulumi.Input[int] from_: The number of seconds in the past, relative to when the rule is evaluated, at which the time range begins.
        :param pulumi.Input[int] to: The number of seconds in the past, relative to when the rule is evaluated, at which the time range ends.
        """
        pulumi.set(__self__, "from_", from_)
        pulumi.set(__self__, "to", to)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> pulumi.Input[int]:
        """
        The number of seconds in the past, relative to when the rule is evaluated, at which the time range begins.
        """
        return pulumi.get(self, "from_")

    @from_.setter
    def from_(self, value: pulumi.Input[int]):
        pulumi.set(self, "from_", value)

    @property
    @pulumi.getter
    def to(self) -> pulumi.Input[int]:
        """
        The number of seconds in the past, relative to when the rule is evaluated, at which the time range ends.
        """
        return pulumi.get(self, "to")

    @to.setter
    def to(self, value: pulumi.Input[int]):
        pulumi.set(self, "to", value)


@pulumi.input_type
class RuleGroupRuleNotificationSettingsArgs:
    def __init__(__self__, *,
                 contact_point: pulumi.Input[str],
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 group_interval: Optional[pulumi.Input[str]] = None,
                 group_wait: Optional[pulumi.Input[str]] = None,
                 mute_timings: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 repeat_interval: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] contact_point: The contact point to route notifications that match this rule to.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] group_bies: A list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping. If empty, no grouping is used. If specified, requires labels 'alertname' and 'grafana_folder' to be included.
        :param pulumi.Input[str] group_interval: Minimum time interval between two notifications for the same group. Default is 5 minutes.
        :param pulumi.Input[str] group_wait: Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] mute_timings: A list of mute timing names to apply to alerts that match this policy.
        :param pulumi.Input[str] repeat_interval: Minimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.
        """
        pulumi.set(__self__, "contact_point", contact_point)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if group_interval is not None:
            pulumi.set(__self__, "group_interval", group_interval)
        if group_wait is not None:
            pulumi.set(__self__, "group_wait", group_wait)
        if mute_timings is not None:
            pulumi.set(__self__, "mute_timings", mute_timings)
        if repeat_interval is not None:
            pulumi.set(__self__, "repeat_interval", repeat_interval)

    @property
    @pulumi.getter(name="contactPoint")
    def contact_point(self) -> pulumi.Input[str]:
        """
        The contact point to route notifications that match this rule to.
        """
        return pulumi.get(self, "contact_point")

    @contact_point.setter
    def contact_point(self, value: pulumi.Input[str]):
        pulumi.set(self, "contact_point", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping. If empty, no grouping is used. If specified, requires labels 'alertname' and 'grafana_folder' to be included.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="groupInterval")
    def group_interval(self) -> Optional[pulumi.Input[str]]:
        """
        Minimum time interval between two notifications for the same group. Default is 5 minutes.
        """
        return pulumi.get(self, "group_interval")

    @group_interval.setter
    def group_interval(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group_interval", value)

    @property
    @pulumi.getter(name="groupWait")
    def group_wait(self) -> Optional[pulumi.Input[str]]:
        """
        Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.
        """
        return pulumi.get(self, "group_wait")

    @group_wait.setter
    def group_wait(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group_wait", value)

    @property
    @pulumi.getter(name="muteTimings")
    def mute_timings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of mute timing names to apply to alerts that match this policy.
        """
        return pulumi.get(self, "mute_timings")

    @mute_timings.setter
    def mute_timings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "mute_timings", value)

    @property
    @pulumi.getter(name="repeatInterval")
    def repeat_interval(self) -> Optional[pulumi.Input[str]]:
        """
        Minimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.
        """
        return pulumi.get(self, "repeat_interval")

    @repeat_interval.setter
    def repeat_interval(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repeat_interval", value)


@pulumi.input_type
class SLOAlertingArgs:
    def __init__(__self__, *,
                 annotations: Optional[pulumi.Input[Sequence[pulumi.Input['SLOAlertingAnnotationArgs']]]] = None,
                 fastburns: Optional[pulumi.Input[Sequence[pulumi.Input['SLOAlertingFastburnArgs']]]] = None,
                 labels: Optional[pulumi.Input[Sequence[pulumi.Input['SLOAlertingLabelArgs']]]] = None,
                 slowburns: Optional[pulumi.Input[Sequence[pulumi.Input['SLOAlertingSlowburnArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['SLOAlertingAnnotationArgs']]] annotations: Annotations will be attached to all alerts generated by any of these rules.
        :param pulumi.Input[Sequence[pulumi.Input['SLOAlertingFastburnArgs']]] fastburns: Alerting Rules generated for Fast Burn alerts
        :param pulumi.Input[Sequence[pulumi.Input['SLOAlertingLabelArgs']]] labels: Labels will be attached to all alerts generated by any of these rules.
        :param pulumi.Input[Sequence[pulumi.Input['SLOAlertingSlowburnArgs']]] slowburns: Alerting Rules generated for Slow Burn alerts
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if fastburns is not None:
            pulumi.set(__self__, "fastburns", fastburns)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if slowburns is not None:
            pulumi.set(__self__, "slowburns", slowburns)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SLOAlertingAnnotationArgs']]]]:
        """
        Annotations will be attached to all alerts generated by any of these rules.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SLOAlertingAnnotationArgs']]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def fastburns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SLOAlertingFastburnArgs']]]]:
        """
        Alerting Rules generated for Fast Burn alerts
        """
        return pulumi.get(self, "fastburns")

    @fastburns.setter
    def fastburns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SLOAlertingFastburnArgs']]]]):
        pulumi.set(self, "fastburns", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SLOAlertingLabelArgs']]]]:
        """
        Labels will be attached to all alerts generated by any of these rules.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SLOAlertingLabelArgs']]]]):
        pulumi.set(self, "labels", value)

    @property
    @pulumi.getter
    def slowburns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SLOAlertingSlowburnArgs']]]]:
        """
        Alerting Rules generated for Slow Burn alerts
        """
        return pulumi.get(self, "slowburns")

    @slowburns.setter
    def slowburns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SLOAlertingSlowburnArgs']]]]):
        pulumi.set(self, "slowburns", value)


@pulumi.input_type
class SLOAlertingAnnotationArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class SLOAlertingFastburnArgs:
    def __init__(__self__, *,
                 annotations: Optional[pulumi.Input[Sequence[pulumi.Input['SLOAlertingFastburnAnnotationArgs']]]] = None,
                 labels: Optional[pulumi.Input[Sequence[pulumi.Input['SLOAlertingFastburnLabelArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['SLOAlertingFastburnAnnotationArgs']]] annotations: Annotations to attach only to Fast Burn alerts.
        :param pulumi.Input[Sequence[pulumi.Input['SLOAlertingFastburnLabelArgs']]] labels: Labels to attach only to Fast Burn alerts.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SLOAlertingFastburnAnnotationArgs']]]]:
        """
        Annotations to attach only to Fast Burn alerts.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SLOAlertingFastburnAnnotationArgs']]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SLOAlertingFastburnLabelArgs']]]]:
        """
        Labels to attach only to Fast Burn alerts.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SLOAlertingFastburnLabelArgs']]]]):
        pulumi.set(self, "labels", value)


@pulumi.input_type
class SLOAlertingFastburnAnnotationArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class SLOAlertingFastburnLabelArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class SLOAlertingLabelArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class SLOAlertingSlowburnArgs:
    def __init__(__self__, *,
                 annotations: Optional[pulumi.Input[Sequence[pulumi.Input['SLOAlertingSlowburnAnnotationArgs']]]] = None,
                 labels: Optional[pulumi.Input[Sequence[pulumi.Input['SLOAlertingSlowburnLabelArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['SLOAlertingSlowburnAnnotationArgs']]] annotations: Annotations to attach only to Slow Burn alerts.
        :param pulumi.Input[Sequence[pulumi.Input['SLOAlertingSlowburnLabelArgs']]] labels: Labels to attach only to Slow Burn alerts.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SLOAlertingSlowburnAnnotationArgs']]]]:
        """
        Annotations to attach only to Slow Burn alerts.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SLOAlertingSlowburnAnnotationArgs']]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SLOAlertingSlowburnLabelArgs']]]]:
        """
        Labels to attach only to Slow Burn alerts.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SLOAlertingSlowburnLabelArgs']]]]):
        pulumi.set(self, "labels", value)


@pulumi.input_type
class SLOAlertingSlowburnAnnotationArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class SLOAlertingSlowburnLabelArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class SLODestinationDatasourceArgs:
    def __init__(__self__, *,
                 uid: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] uid: UID for the Mimir Datasource
        """
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        UID for the Mimir Datasource
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)


@pulumi.input_type
class SLOLabelArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class SLOObjectiveArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[float],
                 window: pulumi.Input[str]):
        """
        :param pulumi.Input[float] value: Value between 0 and 1. If the value of the query is above the objective, the SLO is met.
        :param pulumi.Input[str] window: A Prometheus-parsable time duration string like 24h, 60m. This is the time window the objective is measured over.
        """
        pulumi.set(__self__, "value", value)
        pulumi.set(__self__, "window", window)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[float]:
        """
        Value between 0 and 1. If the value of the query is above the objective, the SLO is met.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[float]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def window(self) -> pulumi.Input[str]:
        """
        A Prometheus-parsable time duration string like 24h, 60m. This is the time window the objective is measured over.
        """
        return pulumi.get(self, "window")

    @window.setter
    def window(self, value: pulumi.Input[str]):
        pulumi.set(self, "window", value)


@pulumi.input_type
class SLOQueryArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 freeform: Optional[pulumi.Input['SLOQueryFreeformArgs']] = None,
                 ratio: Optional[pulumi.Input['SLOQueryRatioArgs']] = None):
        """
        :param pulumi.Input[str] type: Query type must be one of: "freeform", "query", "ratio", or "threshold"
        """
        pulumi.set(__self__, "type", type)
        if freeform is not None:
            pulumi.set(__self__, "freeform", freeform)
        if ratio is not None:
            pulumi.set(__self__, "ratio", ratio)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Query type must be one of: "freeform", "query", "ratio", or "threshold"
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def freeform(self) -> Optional[pulumi.Input['SLOQueryFreeformArgs']]:
        return pulumi.get(self, "freeform")

    @freeform.setter
    def freeform(self, value: Optional[pulumi.Input['SLOQueryFreeformArgs']]):
        pulumi.set(self, "freeform", value)

    @property
    @pulumi.getter
    def ratio(self) -> Optional[pulumi.Input['SLOQueryRatioArgs']]:
        return pulumi.get(self, "ratio")

    @ratio.setter
    def ratio(self, value: Optional[pulumi.Input['SLOQueryRatioArgs']]):
        pulumi.set(self, "ratio", value)


@pulumi.input_type
class SLOQueryFreeformArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str]):
        """
        :param pulumi.Input[str] query: Freeform Query Field
        """
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        Freeform Query Field
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)


@pulumi.input_type
class SLOQueryRatioArgs:
    def __init__(__self__, *,
                 success_metric: pulumi.Input[str],
                 total_metric: pulumi.Input[str],
                 group_by_labels: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] success_metric: Counter metric for success events (numerator)
        :param pulumi.Input[str] total_metric: Metric for total events (denominator)
        :param pulumi.Input[Sequence[pulumi.Input[str]]] group_by_labels: Defines Group By Labels used for per-label alerting. These appear as variables on SLO dashboards to enable filtering and aggregation. Labels must adhere to Prometheus label name schema - "^[a-zA-Z_][a-zA-Z0-9_]*$"
        """
        pulumi.set(__self__, "success_metric", success_metric)
        pulumi.set(__self__, "total_metric", total_metric)
        if group_by_labels is not None:
            pulumi.set(__self__, "group_by_labels", group_by_labels)

    @property
    @pulumi.getter(name="successMetric")
    def success_metric(self) -> pulumi.Input[str]:
        """
        Counter metric for success events (numerator)
        """
        return pulumi.get(self, "success_metric")

    @success_metric.setter
    def success_metric(self, value: pulumi.Input[str]):
        pulumi.set(self, "success_metric", value)

    @property
    @pulumi.getter(name="totalMetric")
    def total_metric(self) -> pulumi.Input[str]:
        """
        Metric for total events (denominator)
        """
        return pulumi.get(self, "total_metric")

    @total_metric.setter
    def total_metric(self, value: pulumi.Input[str]):
        pulumi.set(self, "total_metric", value)

    @property
    @pulumi.getter(name="groupByLabels")
    def group_by_labels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Defines Group By Labels used for per-label alerting. These appear as variables on SLO dashboards to enable filtering and aggregation. Labels must adhere to Prometheus label name schema - "^[a-zA-Z_][a-zA-Z0-9_]*$"
        """
        return pulumi.get(self, "group_by_labels")

    @group_by_labels.setter
    def group_by_labels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "group_by_labels", value)


@pulumi.input_type
class ServiceAccountPermissionPermissionArgs:
    def __init__(__self__, *,
                 permission: pulumi.Input[str],
                 team_id: Optional[pulumi.Input[str]] = None,
                 user_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] permission: Permission to associate with item. Must be `Edit` or `Admin`.
        :param pulumi.Input[str] team_id: ID of the team to manage permissions for. Specify either this or `user_id`.
        :param pulumi.Input[str] user_id: ID of the user or service account to manage permissions for. Specify either this or `team_id`.
        """
        pulumi.set(__self__, "permission", permission)
        if team_id is not None:
            pulumi.set(__self__, "team_id", team_id)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)

    @property
    @pulumi.getter
    def permission(self) -> pulumi.Input[str]:
        """
        Permission to associate with item. Must be `Edit` or `Admin`.
        """
        return pulumi.get(self, "permission")

    @permission.setter
    def permission(self, value: pulumi.Input[str]):
        pulumi.set(self, "permission", value)

    @property
    @pulumi.getter(name="teamId")
    def team_id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the team to manage permissions for. Specify either this or `user_id`.
        """
        return pulumi.get(self, "team_id")

    @team_id.setter
    def team_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "team_id", value)

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the user or service account to manage permissions for. Specify either this or `team_id`.
        """
        return pulumi.get(self, "user_id")

    @user_id.setter
    def user_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_id", value)


@pulumi.input_type
class SsoSettingsOauth2SettingsArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 allow_assign_grafana_admin: Optional[pulumi.Input[bool]] = None,
                 allow_sign_up: Optional[pulumi.Input[bool]] = None,
                 allowed_domains: Optional[pulumi.Input[str]] = None,
                 allowed_groups: Optional[pulumi.Input[str]] = None,
                 allowed_organizations: Optional[pulumi.Input[str]] = None,
                 api_url: Optional[pulumi.Input[str]] = None,
                 auth_style: Optional[pulumi.Input[str]] = None,
                 auth_url: Optional[pulumi.Input[str]] = None,
                 auto_login: Optional[pulumi.Input[bool]] = None,
                 client_secret: Optional[pulumi.Input[str]] = None,
                 custom: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 define_allowed_groups: Optional[pulumi.Input[bool]] = None,
                 define_allowed_teams_ids: Optional[pulumi.Input[bool]] = None,
                 email_attribute_name: Optional[pulumi.Input[str]] = None,
                 email_attribute_path: Optional[pulumi.Input[str]] = None,
                 empty_scopes: Optional[pulumi.Input[bool]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 groups_attribute_path: Optional[pulumi.Input[str]] = None,
                 id_token_attribute_name: Optional[pulumi.Input[str]] = None,
                 login_attribute_path: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 name_attribute_path: Optional[pulumi.Input[str]] = None,
                 role_attribute_path: Optional[pulumi.Input[str]] = None,
                 role_attribute_strict: Optional[pulumi.Input[bool]] = None,
                 scopes: Optional[pulumi.Input[str]] = None,
                 signout_redirect_url: Optional[pulumi.Input[str]] = None,
                 skip_org_role_sync: Optional[pulumi.Input[bool]] = None,
                 team_ids: Optional[pulumi.Input[str]] = None,
                 team_ids_attribute_path: Optional[pulumi.Input[str]] = None,
                 teams_url: Optional[pulumi.Input[str]] = None,
                 tls_client_ca: Optional[pulumi.Input[str]] = None,
                 tls_client_cert: Optional[pulumi.Input[str]] = None,
                 tls_client_key: Optional[pulumi.Input[str]] = None,
                 tls_skip_verify_insecure: Optional[pulumi.Input[bool]] = None,
                 token_url: Optional[pulumi.Input[str]] = None,
                 use_pkce: Optional[pulumi.Input[bool]] = None,
                 use_refresh_token: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] client_id: The client Id of your OAuth2 app.
        :param pulumi.Input[bool] allow_assign_grafana_admin: If enabled, it will automatically sync the Grafana server administrator role.
        :param pulumi.Input[bool] allow_sign_up: If not enabled, only existing Grafana users can log in using OAuth.
        :param pulumi.Input[str] allowed_domains: List of comma- or space-separated domains. The user should belong to at least one domain to log in.
        :param pulumi.Input[str] allowed_groups: List of comma- or space-separated groups. The user should be a member of at least one group to log in. For Generic OAuth, if you configure allowed_groups, you must also configure groups_attribute_path.
        :param pulumi.Input[str] allowed_organizations: List of comma- or space-separated organizations. The user should be a member of at least one organization to log in.
        :param pulumi.Input[str] api_url: The user information endpoint of your OAuth2 provider. Required for azuread, okta and generic_oauth providers.
        :param pulumi.Input[str] auth_style: It determines how client_id and client_secret are sent to Oauth2 provider. Possible values are AutoDetect, InParams, InHeader. Default is AutoDetect.
        :param pulumi.Input[str] auth_url: The authorization endpoint of your OAuth2 provider. Required for azuread, okta and generic_oauth providers.
        :param pulumi.Input[bool] auto_login: Log in automatically, skipping the login screen.
        :param pulumi.Input[str] client_secret: The client secret of your OAuth2 app.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] custom: Custom fields to configure for OAuth2 such as the [force_use_graph_api](https://grafana.com/docs/grafana/latest/setup-grafana/configure-security/configure-authentication/azuread/#force-fetching-groups-from-microsoft-graph-api) field.
        :param pulumi.Input[bool] define_allowed_groups: Define allowed groups.
        :param pulumi.Input[bool] define_allowed_teams_ids: Define allowed teams ids.
        :param pulumi.Input[str] email_attribute_name: Name of the key to use for user email lookup within the attributes map of OAuth2 ID token. Only applicable to Generic OAuth.
        :param pulumi.Input[str] email_attribute_path: JMESPath expression to use for user email lookup from the user information. Only applicable to Generic OAuth.
        :param pulumi.Input[bool] empty_scopes: If enabled, no scopes will be sent to the OAuth2 provider.
        :param pulumi.Input[bool] enabled: Define whether this configuration is enabled for the specified provider.
        :param pulumi.Input[str] groups_attribute_path: JMESPath expression to use for user group lookup. If you configure allowed_groups, you must also configure groups_attribute_path.
        :param pulumi.Input[str] id_token_attribute_name: The name of the key used to extract the ID token from the returned OAuth2 token. Only applicable to Generic OAuth.
        :param pulumi.Input[str] login_attribute_path: JMESPath expression to use for user login lookup from the user ID token. Only applicable to Generic OAuth.
        :param pulumi.Input[str] name: Helpful if you use more than one identity providers or SSO protocols.
        :param pulumi.Input[str] name_attribute_path: JMESPath expression to use for user name lookup from the user ID token. This name will be used as the users display name. Only applicable to Generic OAuth.
        :param pulumi.Input[str] role_attribute_path: JMESPath expression to use for Grafana role lookup.
        :param pulumi.Input[bool] role_attribute_strict: If enabled, denies user login if the Grafana role cannot be extracted using Role attribute path.
        :param pulumi.Input[str] scopes: List of comma- or space-separated OAuth2 scopes.
        :param pulumi.Input[str] signout_redirect_url: The URL to redirect the user to after signing out from Grafana.
        :param pulumi.Input[bool] skip_org_role_sync: Prevent synchronizing users organization roles from your IdP.
        :param pulumi.Input[str] team_ids: String list of Team Ids. If set, the user must be a member of one of the given teams to log in. If you configure team_ids, you must also configure teams_url and team_ids_attribute_path.
        :param pulumi.Input[str] team_ids_attribute_path: The JMESPath expression to use for Grafana Team Id lookup within the results returned by the teams_url endpoint. Only applicable to Generic OAuth.
        :param pulumi.Input[str] teams_url: The URL used to query for Team Ids. If not set, the default value is /teams. If you configure teams_url, you must also configure team_ids_attribute_path. Only applicable to Generic OAuth.
        :param pulumi.Input[str] tls_client_ca: The path to the trusted certificate authority list. Is not applicable on Grafana Cloud.
        :param pulumi.Input[str] tls_client_cert: The path to the certificate. Is not applicable on Grafana Cloud.
        :param pulumi.Input[str] tls_client_key: The path to the key. Is not applicable on Grafana Cloud.
        :param pulumi.Input[bool] tls_skip_verify_insecure: If enabled, the client accepts any certificate presented by the server and any host name in that certificate. You should only use this for testing, because this mode leaves SSL/TLS susceptible to man-in-the-middle attacks.
        :param pulumi.Input[str] token_url: The token endpoint of your OAuth2 provider. Required for azuread, okta and generic_oauth providers.
        :param pulumi.Input[bool] use_pkce: If enabled, Grafana will use Proof Key for Code Exchange (PKCE) with the OAuth2 Authorization Code Grant.
        :param pulumi.Input[bool] use_refresh_token: If enabled, Grafana will fetch a new access token using the refresh token provided by the OAuth2 provider.
        """
        pulumi.set(__self__, "client_id", client_id)
        if allow_assign_grafana_admin is not None:
            pulumi.set(__self__, "allow_assign_grafana_admin", allow_assign_grafana_admin)
        if allow_sign_up is not None:
            pulumi.set(__self__, "allow_sign_up", allow_sign_up)
        if allowed_domains is not None:
            pulumi.set(__self__, "allowed_domains", allowed_domains)
        if allowed_groups is not None:
            pulumi.set(__self__, "allowed_groups", allowed_groups)
        if allowed_organizations is not None:
            pulumi.set(__self__, "allowed_organizations", allowed_organizations)
        if api_url is not None:
            pulumi.set(__self__, "api_url", api_url)
        if auth_style is not None:
            pulumi.set(__self__, "auth_style", auth_style)
        if auth_url is not None:
            pulumi.set(__self__, "auth_url", auth_url)
        if auto_login is not None:
            pulumi.set(__self__, "auto_login", auto_login)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if custom is not None:
            pulumi.set(__self__, "custom", custom)
        if define_allowed_groups is not None:
            pulumi.set(__self__, "define_allowed_groups", define_allowed_groups)
        if define_allowed_teams_ids is not None:
            pulumi.set(__self__, "define_allowed_teams_ids", define_allowed_teams_ids)
        if email_attribute_name is not None:
            pulumi.set(__self__, "email_attribute_name", email_attribute_name)
        if email_attribute_path is not None:
            pulumi.set(__self__, "email_attribute_path", email_attribute_path)
        if empty_scopes is not None:
            pulumi.set(__self__, "empty_scopes", empty_scopes)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if groups_attribute_path is not None:
            pulumi.set(__self__, "groups_attribute_path", groups_attribute_path)
        if id_token_attribute_name is not None:
            pulumi.set(__self__, "id_token_attribute_name", id_token_attribute_name)
        if login_attribute_path is not None:
            pulumi.set(__self__, "login_attribute_path", login_attribute_path)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if name_attribute_path is not None:
            pulumi.set(__self__, "name_attribute_path", name_attribute_path)
        if role_attribute_path is not None:
            pulumi.set(__self__, "role_attribute_path", role_attribute_path)
        if role_attribute_strict is not None:
            pulumi.set(__self__, "role_attribute_strict", role_attribute_strict)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if signout_redirect_url is not None:
            pulumi.set(__self__, "signout_redirect_url", signout_redirect_url)
        if skip_org_role_sync is not None:
            pulumi.set(__self__, "skip_org_role_sync", skip_org_role_sync)
        if team_ids is not None:
            pulumi.set(__self__, "team_ids", team_ids)
        if team_ids_attribute_path is not None:
            pulumi.set(__self__, "team_ids_attribute_path", team_ids_attribute_path)
        if teams_url is not None:
            pulumi.set(__self__, "teams_url", teams_url)
        if tls_client_ca is not None:
            pulumi.set(__self__, "tls_client_ca", tls_client_ca)
        if tls_client_cert is not None:
            pulumi.set(__self__, "tls_client_cert", tls_client_cert)
        if tls_client_key is not None:
            pulumi.set(__self__, "tls_client_key", tls_client_key)
        if tls_skip_verify_insecure is not None:
            pulumi.set(__self__, "tls_skip_verify_insecure", tls_skip_verify_insecure)
        if token_url is not None:
            pulumi.set(__self__, "token_url", token_url)
        if use_pkce is not None:
            pulumi.set(__self__, "use_pkce", use_pkce)
        if use_refresh_token is not None:
            pulumi.set(__self__, "use_refresh_token", use_refresh_token)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The client Id of your OAuth2 app.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="allowAssignGrafanaAdmin")
    def allow_assign_grafana_admin(self) -> Optional[pulumi.Input[bool]]:
        """
        If enabled, it will automatically sync the Grafana server administrator role.
        """
        return pulumi.get(self, "allow_assign_grafana_admin")

    @allow_assign_grafana_admin.setter
    def allow_assign_grafana_admin(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_assign_grafana_admin", value)

    @property
    @pulumi.getter(name="allowSignUp")
    def allow_sign_up(self) -> Optional[pulumi.Input[bool]]:
        """
        If not enabled, only existing Grafana users can log in using OAuth.
        """
        return pulumi.get(self, "allow_sign_up")

    @allow_sign_up.setter
    def allow_sign_up(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_sign_up", value)

    @property
    @pulumi.getter(name="allowedDomains")
    def allowed_domains(self) -> Optional[pulumi.Input[str]]:
        """
        List of comma- or space-separated domains. The user should belong to at least one domain to log in.
        """
        return pulumi.get(self, "allowed_domains")

    @allowed_domains.setter
    def allowed_domains(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "allowed_domains", value)

    @property
    @pulumi.getter(name="allowedGroups")
    def allowed_groups(self) -> Optional[pulumi.Input[str]]:
        """
        List of comma- or space-separated groups. The user should be a member of at least one group to log in. For Generic OAuth, if you configure allowed_groups, you must also configure groups_attribute_path.
        """
        return pulumi.get(self, "allowed_groups")

    @allowed_groups.setter
    def allowed_groups(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "allowed_groups", value)

    @property
    @pulumi.getter(name="allowedOrganizations")
    def allowed_organizations(self) -> Optional[pulumi.Input[str]]:
        """
        List of comma- or space-separated organizations. The user should be a member of at least one organization to log in.
        """
        return pulumi.get(self, "allowed_organizations")

    @allowed_organizations.setter
    def allowed_organizations(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "allowed_organizations", value)

    @property
    @pulumi.getter(name="apiUrl")
    def api_url(self) -> Optional[pulumi.Input[str]]:
        """
        The user information endpoint of your OAuth2 provider. Required for azuread, okta and generic_oauth providers.
        """
        return pulumi.get(self, "api_url")

    @api_url.setter
    def api_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_url", value)

    @property
    @pulumi.getter(name="authStyle")
    def auth_style(self) -> Optional[pulumi.Input[str]]:
        """
        It determines how client_id and client_secret are sent to Oauth2 provider. Possible values are AutoDetect, InParams, InHeader. Default is AutoDetect.
        """
        return pulumi.get(self, "auth_style")

    @auth_style.setter
    def auth_style(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auth_style", value)

    @property
    @pulumi.getter(name="authUrl")
    def auth_url(self) -> Optional[pulumi.Input[str]]:
        """
        The authorization endpoint of your OAuth2 provider. Required for azuread, okta and generic_oauth providers.
        """
        return pulumi.get(self, "auth_url")

    @auth_url.setter
    def auth_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auth_url", value)

    @property
    @pulumi.getter(name="autoLogin")
    def auto_login(self) -> Optional[pulumi.Input[bool]]:
        """
        Log in automatically, skipping the login screen.
        """
        return pulumi.get(self, "auto_login")

    @auto_login.setter
    def auto_login(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "auto_login", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[str]]:
        """
        The client secret of your OAuth2 app.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter
    def custom(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Custom fields to configure for OAuth2 such as the [force_use_graph_api](https://grafana.com/docs/grafana/latest/setup-grafana/configure-security/configure-authentication/azuread/#force-fetching-groups-from-microsoft-graph-api) field.
        """
        return pulumi.get(self, "custom")

    @custom.setter
    def custom(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "custom", value)

    @property
    @pulumi.getter(name="defineAllowedGroups")
    def define_allowed_groups(self) -> Optional[pulumi.Input[bool]]:
        """
        Define allowed groups.
        """
        return pulumi.get(self, "define_allowed_groups")

    @define_allowed_groups.setter
    def define_allowed_groups(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "define_allowed_groups", value)

    @property
    @pulumi.getter(name="defineAllowedTeamsIds")
    def define_allowed_teams_ids(self) -> Optional[pulumi.Input[bool]]:
        """
        Define allowed teams ids.
        """
        return pulumi.get(self, "define_allowed_teams_ids")

    @define_allowed_teams_ids.setter
    def define_allowed_teams_ids(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "define_allowed_teams_ids", value)

    @property
    @pulumi.getter(name="emailAttributeName")
    def email_attribute_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the key to use for user email lookup within the attributes map of OAuth2 ID token. Only applicable to Generic OAuth.
        """
        return pulumi.get(self, "email_attribute_name")

    @email_attribute_name.setter
    def email_attribute_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "email_attribute_name", value)

    @property
    @pulumi.getter(name="emailAttributePath")
    def email_attribute_path(self) -> Optional[pulumi.Input[str]]:
        """
        JMESPath expression to use for user email lookup from the user information. Only applicable to Generic OAuth.
        """
        return pulumi.get(self, "email_attribute_path")

    @email_attribute_path.setter
    def email_attribute_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "email_attribute_path", value)

    @property
    @pulumi.getter(name="emptyScopes")
    def empty_scopes(self) -> Optional[pulumi.Input[bool]]:
        """
        If enabled, no scopes will be sent to the OAuth2 provider.
        """
        return pulumi.get(self, "empty_scopes")

    @empty_scopes.setter
    def empty_scopes(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "empty_scopes", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Define whether this configuration is enabled for the specified provider.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="groupsAttributePath")
    def groups_attribute_path(self) -> Optional[pulumi.Input[str]]:
        """
        JMESPath expression to use for user group lookup. If you configure allowed_groups, you must also configure groups_attribute_path.
        """
        return pulumi.get(self, "groups_attribute_path")

    @groups_attribute_path.setter
    def groups_attribute_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "groups_attribute_path", value)

    @property
    @pulumi.getter(name="idTokenAttributeName")
    def id_token_attribute_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the key used to extract the ID token from the returned OAuth2 token. Only applicable to Generic OAuth.
        """
        return pulumi.get(self, "id_token_attribute_name")

    @id_token_attribute_name.setter
    def id_token_attribute_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id_token_attribute_name", value)

    @property
    @pulumi.getter(name="loginAttributePath")
    def login_attribute_path(self) -> Optional[pulumi.Input[str]]:
        """
        JMESPath expression to use for user login lookup from the user ID token. Only applicable to Generic OAuth.
        """
        return pulumi.get(self, "login_attribute_path")

    @login_attribute_path.setter
    def login_attribute_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "login_attribute_path", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Helpful if you use more than one identity providers or SSO protocols.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="nameAttributePath")
    def name_attribute_path(self) -> Optional[pulumi.Input[str]]:
        """
        JMESPath expression to use for user name lookup from the user ID token. This name will be used as the users display name. Only applicable to Generic OAuth.
        """
        return pulumi.get(self, "name_attribute_path")

    @name_attribute_path.setter
    def name_attribute_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name_attribute_path", value)

    @property
    @pulumi.getter(name="roleAttributePath")
    def role_attribute_path(self) -> Optional[pulumi.Input[str]]:
        """
        JMESPath expression to use for Grafana role lookup.
        """
        return pulumi.get(self, "role_attribute_path")

    @role_attribute_path.setter
    def role_attribute_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role_attribute_path", value)

    @property
    @pulumi.getter(name="roleAttributeStrict")
    def role_attribute_strict(self) -> Optional[pulumi.Input[bool]]:
        """
        If enabled, denies user login if the Grafana role cannot be extracted using Role attribute path.
        """
        return pulumi.get(self, "role_attribute_strict")

    @role_attribute_strict.setter
    def role_attribute_strict(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "role_attribute_strict", value)

    @property
    @pulumi.getter
    def scopes(self) -> Optional[pulumi.Input[str]]:
        """
        List of comma- or space-separated OAuth2 scopes.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scopes", value)

    @property
    @pulumi.getter(name="signoutRedirectUrl")
    def signout_redirect_url(self) -> Optional[pulumi.Input[str]]:
        """
        The URL to redirect the user to after signing out from Grafana.
        """
        return pulumi.get(self, "signout_redirect_url")

    @signout_redirect_url.setter
    def signout_redirect_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "signout_redirect_url", value)

    @property
    @pulumi.getter(name="skipOrgRoleSync")
    def skip_org_role_sync(self) -> Optional[pulumi.Input[bool]]:
        """
        Prevent synchronizing users organization roles from your IdP.
        """
        return pulumi.get(self, "skip_org_role_sync")

    @skip_org_role_sync.setter
    def skip_org_role_sync(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "skip_org_role_sync", value)

    @property
    @pulumi.getter(name="teamIds")
    def team_ids(self) -> Optional[pulumi.Input[str]]:
        """
        String list of Team Ids. If set, the user must be a member of one of the given teams to log in. If you configure team_ids, you must also configure teams_url and team_ids_attribute_path.
        """
        return pulumi.get(self, "team_ids")

    @team_ids.setter
    def team_ids(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "team_ids", value)

    @property
    @pulumi.getter(name="teamIdsAttributePath")
    def team_ids_attribute_path(self) -> Optional[pulumi.Input[str]]:
        """
        The JMESPath expression to use for Grafana Team Id lookup within the results returned by the teams_url endpoint. Only applicable to Generic OAuth.
        """
        return pulumi.get(self, "team_ids_attribute_path")

    @team_ids_attribute_path.setter
    def team_ids_attribute_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "team_ids_attribute_path", value)

    @property
    @pulumi.getter(name="teamsUrl")
    def teams_url(self) -> Optional[pulumi.Input[str]]:
        """
        The URL used to query for Team Ids. If not set, the default value is /teams. If you configure teams_url, you must also configure team_ids_attribute_path. Only applicable to Generic OAuth.
        """
        return pulumi.get(self, "teams_url")

    @teams_url.setter
    def teams_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "teams_url", value)

    @property
    @pulumi.getter(name="tlsClientCa")
    def tls_client_ca(self) -> Optional[pulumi.Input[str]]:
        """
        The path to the trusted certificate authority list. Is not applicable on Grafana Cloud.
        """
        return pulumi.get(self, "tls_client_ca")

    @tls_client_ca.setter
    def tls_client_ca(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tls_client_ca", value)

    @property
    @pulumi.getter(name="tlsClientCert")
    def tls_client_cert(self) -> Optional[pulumi.Input[str]]:
        """
        The path to the certificate. Is not applicable on Grafana Cloud.
        """
        return pulumi.get(self, "tls_client_cert")

    @tls_client_cert.setter
    def tls_client_cert(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tls_client_cert", value)

    @property
    @pulumi.getter(name="tlsClientKey")
    def tls_client_key(self) -> Optional[pulumi.Input[str]]:
        """
        The path to the key. Is not applicable on Grafana Cloud.
        """
        return pulumi.get(self, "tls_client_key")

    @tls_client_key.setter
    def tls_client_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tls_client_key", value)

    @property
    @pulumi.getter(name="tlsSkipVerifyInsecure")
    def tls_skip_verify_insecure(self) -> Optional[pulumi.Input[bool]]:
        """
        If enabled, the client accepts any certificate presented by the server and any host name in that certificate. You should only use this for testing, because this mode leaves SSL/TLS susceptible to man-in-the-middle attacks.
        """
        return pulumi.get(self, "tls_skip_verify_insecure")

    @tls_skip_verify_insecure.setter
    def tls_skip_verify_insecure(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "tls_skip_verify_insecure", value)

    @property
    @pulumi.getter(name="tokenUrl")
    def token_url(self) -> Optional[pulumi.Input[str]]:
        """
        The token endpoint of your OAuth2 provider. Required for azuread, okta and generic_oauth providers.
        """
        return pulumi.get(self, "token_url")

    @token_url.setter
    def token_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "token_url", value)

    @property
    @pulumi.getter(name="usePkce")
    def use_pkce(self) -> Optional[pulumi.Input[bool]]:
        """
        If enabled, Grafana will use Proof Key for Code Exchange (PKCE) with the OAuth2 Authorization Code Grant.
        """
        return pulumi.get(self, "use_pkce")

    @use_pkce.setter
    def use_pkce(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_pkce", value)

    @property
    @pulumi.getter(name="useRefreshToken")
    def use_refresh_token(self) -> Optional[pulumi.Input[bool]]:
        """
        If enabled, Grafana will fetch a new access token using the refresh token provided by the OAuth2 provider.
        """
        return pulumi.get(self, "use_refresh_token")

    @use_refresh_token.setter
    def use_refresh_token(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_refresh_token", value)


@pulumi.input_type
class SyntheticMonitoringCheckSettingsArgs:
    def __init__(__self__, *,
                 dns: Optional[pulumi.Input['SyntheticMonitoringCheckSettingsDnsArgs']] = None,
                 http: Optional[pulumi.Input['SyntheticMonitoringCheckSettingsHttpArgs']] = None,
                 multihttp: Optional[pulumi.Input['SyntheticMonitoringCheckSettingsMultihttpArgs']] = None,
                 ping: Optional[pulumi.Input['SyntheticMonitoringCheckSettingsPingArgs']] = None,
                 tcp: Optional[pulumi.Input['SyntheticMonitoringCheckSettingsTcpArgs']] = None,
                 traceroute: Optional[pulumi.Input['SyntheticMonitoringCheckSettingsTracerouteArgs']] = None):
        """
        :param pulumi.Input['SyntheticMonitoringCheckSettingsDnsArgs'] dns: Settings for DNS check. The target must be a valid hostname (or IP address for `PTR` records).
        :param pulumi.Input['SyntheticMonitoringCheckSettingsHttpArgs'] http: Settings for HTTP check. The target must be a URL (http or https).
        :param pulumi.Input['SyntheticMonitoringCheckSettingsMultihttpArgs'] multihttp: Settings for MultiHTTP check. The target must be a URL (http or https)
        :param pulumi.Input['SyntheticMonitoringCheckSettingsPingArgs'] ping: Settings for ping (ICMP) check. The target must be a valid hostname or IP address.
        :param pulumi.Input['SyntheticMonitoringCheckSettingsTcpArgs'] tcp: Settings for TCP check. The target must be of the form `<host>:<port>`, where the host portion must be a valid hostname or IP address.
        :param pulumi.Input['SyntheticMonitoringCheckSettingsTracerouteArgs'] traceroute: Settings for traceroute check. The target must be a valid hostname or IP address
        """
        if dns is not None:
            pulumi.set(__self__, "dns", dns)
        if http is not None:
            pulumi.set(__self__, "http", http)
        if multihttp is not None:
            pulumi.set(__self__, "multihttp", multihttp)
        if ping is not None:
            pulumi.set(__self__, "ping", ping)
        if tcp is not None:
            pulumi.set(__self__, "tcp", tcp)
        if traceroute is not None:
            pulumi.set(__self__, "traceroute", traceroute)

    @property
    @pulumi.getter
    def dns(self) -> Optional[pulumi.Input['SyntheticMonitoringCheckSettingsDnsArgs']]:
        """
        Settings for DNS check. The target must be a valid hostname (or IP address for `PTR` records).
        """
        return pulumi.get(self, "dns")

    @dns.setter
    def dns(self, value: Optional[pulumi.Input['SyntheticMonitoringCheckSettingsDnsArgs']]):
        pulumi.set(self, "dns", value)

    @property
    @pulumi.getter
    def http(self) -> Optional[pulumi.Input['SyntheticMonitoringCheckSettingsHttpArgs']]:
        """
        Settings for HTTP check. The target must be a URL (http or https).
        """
        return pulumi.get(self, "http")

    @http.setter
    def http(self, value: Optional[pulumi.Input['SyntheticMonitoringCheckSettingsHttpArgs']]):
        pulumi.set(self, "http", value)

    @property
    @pulumi.getter
    def multihttp(self) -> Optional[pulumi.Input['SyntheticMonitoringCheckSettingsMultihttpArgs']]:
        """
        Settings for MultiHTTP check. The target must be a URL (http or https)
        """
        return pulumi.get(self, "multihttp")

    @multihttp.setter
    def multihttp(self, value: Optional[pulumi.Input['SyntheticMonitoringCheckSettingsMultihttpArgs']]):
        pulumi.set(self, "multihttp", value)

    @property
    @pulumi.getter
    def ping(self) -> Optional[pulumi.Input['SyntheticMonitoringCheckSettingsPingArgs']]:
        """
        Settings for ping (ICMP) check. The target must be a valid hostname or IP address.
        """
        return pulumi.get(self, "ping")

    @ping.setter
    def ping(self, value: Optional[pulumi.Input['SyntheticMonitoringCheckSettingsPingArgs']]):
        pulumi.set(self, "ping", value)

    @property
    @pulumi.getter
    def tcp(self) -> Optional[pulumi.Input['SyntheticMonitoringCheckSettingsTcpArgs']]:
        """
        Settings for TCP check. The target must be of the form `<host>:<port>`, where the host portion must be a valid hostname or IP address.
        """
        return pulumi.get(self, "tcp")

    @tcp.setter
    def tcp(self, value: Optional[pulumi.Input['SyntheticMonitoringCheckSettingsTcpArgs']]):
        pulumi.set(self, "tcp", value)

    @property
    @pulumi.getter
    def traceroute(self) -> Optional[pulumi.Input['SyntheticMonitoringCheckSettingsTracerouteArgs']]:
        """
        Settings for traceroute check. The target must be a valid hostname or IP address
        """
        return pulumi.get(self, "traceroute")

    @traceroute.setter
    def traceroute(self, value: Optional[pulumi.Input['SyntheticMonitoringCheckSettingsTracerouteArgs']]):
        pulumi.set(self, "traceroute", value)


@pulumi.input_type
class SyntheticMonitoringCheckSettingsDnsArgs:
    def __init__(__self__, *,
                 ip_version: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 protocol: Optional[pulumi.Input[str]] = None,
                 record_type: Optional[pulumi.Input[str]] = None,
                 server: Optional[pulumi.Input[str]] = None,
                 source_ip_address: Optional[pulumi.Input[str]] = None,
                 valid_r_codes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 validate_additional_rrs: Optional[pulumi.Input[Sequence[pulumi.Input['SyntheticMonitoringCheckSettingsDnsValidateAdditionalRrArgs']]]] = None,
                 validate_answer_rrs: Optional[pulumi.Input['SyntheticMonitoringCheckSettingsDnsValidateAnswerRrsArgs']] = None,
                 validate_authority_rrs: Optional[pulumi.Input['SyntheticMonitoringCheckSettingsDnsValidateAuthorityRrsArgs']] = None):
        """
        :param pulumi.Input[str] ip_version: Options are `V4`, `V6`, `Any`. Specifies whether the corresponding check will be performed using IPv4 or IPv6. The `Any` value indicates that IPv6 should be used, falling back to IPv4 if that's not available.
        :param pulumi.Input[int] port: Port to target.
        :param pulumi.Input[str] protocol: `TCP` or `UDP`.
        :param pulumi.Input[str] record_type: One of `ANY`, `A`, `AAAA`, `CNAME`, `MX`, `NS`, `PTR`, `SOA`, `SRV`, `TXT`.
        :param pulumi.Input[str] server: DNS server address to target.
        :param pulumi.Input[str] source_ip_address: Source IP address.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] valid_r_codes: List of valid response codes. Options include `NOERROR`, `BADALG`, `BADMODE`, `BADKEY`, `BADCOOKIE`, `BADNAME`, `BADSIG`, `BADTIME`, `BADTRUNC`, `BADVERS`, `FORMERR`, `NOTIMP`, `NOTAUTH`, `NOTZONE`, `NXDOMAIN`, `NXRRSET`, `REFUSED`, `SERVFAIL`, `YXDOMAIN`, `YXRRSET`.
        :param pulumi.Input[Sequence[pulumi.Input['SyntheticMonitoringCheckSettingsDnsValidateAdditionalRrArgs']]] validate_additional_rrs: Validate additional matches.
        :param pulumi.Input['SyntheticMonitoringCheckSettingsDnsValidateAnswerRrsArgs'] validate_answer_rrs: Validate response answer.
        :param pulumi.Input['SyntheticMonitoringCheckSettingsDnsValidateAuthorityRrsArgs'] validate_authority_rrs: Validate response authority.
        """
        if ip_version is not None:
            pulumi.set(__self__, "ip_version", ip_version)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if record_type is not None:
            pulumi.set(__self__, "record_type", record_type)
        if server is not None:
            pulumi.set(__self__, "server", server)
        if source_ip_address is not None:
            pulumi.set(__self__, "source_ip_address", source_ip_address)
        if valid_r_codes is not None:
            pulumi.set(__self__, "valid_r_codes", valid_r_codes)
        if validate_additional_rrs is not None:
            pulumi.set(__self__, "validate_additional_rrs", validate_additional_rrs)
        if validate_answer_rrs is not None:
            pulumi.set(__self__, "validate_answer_rrs", validate_answer_rrs)
        if validate_authority_rrs is not None:
            pulumi.set(__self__, "validate_authority_rrs", validate_authority_rrs)

    @property
    @pulumi.getter(name="ipVersion")
    def ip_version(self) -> Optional[pulumi.Input[str]]:
        """
        Options are `V4`, `V6`, `Any`. Specifies whether the corresponding check will be performed using IPv4 or IPv6. The `Any` value indicates that IPv6 should be used, falling back to IPv4 if that's not available.
        """
        return pulumi.get(self, "ip_version")

    @ip_version.setter
    def ip_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_version", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        Port to target.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[str]]:
        """
        `TCP` or `UDP`.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="recordType")
    def record_type(self) -> Optional[pulumi.Input[str]]:
        """
        One of `ANY`, `A`, `AAAA`, `CNAME`, `MX`, `NS`, `PTR`, `SOA`, `SRV`, `TXT`.
        """
        return pulumi.get(self, "record_type")

    @record_type.setter
    def record_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "record_type", value)

    @property
    @pulumi.getter
    def server(self) -> Optional[pulumi.Input[str]]:
        """
        DNS server address to target.
        """
        return pulumi.get(self, "server")

    @server.setter
    def server(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "server", value)

    @property
    @pulumi.getter(name="sourceIpAddress")
    def source_ip_address(self) -> Optional[pulumi.Input[str]]:
        """
        Source IP address.
        """
        return pulumi.get(self, "source_ip_address")

    @source_ip_address.setter
    def source_ip_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_ip_address", value)

    @property
    @pulumi.getter(name="validRCodes")
    def valid_r_codes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of valid response codes. Options include `NOERROR`, `BADALG`, `BADMODE`, `BADKEY`, `BADCOOKIE`, `BADNAME`, `BADSIG`, `BADTIME`, `BADTRUNC`, `BADVERS`, `FORMERR`, `NOTIMP`, `NOTAUTH`, `NOTZONE`, `NXDOMAIN`, `NXRRSET`, `REFUSED`, `SERVFAIL`, `YXDOMAIN`, `YXRRSET`.
        """
        return pulumi.get(self, "valid_r_codes")

    @valid_r_codes.setter
    def valid_r_codes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "valid_r_codes", value)

    @property
    @pulumi.getter(name="validateAdditionalRrs")
    def validate_additional_rrs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SyntheticMonitoringCheckSettingsDnsValidateAdditionalRrArgs']]]]:
        """
        Validate additional matches.
        """
        return pulumi.get(self, "validate_additional_rrs")

    @validate_additional_rrs.setter
    def validate_additional_rrs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SyntheticMonitoringCheckSettingsDnsValidateAdditionalRrArgs']]]]):
        pulumi.set(self, "validate_additional_rrs", value)

    @property
    @pulumi.getter(name="validateAnswerRrs")
    def validate_answer_rrs(self) -> Optional[pulumi.Input['SyntheticMonitoringCheckSettingsDnsValidateAnswerRrsArgs']]:
        """
        Validate response answer.
        """
        return pulumi.get(self, "validate_answer_rrs")

    @validate_answer_rrs.setter
    def validate_answer_rrs(self, value: Optional[pulumi.Input['SyntheticMonitoringCheckSettingsDnsValidateAnswerRrsArgs']]):
        pulumi.set(self, "validate_answer_rrs", value)

    @property
    @pulumi.getter(name="validateAuthorityRrs")
    def validate_authority_rrs(self) -> Optional[pulumi.Input['SyntheticMonitoringCheckSettingsDnsValidateAuthorityRrsArgs']]:
        """
        Validate response authority.
        """
        return pulumi.get(self, "validate_authority_rrs")

    @validate_authority_rrs.setter
    def validate_authority_rrs(self, value: Optional[pulumi.Input['SyntheticMonitoringCheckSettingsDnsValidateAuthorityRrsArgs']]):
        pulumi.set(self, "validate_authority_rrs", value)


@pulumi.input_type
class SyntheticMonitoringCheckSettingsDnsValidateAdditionalRrArgs:
    def __init__(__self__, *,
                 fail_if_matches_regexps: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 fail_if_not_matches_regexps: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] fail_if_matches_regexps: Fail if value matches regex.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] fail_if_not_matches_regexps: Fail if value does not match regex.
        """
        if fail_if_matches_regexps is not None:
            pulumi.set(__self__, "fail_if_matches_regexps", fail_if_matches_regexps)
        if fail_if_not_matches_regexps is not None:
            pulumi.set(__self__, "fail_if_not_matches_regexps", fail_if_not_matches_regexps)

    @property
    @pulumi.getter(name="failIfMatchesRegexps")
    def fail_if_matches_regexps(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Fail if value matches regex.
        """
        return pulumi.get(self, "fail_if_matches_regexps")

    @fail_if_matches_regexps.setter
    def fail_if_matches_regexps(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "fail_if_matches_regexps", value)

    @property
    @pulumi.getter(name="failIfNotMatchesRegexps")
    def fail_if_not_matches_regexps(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Fail if value does not match regex.
        """
        return pulumi.get(self, "fail_if_not_matches_regexps")

    @fail_if_not_matches_regexps.setter
    def fail_if_not_matches_regexps(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "fail_if_not_matches_regexps", value)


@pulumi.input_type
class SyntheticMonitoringCheckSettingsDnsValidateAnswerRrsArgs:
    def __init__(__self__, *,
                 fail_if_matches_regexps: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 fail_if_not_matches_regexps: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] fail_if_matches_regexps: Fail if value matches regex.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] fail_if_not_matches_regexps: Fail if value does not match regex.
        """
        if fail_if_matches_regexps is not None:
            pulumi.set(__self__, "fail_if_matches_regexps", fail_if_matches_regexps)
        if fail_if_not_matches_regexps is not None:
            pulumi.set(__self__, "fail_if_not_matches_regexps", fail_if_not_matches_regexps)

    @property
    @pulumi.getter(name="failIfMatchesRegexps")
    def fail_if_matches_regexps(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Fail if value matches regex.
        """
        return pulumi.get(self, "fail_if_matches_regexps")

    @fail_if_matches_regexps.setter
    def fail_if_matches_regexps(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "fail_if_matches_regexps", value)

    @property
    @pulumi.getter(name="failIfNotMatchesRegexps")
    def fail_if_not_matches_regexps(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Fail if value does not match regex.
        """
        return pulumi.get(self, "fail_if_not_matches_regexps")

    @fail_if_not_matches_regexps.setter
    def fail_if_not_matches_regexps(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "fail_if_not_matches_regexps", value)


@pulumi.input_type
class SyntheticMonitoringCheckSettingsDnsValidateAuthorityRrsArgs:
    def __init__(__self__, *,
                 fail_if_matches_regexps: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 fail_if_not_matches_regexps: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] fail_if_matches_regexps: Fail if value matches regex.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] fail_if_not_matches_regexps: Fail if value does not match regex.
        """
        if fail_if_matches_regexps is not None:
            pulumi.set(__self__, "fail_if_matches_regexps", fail_if_matches_regexps)
        if fail_if_not_matches_regexps is not None:
            pulumi.set(__self__, "fail_if_not_matches_regexps", fail_if_not_matches_regexps)

    @property
    @pulumi.getter(name="failIfMatchesRegexps")
    def fail_if_matches_regexps(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Fail if value matches regex.
        """
        return pulumi.get(self, "fail_if_matches_regexps")

    @fail_if_matches_regexps.setter
    def fail_if_matches_regexps(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "fail_if_matches_regexps", value)

    @property
    @pulumi.getter(name="failIfNotMatchesRegexps")
    def fail_if_not_matches_regexps(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Fail if value does not match regex.
        """
        return pulumi.get(self, "fail_if_not_matches_regexps")

    @fail_if_not_matches_regexps.setter
    def fail_if_not_matches_regexps(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "fail_if_not_matches_regexps", value)


@pulumi.input_type
class SyntheticMonitoringCheckSettingsHttpArgs:
    def __init__(__self__, *,
                 basic_auth: Optional[pulumi.Input['SyntheticMonitoringCheckSettingsHttpBasicAuthArgs']] = None,
                 bearer_token: Optional[pulumi.Input[str]] = None,
                 body: Optional[pulumi.Input[str]] = None,
                 cache_busting_query_param_name: Optional[pulumi.Input[str]] = None,
                 fail_if_body_matches_regexps: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 fail_if_body_not_matches_regexps: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 fail_if_header_matches_regexps: Optional[pulumi.Input[Sequence[pulumi.Input['SyntheticMonitoringCheckSettingsHttpFailIfHeaderMatchesRegexpArgs']]]] = None,
                 fail_if_header_not_matches_regexps: Optional[pulumi.Input[Sequence[pulumi.Input['SyntheticMonitoringCheckSettingsHttpFailIfHeaderNotMatchesRegexpArgs']]]] = None,
                 fail_if_not_ssl: Optional[pulumi.Input[bool]] = None,
                 fail_if_ssl: Optional[pulumi.Input[bool]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 ip_version: Optional[pulumi.Input[str]] = None,
                 method: Optional[pulumi.Input[str]] = None,
                 no_follow_redirects: Optional[pulumi.Input[bool]] = None,
                 proxy_connect_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 proxy_url: Optional[pulumi.Input[str]] = None,
                 tls_config: Optional[pulumi.Input['SyntheticMonitoringCheckSettingsHttpTlsConfigArgs']] = None,
                 valid_http_versions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 valid_status_codes: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None):
        """
        :param pulumi.Input['SyntheticMonitoringCheckSettingsHttpBasicAuthArgs'] basic_auth: Basic auth settings.
        :param pulumi.Input[str] bearer_token: Token for use with bearer authorization header.
        :param pulumi.Input[str] body: The body of the HTTP request used in probe.
        :param pulumi.Input[str] cache_busting_query_param_name: The name of the query parameter used to prevent the server from using a cached response. Each probe will assign a random value to this parameter each time a request is made.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] fail_if_body_matches_regexps: List of regexes. If any match the response body, the check will fail.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] fail_if_body_not_matches_regexps: List of regexes. If any do not match the response body, the check will fail.
        :param pulumi.Input[Sequence[pulumi.Input['SyntheticMonitoringCheckSettingsHttpFailIfHeaderMatchesRegexpArgs']]] fail_if_header_matches_regexps: Check fails if headers match.
        :param pulumi.Input[Sequence[pulumi.Input['SyntheticMonitoringCheckSettingsHttpFailIfHeaderNotMatchesRegexpArgs']]] fail_if_header_not_matches_regexps: Check fails if headers do not match.
        :param pulumi.Input[bool] fail_if_not_ssl: Fail if SSL is not present.
        :param pulumi.Input[bool] fail_if_ssl: Fail if SSL is present.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] headers: The HTTP headers set for the probe.
        :param pulumi.Input[str] ip_version: Options are `V4`, `V6`, `Any`. Specifies whether the corresponding check will be performed using IPv4 or IPv6. The `Any` value indicates that IPv6 should be used, falling back to IPv4 if that's not available.
        :param pulumi.Input[str] method: Request method. One of `GET`, `CONNECT`, `DELETE`, `HEAD`, `OPTIONS`, `POST`, `PUT`, `TRACE`
        :param pulumi.Input[bool] no_follow_redirects: Do not follow redirects.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] proxy_connect_headers: The HTTP headers sent to the proxy URL
        :param pulumi.Input[str] proxy_url: Proxy URL.
        :param pulumi.Input['SyntheticMonitoringCheckSettingsHttpTlsConfigArgs'] tls_config: TLS config.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] valid_http_versions: List of valid HTTP versions. Options include `HTTP/1.0`, `HTTP/1.1`, `HTTP/2.0`
        :param pulumi.Input[Sequence[pulumi.Input[int]]] valid_status_codes: Accepted status codes. If unset, defaults to 2xx.
        """
        if basic_auth is not None:
            pulumi.set(__self__, "basic_auth", basic_auth)
        if bearer_token is not None:
            pulumi.set(__self__, "bearer_token", bearer_token)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cache_busting_query_param_name is not None:
            pulumi.set(__self__, "cache_busting_query_param_name", cache_busting_query_param_name)
        if fail_if_body_matches_regexps is not None:
            pulumi.set(__self__, "fail_if_body_matches_regexps", fail_if_body_matches_regexps)
        if fail_if_body_not_matches_regexps is not None:
            pulumi.set(__self__, "fail_if_body_not_matches_regexps", fail_if_body_not_matches_regexps)
        if fail_if_header_matches_regexps is not None:
            pulumi.set(__self__, "fail_if_header_matches_regexps", fail_if_header_matches_regexps)
        if fail_if_header_not_matches_regexps is not None:
            pulumi.set(__self__, "fail_if_header_not_matches_regexps", fail_if_header_not_matches_regexps)
        if fail_if_not_ssl is not None:
            pulumi.set(__self__, "fail_if_not_ssl", fail_if_not_ssl)
        if fail_if_ssl is not None:
            pulumi.set(__self__, "fail_if_ssl", fail_if_ssl)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ip_version is not None:
            pulumi.set(__self__, "ip_version", ip_version)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if no_follow_redirects is not None:
            pulumi.set(__self__, "no_follow_redirects", no_follow_redirects)
        if proxy_connect_headers is not None:
            pulumi.set(__self__, "proxy_connect_headers", proxy_connect_headers)
        if proxy_url is not None:
            pulumi.set(__self__, "proxy_url", proxy_url)
        if tls_config is not None:
            pulumi.set(__self__, "tls_config", tls_config)
        if valid_http_versions is not None:
            pulumi.set(__self__, "valid_http_versions", valid_http_versions)
        if valid_status_codes is not None:
            pulumi.set(__self__, "valid_status_codes", valid_status_codes)

    @property
    @pulumi.getter(name="basicAuth")
    def basic_auth(self) -> Optional[pulumi.Input['SyntheticMonitoringCheckSettingsHttpBasicAuthArgs']]:
        """
        Basic auth settings.
        """
        return pulumi.get(self, "basic_auth")

    @basic_auth.setter
    def basic_auth(self, value: Optional[pulumi.Input['SyntheticMonitoringCheckSettingsHttpBasicAuthArgs']]):
        pulumi.set(self, "basic_auth", value)

    @property
    @pulumi.getter(name="bearerToken")
    def bearer_token(self) -> Optional[pulumi.Input[str]]:
        """
        Token for use with bearer authorization header.
        """
        return pulumi.get(self, "bearer_token")

    @bearer_token.setter
    def bearer_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bearer_token", value)

    @property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input[str]]:
        """
        The body of the HTTP request used in probe.
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "body", value)

    @property
    @pulumi.getter(name="cacheBustingQueryParamName")
    def cache_busting_query_param_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the query parameter used to prevent the server from using a cached response. Each probe will assign a random value to this parameter each time a request is made.
        """
        return pulumi.get(self, "cache_busting_query_param_name")

    @cache_busting_query_param_name.setter
    def cache_busting_query_param_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cache_busting_query_param_name", value)

    @property
    @pulumi.getter(name="failIfBodyMatchesRegexps")
    def fail_if_body_matches_regexps(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of regexes. If any match the response body, the check will fail.
        """
        return pulumi.get(self, "fail_if_body_matches_regexps")

    @fail_if_body_matches_regexps.setter
    def fail_if_body_matches_regexps(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "fail_if_body_matches_regexps", value)

    @property
    @pulumi.getter(name="failIfBodyNotMatchesRegexps")
    def fail_if_body_not_matches_regexps(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of regexes. If any do not match the response body, the check will fail.
        """
        return pulumi.get(self, "fail_if_body_not_matches_regexps")

    @fail_if_body_not_matches_regexps.setter
    def fail_if_body_not_matches_regexps(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "fail_if_body_not_matches_regexps", value)

    @property
    @pulumi.getter(name="failIfHeaderMatchesRegexps")
    def fail_if_header_matches_regexps(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SyntheticMonitoringCheckSettingsHttpFailIfHeaderMatchesRegexpArgs']]]]:
        """
        Check fails if headers match.
        """
        return pulumi.get(self, "fail_if_header_matches_regexps")

    @fail_if_header_matches_regexps.setter
    def fail_if_header_matches_regexps(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SyntheticMonitoringCheckSettingsHttpFailIfHeaderMatchesRegexpArgs']]]]):
        pulumi.set(self, "fail_if_header_matches_regexps", value)

    @property
    @pulumi.getter(name="failIfHeaderNotMatchesRegexps")
    def fail_if_header_not_matches_regexps(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SyntheticMonitoringCheckSettingsHttpFailIfHeaderNotMatchesRegexpArgs']]]]:
        """
        Check fails if headers do not match.
        """
        return pulumi.get(self, "fail_if_header_not_matches_regexps")

    @fail_if_header_not_matches_regexps.setter
    def fail_if_header_not_matches_regexps(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SyntheticMonitoringCheckSettingsHttpFailIfHeaderNotMatchesRegexpArgs']]]]):
        pulumi.set(self, "fail_if_header_not_matches_regexps", value)

    @property
    @pulumi.getter(name="failIfNotSsl")
    def fail_if_not_ssl(self) -> Optional[pulumi.Input[bool]]:
        """
        Fail if SSL is not present.
        """
        return pulumi.get(self, "fail_if_not_ssl")

    @fail_if_not_ssl.setter
    def fail_if_not_ssl(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "fail_if_not_ssl", value)

    @property
    @pulumi.getter(name="failIfSsl")
    def fail_if_ssl(self) -> Optional[pulumi.Input[bool]]:
        """
        Fail if SSL is present.
        """
        return pulumi.get(self, "fail_if_ssl")

    @fail_if_ssl.setter
    def fail_if_ssl(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "fail_if_ssl", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The HTTP headers set for the probe.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="ipVersion")
    def ip_version(self) -> Optional[pulumi.Input[str]]:
        """
        Options are `V4`, `V6`, `Any`. Specifies whether the corresponding check will be performed using IPv4 or IPv6. The `Any` value indicates that IPv6 should be used, falling back to IPv4 if that's not available.
        """
        return pulumi.get(self, "ip_version")

    @ip_version.setter
    def ip_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_version", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input[str]]:
        """
        Request method. One of `GET`, `CONNECT`, `DELETE`, `HEAD`, `OPTIONS`, `POST`, `PUT`, `TRACE`
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter(name="noFollowRedirects")
    def no_follow_redirects(self) -> Optional[pulumi.Input[bool]]:
        """
        Do not follow redirects.
        """
        return pulumi.get(self, "no_follow_redirects")

    @no_follow_redirects.setter
    def no_follow_redirects(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "no_follow_redirects", value)

    @property
    @pulumi.getter(name="proxyConnectHeaders")
    def proxy_connect_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The HTTP headers sent to the proxy URL
        """
        return pulumi.get(self, "proxy_connect_headers")

    @proxy_connect_headers.setter
    def proxy_connect_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "proxy_connect_headers", value)

    @property
    @pulumi.getter(name="proxyUrl")
    def proxy_url(self) -> Optional[pulumi.Input[str]]:
        """
        Proxy URL.
        """
        return pulumi.get(self, "proxy_url")

    @proxy_url.setter
    def proxy_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proxy_url", value)

    @property
    @pulumi.getter(name="tlsConfig")
    def tls_config(self) -> Optional[pulumi.Input['SyntheticMonitoringCheckSettingsHttpTlsConfigArgs']]:
        """
        TLS config.
        """
        return pulumi.get(self, "tls_config")

    @tls_config.setter
    def tls_config(self, value: Optional[pulumi.Input['SyntheticMonitoringCheckSettingsHttpTlsConfigArgs']]):
        pulumi.set(self, "tls_config", value)

    @property
    @pulumi.getter(name="validHttpVersions")
    def valid_http_versions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of valid HTTP versions. Options include `HTTP/1.0`, `HTTP/1.1`, `HTTP/2.0`
        """
        return pulumi.get(self, "valid_http_versions")

    @valid_http_versions.setter
    def valid_http_versions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "valid_http_versions", value)

    @property
    @pulumi.getter(name="validStatusCodes")
    def valid_status_codes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        Accepted status codes. If unset, defaults to 2xx.
        """
        return pulumi.get(self, "valid_status_codes")

    @valid_status_codes.setter
    def valid_status_codes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "valid_status_codes", value)


@pulumi.input_type
class SyntheticMonitoringCheckSettingsHttpBasicAuthArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[str],
                 username: pulumi.Input[str]):
        """
        :param pulumi.Input[str] password: Basic auth password.
        :param pulumi.Input[str] username: Basic auth username.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        """
        Basic auth password.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        """
        Basic auth username.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class SyntheticMonitoringCheckSettingsHttpFailIfHeaderMatchesRegexpArgs:
    def __init__(__self__, *,
                 header: pulumi.Input[str],
                 regexp: pulumi.Input[str],
                 allow_missing: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] header: Header name.
        :param pulumi.Input[str] regexp: Regex that header value should match.
        :param pulumi.Input[bool] allow_missing: Allow header to be missing from responses.
        """
        pulumi.set(__self__, "header", header)
        pulumi.set(__self__, "regexp", regexp)
        if allow_missing is not None:
            pulumi.set(__self__, "allow_missing", allow_missing)

    @property
    @pulumi.getter
    def header(self) -> pulumi.Input[str]:
        """
        Header name.
        """
        return pulumi.get(self, "header")

    @header.setter
    def header(self, value: pulumi.Input[str]):
        pulumi.set(self, "header", value)

    @property
    @pulumi.getter
    def regexp(self) -> pulumi.Input[str]:
        """
        Regex that header value should match.
        """
        return pulumi.get(self, "regexp")

    @regexp.setter
    def regexp(self, value: pulumi.Input[str]):
        pulumi.set(self, "regexp", value)

    @property
    @pulumi.getter(name="allowMissing")
    def allow_missing(self) -> Optional[pulumi.Input[bool]]:
        """
        Allow header to be missing from responses.
        """
        return pulumi.get(self, "allow_missing")

    @allow_missing.setter
    def allow_missing(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_missing", value)


@pulumi.input_type
class SyntheticMonitoringCheckSettingsHttpFailIfHeaderNotMatchesRegexpArgs:
    def __init__(__self__, *,
                 header: pulumi.Input[str],
                 regexp: pulumi.Input[str],
                 allow_missing: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] header: Header name.
        :param pulumi.Input[str] regexp: Regex that header value should match.
        :param pulumi.Input[bool] allow_missing: Allow header to be missing from responses.
        """
        pulumi.set(__self__, "header", header)
        pulumi.set(__self__, "regexp", regexp)
        if allow_missing is not None:
            pulumi.set(__self__, "allow_missing", allow_missing)

    @property
    @pulumi.getter
    def header(self) -> pulumi.Input[str]:
        """
        Header name.
        """
        return pulumi.get(self, "header")

    @header.setter
    def header(self, value: pulumi.Input[str]):
        pulumi.set(self, "header", value)

    @property
    @pulumi.getter
    def regexp(self) -> pulumi.Input[str]:
        """
        Regex that header value should match.
        """
        return pulumi.get(self, "regexp")

    @regexp.setter
    def regexp(self, value: pulumi.Input[str]):
        pulumi.set(self, "regexp", value)

    @property
    @pulumi.getter(name="allowMissing")
    def allow_missing(self) -> Optional[pulumi.Input[bool]]:
        """
        Allow header to be missing from responses.
        """
        return pulumi.get(self, "allow_missing")

    @allow_missing.setter
    def allow_missing(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_missing", value)


@pulumi.input_type
class SyntheticMonitoringCheckSettingsHttpTlsConfigArgs:
    def __init__(__self__, *,
                 ca_cert: Optional[pulumi.Input[str]] = None,
                 client_cert: Optional[pulumi.Input[str]] = None,
                 client_key: Optional[pulumi.Input[str]] = None,
                 insecure_skip_verify: Optional[pulumi.Input[bool]] = None,
                 server_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ca_cert: CA certificate in PEM format.
        :param pulumi.Input[str] client_cert: Client certificate in PEM format.
        :param pulumi.Input[str] client_key: Client key in PEM format.
        :param pulumi.Input[bool] insecure_skip_verify: Disable target certificate validation.
        :param pulumi.Input[str] server_name: Used to verify the hostname for the targets.
        """
        if ca_cert is not None:
            pulumi.set(__self__, "ca_cert", ca_cert)
        if client_cert is not None:
            pulumi.set(__self__, "client_cert", client_cert)
        if client_key is not None:
            pulumi.set(__self__, "client_key", client_key)
        if insecure_skip_verify is not None:
            pulumi.set(__self__, "insecure_skip_verify", insecure_skip_verify)
        if server_name is not None:
            pulumi.set(__self__, "server_name", server_name)

    @property
    @pulumi.getter(name="caCert")
    def ca_cert(self) -> Optional[pulumi.Input[str]]:
        """
        CA certificate in PEM format.
        """
        return pulumi.get(self, "ca_cert")

    @ca_cert.setter
    def ca_cert(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ca_cert", value)

    @property
    @pulumi.getter(name="clientCert")
    def client_cert(self) -> Optional[pulumi.Input[str]]:
        """
        Client certificate in PEM format.
        """
        return pulumi.get(self, "client_cert")

    @client_cert.setter
    def client_cert(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_cert", value)

    @property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> Optional[pulumi.Input[str]]:
        """
        Client key in PEM format.
        """
        return pulumi.get(self, "client_key")

    @client_key.setter
    def client_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_key", value)

    @property
    @pulumi.getter(name="insecureSkipVerify")
    def insecure_skip_verify(self) -> Optional[pulumi.Input[bool]]:
        """
        Disable target certificate validation.
        """
        return pulumi.get(self, "insecure_skip_verify")

    @insecure_skip_verify.setter
    def insecure_skip_verify(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "insecure_skip_verify", value)

    @property
    @pulumi.getter(name="serverName")
    def server_name(self) -> Optional[pulumi.Input[str]]:
        """
        Used to verify the hostname for the targets.
        """
        return pulumi.get(self, "server_name")

    @server_name.setter
    def server_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "server_name", value)


@pulumi.input_type
class SyntheticMonitoringCheckSettingsMultihttpArgs:
    def __init__(__self__, *,
                 entries: Optional[pulumi.Input[Sequence[pulumi.Input['SyntheticMonitoringCheckSettingsMultihttpEntryArgs']]]] = None):
        if entries is not None:
            pulumi.set(__self__, "entries", entries)

    @property
    @pulumi.getter
    def entries(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SyntheticMonitoringCheckSettingsMultihttpEntryArgs']]]]:
        return pulumi.get(self, "entries")

    @entries.setter
    def entries(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SyntheticMonitoringCheckSettingsMultihttpEntryArgs']]]]):
        pulumi.set(self, "entries", value)


@pulumi.input_type
class SyntheticMonitoringCheckSettingsMultihttpEntryArgs:
    def __init__(__self__, *,
                 assertions: Optional[pulumi.Input[Sequence[pulumi.Input['SyntheticMonitoringCheckSettingsMultihttpEntryAssertionArgs']]]] = None,
                 request: Optional[pulumi.Input['SyntheticMonitoringCheckSettingsMultihttpEntryRequestArgs']] = None,
                 variables: Optional[pulumi.Input[Sequence[pulumi.Input['SyntheticMonitoringCheckSettingsMultihttpEntryVariableArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['SyntheticMonitoringCheckSettingsMultihttpEntryAssertionArgs']]] assertions: Assertions to make on the request response
        :param pulumi.Input['SyntheticMonitoringCheckSettingsMultihttpEntryRequestArgs'] request: An individual MultiHTTP request
        :param pulumi.Input[Sequence[pulumi.Input['SyntheticMonitoringCheckSettingsMultihttpEntryVariableArgs']]] variables: Variables to extract from the request response
        """
        if assertions is not None:
            pulumi.set(__self__, "assertions", assertions)
        if request is not None:
            pulumi.set(__self__, "request", request)
        if variables is not None:
            pulumi.set(__self__, "variables", variables)

    @property
    @pulumi.getter
    def assertions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SyntheticMonitoringCheckSettingsMultihttpEntryAssertionArgs']]]]:
        """
        Assertions to make on the request response
        """
        return pulumi.get(self, "assertions")

    @assertions.setter
    def assertions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SyntheticMonitoringCheckSettingsMultihttpEntryAssertionArgs']]]]):
        pulumi.set(self, "assertions", value)

    @property
    @pulumi.getter
    def request(self) -> Optional[pulumi.Input['SyntheticMonitoringCheckSettingsMultihttpEntryRequestArgs']]:
        """
        An individual MultiHTTP request
        """
        return pulumi.get(self, "request")

    @request.setter
    def request(self, value: Optional[pulumi.Input['SyntheticMonitoringCheckSettingsMultihttpEntryRequestArgs']]):
        pulumi.set(self, "request", value)

    @property
    @pulumi.getter
    def variables(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SyntheticMonitoringCheckSettingsMultihttpEntryVariableArgs']]]]:
        """
        Variables to extract from the request response
        """
        return pulumi.get(self, "variables")

    @variables.setter
    def variables(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SyntheticMonitoringCheckSettingsMultihttpEntryVariableArgs']]]]):
        pulumi.set(self, "variables", value)


@pulumi.input_type
class SyntheticMonitoringCheckSettingsMultihttpEntryAssertionArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 condition: Optional[pulumi.Input[str]] = None,
                 expression: Optional[pulumi.Input[str]] = None,
                 subject: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: The type of assertion to make: TEXT, JSON_PATH_VALUE, JSON_PATH_ASSERTION, REGEX_ASSERTION
        :param pulumi.Input[str] condition: The condition of the assertion: NOT_CONTAINS, EQUALS, STARTS_WITH, ENDS_WITH, TYPE_OF, CONTAINS
        :param pulumi.Input[str] expression: The expression of the assertion. Should start with $.
        :param pulumi.Input[str] subject: The subject of the assertion: RESPONSE_HEADERS, HTTP_STATUS_CODE, RESPONSE_BODY
        :param pulumi.Input[str] value: The value of the assertion
        """
        pulumi.set(__self__, "type", type)
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if subject is not None:
            pulumi.set(__self__, "subject", subject)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of assertion to make: TEXT, JSON_PATH_VALUE, JSON_PATH_ASSERTION, REGEX_ASSERTION
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def condition(self) -> Optional[pulumi.Input[str]]:
        """
        The condition of the assertion: NOT_CONTAINS, EQUALS, STARTS_WITH, ENDS_WITH, TYPE_OF, CONTAINS
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def expression(self) -> Optional[pulumi.Input[str]]:
        """
        The expression of the assertion. Should start with $.
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def subject(self) -> Optional[pulumi.Input[str]]:
        """
        The subject of the assertion: RESPONSE_HEADERS, HTTP_STATUS_CODE, RESPONSE_BODY
        """
        return pulumi.get(self, "subject")

    @subject.setter
    def subject(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subject", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The value of the assertion
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class SyntheticMonitoringCheckSettingsMultihttpEntryRequestArgs:
    def __init__(__self__, *,
                 method: pulumi.Input[str],
                 url: pulumi.Input[str],
                 bodies: Optional[pulumi.Input[Sequence[pulumi.Input['SyntheticMonitoringCheckSettingsMultihttpEntryRequestBodyArgs']]]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['SyntheticMonitoringCheckSettingsMultihttpEntryRequestHeaderArgs']]]] = None,
                 query_fields: Optional[pulumi.Input[Sequence[pulumi.Input['SyntheticMonitoringCheckSettingsMultihttpEntryRequestQueryFieldArgs']]]] = None):
        """
        :param pulumi.Input[str] method: The HTTP method to use
        :param pulumi.Input[str] url: The URL for the request
        :param pulumi.Input[Sequence[pulumi.Input['SyntheticMonitoringCheckSettingsMultihttpEntryRequestBodyArgs']]] bodies: The body of the HTTP request used in probe.
        :param pulumi.Input[Sequence[pulumi.Input['SyntheticMonitoringCheckSettingsMultihttpEntryRequestHeaderArgs']]] headers: The headers to send with the request
        :param pulumi.Input[Sequence[pulumi.Input['SyntheticMonitoringCheckSettingsMultihttpEntryRequestQueryFieldArgs']]] query_fields: Query fields to send with the request
        """
        pulumi.set(__self__, "method", method)
        pulumi.set(__self__, "url", url)
        if bodies is not None:
            pulumi.set(__self__, "bodies", bodies)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if query_fields is not None:
            pulumi.set(__self__, "query_fields", query_fields)

    @property
    @pulumi.getter
    def method(self) -> pulumi.Input[str]:
        """
        The HTTP method to use
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: pulumi.Input[str]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        The URL for the request
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter
    def bodies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SyntheticMonitoringCheckSettingsMultihttpEntryRequestBodyArgs']]]]:
        """
        The body of the HTTP request used in probe.
        """
        return pulumi.get(self, "bodies")

    @bodies.setter
    def bodies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SyntheticMonitoringCheckSettingsMultihttpEntryRequestBodyArgs']]]]):
        pulumi.set(self, "bodies", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SyntheticMonitoringCheckSettingsMultihttpEntryRequestHeaderArgs']]]]:
        """
        The headers to send with the request
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SyntheticMonitoringCheckSettingsMultihttpEntryRequestHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="queryFields")
    def query_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SyntheticMonitoringCheckSettingsMultihttpEntryRequestQueryFieldArgs']]]]:
        """
        Query fields to send with the request
        """
        return pulumi.get(self, "query_fields")

    @query_fields.setter
    def query_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SyntheticMonitoringCheckSettingsMultihttpEntryRequestQueryFieldArgs']]]]):
        pulumi.set(self, "query_fields", value)


@pulumi.input_type
class SyntheticMonitoringCheckSettingsMultihttpEntryRequestBodyArgs:
    def __init__(__self__, *,
                 content_encoding: Optional[pulumi.Input[str]] = None,
                 content_type: Optional[pulumi.Input[str]] = None,
                 payload: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] content_encoding: The content encoding of the body
        :param pulumi.Input[str] content_type: The content type of the body
        :param pulumi.Input[str] payload: The body payload
        """
        if content_encoding is not None:
            pulumi.set(__self__, "content_encoding", content_encoding)
        if content_type is not None:
            pulumi.set(__self__, "content_type", content_type)
        if payload is not None:
            pulumi.set(__self__, "payload", payload)

    @property
    @pulumi.getter(name="contentEncoding")
    def content_encoding(self) -> Optional[pulumi.Input[str]]:
        """
        The content encoding of the body
        """
        return pulumi.get(self, "content_encoding")

    @content_encoding.setter
    def content_encoding(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "content_encoding", value)

    @property
    @pulumi.getter(name="contentType")
    def content_type(self) -> Optional[pulumi.Input[str]]:
        """
        The content type of the body
        """
        return pulumi.get(self, "content_type")

    @content_type.setter
    def content_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "content_type", value)

    @property
    @pulumi.getter
    def payload(self) -> Optional[pulumi.Input[str]]:
        """
        The body payload
        """
        return pulumi.get(self, "payload")

    @payload.setter
    def payload(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "payload", value)


@pulumi.input_type
class SyntheticMonitoringCheckSettingsMultihttpEntryRequestHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the header to send
        :param pulumi.Input[str] value: Value of the header to send
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the header to send
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Value of the header to send
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class SyntheticMonitoringCheckSettingsMultihttpEntryRequestQueryFieldArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the query field to send
        :param pulumi.Input[str] value: Value of the query field to send
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the query field to send
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Value of the query field to send
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class SyntheticMonitoringCheckSettingsMultihttpEntryVariableArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 attribute: Optional[pulumi.Input[str]] = None,
                 expression: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: The method of finding the variable value to extract. JSON_PATH, REGEX, CSS_SELECTOR
        :param pulumi.Input[str] attribute: The attribute to use when finding the variable value. Only used when type is CSS_SELECTOR
        :param pulumi.Input[str] expression: The expression to when finding the variable. Should start with $. Only use when type is JSON_PATH or REGEX
        :param pulumi.Input[str] name: The name of the variable to extract
        """
        pulumi.set(__self__, "type", type)
        if attribute is not None:
            pulumi.set(__self__, "attribute", attribute)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The method of finding the variable value to extract. JSON_PATH, REGEX, CSS_SELECTOR
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def attribute(self) -> Optional[pulumi.Input[str]]:
        """
        The attribute to use when finding the variable value. Only used when type is CSS_SELECTOR
        """
        return pulumi.get(self, "attribute")

    @attribute.setter
    def attribute(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "attribute", value)

    @property
    @pulumi.getter
    def expression(self) -> Optional[pulumi.Input[str]]:
        """
        The expression to when finding the variable. Should start with $. Only use when type is JSON_PATH or REGEX
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the variable to extract
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class SyntheticMonitoringCheckSettingsPingArgs:
    def __init__(__self__, *,
                 dont_fragment: Optional[pulumi.Input[bool]] = None,
                 ip_version: Optional[pulumi.Input[str]] = None,
                 payload_size: Optional[pulumi.Input[int]] = None,
                 source_ip_address: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] dont_fragment: Set the DF-bit in the IP-header. Only works with ipV4.
        :param pulumi.Input[str] ip_version: Options are `V4`, `V6`, `Any`. Specifies whether the corresponding check will be performed using IPv4 or IPv6. The `Any` value indicates that IPv6 should be used, falling back to IPv4 if that's not available.
        :param pulumi.Input[int] payload_size: Payload size.
        :param pulumi.Input[str] source_ip_address: Source IP address.
        """
        if dont_fragment is not None:
            pulumi.set(__self__, "dont_fragment", dont_fragment)
        if ip_version is not None:
            pulumi.set(__self__, "ip_version", ip_version)
        if payload_size is not None:
            pulumi.set(__self__, "payload_size", payload_size)
        if source_ip_address is not None:
            pulumi.set(__self__, "source_ip_address", source_ip_address)

    @property
    @pulumi.getter(name="dontFragment")
    def dont_fragment(self) -> Optional[pulumi.Input[bool]]:
        """
        Set the DF-bit in the IP-header. Only works with ipV4.
        """
        return pulumi.get(self, "dont_fragment")

    @dont_fragment.setter
    def dont_fragment(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "dont_fragment", value)

    @property
    @pulumi.getter(name="ipVersion")
    def ip_version(self) -> Optional[pulumi.Input[str]]:
        """
        Options are `V4`, `V6`, `Any`. Specifies whether the corresponding check will be performed using IPv4 or IPv6. The `Any` value indicates that IPv6 should be used, falling back to IPv4 if that's not available.
        """
        return pulumi.get(self, "ip_version")

    @ip_version.setter
    def ip_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_version", value)

    @property
    @pulumi.getter(name="payloadSize")
    def payload_size(self) -> Optional[pulumi.Input[int]]:
        """
        Payload size.
        """
        return pulumi.get(self, "payload_size")

    @payload_size.setter
    def payload_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "payload_size", value)

    @property
    @pulumi.getter(name="sourceIpAddress")
    def source_ip_address(self) -> Optional[pulumi.Input[str]]:
        """
        Source IP address.
        """
        return pulumi.get(self, "source_ip_address")

    @source_ip_address.setter
    def source_ip_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_ip_address", value)


@pulumi.input_type
class SyntheticMonitoringCheckSettingsTcpArgs:
    def __init__(__self__, *,
                 ip_version: Optional[pulumi.Input[str]] = None,
                 query_responses: Optional[pulumi.Input[Sequence[pulumi.Input['SyntheticMonitoringCheckSettingsTcpQueryResponseArgs']]]] = None,
                 source_ip_address: Optional[pulumi.Input[str]] = None,
                 tls: Optional[pulumi.Input[bool]] = None,
                 tls_config: Optional[pulumi.Input['SyntheticMonitoringCheckSettingsTcpTlsConfigArgs']] = None):
        """
        :param pulumi.Input[str] ip_version: Options are `V4`, `V6`, `Any`. Specifies whether the corresponding check will be performed using IPv4 or IPv6. The `Any` value indicates that IPv6 should be used, falling back to IPv4 if that's not available.
        :param pulumi.Input[Sequence[pulumi.Input['SyntheticMonitoringCheckSettingsTcpQueryResponseArgs']]] query_responses: The query sent in the TCP probe and the expected associated response.
        :param pulumi.Input[str] source_ip_address: Source IP address.
        :param pulumi.Input[bool] tls: Whether or not TLS is used when the connection is initiated.
        :param pulumi.Input['SyntheticMonitoringCheckSettingsTcpTlsConfigArgs'] tls_config: TLS config.
        """
        if ip_version is not None:
            pulumi.set(__self__, "ip_version", ip_version)
        if query_responses is not None:
            pulumi.set(__self__, "query_responses", query_responses)
        if source_ip_address is not None:
            pulumi.set(__self__, "source_ip_address", source_ip_address)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)
        if tls_config is not None:
            pulumi.set(__self__, "tls_config", tls_config)

    @property
    @pulumi.getter(name="ipVersion")
    def ip_version(self) -> Optional[pulumi.Input[str]]:
        """
        Options are `V4`, `V6`, `Any`. Specifies whether the corresponding check will be performed using IPv4 or IPv6. The `Any` value indicates that IPv6 should be used, falling back to IPv4 if that's not available.
        """
        return pulumi.get(self, "ip_version")

    @ip_version.setter
    def ip_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_version", value)

    @property
    @pulumi.getter(name="queryResponses")
    def query_responses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SyntheticMonitoringCheckSettingsTcpQueryResponseArgs']]]]:
        """
        The query sent in the TCP probe and the expected associated response.
        """
        return pulumi.get(self, "query_responses")

    @query_responses.setter
    def query_responses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SyntheticMonitoringCheckSettingsTcpQueryResponseArgs']]]]):
        pulumi.set(self, "query_responses", value)

    @property
    @pulumi.getter(name="sourceIpAddress")
    def source_ip_address(self) -> Optional[pulumi.Input[str]]:
        """
        Source IP address.
        """
        return pulumi.get(self, "source_ip_address")

    @source_ip_address.setter
    def source_ip_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_ip_address", value)

    @property
    @pulumi.getter
    def tls(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether or not TLS is used when the connection is initiated.
        """
        return pulumi.get(self, "tls")

    @tls.setter
    def tls(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "tls", value)

    @property
    @pulumi.getter(name="tlsConfig")
    def tls_config(self) -> Optional[pulumi.Input['SyntheticMonitoringCheckSettingsTcpTlsConfigArgs']]:
        """
        TLS config.
        """
        return pulumi.get(self, "tls_config")

    @tls_config.setter
    def tls_config(self, value: Optional[pulumi.Input['SyntheticMonitoringCheckSettingsTcpTlsConfigArgs']]):
        pulumi.set(self, "tls_config", value)


@pulumi.input_type
class SyntheticMonitoringCheckSettingsTcpQueryResponseArgs:
    def __init__(__self__, *,
                 expect: pulumi.Input[str],
                 send: pulumi.Input[str],
                 start_tls: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] expect: Response to expect.
        :param pulumi.Input[str] send: Data to send.
        :param pulumi.Input[bool] start_tls: Upgrade TCP connection to TLS.
        """
        pulumi.set(__self__, "expect", expect)
        pulumi.set(__self__, "send", send)
        if start_tls is not None:
            pulumi.set(__self__, "start_tls", start_tls)

    @property
    @pulumi.getter
    def expect(self) -> pulumi.Input[str]:
        """
        Response to expect.
        """
        return pulumi.get(self, "expect")

    @expect.setter
    def expect(self, value: pulumi.Input[str]):
        pulumi.set(self, "expect", value)

    @property
    @pulumi.getter
    def send(self) -> pulumi.Input[str]:
        """
        Data to send.
        """
        return pulumi.get(self, "send")

    @send.setter
    def send(self, value: pulumi.Input[str]):
        pulumi.set(self, "send", value)

    @property
    @pulumi.getter(name="startTls")
    def start_tls(self) -> Optional[pulumi.Input[bool]]:
        """
        Upgrade TCP connection to TLS.
        """
        return pulumi.get(self, "start_tls")

    @start_tls.setter
    def start_tls(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "start_tls", value)


@pulumi.input_type
class SyntheticMonitoringCheckSettingsTcpTlsConfigArgs:
    def __init__(__self__, *,
                 ca_cert: Optional[pulumi.Input[str]] = None,
                 client_cert: Optional[pulumi.Input[str]] = None,
                 client_key: Optional[pulumi.Input[str]] = None,
                 insecure_skip_verify: Optional[pulumi.Input[bool]] = None,
                 server_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ca_cert: CA certificate in PEM format.
        :param pulumi.Input[str] client_cert: Client certificate in PEM format.
        :param pulumi.Input[str] client_key: Client key in PEM format.
        :param pulumi.Input[bool] insecure_skip_verify: Disable target certificate validation.
        :param pulumi.Input[str] server_name: Used to verify the hostname for the targets.
        """
        if ca_cert is not None:
            pulumi.set(__self__, "ca_cert", ca_cert)
        if client_cert is not None:
            pulumi.set(__self__, "client_cert", client_cert)
        if client_key is not None:
            pulumi.set(__self__, "client_key", client_key)
        if insecure_skip_verify is not None:
            pulumi.set(__self__, "insecure_skip_verify", insecure_skip_verify)
        if server_name is not None:
            pulumi.set(__self__, "server_name", server_name)

    @property
    @pulumi.getter(name="caCert")
    def ca_cert(self) -> Optional[pulumi.Input[str]]:
        """
        CA certificate in PEM format.
        """
        return pulumi.get(self, "ca_cert")

    @ca_cert.setter
    def ca_cert(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ca_cert", value)

    @property
    @pulumi.getter(name="clientCert")
    def client_cert(self) -> Optional[pulumi.Input[str]]:
        """
        Client certificate in PEM format.
        """
        return pulumi.get(self, "client_cert")

    @client_cert.setter
    def client_cert(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_cert", value)

    @property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> Optional[pulumi.Input[str]]:
        """
        Client key in PEM format.
        """
        return pulumi.get(self, "client_key")

    @client_key.setter
    def client_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_key", value)

    @property
    @pulumi.getter(name="insecureSkipVerify")
    def insecure_skip_verify(self) -> Optional[pulumi.Input[bool]]:
        """
        Disable target certificate validation.
        """
        return pulumi.get(self, "insecure_skip_verify")

    @insecure_skip_verify.setter
    def insecure_skip_verify(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "insecure_skip_verify", value)

    @property
    @pulumi.getter(name="serverName")
    def server_name(self) -> Optional[pulumi.Input[str]]:
        """
        Used to verify the hostname for the targets.
        """
        return pulumi.get(self, "server_name")

    @server_name.setter
    def server_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "server_name", value)


@pulumi.input_type
class SyntheticMonitoringCheckSettingsTracerouteArgs:
    def __init__(__self__, *,
                 max_hops: Optional[pulumi.Input[int]] = None,
                 max_unknown_hops: Optional[pulumi.Input[int]] = None,
                 ptr_lookup: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[int] max_hops: Maximum TTL for the trace
        :param pulumi.Input[int] max_unknown_hops: Maximum number of hosts to travers that give no response
        :param pulumi.Input[bool] ptr_lookup: Reverse lookup hostnames from IP addresses
        """
        if max_hops is not None:
            pulumi.set(__self__, "max_hops", max_hops)
        if max_unknown_hops is not None:
            pulumi.set(__self__, "max_unknown_hops", max_unknown_hops)
        if ptr_lookup is not None:
            pulumi.set(__self__, "ptr_lookup", ptr_lookup)

    @property
    @pulumi.getter(name="maxHops")
    def max_hops(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum TTL for the trace
        """
        return pulumi.get(self, "max_hops")

    @max_hops.setter
    def max_hops(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_hops", value)

    @property
    @pulumi.getter(name="maxUnknownHops")
    def max_unknown_hops(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of hosts to travers that give no response
        """
        return pulumi.get(self, "max_unknown_hops")

    @max_unknown_hops.setter
    def max_unknown_hops(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_unknown_hops", value)

    @property
    @pulumi.getter(name="ptrLookup")
    def ptr_lookup(self) -> Optional[pulumi.Input[bool]]:
        """
        Reverse lookup hostnames from IP addresses
        """
        return pulumi.get(self, "ptr_lookup")

    @ptr_lookup.setter
    def ptr_lookup(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ptr_lookup", value)


@pulumi.input_type
class TeamPreferencesArgs:
    def __init__(__self__, *,
                 home_dashboard_uid: Optional[pulumi.Input[str]] = None,
                 theme: Optional[pulumi.Input[str]] = None,
                 timezone: Optional[pulumi.Input[str]] = None,
                 week_start: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] home_dashboard_uid: The UID of the dashboard to display when a team member logs in.
        :param pulumi.Input[str] theme: The default theme for this team. Available themes are `light`, `dark`, `system`, or an empty string for the default theme.
        :param pulumi.Input[str] timezone: The default timezone for this team. Available values are `utc`, `browser`, or an empty string for the default.
        :param pulumi.Input[str] week_start: The default week start day for this team. Available values are `sunday`, `monday`, `saturday`, or an empty string for the default.
        """
        if home_dashboard_uid is not None:
            pulumi.set(__self__, "home_dashboard_uid", home_dashboard_uid)
        if theme is not None:
            pulumi.set(__self__, "theme", theme)
        if timezone is not None:
            pulumi.set(__self__, "timezone", timezone)
        if week_start is not None:
            pulumi.set(__self__, "week_start", week_start)

    @property
    @pulumi.getter(name="homeDashboardUid")
    def home_dashboard_uid(self) -> Optional[pulumi.Input[str]]:
        """
        The UID of the dashboard to display when a team member logs in.
        """
        return pulumi.get(self, "home_dashboard_uid")

    @home_dashboard_uid.setter
    def home_dashboard_uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "home_dashboard_uid", value)

    @property
    @pulumi.getter
    def theme(self) -> Optional[pulumi.Input[str]]:
        """
        The default theme for this team. Available themes are `light`, `dark`, `system`, or an empty string for the default theme.
        """
        return pulumi.get(self, "theme")

    @theme.setter
    def theme(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "theme", value)

    @property
    @pulumi.getter
    def timezone(self) -> Optional[pulumi.Input[str]]:
        """
        The default timezone for this team. Available values are `utc`, `browser`, or an empty string for the default.
        """
        return pulumi.get(self, "timezone")

    @timezone.setter
    def timezone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timezone", value)

    @property
    @pulumi.getter(name="weekStart")
    def week_start(self) -> Optional[pulumi.Input[str]]:
        """
        The default week start day for this team. Available values are `sunday`, `monday`, `saturday`, or an empty string for the default.
        """
        return pulumi.get(self, "week_start")

    @week_start.setter
    def week_start(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "week_start", value)


@pulumi.input_type
class TeamTeamSyncArgs:
    def __init__(__self__, *,
                 groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if groups is not None:
            pulumi.set(__self__, "groups", groups)

    @property
    @pulumi.getter
    def groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "groups", value)


