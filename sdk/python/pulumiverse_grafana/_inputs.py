# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities

__all__ = [
    'CloudAccessPolicyRealmArgs',
    'CloudAccessPolicyRealmArgsDict',
    'CloudAccessPolicyRealmLabelPolicyArgs',
    'CloudAccessPolicyRealmLabelPolicyArgsDict',
    'ContactPointAlertmanagerArgs',
    'ContactPointAlertmanagerArgsDict',
    'ContactPointDingdingArgs',
    'ContactPointDingdingArgsDict',
    'ContactPointDiscordArgs',
    'ContactPointDiscordArgsDict',
    'ContactPointEmailArgs',
    'ContactPointEmailArgsDict',
    'ContactPointGooglechatArgs',
    'ContactPointGooglechatArgsDict',
    'ContactPointKafkaArgs',
    'ContactPointKafkaArgsDict',
    'ContactPointLineArgs',
    'ContactPointLineArgsDict',
    'ContactPointOncallArgs',
    'ContactPointOncallArgsDict',
    'ContactPointOpsgenyArgs',
    'ContactPointOpsgenyArgsDict',
    'ContactPointOpsgenyResponderArgs',
    'ContactPointOpsgenyResponderArgsDict',
    'ContactPointPagerdutyArgs',
    'ContactPointPagerdutyArgsDict',
    'ContactPointPushoverArgs',
    'ContactPointPushoverArgsDict',
    'ContactPointSensugoArgs',
    'ContactPointSensugoArgsDict',
    'ContactPointSlackArgs',
    'ContactPointSlackArgsDict',
    'ContactPointSnArgs',
    'ContactPointSnArgsDict',
    'ContactPointTeamArgs',
    'ContactPointTeamArgsDict',
    'ContactPointTelegramArgs',
    'ContactPointTelegramArgsDict',
    'ContactPointThreemaArgs',
    'ContactPointThreemaArgsDict',
    'ContactPointVictoropArgs',
    'ContactPointVictoropArgsDict',
    'ContactPointWebexArgs',
    'ContactPointWebexArgsDict',
    'ContactPointWebhookArgs',
    'ContactPointWebhookArgsDict',
    'ContactPointWecomArgs',
    'ContactPointWecomArgsDict',
    'DashboardPermissionPermissionArgs',
    'DashboardPermissionPermissionArgsDict',
    'DataSourcePermissionPermissionArgs',
    'DataSourcePermissionPermissionArgsDict',
    'FolderPermissionPermissionArgs',
    'FolderPermissionPermissionArgsDict',
    'MachineLearningHolidayCustomPeriodArgs',
    'MachineLearningHolidayCustomPeriodArgsDict',
    'MachineLearningOutlierDetectorAlgorithmArgs',
    'MachineLearningOutlierDetectorAlgorithmArgsDict',
    'MachineLearningOutlierDetectorAlgorithmConfigArgs',
    'MachineLearningOutlierDetectorAlgorithmConfigArgsDict',
    'MuteTimingIntervalArgs',
    'MuteTimingIntervalArgsDict',
    'MuteTimingIntervalTimeArgs',
    'MuteTimingIntervalTimeArgsDict',
    'NotificationPolicyPolicyArgs',
    'NotificationPolicyPolicyArgsDict',
    'NotificationPolicyPolicyMatcherArgs',
    'NotificationPolicyPolicyMatcherArgsDict',
    'NotificationPolicyPolicyPolicyArgs',
    'NotificationPolicyPolicyPolicyArgsDict',
    'NotificationPolicyPolicyPolicyMatcherArgs',
    'NotificationPolicyPolicyPolicyMatcherArgsDict',
    'NotificationPolicyPolicyPolicyPolicyArgs',
    'NotificationPolicyPolicyPolicyPolicyArgsDict',
    'NotificationPolicyPolicyPolicyPolicyMatcherArgs',
    'NotificationPolicyPolicyPolicyPolicyMatcherArgsDict',
    'NotificationPolicyPolicyPolicyPolicyPolicyArgs',
    'NotificationPolicyPolicyPolicyPolicyPolicyArgsDict',
    'NotificationPolicyPolicyPolicyPolicyPolicyMatcherArgs',
    'NotificationPolicyPolicyPolicyPolicyPolicyMatcherArgsDict',
    'OncallIntegrationDefaultRouteArgs',
    'OncallIntegrationDefaultRouteArgsDict',
    'OncallIntegrationDefaultRouteMsteamsArgs',
    'OncallIntegrationDefaultRouteMsteamsArgsDict',
    'OncallIntegrationDefaultRouteSlackArgs',
    'OncallIntegrationDefaultRouteSlackArgsDict',
    'OncallIntegrationDefaultRouteTelegramArgs',
    'OncallIntegrationDefaultRouteTelegramArgsDict',
    'OncallIntegrationTemplatesArgs',
    'OncallIntegrationTemplatesArgsDict',
    'OncallIntegrationTemplatesEmailArgs',
    'OncallIntegrationTemplatesEmailArgsDict',
    'OncallIntegrationTemplatesMicrosoftTeamsArgs',
    'OncallIntegrationTemplatesMicrosoftTeamsArgsDict',
    'OncallIntegrationTemplatesMobileAppArgs',
    'OncallIntegrationTemplatesMobileAppArgsDict',
    'OncallIntegrationTemplatesPhoneCallArgs',
    'OncallIntegrationTemplatesPhoneCallArgsDict',
    'OncallIntegrationTemplatesSlackArgs',
    'OncallIntegrationTemplatesSlackArgsDict',
    'OncallIntegrationTemplatesSmsArgs',
    'OncallIntegrationTemplatesSmsArgsDict',
    'OncallIntegrationTemplatesTelegramArgs',
    'OncallIntegrationTemplatesTelegramArgsDict',
    'OncallIntegrationTemplatesWebArgs',
    'OncallIntegrationTemplatesWebArgsDict',
    'OncallRouteMsteamsArgs',
    'OncallRouteMsteamsArgsDict',
    'OncallRouteSlackArgs',
    'OncallRouteSlackArgsDict',
    'OncallRouteTelegramArgs',
    'OncallRouteTelegramArgsDict',
    'OncallScheduleSlackArgs',
    'OncallScheduleSlackArgsDict',
    'PlaylistItemArgs',
    'PlaylistItemArgsDict',
    'ReportDashboardArgs',
    'ReportDashboardArgsDict',
    'ReportDashboardTimeRangeArgs',
    'ReportDashboardTimeRangeArgsDict',
    'ReportScheduleArgs',
    'ReportScheduleArgsDict',
    'RolePermissionArgs',
    'RolePermissionArgsDict',
    'RuleGroupRuleArgs',
    'RuleGroupRuleArgsDict',
    'RuleGroupRuleDataArgs',
    'RuleGroupRuleDataArgsDict',
    'RuleGroupRuleDataRelativeTimeRangeArgs',
    'RuleGroupRuleDataRelativeTimeRangeArgsDict',
    'RuleGroupRuleNotificationSettingsArgs',
    'RuleGroupRuleNotificationSettingsArgsDict',
    'RuleGroupRuleRecordArgs',
    'RuleGroupRuleRecordArgsDict',
    'SLOAlertingArgs',
    'SLOAlertingArgsDict',
    'SLOAlertingAdvancedOptionsArgs',
    'SLOAlertingAdvancedOptionsArgsDict',
    'SLOAlertingAnnotationArgs',
    'SLOAlertingAnnotationArgsDict',
    'SLOAlertingFastburnArgs',
    'SLOAlertingFastburnArgsDict',
    'SLOAlertingFastburnAnnotationArgs',
    'SLOAlertingFastburnAnnotationArgsDict',
    'SLOAlertingFastburnLabelArgs',
    'SLOAlertingFastburnLabelArgsDict',
    'SLOAlertingLabelArgs',
    'SLOAlertingLabelArgsDict',
    'SLOAlertingSlowburnArgs',
    'SLOAlertingSlowburnArgsDict',
    'SLOAlertingSlowburnAnnotationArgs',
    'SLOAlertingSlowburnAnnotationArgsDict',
    'SLOAlertingSlowburnLabelArgs',
    'SLOAlertingSlowburnLabelArgsDict',
    'SLODestinationDatasourceArgs',
    'SLODestinationDatasourceArgsDict',
    'SLOLabelArgs',
    'SLOLabelArgsDict',
    'SLOObjectiveArgs',
    'SLOObjectiveArgsDict',
    'SLOQueryArgs',
    'SLOQueryArgsDict',
    'SLOQueryFreeformArgs',
    'SLOQueryFreeformArgsDict',
    'SLOQueryRatioArgs',
    'SLOQueryRatioArgsDict',
    'ServiceAccountPermissionPermissionArgs',
    'ServiceAccountPermissionPermissionArgsDict',
    'SsoSettingsLdapSettingsArgs',
    'SsoSettingsLdapSettingsArgsDict',
    'SsoSettingsLdapSettingsConfigArgs',
    'SsoSettingsLdapSettingsConfigArgsDict',
    'SsoSettingsLdapSettingsConfigServerArgs',
    'SsoSettingsLdapSettingsConfigServerArgsDict',
    'SsoSettingsLdapSettingsConfigServerGroupMappingArgs',
    'SsoSettingsLdapSettingsConfigServerGroupMappingArgsDict',
    'SsoSettingsOauth2SettingsArgs',
    'SsoSettingsOauth2SettingsArgsDict',
    'SsoSettingsSamlSettingsArgs',
    'SsoSettingsSamlSettingsArgsDict',
    'SyntheticMonitoringCheckSettingsArgs',
    'SyntheticMonitoringCheckSettingsArgsDict',
    'SyntheticMonitoringCheckSettingsBrowserArgs',
    'SyntheticMonitoringCheckSettingsBrowserArgsDict',
    'SyntheticMonitoringCheckSettingsDnsArgs',
    'SyntheticMonitoringCheckSettingsDnsArgsDict',
    'SyntheticMonitoringCheckSettingsDnsValidateAdditionalRrArgs',
    'SyntheticMonitoringCheckSettingsDnsValidateAdditionalRrArgsDict',
    'SyntheticMonitoringCheckSettingsDnsValidateAnswerRrsArgs',
    'SyntheticMonitoringCheckSettingsDnsValidateAnswerRrsArgsDict',
    'SyntheticMonitoringCheckSettingsDnsValidateAuthorityRrsArgs',
    'SyntheticMonitoringCheckSettingsDnsValidateAuthorityRrsArgsDict',
    'SyntheticMonitoringCheckSettingsGrpcArgs',
    'SyntheticMonitoringCheckSettingsGrpcArgsDict',
    'SyntheticMonitoringCheckSettingsGrpcTlsConfigArgs',
    'SyntheticMonitoringCheckSettingsGrpcTlsConfigArgsDict',
    'SyntheticMonitoringCheckSettingsHttpArgs',
    'SyntheticMonitoringCheckSettingsHttpArgsDict',
    'SyntheticMonitoringCheckSettingsHttpBasicAuthArgs',
    'SyntheticMonitoringCheckSettingsHttpBasicAuthArgsDict',
    'SyntheticMonitoringCheckSettingsHttpFailIfHeaderMatchesRegexpArgs',
    'SyntheticMonitoringCheckSettingsHttpFailIfHeaderMatchesRegexpArgsDict',
    'SyntheticMonitoringCheckSettingsHttpFailIfHeaderNotMatchesRegexpArgs',
    'SyntheticMonitoringCheckSettingsHttpFailIfHeaderNotMatchesRegexpArgsDict',
    'SyntheticMonitoringCheckSettingsHttpTlsConfigArgs',
    'SyntheticMonitoringCheckSettingsHttpTlsConfigArgsDict',
    'SyntheticMonitoringCheckSettingsMultihttpArgs',
    'SyntheticMonitoringCheckSettingsMultihttpArgsDict',
    'SyntheticMonitoringCheckSettingsMultihttpEntryArgs',
    'SyntheticMonitoringCheckSettingsMultihttpEntryArgsDict',
    'SyntheticMonitoringCheckSettingsMultihttpEntryAssertionArgs',
    'SyntheticMonitoringCheckSettingsMultihttpEntryAssertionArgsDict',
    'SyntheticMonitoringCheckSettingsMultihttpEntryRequestArgs',
    'SyntheticMonitoringCheckSettingsMultihttpEntryRequestArgsDict',
    'SyntheticMonitoringCheckSettingsMultihttpEntryRequestBodyArgs',
    'SyntheticMonitoringCheckSettingsMultihttpEntryRequestBodyArgsDict',
    'SyntheticMonitoringCheckSettingsMultihttpEntryRequestHeaderArgs',
    'SyntheticMonitoringCheckSettingsMultihttpEntryRequestHeaderArgsDict',
    'SyntheticMonitoringCheckSettingsMultihttpEntryRequestQueryFieldArgs',
    'SyntheticMonitoringCheckSettingsMultihttpEntryRequestQueryFieldArgsDict',
    'SyntheticMonitoringCheckSettingsMultihttpEntryVariableArgs',
    'SyntheticMonitoringCheckSettingsMultihttpEntryVariableArgsDict',
    'SyntheticMonitoringCheckSettingsPingArgs',
    'SyntheticMonitoringCheckSettingsPingArgsDict',
    'SyntheticMonitoringCheckSettingsScriptedArgs',
    'SyntheticMonitoringCheckSettingsScriptedArgsDict',
    'SyntheticMonitoringCheckSettingsTcpArgs',
    'SyntheticMonitoringCheckSettingsTcpArgsDict',
    'SyntheticMonitoringCheckSettingsTcpQueryResponseArgs',
    'SyntheticMonitoringCheckSettingsTcpQueryResponseArgsDict',
    'SyntheticMonitoringCheckSettingsTcpTlsConfigArgs',
    'SyntheticMonitoringCheckSettingsTcpTlsConfigArgsDict',
    'SyntheticMonitoringCheckSettingsTracerouteArgs',
    'SyntheticMonitoringCheckSettingsTracerouteArgsDict',
    'TeamPreferencesArgs',
    'TeamPreferencesArgsDict',
    'TeamTeamSyncArgs',
    'TeamTeamSyncArgsDict',
]

MYPY = False

if not MYPY:
    class CloudAccessPolicyRealmArgsDict(TypedDict):
        identifier: pulumi.Input[str]
        """
        The identifier of the org or stack. For orgs, this is the slug, for stacks, this is the stack ID.
        """
        type: pulumi.Input[str]
        """
        Whether a policy applies to a Cloud org or a specific stack. Should be one of `org` or `stack`.
        """
        label_policies: NotRequired[pulumi.Input[Sequence[pulumi.Input['CloudAccessPolicyRealmLabelPolicyArgsDict']]]]
elif False:
    CloudAccessPolicyRealmArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudAccessPolicyRealmArgs:
    def __init__(__self__, *,
                 identifier: pulumi.Input[str],
                 type: pulumi.Input[str],
                 label_policies: Optional[pulumi.Input[Sequence[pulumi.Input['CloudAccessPolicyRealmLabelPolicyArgs']]]] = None):
        """
        :param pulumi.Input[str] identifier: The identifier of the org or stack. For orgs, this is the slug, for stacks, this is the stack ID.
        :param pulumi.Input[str] type: Whether a policy applies to a Cloud org or a specific stack. Should be one of `org` or `stack`.
        """
        pulumi.set(__self__, "identifier", identifier)
        pulumi.set(__self__, "type", type)
        if label_policies is not None:
            pulumi.set(__self__, "label_policies", label_policies)

    @property
    @pulumi.getter
    def identifier(self) -> pulumi.Input[str]:
        """
        The identifier of the org or stack. For orgs, this is the slug, for stacks, this is the stack ID.
        """
        return pulumi.get(self, "identifier")

    @identifier.setter
    def identifier(self, value: pulumi.Input[str]):
        pulumi.set(self, "identifier", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Whether a policy applies to a Cloud org or a specific stack. Should be one of `org` or `stack`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="labelPolicies")
    def label_policies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CloudAccessPolicyRealmLabelPolicyArgs']]]]:
        return pulumi.get(self, "label_policies")

    @label_policies.setter
    def label_policies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CloudAccessPolicyRealmLabelPolicyArgs']]]]):
        pulumi.set(self, "label_policies", value)


if not MYPY:
    class CloudAccessPolicyRealmLabelPolicyArgsDict(TypedDict):
        selector: pulumi.Input[str]
        """
        The label selector to match in metrics or logs query. Should be in PromQL or LogQL format.
        """
elif False:
    CloudAccessPolicyRealmLabelPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudAccessPolicyRealmLabelPolicyArgs:
    def __init__(__self__, *,
                 selector: pulumi.Input[str]):
        """
        :param pulumi.Input[str] selector: The label selector to match in metrics or logs query. Should be in PromQL or LogQL format.
        """
        pulumi.set(__self__, "selector", selector)

    @property
    @pulumi.getter
    def selector(self) -> pulumi.Input[str]:
        """
        The label selector to match in metrics or logs query. Should be in PromQL or LogQL format.
        """
        return pulumi.get(self, "selector")

    @selector.setter
    def selector(self, value: pulumi.Input[str]):
        pulumi.set(self, "selector", value)


if not MYPY:
    class ContactPointAlertmanagerArgsDict(TypedDict):
        url: pulumi.Input[str]
        """
        The URL of the Alertmanager instance.
        """
        basic_auth_password: NotRequired[pulumi.Input[str]]
        """
        The password component of the basic auth credentials to use.
        """
        basic_auth_user: NotRequired[pulumi.Input[str]]
        """
        The username component of the basic auth credentials to use.
        """
        disable_resolve_message: NotRequired[pulumi.Input[bool]]
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        settings: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        uid: NotRequired[pulumi.Input[str]]
        """
        The UID of the contact point.
        """
elif False:
    ContactPointAlertmanagerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContactPointAlertmanagerArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 basic_auth_password: Optional[pulumi.Input[str]] = None,
                 basic_auth_user: Optional[pulumi.Input[str]] = None,
                 disable_resolve_message: Optional[pulumi.Input[bool]] = None,
                 settings: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 uid: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] url: The URL of the Alertmanager instance.
        :param pulumi.Input[str] basic_auth_password: The password component of the basic auth credentials to use.
        :param pulumi.Input[str] basic_auth_user: The username component of the basic auth credentials to use.
        :param pulumi.Input[bool] disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param pulumi.Input[str] uid: The UID of the contact point.
        """
        pulumi.set(__self__, "url", url)
        if basic_auth_password is not None:
            pulumi.set(__self__, "basic_auth_password", basic_auth_password)
        if basic_auth_user is not None:
            pulumi.set(__self__, "basic_auth_user", basic_auth_user)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        The URL of the Alertmanager instance.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="basicAuthPassword")
    def basic_auth_password(self) -> Optional[pulumi.Input[str]]:
        """
        The password component of the basic auth credentials to use.
        """
        return pulumi.get(self, "basic_auth_password")

    @basic_auth_password.setter
    def basic_auth_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "basic_auth_password", value)

    @property
    @pulumi.getter(name="basicAuthUser")
    def basic_auth_user(self) -> Optional[pulumi.Input[str]]:
        """
        The username component of the basic auth credentials to use.
        """
        return pulumi.get(self, "basic_auth_user")

    @basic_auth_user.setter
    def basic_auth_user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "basic_auth_user", value)

    @property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @disable_resolve_message.setter
    def disable_resolve_message(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_resolve_message", value)

    @property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "settings", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)


if not MYPY:
    class ContactPointDingdingArgsDict(TypedDict):
        url: pulumi.Input[str]
        """
        The DingDing webhook URL.
        """
        disable_resolve_message: NotRequired[pulumi.Input[bool]]
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        message: NotRequired[pulumi.Input[str]]
        """
        The templated content of the message.
        """
        message_type: NotRequired[pulumi.Input[str]]
        """
        The format of message to send - either 'link' or 'actionCard'
        """
        settings: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        title: NotRequired[pulumi.Input[str]]
        """
        The templated title of the message.
        """
        uid: NotRequired[pulumi.Input[str]]
        """
        The UID of the contact point.
        """
elif False:
    ContactPointDingdingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContactPointDingdingArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 disable_resolve_message: Optional[pulumi.Input[bool]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 message_type: Optional[pulumi.Input[str]] = None,
                 settings: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 uid: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] url: The DingDing webhook URL.
        :param pulumi.Input[bool] disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param pulumi.Input[str] message: The templated content of the message.
        :param pulumi.Input[str] message_type: The format of message to send - either 'link' or 'actionCard'
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param pulumi.Input[str] title: The templated title of the message.
        :param pulumi.Input[str] uid: The UID of the contact point.
        """
        pulumi.set(__self__, "url", url)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if message_type is not None:
            pulumi.set(__self__, "message_type", message_type)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        The DingDing webhook URL.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @disable_resolve_message.setter
    def disable_resolve_message(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_resolve_message", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        The templated content of the message.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter(name="messageType")
    def message_type(self) -> Optional[pulumi.Input[str]]:
        """
        The format of message to send - either 'link' or 'actionCard'
        """
        return pulumi.get(self, "message_type")

    @message_type.setter
    def message_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message_type", value)

    @property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "settings", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        The templated title of the message.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)


if not MYPY:
    class ContactPointDiscordArgsDict(TypedDict):
        url: pulumi.Input[str]
        """
        The discord webhook URL.
        """
        avatar_url: NotRequired[pulumi.Input[str]]
        """
        The URL of a custom avatar image to use. Defaults to ``.
        """
        disable_resolve_message: NotRequired[pulumi.Input[bool]]
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        message: NotRequired[pulumi.Input[str]]
        """
        The templated content of the message. Defaults to ``.
        """
        settings: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        title: NotRequired[pulumi.Input[str]]
        """
        The templated content of the title.
        """
        uid: NotRequired[pulumi.Input[str]]
        """
        The UID of the contact point.
        """
        use_discord_username: NotRequired[pulumi.Input[bool]]
        """
        Whether to use the bot account's plain username instead of "Grafana." Defaults to `false`.
        """
elif False:
    ContactPointDiscordArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContactPointDiscordArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 avatar_url: Optional[pulumi.Input[str]] = None,
                 disable_resolve_message: Optional[pulumi.Input[bool]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 settings: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 uid: Optional[pulumi.Input[str]] = None,
                 use_discord_username: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] url: The discord webhook URL.
        :param pulumi.Input[str] avatar_url: The URL of a custom avatar image to use. Defaults to ``.
        :param pulumi.Input[bool] disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param pulumi.Input[str] message: The templated content of the message. Defaults to ``.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param pulumi.Input[str] title: The templated content of the title.
        :param pulumi.Input[str] uid: The UID of the contact point.
        :param pulumi.Input[bool] use_discord_username: Whether to use the bot account's plain username instead of "Grafana." Defaults to `false`.
        """
        pulumi.set(__self__, "url", url)
        if avatar_url is not None:
            pulumi.set(__self__, "avatar_url", avatar_url)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)
        if use_discord_username is not None:
            pulumi.set(__self__, "use_discord_username", use_discord_username)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        The discord webhook URL.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="avatarUrl")
    def avatar_url(self) -> Optional[pulumi.Input[str]]:
        """
        The URL of a custom avatar image to use. Defaults to ``.
        """
        return pulumi.get(self, "avatar_url")

    @avatar_url.setter
    def avatar_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "avatar_url", value)

    @property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @disable_resolve_message.setter
    def disable_resolve_message(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_resolve_message", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        The templated content of the message. Defaults to ``.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "settings", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        The templated content of the title.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)

    @property
    @pulumi.getter(name="useDiscordUsername")
    def use_discord_username(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to use the bot account's plain username instead of "Grafana." Defaults to `false`.
        """
        return pulumi.get(self, "use_discord_username")

    @use_discord_username.setter
    def use_discord_username(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_discord_username", value)


if not MYPY:
    class ContactPointEmailArgsDict(TypedDict):
        addresses: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        The addresses to send emails to.
        """
        disable_resolve_message: NotRequired[pulumi.Input[bool]]
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        message: NotRequired[pulumi.Input[str]]
        """
        The templated content of the email. Defaults to ``.
        """
        settings: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        single_email: NotRequired[pulumi.Input[bool]]
        """
        Whether to send a single email CC'ing all addresses, rather than a separate email to each address. Defaults to `false`.
        """
        subject: NotRequired[pulumi.Input[str]]
        """
        The templated subject line of the email. Defaults to ``.
        """
        uid: NotRequired[pulumi.Input[str]]
        """
        The UID of the contact point.
        """
elif False:
    ContactPointEmailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContactPointEmailArgs:
    def __init__(__self__, *,
                 addresses: pulumi.Input[Sequence[pulumi.Input[str]]],
                 disable_resolve_message: Optional[pulumi.Input[bool]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 settings: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 single_email: Optional[pulumi.Input[bool]] = None,
                 subject: Optional[pulumi.Input[str]] = None,
                 uid: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] addresses: The addresses to send emails to.
        :param pulumi.Input[bool] disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param pulumi.Input[str] message: The templated content of the email. Defaults to ``.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param pulumi.Input[bool] single_email: Whether to send a single email CC'ing all addresses, rather than a separate email to each address. Defaults to `false`.
        :param pulumi.Input[str] subject: The templated subject line of the email. Defaults to ``.
        :param pulumi.Input[str] uid: The UID of the contact point.
        """
        pulumi.set(__self__, "addresses", addresses)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if single_email is not None:
            pulumi.set(__self__, "single_email", single_email)
        if subject is not None:
            pulumi.set(__self__, "subject", subject)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter
    def addresses(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The addresses to send emails to.
        """
        return pulumi.get(self, "addresses")

    @addresses.setter
    def addresses(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "addresses", value)

    @property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @disable_resolve_message.setter
    def disable_resolve_message(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_resolve_message", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        The templated content of the email. Defaults to ``.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "settings", value)

    @property
    @pulumi.getter(name="singleEmail")
    def single_email(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to send a single email CC'ing all addresses, rather than a separate email to each address. Defaults to `false`.
        """
        return pulumi.get(self, "single_email")

    @single_email.setter
    def single_email(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "single_email", value)

    @property
    @pulumi.getter
    def subject(self) -> Optional[pulumi.Input[str]]:
        """
        The templated subject line of the email. Defaults to ``.
        """
        return pulumi.get(self, "subject")

    @subject.setter
    def subject(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subject", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)


if not MYPY:
    class ContactPointGooglechatArgsDict(TypedDict):
        url: pulumi.Input[str]
        """
        The Google Chat webhook URL.
        """
        disable_resolve_message: NotRequired[pulumi.Input[bool]]
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        message: NotRequired[pulumi.Input[str]]
        """
        The templated content of the message.
        """
        settings: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        title: NotRequired[pulumi.Input[str]]
        """
        The templated content of the title.
        """
        uid: NotRequired[pulumi.Input[str]]
        """
        The UID of the contact point.
        """
elif False:
    ContactPointGooglechatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContactPointGooglechatArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 disable_resolve_message: Optional[pulumi.Input[bool]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 settings: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 uid: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] url: The Google Chat webhook URL.
        :param pulumi.Input[bool] disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param pulumi.Input[str] message: The templated content of the message.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param pulumi.Input[str] title: The templated content of the title.
        :param pulumi.Input[str] uid: The UID of the contact point.
        """
        pulumi.set(__self__, "url", url)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        The Google Chat webhook URL.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @disable_resolve_message.setter
    def disable_resolve_message(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_resolve_message", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        The templated content of the message.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "settings", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        The templated content of the title.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)


if not MYPY:
    class ContactPointKafkaArgsDict(TypedDict):
        rest_proxy_url: pulumi.Input[str]
        """
        The URL of the Kafka REST proxy to send requests to.
        """
        topic: pulumi.Input[str]
        """
        The name of the Kafka topic to publish to.
        """
        api_version: NotRequired[pulumi.Input[str]]
        """
        The API version to use when contacting the Kafka REST Server. Supported: v2 (default) and v3. Defaults to `v2`.
        """
        cluster_id: NotRequired[pulumi.Input[str]]
        """
        The Id of cluster to use when contacting the Kafka REST Server. Required api_version to be 'v3'
        """
        description: NotRequired[pulumi.Input[str]]
        """
        The templated description of the Kafka message.
        """
        details: NotRequired[pulumi.Input[str]]
        """
        The templated details to include with the message.
        """
        disable_resolve_message: NotRequired[pulumi.Input[bool]]
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        password: NotRequired[pulumi.Input[str]]
        """
        The password to use when making a call to the Kafka REST Proxy
        """
        settings: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        uid: NotRequired[pulumi.Input[str]]
        """
        The UID of the contact point.
        """
        username: NotRequired[pulumi.Input[str]]
        """
        The user name to use when making a call to the Kafka REST Proxy
        """
elif False:
    ContactPointKafkaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContactPointKafkaArgs:
    def __init__(__self__, *,
                 rest_proxy_url: pulumi.Input[str],
                 topic: pulumi.Input[str],
                 api_version: Optional[pulumi.Input[str]] = None,
                 cluster_id: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 details: Optional[pulumi.Input[str]] = None,
                 disable_resolve_message: Optional[pulumi.Input[bool]] = None,
                 password: Optional[pulumi.Input[str]] = None,
                 settings: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 uid: Optional[pulumi.Input[str]] = None,
                 username: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] rest_proxy_url: The URL of the Kafka REST proxy to send requests to.
        :param pulumi.Input[str] topic: The name of the Kafka topic to publish to.
        :param pulumi.Input[str] api_version: The API version to use when contacting the Kafka REST Server. Supported: v2 (default) and v3. Defaults to `v2`.
        :param pulumi.Input[str] cluster_id: The Id of cluster to use when contacting the Kafka REST Server. Required api_version to be 'v3'
        :param pulumi.Input[str] description: The templated description of the Kafka message.
        :param pulumi.Input[str] details: The templated details to include with the message.
        :param pulumi.Input[bool] disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param pulumi.Input[str] password: The password to use when making a call to the Kafka REST Proxy
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param pulumi.Input[str] uid: The UID of the contact point.
        :param pulumi.Input[str] username: The user name to use when making a call to the Kafka REST Proxy
        """
        pulumi.set(__self__, "rest_proxy_url", rest_proxy_url)
        pulumi.set(__self__, "topic", topic)
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if cluster_id is not None:
            pulumi.set(__self__, "cluster_id", cluster_id)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if details is not None:
            pulumi.set(__self__, "details", details)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="restProxyUrl")
    def rest_proxy_url(self) -> pulumi.Input[str]:
        """
        The URL of the Kafka REST proxy to send requests to.
        """
        return pulumi.get(self, "rest_proxy_url")

    @rest_proxy_url.setter
    def rest_proxy_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "rest_proxy_url", value)

    @property
    @pulumi.getter
    def topic(self) -> pulumi.Input[str]:
        """
        The name of the Kafka topic to publish to.
        """
        return pulumi.get(self, "topic")

    @topic.setter
    def topic(self, value: pulumi.Input[str]):
        pulumi.set(self, "topic", value)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[pulumi.Input[str]]:
        """
        The API version to use when contacting the Kafka REST Server. Supported: v2 (default) and v3. Defaults to `v2`.
        """
        return pulumi.get(self, "api_version")

    @api_version.setter
    def api_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_version", value)

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Id of cluster to use when contacting the Kafka REST Server. Required api_version to be 'v3'
        """
        return pulumi.get(self, "cluster_id")

    @cluster_id.setter
    def cluster_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_id", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The templated description of the Kafka message.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def details(self) -> Optional[pulumi.Input[str]]:
        """
        The templated details to include with the message.
        """
        return pulumi.get(self, "details")

    @details.setter
    def details(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "details", value)

    @property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @disable_resolve_message.setter
    def disable_resolve_message(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_resolve_message", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        The password to use when making a call to the Kafka REST Proxy
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "settings", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        The user name to use when making a call to the Kafka REST Proxy
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ContactPointLineArgsDict(TypedDict):
        token: pulumi.Input[str]
        """
        The bearer token used to authorize the client.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        The templated description of the message.
        """
        disable_resolve_message: NotRequired[pulumi.Input[bool]]
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        settings: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        title: NotRequired[pulumi.Input[str]]
        """
        The templated title of the message.
        """
        uid: NotRequired[pulumi.Input[str]]
        """
        The UID of the contact point.
        """
elif False:
    ContactPointLineArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContactPointLineArgs:
    def __init__(__self__, *,
                 token: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None,
                 disable_resolve_message: Optional[pulumi.Input[bool]] = None,
                 settings: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 uid: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] token: The bearer token used to authorize the client.
        :param pulumi.Input[str] description: The templated description of the message.
        :param pulumi.Input[bool] disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param pulumi.Input[str] title: The templated title of the message.
        :param pulumi.Input[str] uid: The UID of the contact point.
        """
        pulumi.set(__self__, "token", token)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter
    def token(self) -> pulumi.Input[str]:
        """
        The bearer token used to authorize the client.
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: pulumi.Input[str]):
        pulumi.set(self, "token", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The templated description of the message.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @disable_resolve_message.setter
    def disable_resolve_message(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_resolve_message", value)

    @property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "settings", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        The templated title of the message.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)


if not MYPY:
    class ContactPointOncallArgsDict(TypedDict):
        url: pulumi.Input[str]
        """
        The URL to send webhook requests to.
        """
        authorization_credentials: NotRequired[pulumi.Input[str]]
        """
        Allows a custom authorization scheme - attaches an auth header with this value. Do not use in conjunction with basic auth parameters.
        """
        authorization_scheme: NotRequired[pulumi.Input[str]]
        """
        Allows a custom authorization scheme - attaches an auth header with this name. Do not use in conjunction with basic auth parameters.
        """
        basic_auth_password: NotRequired[pulumi.Input[str]]
        """
        The username to use in basic auth headers attached to the request. If omitted, basic auth will not be used.
        """
        basic_auth_user: NotRequired[pulumi.Input[str]]
        """
        The username to use in basic auth headers attached to the request. If omitted, basic auth will not be used.
        """
        disable_resolve_message: NotRequired[pulumi.Input[bool]]
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        http_method: NotRequired[pulumi.Input[str]]
        """
        The HTTP method to use in the request. Defaults to `POST`.
        """
        max_alerts: NotRequired[pulumi.Input[int]]
        """
        The maximum number of alerts to send in a single request. This can be helpful in limiting the size of the request body. The default is 0, which indicates no limit.
        """
        message: NotRequired[pulumi.Input[str]]
        """
        Custom message. You can use template variables.
        """
        settings: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        title: NotRequired[pulumi.Input[str]]
        """
        Templated title of the message.
        """
        uid: NotRequired[pulumi.Input[str]]
        """
        The UID of the contact point.
        """
elif False:
    ContactPointOncallArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContactPointOncallArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 authorization_credentials: Optional[pulumi.Input[str]] = None,
                 authorization_scheme: Optional[pulumi.Input[str]] = None,
                 basic_auth_password: Optional[pulumi.Input[str]] = None,
                 basic_auth_user: Optional[pulumi.Input[str]] = None,
                 disable_resolve_message: Optional[pulumi.Input[bool]] = None,
                 http_method: Optional[pulumi.Input[str]] = None,
                 max_alerts: Optional[pulumi.Input[int]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 settings: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 uid: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] url: The URL to send webhook requests to.
        :param pulumi.Input[str] authorization_credentials: Allows a custom authorization scheme - attaches an auth header with this value. Do not use in conjunction with basic auth parameters.
        :param pulumi.Input[str] authorization_scheme: Allows a custom authorization scheme - attaches an auth header with this name. Do not use in conjunction with basic auth parameters.
        :param pulumi.Input[str] basic_auth_password: The username to use in basic auth headers attached to the request. If omitted, basic auth will not be used.
        :param pulumi.Input[str] basic_auth_user: The username to use in basic auth headers attached to the request. If omitted, basic auth will not be used.
        :param pulumi.Input[bool] disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param pulumi.Input[str] http_method: The HTTP method to use in the request. Defaults to `POST`.
        :param pulumi.Input[int] max_alerts: The maximum number of alerts to send in a single request. This can be helpful in limiting the size of the request body. The default is 0, which indicates no limit.
        :param pulumi.Input[str] message: Custom message. You can use template variables.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param pulumi.Input[str] title: Templated title of the message.
        :param pulumi.Input[str] uid: The UID of the contact point.
        """
        pulumi.set(__self__, "url", url)
        if authorization_credentials is not None:
            pulumi.set(__self__, "authorization_credentials", authorization_credentials)
        if authorization_scheme is not None:
            pulumi.set(__self__, "authorization_scheme", authorization_scheme)
        if basic_auth_password is not None:
            pulumi.set(__self__, "basic_auth_password", basic_auth_password)
        if basic_auth_user is not None:
            pulumi.set(__self__, "basic_auth_user", basic_auth_user)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if http_method is not None:
            pulumi.set(__self__, "http_method", http_method)
        if max_alerts is not None:
            pulumi.set(__self__, "max_alerts", max_alerts)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        The URL to send webhook requests to.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="authorizationCredentials")
    def authorization_credentials(self) -> Optional[pulumi.Input[str]]:
        """
        Allows a custom authorization scheme - attaches an auth header with this value. Do not use in conjunction with basic auth parameters.
        """
        return pulumi.get(self, "authorization_credentials")

    @authorization_credentials.setter
    def authorization_credentials(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "authorization_credentials", value)

    @property
    @pulumi.getter(name="authorizationScheme")
    def authorization_scheme(self) -> Optional[pulumi.Input[str]]:
        """
        Allows a custom authorization scheme - attaches an auth header with this name. Do not use in conjunction with basic auth parameters.
        """
        return pulumi.get(self, "authorization_scheme")

    @authorization_scheme.setter
    def authorization_scheme(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "authorization_scheme", value)

    @property
    @pulumi.getter(name="basicAuthPassword")
    def basic_auth_password(self) -> Optional[pulumi.Input[str]]:
        """
        The username to use in basic auth headers attached to the request. If omitted, basic auth will not be used.
        """
        return pulumi.get(self, "basic_auth_password")

    @basic_auth_password.setter
    def basic_auth_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "basic_auth_password", value)

    @property
    @pulumi.getter(name="basicAuthUser")
    def basic_auth_user(self) -> Optional[pulumi.Input[str]]:
        """
        The username to use in basic auth headers attached to the request. If omitted, basic auth will not be used.
        """
        return pulumi.get(self, "basic_auth_user")

    @basic_auth_user.setter
    def basic_auth_user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "basic_auth_user", value)

    @property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @disable_resolve_message.setter
    def disable_resolve_message(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_resolve_message", value)

    @property
    @pulumi.getter(name="httpMethod")
    def http_method(self) -> Optional[pulumi.Input[str]]:
        """
        The HTTP method to use in the request. Defaults to `POST`.
        """
        return pulumi.get(self, "http_method")

    @http_method.setter
    def http_method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "http_method", value)

    @property
    @pulumi.getter(name="maxAlerts")
    def max_alerts(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of alerts to send in a single request. This can be helpful in limiting the size of the request body. The default is 0, which indicates no limit.
        """
        return pulumi.get(self, "max_alerts")

    @max_alerts.setter
    def max_alerts(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_alerts", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        Custom message. You can use template variables.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "settings", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        Templated title of the message.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)


if not MYPY:
    class ContactPointOpsgenyArgsDict(TypedDict):
        api_key: pulumi.Input[str]
        """
        The OpsGenie API key to use.
        """
        auto_close: NotRequired[pulumi.Input[bool]]
        """
        Whether to auto-close alerts in OpsGenie when they resolve in the Alertmanager.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        A templated high-level description to use for the alert.
        """
        disable_resolve_message: NotRequired[pulumi.Input[bool]]
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        message: NotRequired[pulumi.Input[str]]
        """
        The templated content of the message.
        """
        override_priority: NotRequired[pulumi.Input[bool]]
        """
        Whether to allow the alert priority to be configured via the value of the `og_priority` annotation on the alert.
        """
        responders: NotRequired[pulumi.Input[Sequence[pulumi.Input['ContactPointOpsgenyResponderArgsDict']]]]
        """
        Teams, users, escalations and schedules that the alert will be routed to send notifications. If the API Key belongs to a team integration, this field will be overwritten with the owner team. This feature is available from Grafana 10.3+.
        """
        send_tags_as: NotRequired[pulumi.Input[str]]
        """
        Whether to send annotations to OpsGenie as Tags, Details, or both. Supported values are `tags`, `details`, `both`, or empty to use the default behavior of Tags.
        """
        settings: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        uid: NotRequired[pulumi.Input[str]]
        """
        The UID of the contact point.
        """
        url: NotRequired[pulumi.Input[str]]
        """
        Allows customization of the OpsGenie API URL.
        """
elif False:
    ContactPointOpsgenyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContactPointOpsgenyArgs:
    def __init__(__self__, *,
                 api_key: pulumi.Input[str],
                 auto_close: Optional[pulumi.Input[bool]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 disable_resolve_message: Optional[pulumi.Input[bool]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 override_priority: Optional[pulumi.Input[bool]] = None,
                 responders: Optional[pulumi.Input[Sequence[pulumi.Input['ContactPointOpsgenyResponderArgs']]]] = None,
                 send_tags_as: Optional[pulumi.Input[str]] = None,
                 settings: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 uid: Optional[pulumi.Input[str]] = None,
                 url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] api_key: The OpsGenie API key to use.
        :param pulumi.Input[bool] auto_close: Whether to auto-close alerts in OpsGenie when they resolve in the Alertmanager.
        :param pulumi.Input[str] description: A templated high-level description to use for the alert.
        :param pulumi.Input[bool] disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param pulumi.Input[str] message: The templated content of the message.
        :param pulumi.Input[bool] override_priority: Whether to allow the alert priority to be configured via the value of the `og_priority` annotation on the alert.
        :param pulumi.Input[Sequence[pulumi.Input['ContactPointOpsgenyResponderArgs']]] responders: Teams, users, escalations and schedules that the alert will be routed to send notifications. If the API Key belongs to a team integration, this field will be overwritten with the owner team. This feature is available from Grafana 10.3+.
        :param pulumi.Input[str] send_tags_as: Whether to send annotations to OpsGenie as Tags, Details, or both. Supported values are `tags`, `details`, `both`, or empty to use the default behavior of Tags.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param pulumi.Input[str] uid: The UID of the contact point.
        :param pulumi.Input[str] url: Allows customization of the OpsGenie API URL.
        """
        pulumi.set(__self__, "api_key", api_key)
        if auto_close is not None:
            pulumi.set(__self__, "auto_close", auto_close)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if override_priority is not None:
            pulumi.set(__self__, "override_priority", override_priority)
        if responders is not None:
            pulumi.set(__self__, "responders", responders)
        if send_tags_as is not None:
            pulumi.set(__self__, "send_tags_as", send_tags_as)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[str]:
        """
        The OpsGenie API key to use.
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_key", value)

    @property
    @pulumi.getter(name="autoClose")
    def auto_close(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to auto-close alerts in OpsGenie when they resolve in the Alertmanager.
        """
        return pulumi.get(self, "auto_close")

    @auto_close.setter
    def auto_close(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "auto_close", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        A templated high-level description to use for the alert.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @disable_resolve_message.setter
    def disable_resolve_message(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_resolve_message", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        The templated content of the message.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter(name="overridePriority")
    def override_priority(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to allow the alert priority to be configured via the value of the `og_priority` annotation on the alert.
        """
        return pulumi.get(self, "override_priority")

    @override_priority.setter
    def override_priority(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "override_priority", value)

    @property
    @pulumi.getter
    def responders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ContactPointOpsgenyResponderArgs']]]]:
        """
        Teams, users, escalations and schedules that the alert will be routed to send notifications. If the API Key belongs to a team integration, this field will be overwritten with the owner team. This feature is available from Grafana 10.3+.
        """
        return pulumi.get(self, "responders")

    @responders.setter
    def responders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ContactPointOpsgenyResponderArgs']]]]):
        pulumi.set(self, "responders", value)

    @property
    @pulumi.getter(name="sendTagsAs")
    def send_tags_as(self) -> Optional[pulumi.Input[str]]:
        """
        Whether to send annotations to OpsGenie as Tags, Details, or both. Supported values are `tags`, `details`, `both`, or empty to use the default behavior of Tags.
        """
        return pulumi.get(self, "send_tags_as")

    @send_tags_as.setter
    def send_tags_as(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "send_tags_as", value)

    @property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "settings", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)

    @property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[str]]:
        """
        Allows customization of the OpsGenie API URL.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class ContactPointOpsgenyResponderArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        Type of the responder. Supported: team, teams, user, escalation, schedule or a template that is expanded to one of these values.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        ID of the responder. Must be specified if name and username are empty.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name of the responder. Must be specified if username and id are empty.
        """
        username: NotRequired[pulumi.Input[str]]
        """
        User name of the responder. Must be specified if name and id are empty.
        """
elif False:
    ContactPointOpsgenyResponderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContactPointOpsgenyResponderArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 username: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: Type of the responder. Supported: team, teams, user, escalation, schedule or a template that is expanded to one of these values.
        :param pulumi.Input[str] id: ID of the responder. Must be specified if name and username are empty.
        :param pulumi.Input[str] name: Name of the responder. Must be specified if username and id are empty.
        :param pulumi.Input[str] username: User name of the responder. Must be specified if name and id are empty.
        """
        pulumi.set(__self__, "type", type)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of the responder. Supported: team, teams, user, escalation, schedule or a template that is expanded to one of these values.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the responder. Must be specified if name and username are empty.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the responder. Must be specified if username and id are empty.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        User name of the responder. Must be specified if name and id are empty.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ContactPointPagerdutyArgsDict(TypedDict):
        integration_key: pulumi.Input[str]
        """
        The PagerDuty API key.
        """
        class_: NotRequired[pulumi.Input[str]]
        """
        The class or type of event, for example `ping failure`.
        """
        client: NotRequired[pulumi.Input[str]]
        """
        The name of the monitoring client that is triggering this event.
        """
        client_url: NotRequired[pulumi.Input[str]]
        """
        The URL of the monitoring client that is triggering this event.
        """
        component: NotRequired[pulumi.Input[str]]
        """
        The component being affected by the event.
        """
        details: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        A set of arbitrary key/value pairs that provide further detail about the incident.
        """
        disable_resolve_message: NotRequired[pulumi.Input[bool]]
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        group: NotRequired[pulumi.Input[str]]
        """
        The group to which the provided component belongs to.
        """
        settings: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        severity: NotRequired[pulumi.Input[str]]
        """
        The PagerDuty event severity level. Default is `critical`.
        """
        source: NotRequired[pulumi.Input[str]]
        """
        The unique location of the affected system.
        """
        summary: NotRequired[pulumi.Input[str]]
        """
        The templated summary message of the event.
        """
        uid: NotRequired[pulumi.Input[str]]
        """
        The UID of the contact point.
        """
        url: NotRequired[pulumi.Input[str]]
        """
        The URL to send API requests to
        """
elif False:
    ContactPointPagerdutyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContactPointPagerdutyArgs:
    def __init__(__self__, *,
                 integration_key: pulumi.Input[str],
                 class_: Optional[pulumi.Input[str]] = None,
                 client: Optional[pulumi.Input[str]] = None,
                 client_url: Optional[pulumi.Input[str]] = None,
                 component: Optional[pulumi.Input[str]] = None,
                 details: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 disable_resolve_message: Optional[pulumi.Input[bool]] = None,
                 group: Optional[pulumi.Input[str]] = None,
                 settings: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 severity: Optional[pulumi.Input[str]] = None,
                 source: Optional[pulumi.Input[str]] = None,
                 summary: Optional[pulumi.Input[str]] = None,
                 uid: Optional[pulumi.Input[str]] = None,
                 url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] integration_key: The PagerDuty API key.
        :param pulumi.Input[str] class_: The class or type of event, for example `ping failure`.
        :param pulumi.Input[str] client: The name of the monitoring client that is triggering this event.
        :param pulumi.Input[str] client_url: The URL of the monitoring client that is triggering this event.
        :param pulumi.Input[str] component: The component being affected by the event.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] details: A set of arbitrary key/value pairs that provide further detail about the incident.
        :param pulumi.Input[bool] disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param pulumi.Input[str] group: The group to which the provided component belongs to.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param pulumi.Input[str] severity: The PagerDuty event severity level. Default is `critical`.
        :param pulumi.Input[str] source: The unique location of the affected system.
        :param pulumi.Input[str] summary: The templated summary message of the event.
        :param pulumi.Input[str] uid: The UID of the contact point.
        :param pulumi.Input[str] url: The URL to send API requests to
        """
        pulumi.set(__self__, "integration_key", integration_key)
        if class_ is not None:
            pulumi.set(__self__, "class_", class_)
        if client is not None:
            pulumi.set(__self__, "client", client)
        if client_url is not None:
            pulumi.set(__self__, "client_url", client_url)
        if component is not None:
            pulumi.set(__self__, "component", component)
        if details is not None:
            pulumi.set(__self__, "details", details)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if group is not None:
            pulumi.set(__self__, "group", group)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if summary is not None:
            pulumi.set(__self__, "summary", summary)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter(name="integrationKey")
    def integration_key(self) -> pulumi.Input[str]:
        """
        The PagerDuty API key.
        """
        return pulumi.get(self, "integration_key")

    @integration_key.setter
    def integration_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "integration_key", value)

    @property
    @pulumi.getter(name="class")
    def class_(self) -> Optional[pulumi.Input[str]]:
        """
        The class or type of event, for example `ping failure`.
        """
        return pulumi.get(self, "class_")

    @class_.setter
    def class_(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "class_", value)

    @property
    @pulumi.getter
    def client(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the monitoring client that is triggering this event.
        """
        return pulumi.get(self, "client")

    @client.setter
    def client(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client", value)

    @property
    @pulumi.getter(name="clientUrl")
    def client_url(self) -> Optional[pulumi.Input[str]]:
        """
        The URL of the monitoring client that is triggering this event.
        """
        return pulumi.get(self, "client_url")

    @client_url.setter
    def client_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_url", value)

    @property
    @pulumi.getter
    def component(self) -> Optional[pulumi.Input[str]]:
        """
        The component being affected by the event.
        """
        return pulumi.get(self, "component")

    @component.setter
    def component(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "component", value)

    @property
    @pulumi.getter
    def details(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A set of arbitrary key/value pairs that provide further detail about the incident.
        """
        return pulumi.get(self, "details")

    @details.setter
    def details(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "details", value)

    @property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @disable_resolve_message.setter
    def disable_resolve_message(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_resolve_message", value)

    @property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input[str]]:
        """
        The group to which the provided component belongs to.
        """
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group", value)

    @property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "settings", value)

    @property
    @pulumi.getter
    def severity(self) -> Optional[pulumi.Input[str]]:
        """
        The PagerDuty event severity level. Default is `critical`.
        """
        return pulumi.get(self, "severity")

    @severity.setter
    def severity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "severity", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[str]]:
        """
        The unique location of the affected system.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter
    def summary(self) -> Optional[pulumi.Input[str]]:
        """
        The templated summary message of the event.
        """
        return pulumi.get(self, "summary")

    @summary.setter
    def summary(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "summary", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)

    @property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[str]]:
        """
        The URL to send API requests to
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class ContactPointPushoverArgsDict(TypedDict):
        api_token: pulumi.Input[str]
        """
        The Pushover API token.
        """
        user_key: pulumi.Input[str]
        """
        The Pushover user key.
        """
        device: NotRequired[pulumi.Input[str]]
        """
        Comma-separated list of devices to which the event is associated.
        """
        disable_resolve_message: NotRequired[pulumi.Input[bool]]
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        expire: NotRequired[pulumi.Input[int]]
        """
        How many seconds for which the notification will continue to be retried by Pushover.
        """
        message: NotRequired[pulumi.Input[str]]
        """
        The templated notification message content.
        """
        ok_priority: NotRequired[pulumi.Input[int]]
        """
        The priority level of the resolved event.
        """
        ok_sound: NotRequired[pulumi.Input[str]]
        """
        The sound associated with the resolved notification.
        """
        priority: NotRequired[pulumi.Input[int]]
        """
        The priority level of the event.
        """
        retry: NotRequired[pulumi.Input[int]]
        """
        How often, in seconds, the Pushover servers will send the same notification to the user.
        """
        settings: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        sound: NotRequired[pulumi.Input[str]]
        """
        The sound associated with the notification.
        """
        title: NotRequired[pulumi.Input[str]]
        """
        The templated title of the message.
        """
        uid: NotRequired[pulumi.Input[str]]
        """
        The UID of the contact point.
        """
        upload_image: NotRequired[pulumi.Input[bool]]
        """
        Whether to send images in the notification or not. Default is true. Requires Grafana to be configured to send images in notifications.
        """
elif False:
    ContactPointPushoverArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContactPointPushoverArgs:
    def __init__(__self__, *,
                 api_token: pulumi.Input[str],
                 user_key: pulumi.Input[str],
                 device: Optional[pulumi.Input[str]] = None,
                 disable_resolve_message: Optional[pulumi.Input[bool]] = None,
                 expire: Optional[pulumi.Input[int]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 ok_priority: Optional[pulumi.Input[int]] = None,
                 ok_sound: Optional[pulumi.Input[str]] = None,
                 priority: Optional[pulumi.Input[int]] = None,
                 retry: Optional[pulumi.Input[int]] = None,
                 settings: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 sound: Optional[pulumi.Input[str]] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 uid: Optional[pulumi.Input[str]] = None,
                 upload_image: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] api_token: The Pushover API token.
        :param pulumi.Input[str] user_key: The Pushover user key.
        :param pulumi.Input[str] device: Comma-separated list of devices to which the event is associated.
        :param pulumi.Input[bool] disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param pulumi.Input[int] expire: How many seconds for which the notification will continue to be retried by Pushover.
        :param pulumi.Input[str] message: The templated notification message content.
        :param pulumi.Input[int] ok_priority: The priority level of the resolved event.
        :param pulumi.Input[str] ok_sound: The sound associated with the resolved notification.
        :param pulumi.Input[int] priority: The priority level of the event.
        :param pulumi.Input[int] retry: How often, in seconds, the Pushover servers will send the same notification to the user.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param pulumi.Input[str] sound: The sound associated with the notification.
        :param pulumi.Input[str] title: The templated title of the message.
        :param pulumi.Input[str] uid: The UID of the contact point.
        :param pulumi.Input[bool] upload_image: Whether to send images in the notification or not. Default is true. Requires Grafana to be configured to send images in notifications.
        """
        pulumi.set(__self__, "api_token", api_token)
        pulumi.set(__self__, "user_key", user_key)
        if device is not None:
            pulumi.set(__self__, "device", device)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if expire is not None:
            pulumi.set(__self__, "expire", expire)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if ok_priority is not None:
            pulumi.set(__self__, "ok_priority", ok_priority)
        if ok_sound is not None:
            pulumi.set(__self__, "ok_sound", ok_sound)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if retry is not None:
            pulumi.set(__self__, "retry", retry)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if sound is not None:
            pulumi.set(__self__, "sound", sound)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)
        if upload_image is not None:
            pulumi.set(__self__, "upload_image", upload_image)

    @property
    @pulumi.getter(name="apiToken")
    def api_token(self) -> pulumi.Input[str]:
        """
        The Pushover API token.
        """
        return pulumi.get(self, "api_token")

    @api_token.setter
    def api_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_token", value)

    @property
    @pulumi.getter(name="userKey")
    def user_key(self) -> pulumi.Input[str]:
        """
        The Pushover user key.
        """
        return pulumi.get(self, "user_key")

    @user_key.setter
    def user_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "user_key", value)

    @property
    @pulumi.getter
    def device(self) -> Optional[pulumi.Input[str]]:
        """
        Comma-separated list of devices to which the event is associated.
        """
        return pulumi.get(self, "device")

    @device.setter
    def device(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "device", value)

    @property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @disable_resolve_message.setter
    def disable_resolve_message(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_resolve_message", value)

    @property
    @pulumi.getter
    def expire(self) -> Optional[pulumi.Input[int]]:
        """
        How many seconds for which the notification will continue to be retried by Pushover.
        """
        return pulumi.get(self, "expire")

    @expire.setter
    def expire(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "expire", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        The templated notification message content.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter(name="okPriority")
    def ok_priority(self) -> Optional[pulumi.Input[int]]:
        """
        The priority level of the resolved event.
        """
        return pulumi.get(self, "ok_priority")

    @ok_priority.setter
    def ok_priority(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ok_priority", value)

    @property
    @pulumi.getter(name="okSound")
    def ok_sound(self) -> Optional[pulumi.Input[str]]:
        """
        The sound associated with the resolved notification.
        """
        return pulumi.get(self, "ok_sound")

    @ok_sound.setter
    def ok_sound(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ok_sound", value)

    @property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[int]]:
        """
        The priority level of the event.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def retry(self) -> Optional[pulumi.Input[int]]:
        """
        How often, in seconds, the Pushover servers will send the same notification to the user.
        """
        return pulumi.get(self, "retry")

    @retry.setter
    def retry(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "retry", value)

    @property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "settings", value)

    @property
    @pulumi.getter
    def sound(self) -> Optional[pulumi.Input[str]]:
        """
        The sound associated with the notification.
        """
        return pulumi.get(self, "sound")

    @sound.setter
    def sound(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sound", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        The templated title of the message.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)

    @property
    @pulumi.getter(name="uploadImage")
    def upload_image(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to send images in the notification or not. Default is true. Requires Grafana to be configured to send images in notifications.
        """
        return pulumi.get(self, "upload_image")

    @upload_image.setter
    def upload_image(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "upload_image", value)


if not MYPY:
    class ContactPointSensugoArgsDict(TypedDict):
        api_key: pulumi.Input[str]
        """
        The SensuGo API key.
        """
        url: pulumi.Input[str]
        """
        The SensuGo URL to send requests to.
        """
        check: NotRequired[pulumi.Input[str]]
        """
        The SensuGo check to which the event should be routed.
        """
        disable_resolve_message: NotRequired[pulumi.Input[bool]]
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        entity: NotRequired[pulumi.Input[str]]
        """
        The entity being monitored.
        """
        handler: NotRequired[pulumi.Input[str]]
        """
        A custom handler to execute in addition to the check.
        """
        message: NotRequired[pulumi.Input[str]]
        """
        Templated message content describing the alert.
        """
        namespace: NotRequired[pulumi.Input[str]]
        """
        The namespace in which the check resides.
        """
        settings: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        uid: NotRequired[pulumi.Input[str]]
        """
        The UID of the contact point.
        """
elif False:
    ContactPointSensugoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContactPointSensugoArgs:
    def __init__(__self__, *,
                 api_key: pulumi.Input[str],
                 url: pulumi.Input[str],
                 check: Optional[pulumi.Input[str]] = None,
                 disable_resolve_message: Optional[pulumi.Input[bool]] = None,
                 entity: Optional[pulumi.Input[str]] = None,
                 handler: Optional[pulumi.Input[str]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 namespace: Optional[pulumi.Input[str]] = None,
                 settings: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 uid: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] api_key: The SensuGo API key.
        :param pulumi.Input[str] url: The SensuGo URL to send requests to.
        :param pulumi.Input[str] check: The SensuGo check to which the event should be routed.
        :param pulumi.Input[bool] disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param pulumi.Input[str] entity: The entity being monitored.
        :param pulumi.Input[str] handler: A custom handler to execute in addition to the check.
        :param pulumi.Input[str] message: Templated message content describing the alert.
        :param pulumi.Input[str] namespace: The namespace in which the check resides.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param pulumi.Input[str] uid: The UID of the contact point.
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "url", url)
        if check is not None:
            pulumi.set(__self__, "check", check)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if entity is not None:
            pulumi.set(__self__, "entity", entity)
        if handler is not None:
            pulumi.set(__self__, "handler", handler)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[str]:
        """
        The SensuGo API key.
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_key", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        The SensuGo URL to send requests to.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter
    def check(self) -> Optional[pulumi.Input[str]]:
        """
        The SensuGo check to which the event should be routed.
        """
        return pulumi.get(self, "check")

    @check.setter
    def check(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "check", value)

    @property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @disable_resolve_message.setter
    def disable_resolve_message(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_resolve_message", value)

    @property
    @pulumi.getter
    def entity(self) -> Optional[pulumi.Input[str]]:
        """
        The entity being monitored.
        """
        return pulumi.get(self, "entity")

    @entity.setter
    def entity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "entity", value)

    @property
    @pulumi.getter
    def handler(self) -> Optional[pulumi.Input[str]]:
        """
        A custom handler to execute in addition to the check.
        """
        return pulumi.get(self, "handler")

    @handler.setter
    def handler(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "handler", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        Templated message content describing the alert.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        """
        The namespace in which the check resides.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "settings", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)


if not MYPY:
    class ContactPointSlackArgsDict(TypedDict):
        disable_resolve_message: NotRequired[pulumi.Input[bool]]
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        endpoint_url: NotRequired[pulumi.Input[str]]
        """
        Use this to override the Slack API endpoint URL to send requests to.
        """
        icon_emoji: NotRequired[pulumi.Input[str]]
        """
        The name of a Slack workspace emoji to use as the bot icon.
        """
        icon_url: NotRequired[pulumi.Input[str]]
        """
        A URL of an image to use as the bot icon.
        """
        mention_channel: NotRequired[pulumi.Input[str]]
        """
        Describes how to ping the slack channel that messages are being sent to. Options are `here` for an @here ping, `channel` for @channel, or empty for no ping.
        """
        mention_groups: NotRequired[pulumi.Input[str]]
        """
        Comma-separated list of groups to mention in the message.
        """
        mention_users: NotRequired[pulumi.Input[str]]
        """
        Comma-separated list of users to mention in the message.
        """
        recipient: NotRequired[pulumi.Input[str]]
        """
        Channel, private group, or IM channel (can be an encoded ID or a name) to send messages to.
        """
        settings: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        text: NotRequired[pulumi.Input[str]]
        """
        Templated content of the message.
        """
        title: NotRequired[pulumi.Input[str]]
        """
        Templated title of the message.
        """
        token: NotRequired[pulumi.Input[str]]
        """
        A Slack API token,for sending messages directly without the webhook method.
        """
        uid: NotRequired[pulumi.Input[str]]
        """
        The UID of the contact point.
        """
        url: NotRequired[pulumi.Input[str]]
        """
        A Slack webhook URL,for sending messages via the webhook method.
        """
        username: NotRequired[pulumi.Input[str]]
        """
        Username for the bot to use.
        """
elif False:
    ContactPointSlackArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContactPointSlackArgs:
    def __init__(__self__, *,
                 disable_resolve_message: Optional[pulumi.Input[bool]] = None,
                 endpoint_url: Optional[pulumi.Input[str]] = None,
                 icon_emoji: Optional[pulumi.Input[str]] = None,
                 icon_url: Optional[pulumi.Input[str]] = None,
                 mention_channel: Optional[pulumi.Input[str]] = None,
                 mention_groups: Optional[pulumi.Input[str]] = None,
                 mention_users: Optional[pulumi.Input[str]] = None,
                 recipient: Optional[pulumi.Input[str]] = None,
                 settings: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 text: Optional[pulumi.Input[str]] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 token: Optional[pulumi.Input[str]] = None,
                 uid: Optional[pulumi.Input[str]] = None,
                 url: Optional[pulumi.Input[str]] = None,
                 username: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param pulumi.Input[str] endpoint_url: Use this to override the Slack API endpoint URL to send requests to.
        :param pulumi.Input[str] icon_emoji: The name of a Slack workspace emoji to use as the bot icon.
        :param pulumi.Input[str] icon_url: A URL of an image to use as the bot icon.
        :param pulumi.Input[str] mention_channel: Describes how to ping the slack channel that messages are being sent to. Options are `here` for an @here ping, `channel` for @channel, or empty for no ping.
        :param pulumi.Input[str] mention_groups: Comma-separated list of groups to mention in the message.
        :param pulumi.Input[str] mention_users: Comma-separated list of users to mention in the message.
        :param pulumi.Input[str] recipient: Channel, private group, or IM channel (can be an encoded ID or a name) to send messages to.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param pulumi.Input[str] text: Templated content of the message.
        :param pulumi.Input[str] title: Templated title of the message.
        :param pulumi.Input[str] token: A Slack API token,for sending messages directly without the webhook method.
        :param pulumi.Input[str] uid: The UID of the contact point.
        :param pulumi.Input[str] url: A Slack webhook URL,for sending messages via the webhook method.
        :param pulumi.Input[str] username: Username for the bot to use.
        """
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if endpoint_url is not None:
            pulumi.set(__self__, "endpoint_url", endpoint_url)
        if icon_emoji is not None:
            pulumi.set(__self__, "icon_emoji", icon_emoji)
        if icon_url is not None:
            pulumi.set(__self__, "icon_url", icon_url)
        if mention_channel is not None:
            pulumi.set(__self__, "mention_channel", mention_channel)
        if mention_groups is not None:
            pulumi.set(__self__, "mention_groups", mention_groups)
        if mention_users is not None:
            pulumi.set(__self__, "mention_users", mention_users)
        if recipient is not None:
            pulumi.set(__self__, "recipient", recipient)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if text is not None:
            pulumi.set(__self__, "text", text)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if token is not None:
            pulumi.set(__self__, "token", token)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @disable_resolve_message.setter
    def disable_resolve_message(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_resolve_message", value)

    @property
    @pulumi.getter(name="endpointUrl")
    def endpoint_url(self) -> Optional[pulumi.Input[str]]:
        """
        Use this to override the Slack API endpoint URL to send requests to.
        """
        return pulumi.get(self, "endpoint_url")

    @endpoint_url.setter
    def endpoint_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "endpoint_url", value)

    @property
    @pulumi.getter(name="iconEmoji")
    def icon_emoji(self) -> Optional[pulumi.Input[str]]:
        """
        The name of a Slack workspace emoji to use as the bot icon.
        """
        return pulumi.get(self, "icon_emoji")

    @icon_emoji.setter
    def icon_emoji(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "icon_emoji", value)

    @property
    @pulumi.getter(name="iconUrl")
    def icon_url(self) -> Optional[pulumi.Input[str]]:
        """
        A URL of an image to use as the bot icon.
        """
        return pulumi.get(self, "icon_url")

    @icon_url.setter
    def icon_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "icon_url", value)

    @property
    @pulumi.getter(name="mentionChannel")
    def mention_channel(self) -> Optional[pulumi.Input[str]]:
        """
        Describes how to ping the slack channel that messages are being sent to. Options are `here` for an @here ping, `channel` for @channel, or empty for no ping.
        """
        return pulumi.get(self, "mention_channel")

    @mention_channel.setter
    def mention_channel(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mention_channel", value)

    @property
    @pulumi.getter(name="mentionGroups")
    def mention_groups(self) -> Optional[pulumi.Input[str]]:
        """
        Comma-separated list of groups to mention in the message.
        """
        return pulumi.get(self, "mention_groups")

    @mention_groups.setter
    def mention_groups(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mention_groups", value)

    @property
    @pulumi.getter(name="mentionUsers")
    def mention_users(self) -> Optional[pulumi.Input[str]]:
        """
        Comma-separated list of users to mention in the message.
        """
        return pulumi.get(self, "mention_users")

    @mention_users.setter
    def mention_users(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mention_users", value)

    @property
    @pulumi.getter
    def recipient(self) -> Optional[pulumi.Input[str]]:
        """
        Channel, private group, or IM channel (can be an encoded ID or a name) to send messages to.
        """
        return pulumi.get(self, "recipient")

    @recipient.setter
    def recipient(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "recipient", value)

    @property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "settings", value)

    @property
    @pulumi.getter
    def text(self) -> Optional[pulumi.Input[str]]:
        """
        Templated content of the message.
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "text", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        Templated title of the message.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def token(self) -> Optional[pulumi.Input[str]]:
        """
        A Slack API token,for sending messages directly without the webhook method.
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "token", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)

    @property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[str]]:
        """
        A Slack webhook URL,for sending messages via the webhook method.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        Username for the bot to use.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ContactPointSnArgsDict(TypedDict):
        topic: pulumi.Input[str]
        """
        The Amazon SNS topic to send notifications to.
        """
        access_key: NotRequired[pulumi.Input[str]]
        """
        AWS access key ID used to authenticate with Amazon SNS.
        """
        assume_role_arn: NotRequired[pulumi.Input[str]]
        """
        The Amazon Resource Name (ARN) of the role to assume to send notifications to Amazon SNS.
        """
        auth_provider: NotRequired[pulumi.Input[str]]
        """
        The authentication provider to use. Valid values are `default`, `arn` and `keys`. Default is `default`. Defaults to `default`.
        """
        body: NotRequired[pulumi.Input[str]]
        disable_resolve_message: NotRequired[pulumi.Input[bool]]
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        external_id: NotRequired[pulumi.Input[str]]
        """
        The external ID to use when assuming the role.
        """
        message_format: NotRequired[pulumi.Input[str]]
        """
        The format of the message to send. Valid values are `text`, `body` and `json`. Default is `text`. Defaults to `text`.
        """
        secret_key: NotRequired[pulumi.Input[str]]
        """
        AWS secret access key used to authenticate with Amazon SNS.
        """
        settings: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        subject: NotRequired[pulumi.Input[str]]
        uid: NotRequired[pulumi.Input[str]]
        """
        The UID of the contact point.
        """
elif False:
    ContactPointSnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContactPointSnArgs:
    def __init__(__self__, *,
                 topic: pulumi.Input[str],
                 access_key: Optional[pulumi.Input[str]] = None,
                 assume_role_arn: Optional[pulumi.Input[str]] = None,
                 auth_provider: Optional[pulumi.Input[str]] = None,
                 body: Optional[pulumi.Input[str]] = None,
                 disable_resolve_message: Optional[pulumi.Input[bool]] = None,
                 external_id: Optional[pulumi.Input[str]] = None,
                 message_format: Optional[pulumi.Input[str]] = None,
                 secret_key: Optional[pulumi.Input[str]] = None,
                 settings: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 subject: Optional[pulumi.Input[str]] = None,
                 uid: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] topic: The Amazon SNS topic to send notifications to.
        :param pulumi.Input[str] access_key: AWS access key ID used to authenticate with Amazon SNS.
        :param pulumi.Input[str] assume_role_arn: The Amazon Resource Name (ARN) of the role to assume to send notifications to Amazon SNS.
        :param pulumi.Input[str] auth_provider: The authentication provider to use. Valid values are `default`, `arn` and `keys`. Default is `default`. Defaults to `default`.
        :param pulumi.Input[bool] disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param pulumi.Input[str] external_id: The external ID to use when assuming the role.
        :param pulumi.Input[str] message_format: The format of the message to send. Valid values are `text`, `body` and `json`. Default is `text`. Defaults to `text`.
        :param pulumi.Input[str] secret_key: AWS secret access key used to authenticate with Amazon SNS.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param pulumi.Input[str] uid: The UID of the contact point.
        """
        pulumi.set(__self__, "topic", topic)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if assume_role_arn is not None:
            pulumi.set(__self__, "assume_role_arn", assume_role_arn)
        if auth_provider is not None:
            pulumi.set(__self__, "auth_provider", auth_provider)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)
        if message_format is not None:
            pulumi.set(__self__, "message_format", message_format)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if subject is not None:
            pulumi.set(__self__, "subject", subject)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter
    def topic(self) -> pulumi.Input[str]:
        """
        The Amazon SNS topic to send notifications to.
        """
        return pulumi.get(self, "topic")

    @topic.setter
    def topic(self, value: pulumi.Input[str]):
        pulumi.set(self, "topic", value)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[pulumi.Input[str]]:
        """
        AWS access key ID used to authenticate with Amazon SNS.
        """
        return pulumi.get(self, "access_key")

    @access_key.setter
    def access_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_key", value)

    @property
    @pulumi.getter(name="assumeRoleArn")
    def assume_role_arn(self) -> Optional[pulumi.Input[str]]:
        """
        The Amazon Resource Name (ARN) of the role to assume to send notifications to Amazon SNS.
        """
        return pulumi.get(self, "assume_role_arn")

    @assume_role_arn.setter
    def assume_role_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "assume_role_arn", value)

    @property
    @pulumi.getter(name="authProvider")
    def auth_provider(self) -> Optional[pulumi.Input[str]]:
        """
        The authentication provider to use. Valid values are `default`, `arn` and `keys`. Default is `default`. Defaults to `default`.
        """
        return pulumi.get(self, "auth_provider")

    @auth_provider.setter
    def auth_provider(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auth_provider", value)

    @property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "body", value)

    @property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @disable_resolve_message.setter
    def disable_resolve_message(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_resolve_message", value)

    @property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[pulumi.Input[str]]:
        """
        The external ID to use when assuming the role.
        """
        return pulumi.get(self, "external_id")

    @external_id.setter
    def external_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "external_id", value)

    @property
    @pulumi.getter(name="messageFormat")
    def message_format(self) -> Optional[pulumi.Input[str]]:
        """
        The format of the message to send. Valid values are `text`, `body` and `json`. Default is `text`. Defaults to `text`.
        """
        return pulumi.get(self, "message_format")

    @message_format.setter
    def message_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message_format", value)

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[pulumi.Input[str]]:
        """
        AWS secret access key used to authenticate with Amazon SNS.
        """
        return pulumi.get(self, "secret_key")

    @secret_key.setter
    def secret_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret_key", value)

    @property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "settings", value)

    @property
    @pulumi.getter
    def subject(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "subject")

    @subject.setter
    def subject(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subject", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)


if not MYPY:
    class ContactPointTeamArgsDict(TypedDict):
        url: pulumi.Input[str]
        """
        A Teams webhook URL.
        """
        disable_resolve_message: NotRequired[pulumi.Input[bool]]
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        message: NotRequired[pulumi.Input[str]]
        """
        The templated message content to send.
        """
        section_title: NotRequired[pulumi.Input[str]]
        """
        The templated subtitle for each message section.
        """
        settings: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        title: NotRequired[pulumi.Input[str]]
        """
        The templated title of the message.
        """
        uid: NotRequired[pulumi.Input[str]]
        """
        The UID of the contact point.
        """
elif False:
    ContactPointTeamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContactPointTeamArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 disable_resolve_message: Optional[pulumi.Input[bool]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 section_title: Optional[pulumi.Input[str]] = None,
                 settings: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 uid: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] url: A Teams webhook URL.
        :param pulumi.Input[bool] disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param pulumi.Input[str] message: The templated message content to send.
        :param pulumi.Input[str] section_title: The templated subtitle for each message section.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param pulumi.Input[str] title: The templated title of the message.
        :param pulumi.Input[str] uid: The UID of the contact point.
        """
        pulumi.set(__self__, "url", url)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if section_title is not None:
            pulumi.set(__self__, "section_title", section_title)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        A Teams webhook URL.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @disable_resolve_message.setter
    def disable_resolve_message(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_resolve_message", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        The templated message content to send.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter(name="sectionTitle")
    def section_title(self) -> Optional[pulumi.Input[str]]:
        """
        The templated subtitle for each message section.
        """
        return pulumi.get(self, "section_title")

    @section_title.setter
    def section_title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "section_title", value)

    @property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "settings", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        The templated title of the message.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)


if not MYPY:
    class ContactPointTelegramArgsDict(TypedDict):
        chat_id: pulumi.Input[str]
        """
        The chat ID to send messages to.
        """
        token: pulumi.Input[str]
        """
        The Telegram bot token.
        """
        disable_notifications: NotRequired[pulumi.Input[bool]]
        """
        When set users will receive a notification with no sound.
        """
        disable_resolve_message: NotRequired[pulumi.Input[bool]]
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        disable_web_page_preview: NotRequired[pulumi.Input[bool]]
        """
        When set it disables link previews for links in the message.
        """
        message: NotRequired[pulumi.Input[str]]
        """
        The templated content of the message.
        """
        message_thread_id: NotRequired[pulumi.Input[str]]
        """
        The ID of the message thread to send the message to.
        """
        parse_mode: NotRequired[pulumi.Input[str]]
        """
        Mode for parsing entities in the message text. Supported: None, Markdown, MarkdownV2, and HTML. HTML is the default.
        """
        protect_content: NotRequired[pulumi.Input[bool]]
        """
        When set it protects the contents of the message from forwarding and saving.
        """
        settings: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        uid: NotRequired[pulumi.Input[str]]
        """
        The UID of the contact point.
        """
elif False:
    ContactPointTelegramArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContactPointTelegramArgs:
    def __init__(__self__, *,
                 chat_id: pulumi.Input[str],
                 token: pulumi.Input[str],
                 disable_notifications: Optional[pulumi.Input[bool]] = None,
                 disable_resolve_message: Optional[pulumi.Input[bool]] = None,
                 disable_web_page_preview: Optional[pulumi.Input[bool]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 message_thread_id: Optional[pulumi.Input[str]] = None,
                 parse_mode: Optional[pulumi.Input[str]] = None,
                 protect_content: Optional[pulumi.Input[bool]] = None,
                 settings: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 uid: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] chat_id: The chat ID to send messages to.
        :param pulumi.Input[str] token: The Telegram bot token.
        :param pulumi.Input[bool] disable_notifications: When set users will receive a notification with no sound.
        :param pulumi.Input[bool] disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param pulumi.Input[bool] disable_web_page_preview: When set it disables link previews for links in the message.
        :param pulumi.Input[str] message: The templated content of the message.
        :param pulumi.Input[str] message_thread_id: The ID of the message thread to send the message to.
        :param pulumi.Input[str] parse_mode: Mode for parsing entities in the message text. Supported: None, Markdown, MarkdownV2, and HTML. HTML is the default.
        :param pulumi.Input[bool] protect_content: When set it protects the contents of the message from forwarding and saving.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param pulumi.Input[str] uid: The UID of the contact point.
        """
        pulumi.set(__self__, "chat_id", chat_id)
        pulumi.set(__self__, "token", token)
        if disable_notifications is not None:
            pulumi.set(__self__, "disable_notifications", disable_notifications)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if disable_web_page_preview is not None:
            pulumi.set(__self__, "disable_web_page_preview", disable_web_page_preview)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if message_thread_id is not None:
            pulumi.set(__self__, "message_thread_id", message_thread_id)
        if parse_mode is not None:
            pulumi.set(__self__, "parse_mode", parse_mode)
        if protect_content is not None:
            pulumi.set(__self__, "protect_content", protect_content)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="chatId")
    def chat_id(self) -> pulumi.Input[str]:
        """
        The chat ID to send messages to.
        """
        return pulumi.get(self, "chat_id")

    @chat_id.setter
    def chat_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "chat_id", value)

    @property
    @pulumi.getter
    def token(self) -> pulumi.Input[str]:
        """
        The Telegram bot token.
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: pulumi.Input[str]):
        pulumi.set(self, "token", value)

    @property
    @pulumi.getter(name="disableNotifications")
    def disable_notifications(self) -> Optional[pulumi.Input[bool]]:
        """
        When set users will receive a notification with no sound.
        """
        return pulumi.get(self, "disable_notifications")

    @disable_notifications.setter
    def disable_notifications(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_notifications", value)

    @property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @disable_resolve_message.setter
    def disable_resolve_message(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_resolve_message", value)

    @property
    @pulumi.getter(name="disableWebPagePreview")
    def disable_web_page_preview(self) -> Optional[pulumi.Input[bool]]:
        """
        When set it disables link previews for links in the message.
        """
        return pulumi.get(self, "disable_web_page_preview")

    @disable_web_page_preview.setter
    def disable_web_page_preview(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_web_page_preview", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        The templated content of the message.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter(name="messageThreadId")
    def message_thread_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the message thread to send the message to.
        """
        return pulumi.get(self, "message_thread_id")

    @message_thread_id.setter
    def message_thread_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message_thread_id", value)

    @property
    @pulumi.getter(name="parseMode")
    def parse_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Mode for parsing entities in the message text. Supported: None, Markdown, MarkdownV2, and HTML. HTML is the default.
        """
        return pulumi.get(self, "parse_mode")

    @parse_mode.setter
    def parse_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "parse_mode", value)

    @property
    @pulumi.getter(name="protectContent")
    def protect_content(self) -> Optional[pulumi.Input[bool]]:
        """
        When set it protects the contents of the message from forwarding and saving.
        """
        return pulumi.get(self, "protect_content")

    @protect_content.setter
    def protect_content(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "protect_content", value)

    @property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "settings", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)


if not MYPY:
    class ContactPointThreemaArgsDict(TypedDict):
        api_secret: pulumi.Input[str]
        """
        The Threema API key.
        """
        gateway_id: pulumi.Input[str]
        """
        The Threema gateway ID.
        """
        recipient_id: pulumi.Input[str]
        """
        The ID of the recipient of the message.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        The templated description of the message.
        """
        disable_resolve_message: NotRequired[pulumi.Input[bool]]
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        settings: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        title: NotRequired[pulumi.Input[str]]
        """
        The templated title of the message.
        """
        uid: NotRequired[pulumi.Input[str]]
        """
        The UID of the contact point.
        """
elif False:
    ContactPointThreemaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContactPointThreemaArgs:
    def __init__(__self__, *,
                 api_secret: pulumi.Input[str],
                 gateway_id: pulumi.Input[str],
                 recipient_id: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None,
                 disable_resolve_message: Optional[pulumi.Input[bool]] = None,
                 settings: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 uid: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] api_secret: The Threema API key.
        :param pulumi.Input[str] gateway_id: The Threema gateway ID.
        :param pulumi.Input[str] recipient_id: The ID of the recipient of the message.
        :param pulumi.Input[str] description: The templated description of the message.
        :param pulumi.Input[bool] disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param pulumi.Input[str] title: The templated title of the message.
        :param pulumi.Input[str] uid: The UID of the contact point.
        """
        pulumi.set(__self__, "api_secret", api_secret)
        pulumi.set(__self__, "gateway_id", gateway_id)
        pulumi.set(__self__, "recipient_id", recipient_id)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="apiSecret")
    def api_secret(self) -> pulumi.Input[str]:
        """
        The Threema API key.
        """
        return pulumi.get(self, "api_secret")

    @api_secret.setter
    def api_secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_secret", value)

    @property
    @pulumi.getter(name="gatewayId")
    def gateway_id(self) -> pulumi.Input[str]:
        """
        The Threema gateway ID.
        """
        return pulumi.get(self, "gateway_id")

    @gateway_id.setter
    def gateway_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "gateway_id", value)

    @property
    @pulumi.getter(name="recipientId")
    def recipient_id(self) -> pulumi.Input[str]:
        """
        The ID of the recipient of the message.
        """
        return pulumi.get(self, "recipient_id")

    @recipient_id.setter
    def recipient_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "recipient_id", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The templated description of the message.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @disable_resolve_message.setter
    def disable_resolve_message(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_resolve_message", value)

    @property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "settings", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        The templated title of the message.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)


if not MYPY:
    class ContactPointVictoropArgsDict(TypedDict):
        url: pulumi.Input[str]
        """
        The VictorOps webhook URL.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        Templated description of the message.
        """
        disable_resolve_message: NotRequired[pulumi.Input[bool]]
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        message_type: NotRequired[pulumi.Input[str]]
        """
        The VictorOps alert state - typically either `CRITICAL` or `RECOVERY`.
        """
        settings: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        title: NotRequired[pulumi.Input[str]]
        """
        Templated title to display.
        """
        uid: NotRequired[pulumi.Input[str]]
        """
        The UID of the contact point.
        """
elif False:
    ContactPointVictoropArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContactPointVictoropArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None,
                 disable_resolve_message: Optional[pulumi.Input[bool]] = None,
                 message_type: Optional[pulumi.Input[str]] = None,
                 settings: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 uid: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] url: The VictorOps webhook URL.
        :param pulumi.Input[str] description: Templated description of the message.
        :param pulumi.Input[bool] disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param pulumi.Input[str] message_type: The VictorOps alert state - typically either `CRITICAL` or `RECOVERY`.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param pulumi.Input[str] title: Templated title to display.
        :param pulumi.Input[str] uid: The UID of the contact point.
        """
        pulumi.set(__self__, "url", url)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if message_type is not None:
            pulumi.set(__self__, "message_type", message_type)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        The VictorOps webhook URL.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Templated description of the message.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @disable_resolve_message.setter
    def disable_resolve_message(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_resolve_message", value)

    @property
    @pulumi.getter(name="messageType")
    def message_type(self) -> Optional[pulumi.Input[str]]:
        """
        The VictorOps alert state - typically either `CRITICAL` or `RECOVERY`.
        """
        return pulumi.get(self, "message_type")

    @message_type.setter
    def message_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message_type", value)

    @property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "settings", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        Templated title to display.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)


if not MYPY:
    class ContactPointWebexArgsDict(TypedDict):
        api_url: NotRequired[pulumi.Input[str]]
        """
        The URL to send webhook requests to.
        """
        disable_resolve_message: NotRequired[pulumi.Input[bool]]
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        message: NotRequired[pulumi.Input[str]]
        """
        The templated title of the message to send.
        """
        room_id: NotRequired[pulumi.Input[str]]
        """
        ID of the Webex Teams room where to send the messages.
        """
        settings: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        token: NotRequired[pulumi.Input[str]]
        """
        The bearer token used to authorize the client.
        """
        uid: NotRequired[pulumi.Input[str]]
        """
        The UID of the contact point.
        """
elif False:
    ContactPointWebexArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContactPointWebexArgs:
    def __init__(__self__, *,
                 api_url: Optional[pulumi.Input[str]] = None,
                 disable_resolve_message: Optional[pulumi.Input[bool]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 room_id: Optional[pulumi.Input[str]] = None,
                 settings: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 token: Optional[pulumi.Input[str]] = None,
                 uid: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] api_url: The URL to send webhook requests to.
        :param pulumi.Input[bool] disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param pulumi.Input[str] message: The templated title of the message to send.
        :param pulumi.Input[str] room_id: ID of the Webex Teams room where to send the messages.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param pulumi.Input[str] token: The bearer token used to authorize the client.
        :param pulumi.Input[str] uid: The UID of the contact point.
        """
        if api_url is not None:
            pulumi.set(__self__, "api_url", api_url)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if room_id is not None:
            pulumi.set(__self__, "room_id", room_id)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if token is not None:
            pulumi.set(__self__, "token", token)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="apiUrl")
    def api_url(self) -> Optional[pulumi.Input[str]]:
        """
        The URL to send webhook requests to.
        """
        return pulumi.get(self, "api_url")

    @api_url.setter
    def api_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_url", value)

    @property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @disable_resolve_message.setter
    def disable_resolve_message(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_resolve_message", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        The templated title of the message to send.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter(name="roomId")
    def room_id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the Webex Teams room where to send the messages.
        """
        return pulumi.get(self, "room_id")

    @room_id.setter
    def room_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "room_id", value)

    @property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "settings", value)

    @property
    @pulumi.getter
    def token(self) -> Optional[pulumi.Input[str]]:
        """
        The bearer token used to authorize the client.
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "token", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)


if not MYPY:
    class ContactPointWebhookArgsDict(TypedDict):
        url: pulumi.Input[str]
        """
        The URL to send webhook requests to.
        """
        authorization_credentials: NotRequired[pulumi.Input[str]]
        """
        Allows a custom authorization scheme - attaches an auth header with this value. Do not use in conjunction with basic auth parameters.
        """
        authorization_scheme: NotRequired[pulumi.Input[str]]
        """
        Allows a custom authorization scheme - attaches an auth header with this name. Do not use in conjunction with basic auth parameters.
        """
        basic_auth_password: NotRequired[pulumi.Input[str]]
        """
        The username to use in basic auth headers attached to the request. If omitted, basic auth will not be used.
        """
        basic_auth_user: NotRequired[pulumi.Input[str]]
        """
        The username to use in basic auth headers attached to the request. If omitted, basic auth will not be used.
        """
        disable_resolve_message: NotRequired[pulumi.Input[bool]]
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        http_method: NotRequired[pulumi.Input[str]]
        """
        The HTTP method to use in the request. Defaults to `POST`.
        """
        max_alerts: NotRequired[pulumi.Input[int]]
        """
        The maximum number of alerts to send in a single request. This can be helpful in limiting the size of the request body. The default is 0, which indicates no limit.
        """
        message: NotRequired[pulumi.Input[str]]
        """
        Custom message. You can use template variables.
        """
        settings: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        title: NotRequired[pulumi.Input[str]]
        """
        Templated title of the message.
        """
        uid: NotRequired[pulumi.Input[str]]
        """
        The UID of the contact point.
        """
elif False:
    ContactPointWebhookArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContactPointWebhookArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 authorization_credentials: Optional[pulumi.Input[str]] = None,
                 authorization_scheme: Optional[pulumi.Input[str]] = None,
                 basic_auth_password: Optional[pulumi.Input[str]] = None,
                 basic_auth_user: Optional[pulumi.Input[str]] = None,
                 disable_resolve_message: Optional[pulumi.Input[bool]] = None,
                 http_method: Optional[pulumi.Input[str]] = None,
                 max_alerts: Optional[pulumi.Input[int]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 settings: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 uid: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] url: The URL to send webhook requests to.
        :param pulumi.Input[str] authorization_credentials: Allows a custom authorization scheme - attaches an auth header with this value. Do not use in conjunction with basic auth parameters.
        :param pulumi.Input[str] authorization_scheme: Allows a custom authorization scheme - attaches an auth header with this name. Do not use in conjunction with basic auth parameters.
        :param pulumi.Input[str] basic_auth_password: The username to use in basic auth headers attached to the request. If omitted, basic auth will not be used.
        :param pulumi.Input[str] basic_auth_user: The username to use in basic auth headers attached to the request. If omitted, basic auth will not be used.
        :param pulumi.Input[bool] disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param pulumi.Input[str] http_method: The HTTP method to use in the request. Defaults to `POST`.
        :param pulumi.Input[int] max_alerts: The maximum number of alerts to send in a single request. This can be helpful in limiting the size of the request body. The default is 0, which indicates no limit.
        :param pulumi.Input[str] message: Custom message. You can use template variables.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param pulumi.Input[str] title: Templated title of the message.
        :param pulumi.Input[str] uid: The UID of the contact point.
        """
        pulumi.set(__self__, "url", url)
        if authorization_credentials is not None:
            pulumi.set(__self__, "authorization_credentials", authorization_credentials)
        if authorization_scheme is not None:
            pulumi.set(__self__, "authorization_scheme", authorization_scheme)
        if basic_auth_password is not None:
            pulumi.set(__self__, "basic_auth_password", basic_auth_password)
        if basic_auth_user is not None:
            pulumi.set(__self__, "basic_auth_user", basic_auth_user)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if http_method is not None:
            pulumi.set(__self__, "http_method", http_method)
        if max_alerts is not None:
            pulumi.set(__self__, "max_alerts", max_alerts)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        The URL to send webhook requests to.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="authorizationCredentials")
    def authorization_credentials(self) -> Optional[pulumi.Input[str]]:
        """
        Allows a custom authorization scheme - attaches an auth header with this value. Do not use in conjunction with basic auth parameters.
        """
        return pulumi.get(self, "authorization_credentials")

    @authorization_credentials.setter
    def authorization_credentials(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "authorization_credentials", value)

    @property
    @pulumi.getter(name="authorizationScheme")
    def authorization_scheme(self) -> Optional[pulumi.Input[str]]:
        """
        Allows a custom authorization scheme - attaches an auth header with this name. Do not use in conjunction with basic auth parameters.
        """
        return pulumi.get(self, "authorization_scheme")

    @authorization_scheme.setter
    def authorization_scheme(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "authorization_scheme", value)

    @property
    @pulumi.getter(name="basicAuthPassword")
    def basic_auth_password(self) -> Optional[pulumi.Input[str]]:
        """
        The username to use in basic auth headers attached to the request. If omitted, basic auth will not be used.
        """
        return pulumi.get(self, "basic_auth_password")

    @basic_auth_password.setter
    def basic_auth_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "basic_auth_password", value)

    @property
    @pulumi.getter(name="basicAuthUser")
    def basic_auth_user(self) -> Optional[pulumi.Input[str]]:
        """
        The username to use in basic auth headers attached to the request. If omitted, basic auth will not be used.
        """
        return pulumi.get(self, "basic_auth_user")

    @basic_auth_user.setter
    def basic_auth_user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "basic_auth_user", value)

    @property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @disable_resolve_message.setter
    def disable_resolve_message(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_resolve_message", value)

    @property
    @pulumi.getter(name="httpMethod")
    def http_method(self) -> Optional[pulumi.Input[str]]:
        """
        The HTTP method to use in the request. Defaults to `POST`.
        """
        return pulumi.get(self, "http_method")

    @http_method.setter
    def http_method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "http_method", value)

    @property
    @pulumi.getter(name="maxAlerts")
    def max_alerts(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of alerts to send in a single request. This can be helpful in limiting the size of the request body. The default is 0, which indicates no limit.
        """
        return pulumi.get(self, "max_alerts")

    @max_alerts.setter
    def max_alerts(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_alerts", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        Custom message. You can use template variables.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "settings", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        Templated title of the message.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)


if not MYPY:
    class ContactPointWecomArgsDict(TypedDict):
        agent_id: NotRequired[pulumi.Input[str]]
        """
        Agent ID added to the request payload when using APIAPP.
        """
        corp_id: NotRequired[pulumi.Input[str]]
        """
        Corp ID used to get token when using APIAPP.
        """
        disable_resolve_message: NotRequired[pulumi.Input[bool]]
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        message: NotRequired[pulumi.Input[str]]
        """
        The templated content of the message to send.
        """
        msg_type: NotRequired[pulumi.Input[str]]
        """
        The type of them message. Supported: markdown, text. Default: text.
        """
        secret: NotRequired[pulumi.Input[str]]
        """
        The secret key required to obtain access token when using APIAPP. See https://work.weixin.qq.com/wework_admin/frame#apps to create APIAPP.
        """
        settings: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        title: NotRequired[pulumi.Input[str]]
        """
        The templated title of the message to send.
        """
        to_user: NotRequired[pulumi.Input[str]]
        """
        The ID of user that should receive the message. Multiple entries should be separated by '|'. Default: @all.
        """
        uid: NotRequired[pulumi.Input[str]]
        """
        The UID of the contact point.
        """
        url: NotRequired[pulumi.Input[str]]
        """
        The WeCom webhook URL. Required if using GroupRobot.
        """
elif False:
    ContactPointWecomArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContactPointWecomArgs:
    def __init__(__self__, *,
                 agent_id: Optional[pulumi.Input[str]] = None,
                 corp_id: Optional[pulumi.Input[str]] = None,
                 disable_resolve_message: Optional[pulumi.Input[bool]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 msg_type: Optional[pulumi.Input[str]] = None,
                 secret: Optional[pulumi.Input[str]] = None,
                 settings: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 to_user: Optional[pulumi.Input[str]] = None,
                 uid: Optional[pulumi.Input[str]] = None,
                 url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] agent_id: Agent ID added to the request payload when using APIAPP.
        :param pulumi.Input[str] corp_id: Corp ID used to get token when using APIAPP.
        :param pulumi.Input[bool] disable_resolve_message: Whether to disable sending resolve messages. Defaults to `false`.
        :param pulumi.Input[str] message: The templated content of the message to send.
        :param pulumi.Input[str] msg_type: The type of them message. Supported: markdown, text. Default: text.
        :param pulumi.Input[str] secret: The secret key required to obtain access token when using APIAPP. See https://work.weixin.qq.com/wework_admin/frame#apps to create APIAPP.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] settings: Additional custom properties to attach to the notifier. Defaults to `map[]`.
        :param pulumi.Input[str] title: The templated title of the message to send.
        :param pulumi.Input[str] to_user: The ID of user that should receive the message. Multiple entries should be separated by '|'. Default: @all.
        :param pulumi.Input[str] uid: The UID of the contact point.
        :param pulumi.Input[str] url: The WeCom webhook URL. Required if using GroupRobot.
        """
        if agent_id is not None:
            pulumi.set(__self__, "agent_id", agent_id)
        if corp_id is not None:
            pulumi.set(__self__, "corp_id", corp_id)
        if disable_resolve_message is not None:
            pulumi.set(__self__, "disable_resolve_message", disable_resolve_message)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if msg_type is not None:
            pulumi.set(__self__, "msg_type", msg_type)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if to_user is not None:
            pulumi.set(__self__, "to_user", to_user)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter(name="agentId")
    def agent_id(self) -> Optional[pulumi.Input[str]]:
        """
        Agent ID added to the request payload when using APIAPP.
        """
        return pulumi.get(self, "agent_id")

    @agent_id.setter
    def agent_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "agent_id", value)

    @property
    @pulumi.getter(name="corpId")
    def corp_id(self) -> Optional[pulumi.Input[str]]:
        """
        Corp ID used to get token when using APIAPP.
        """
        return pulumi.get(self, "corp_id")

    @corp_id.setter
    def corp_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "corp_id", value)

    @property
    @pulumi.getter(name="disableResolveMessage")
    def disable_resolve_message(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to disable sending resolve messages. Defaults to `false`.
        """
        return pulumi.get(self, "disable_resolve_message")

    @disable_resolve_message.setter
    def disable_resolve_message(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_resolve_message", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        The templated content of the message to send.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter(name="msgType")
    def msg_type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of them message. Supported: markdown, text. Default: text.
        """
        return pulumi.get(self, "msg_type")

    @msg_type.setter
    def msg_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "msg_type", value)

    @property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input[str]]:
        """
        The secret key required to obtain access token when using APIAPP. See https://work.weixin.qq.com/wework_admin/frame#apps to create APIAPP.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret", value)

    @property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Additional custom properties to attach to the notifier. Defaults to `map[]`.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "settings", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        The templated title of the message to send.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter(name="toUser")
    def to_user(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of user that should receive the message. Multiple entries should be separated by '|'. Default: @all.
        """
        return pulumi.get(self, "to_user")

    @to_user.setter
    def to_user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "to_user", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        The UID of the contact point.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)

    @property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[str]]:
        """
        The WeCom webhook URL. Required if using GroupRobot.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class DashboardPermissionPermissionArgsDict(TypedDict):
        permission: pulumi.Input[str]
        """
        Permission to associate with item. Must be one of `View`, `Edit`, or `Admin`.
        """
        role: NotRequired[pulumi.Input[str]]
        """
        Name of the basic role to manage permissions for. Options: `Viewer`, `Editor` or `Admin`.
        """
        team_id: NotRequired[pulumi.Input[str]]
        """
        ID of the team to manage permissions for. Defaults to `0`.
        """
        user_id: NotRequired[pulumi.Input[str]]
        """
        ID of the user or service account to manage permissions for. Defaults to `0`.
        """
elif False:
    DashboardPermissionPermissionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardPermissionPermissionArgs:
    def __init__(__self__, *,
                 permission: pulumi.Input[str],
                 role: Optional[pulumi.Input[str]] = None,
                 team_id: Optional[pulumi.Input[str]] = None,
                 user_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] permission: Permission to associate with item. Must be one of `View`, `Edit`, or `Admin`.
        :param pulumi.Input[str] role: Name of the basic role to manage permissions for. Options: `Viewer`, `Editor` or `Admin`.
        :param pulumi.Input[str] team_id: ID of the team to manage permissions for. Defaults to `0`.
        :param pulumi.Input[str] user_id: ID of the user or service account to manage permissions for. Defaults to `0`.
        """
        pulumi.set(__self__, "permission", permission)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if team_id is not None:
            pulumi.set(__self__, "team_id", team_id)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)

    @property
    @pulumi.getter
    def permission(self) -> pulumi.Input[str]:
        """
        Permission to associate with item. Must be one of `View`, `Edit`, or `Admin`.
        """
        return pulumi.get(self, "permission")

    @permission.setter
    def permission(self, value: pulumi.Input[str]):
        pulumi.set(self, "permission", value)

    @property
    @pulumi.getter
    def role(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the basic role to manage permissions for. Options: `Viewer`, `Editor` or `Admin`.
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role", value)

    @property
    @pulumi.getter(name="teamId")
    def team_id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the team to manage permissions for. Defaults to `0`.
        """
        return pulumi.get(self, "team_id")

    @team_id.setter
    def team_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "team_id", value)

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the user or service account to manage permissions for. Defaults to `0`.
        """
        return pulumi.get(self, "user_id")

    @user_id.setter
    def user_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_id", value)


if not MYPY:
    class DataSourcePermissionPermissionArgsDict(TypedDict):
        permission: pulumi.Input[str]
        """
        Permission to associate with item. Options: `Query`, `Edit` or `Admin` (`Admin` can only be used with Grafana v10.3.0+).
        """
        built_in_role: NotRequired[pulumi.Input[str]]
        """
        Name of the basic role to manage permissions for. Options: `Viewer`, `Editor` or `Admin`.
        """
        team_id: NotRequired[pulumi.Input[str]]
        """
        ID of the team to manage permissions for. Defaults to `0`.
        """
        user_id: NotRequired[pulumi.Input[str]]
        """
        ID of the user or service account to manage permissions for. Defaults to `0`.
        """
elif False:
    DataSourcePermissionPermissionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourcePermissionPermissionArgs:
    def __init__(__self__, *,
                 permission: pulumi.Input[str],
                 built_in_role: Optional[pulumi.Input[str]] = None,
                 team_id: Optional[pulumi.Input[str]] = None,
                 user_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] permission: Permission to associate with item. Options: `Query`, `Edit` or `Admin` (`Admin` can only be used with Grafana v10.3.0+).
        :param pulumi.Input[str] built_in_role: Name of the basic role to manage permissions for. Options: `Viewer`, `Editor` or `Admin`.
        :param pulumi.Input[str] team_id: ID of the team to manage permissions for. Defaults to `0`.
        :param pulumi.Input[str] user_id: ID of the user or service account to manage permissions for. Defaults to `0`.
        """
        pulumi.set(__self__, "permission", permission)
        if built_in_role is not None:
            pulumi.set(__self__, "built_in_role", built_in_role)
        if team_id is not None:
            pulumi.set(__self__, "team_id", team_id)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)

    @property
    @pulumi.getter
    def permission(self) -> pulumi.Input[str]:
        """
        Permission to associate with item. Options: `Query`, `Edit` or `Admin` (`Admin` can only be used with Grafana v10.3.0+).
        """
        return pulumi.get(self, "permission")

    @permission.setter
    def permission(self, value: pulumi.Input[str]):
        pulumi.set(self, "permission", value)

    @property
    @pulumi.getter(name="builtInRole")
    def built_in_role(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the basic role to manage permissions for. Options: `Viewer`, `Editor` or `Admin`.
        """
        return pulumi.get(self, "built_in_role")

    @built_in_role.setter
    def built_in_role(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "built_in_role", value)

    @property
    @pulumi.getter(name="teamId")
    def team_id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the team to manage permissions for. Defaults to `0`.
        """
        return pulumi.get(self, "team_id")

    @team_id.setter
    def team_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "team_id", value)

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the user or service account to manage permissions for. Defaults to `0`.
        """
        return pulumi.get(self, "user_id")

    @user_id.setter
    def user_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_id", value)


if not MYPY:
    class FolderPermissionPermissionArgsDict(TypedDict):
        permission: pulumi.Input[str]
        """
        Permission to associate with item. Must be one of `View`, `Edit`, or `Admin`.
        """
        role: NotRequired[pulumi.Input[str]]
        """
        Name of the basic role to manage permissions for. Options: `Viewer`, `Editor` or `Admin`.
        """
        team_id: NotRequired[pulumi.Input[str]]
        """
        ID of the team to manage permissions for. Defaults to `0`.
        """
        user_id: NotRequired[pulumi.Input[str]]
        """
        ID of the user or service account to manage permissions for. Defaults to `0`.
        """
elif False:
    FolderPermissionPermissionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FolderPermissionPermissionArgs:
    def __init__(__self__, *,
                 permission: pulumi.Input[str],
                 role: Optional[pulumi.Input[str]] = None,
                 team_id: Optional[pulumi.Input[str]] = None,
                 user_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] permission: Permission to associate with item. Must be one of `View`, `Edit`, or `Admin`.
        :param pulumi.Input[str] role: Name of the basic role to manage permissions for. Options: `Viewer`, `Editor` or `Admin`.
        :param pulumi.Input[str] team_id: ID of the team to manage permissions for. Defaults to `0`.
        :param pulumi.Input[str] user_id: ID of the user or service account to manage permissions for. Defaults to `0`.
        """
        pulumi.set(__self__, "permission", permission)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if team_id is not None:
            pulumi.set(__self__, "team_id", team_id)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)

    @property
    @pulumi.getter
    def permission(self) -> pulumi.Input[str]:
        """
        Permission to associate with item. Must be one of `View`, `Edit`, or `Admin`.
        """
        return pulumi.get(self, "permission")

    @permission.setter
    def permission(self, value: pulumi.Input[str]):
        pulumi.set(self, "permission", value)

    @property
    @pulumi.getter
    def role(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the basic role to manage permissions for. Options: `Viewer`, `Editor` or `Admin`.
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role", value)

    @property
    @pulumi.getter(name="teamId")
    def team_id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the team to manage permissions for. Defaults to `0`.
        """
        return pulumi.get(self, "team_id")

    @team_id.setter
    def team_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "team_id", value)

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the user or service account to manage permissions for. Defaults to `0`.
        """
        return pulumi.get(self, "user_id")

    @user_id.setter
    def user_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_id", value)


if not MYPY:
    class MachineLearningHolidayCustomPeriodArgsDict(TypedDict):
        end_time: pulumi.Input[str]
        start_time: pulumi.Input[str]
        name: NotRequired[pulumi.Input[str]]
        """
        The name of the custom period.
        """
elif False:
    MachineLearningHolidayCustomPeriodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MachineLearningHolidayCustomPeriodArgs:
    def __init__(__self__, *,
                 end_time: pulumi.Input[str],
                 start_time: pulumi.Input[str],
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the custom period.
        """
        pulumi.set(__self__, "end_time", end_time)
        pulumi.set(__self__, "start_time", start_time)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> pulumi.Input[str]:
        return pulumi.get(self, "end_time")

    @end_time.setter
    def end_time(self, value: pulumi.Input[str]):
        pulumi.set(self, "end_time", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> pulumi.Input[str]:
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_time", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the custom period.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class MachineLearningOutlierDetectorAlgorithmArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the algorithm to use ('mad' or 'dbscan').
        """
        sensitivity: pulumi.Input[float]
        """
        Specify the sensitivity of the detector (in range [0,1]).
        """
        config: NotRequired[pulumi.Input['MachineLearningOutlierDetectorAlgorithmConfigArgsDict']]
        """
        For DBSCAN only, specify the configuration map
        """
elif False:
    MachineLearningOutlierDetectorAlgorithmArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MachineLearningOutlierDetectorAlgorithmArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 sensitivity: pulumi.Input[float],
                 config: Optional[pulumi.Input['MachineLearningOutlierDetectorAlgorithmConfigArgs']] = None):
        """
        :param pulumi.Input[str] name: The name of the algorithm to use ('mad' or 'dbscan').
        :param pulumi.Input[float] sensitivity: Specify the sensitivity of the detector (in range [0,1]).
        :param pulumi.Input['MachineLearningOutlierDetectorAlgorithmConfigArgs'] config: For DBSCAN only, specify the configuration map
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "sensitivity", sensitivity)
        if config is not None:
            pulumi.set(__self__, "config", config)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the algorithm to use ('mad' or 'dbscan').
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def sensitivity(self) -> pulumi.Input[float]:
        """
        Specify the sensitivity of the detector (in range [0,1]).
        """
        return pulumi.get(self, "sensitivity")

    @sensitivity.setter
    def sensitivity(self, value: pulumi.Input[float]):
        pulumi.set(self, "sensitivity", value)

    @property
    @pulumi.getter
    def config(self) -> Optional[pulumi.Input['MachineLearningOutlierDetectorAlgorithmConfigArgs']]:
        """
        For DBSCAN only, specify the configuration map
        """
        return pulumi.get(self, "config")

    @config.setter
    def config(self, value: Optional[pulumi.Input['MachineLearningOutlierDetectorAlgorithmConfigArgs']]):
        pulumi.set(self, "config", value)


if not MYPY:
    class MachineLearningOutlierDetectorAlgorithmConfigArgsDict(TypedDict):
        epsilon: pulumi.Input[float]
        """
        Specify the epsilon parameter (positive float)
        """
elif False:
    MachineLearningOutlierDetectorAlgorithmConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MachineLearningOutlierDetectorAlgorithmConfigArgs:
    def __init__(__self__, *,
                 epsilon: pulumi.Input[float]):
        """
        :param pulumi.Input[float] epsilon: Specify the epsilon parameter (positive float)
        """
        pulumi.set(__self__, "epsilon", epsilon)

    @property
    @pulumi.getter
    def epsilon(self) -> pulumi.Input[float]:
        """
        Specify the epsilon parameter (positive float)
        """
        return pulumi.get(self, "epsilon")

    @epsilon.setter
    def epsilon(self, value: pulumi.Input[float]):
        pulumi.set(self, "epsilon", value)


if not MYPY:
    class MuteTimingIntervalArgsDict(TypedDict):
        days_of_months: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        An inclusive range of days, 1-31, within a month, e.g. "1" or "14:16". Negative values can be used to represent days counting from the end of a month, e.g. "-1".
        """
        location: NotRequired[pulumi.Input[str]]
        """
        Provides the time zone for the time interval. Must be a location in the IANA time zone database, e.g "America/New_York"
        """
        months: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        An inclusive range of months, either numerical or full calendar month, e.g. "1:3", "december", or "may:august".
        """
        times: NotRequired[pulumi.Input[Sequence[pulumi.Input['MuteTimingIntervalTimeArgsDict']]]]
        """
        The time ranges, represented in minutes, during which to mute in a given day.
        """
        weekdays: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        An inclusive range of weekdays, e.g. "monday" or "tuesday:thursday".
        """
        years: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A positive inclusive range of years, e.g. "2030" or "2025:2026".
        """
elif False:
    MuteTimingIntervalArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MuteTimingIntervalArgs:
    def __init__(__self__, *,
                 days_of_months: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 location: Optional[pulumi.Input[str]] = None,
                 months: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 times: Optional[pulumi.Input[Sequence[pulumi.Input['MuteTimingIntervalTimeArgs']]]] = None,
                 weekdays: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 years: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] days_of_months: An inclusive range of days, 1-31, within a month, e.g. "1" or "14:16". Negative values can be used to represent days counting from the end of a month, e.g. "-1".
        :param pulumi.Input[str] location: Provides the time zone for the time interval. Must be a location in the IANA time zone database, e.g "America/New_York"
        :param pulumi.Input[Sequence[pulumi.Input[str]]] months: An inclusive range of months, either numerical or full calendar month, e.g. "1:3", "december", or "may:august".
        :param pulumi.Input[Sequence[pulumi.Input['MuteTimingIntervalTimeArgs']]] times: The time ranges, represented in minutes, during which to mute in a given day.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] weekdays: An inclusive range of weekdays, e.g. "monday" or "tuesday:thursday".
        :param pulumi.Input[Sequence[pulumi.Input[str]]] years: A positive inclusive range of years, e.g. "2030" or "2025:2026".
        """
        if days_of_months is not None:
            pulumi.set(__self__, "days_of_months", days_of_months)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if months is not None:
            pulumi.set(__self__, "months", months)
        if times is not None:
            pulumi.set(__self__, "times", times)
        if weekdays is not None:
            pulumi.set(__self__, "weekdays", weekdays)
        if years is not None:
            pulumi.set(__self__, "years", years)

    @property
    @pulumi.getter(name="daysOfMonths")
    def days_of_months(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An inclusive range of days, 1-31, within a month, e.g. "1" or "14:16". Negative values can be used to represent days counting from the end of a month, e.g. "-1".
        """
        return pulumi.get(self, "days_of_months")

    @days_of_months.setter
    def days_of_months(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "days_of_months", value)

    @property
    @pulumi.getter
    def location(self) -> Optional[pulumi.Input[str]]:
        """
        Provides the time zone for the time interval. Must be a location in the IANA time zone database, e.g "America/New_York"
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "location", value)

    @property
    @pulumi.getter
    def months(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An inclusive range of months, either numerical or full calendar month, e.g. "1:3", "december", or "may:august".
        """
        return pulumi.get(self, "months")

    @months.setter
    def months(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "months", value)

    @property
    @pulumi.getter
    def times(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MuteTimingIntervalTimeArgs']]]]:
        """
        The time ranges, represented in minutes, during which to mute in a given day.
        """
        return pulumi.get(self, "times")

    @times.setter
    def times(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MuteTimingIntervalTimeArgs']]]]):
        pulumi.set(self, "times", value)

    @property
    @pulumi.getter
    def weekdays(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An inclusive range of weekdays, e.g. "monday" or "tuesday:thursday".
        """
        return pulumi.get(self, "weekdays")

    @weekdays.setter
    def weekdays(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "weekdays", value)

    @property
    @pulumi.getter
    def years(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A positive inclusive range of years, e.g. "2030" or "2025:2026".
        """
        return pulumi.get(self, "years")

    @years.setter
    def years(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "years", value)


if not MYPY:
    class MuteTimingIntervalTimeArgsDict(TypedDict):
        end: pulumi.Input[str]
        """
        The time, in hh:mm format, of when the interval should end exclusively.
        """
        start: pulumi.Input[str]
        """
        The time, in hh:mm format, of when the interval should begin inclusively.
        """
elif False:
    MuteTimingIntervalTimeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MuteTimingIntervalTimeArgs:
    def __init__(__self__, *,
                 end: pulumi.Input[str],
                 start: pulumi.Input[str]):
        """
        :param pulumi.Input[str] end: The time, in hh:mm format, of when the interval should end exclusively.
        :param pulumi.Input[str] start: The time, in hh:mm format, of when the interval should begin inclusively.
        """
        pulumi.set(__self__, "end", end)
        pulumi.set(__self__, "start", start)

    @property
    @pulumi.getter
    def end(self) -> pulumi.Input[str]:
        """
        The time, in hh:mm format, of when the interval should end exclusively.
        """
        return pulumi.get(self, "end")

    @end.setter
    def end(self, value: pulumi.Input[str]):
        pulumi.set(self, "end", value)

    @property
    @pulumi.getter
    def start(self) -> pulumi.Input[str]:
        """
        The time, in hh:mm format, of when the interval should begin inclusively.
        """
        return pulumi.get(self, "start")

    @start.setter
    def start(self, value: pulumi.Input[str]):
        pulumi.set(self, "start", value)


if not MYPY:
    class NotificationPolicyPolicyArgsDict(TypedDict):
        contact_point: NotRequired[pulumi.Input[str]]
        """
        The contact point to route notifications that match this rule to.
        """
        continue_: NotRequired[pulumi.Input[bool]]
        """
        Whether to continue matching subsequent rules if an alert matches the current rule. Otherwise, the rule will be 'consumed' by the first policy to match it.
        """
        group_bies: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping. Required for root policy only. If empty, the parent grouping is used.
        """
        group_interval: NotRequired[pulumi.Input[str]]
        """
        Minimum time interval between two notifications for the same group. Default is 5 minutes.
        """
        group_wait: NotRequired[pulumi.Input[str]]
        """
        Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.
        """
        matchers: NotRequired[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyMatcherArgsDict']]]]
        """
        Describes which labels this rule should match. When multiple matchers are supplied, an alert must match ALL matchers to be accepted by this policy. When no matchers are supplied, the rule will match all alert instances.
        """
        mute_timings: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of mute timing names to apply to alerts that match this policy.
        """
        policies: NotRequired[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyArgsDict']]]]
        """
        Routing rules for specific label sets.
        """
        repeat_interval: NotRequired[pulumi.Input[str]]
        """
        Minimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.
        """
elif False:
    NotificationPolicyPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NotificationPolicyPolicyArgs:
    def __init__(__self__, *,
                 contact_point: Optional[pulumi.Input[str]] = None,
                 continue_: Optional[pulumi.Input[bool]] = None,
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 group_interval: Optional[pulumi.Input[str]] = None,
                 group_wait: Optional[pulumi.Input[str]] = None,
                 matchers: Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyMatcherArgs']]]] = None,
                 mute_timings: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 policies: Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyArgs']]]] = None,
                 repeat_interval: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] contact_point: The contact point to route notifications that match this rule to.
        :param pulumi.Input[bool] continue_: Whether to continue matching subsequent rules if an alert matches the current rule. Otherwise, the rule will be 'consumed' by the first policy to match it.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] group_bies: A list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping. Required for root policy only. If empty, the parent grouping is used.
        :param pulumi.Input[str] group_interval: Minimum time interval between two notifications for the same group. Default is 5 minutes.
        :param pulumi.Input[str] group_wait: Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.
        :param pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyMatcherArgs']]] matchers: Describes which labels this rule should match. When multiple matchers are supplied, an alert must match ALL matchers to be accepted by this policy. When no matchers are supplied, the rule will match all alert instances.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] mute_timings: A list of mute timing names to apply to alerts that match this policy.
        :param pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyArgs']]] policies: Routing rules for specific label sets.
        :param pulumi.Input[str] repeat_interval: Minimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.
        """
        if contact_point is not None:
            pulumi.set(__self__, "contact_point", contact_point)
        if continue_ is not None:
            pulumi.set(__self__, "continue_", continue_)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if group_interval is not None:
            pulumi.set(__self__, "group_interval", group_interval)
        if group_wait is not None:
            pulumi.set(__self__, "group_wait", group_wait)
        if matchers is not None:
            pulumi.set(__self__, "matchers", matchers)
        if mute_timings is not None:
            pulumi.set(__self__, "mute_timings", mute_timings)
        if policies is not None:
            pulumi.set(__self__, "policies", policies)
        if repeat_interval is not None:
            pulumi.set(__self__, "repeat_interval", repeat_interval)

    @property
    @pulumi.getter(name="contactPoint")
    def contact_point(self) -> Optional[pulumi.Input[str]]:
        """
        The contact point to route notifications that match this rule to.
        """
        return pulumi.get(self, "contact_point")

    @contact_point.setter
    def contact_point(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "contact_point", value)

    @property
    @pulumi.getter(name="continue")
    def continue_(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to continue matching subsequent rules if an alert matches the current rule. Otherwise, the rule will be 'consumed' by the first policy to match it.
        """
        return pulumi.get(self, "continue_")

    @continue_.setter
    def continue_(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "continue_", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping. Required for root policy only. If empty, the parent grouping is used.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="groupInterval")
    def group_interval(self) -> Optional[pulumi.Input[str]]:
        """
        Minimum time interval between two notifications for the same group. Default is 5 minutes.
        """
        return pulumi.get(self, "group_interval")

    @group_interval.setter
    def group_interval(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group_interval", value)

    @property
    @pulumi.getter(name="groupWait")
    def group_wait(self) -> Optional[pulumi.Input[str]]:
        """
        Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.
        """
        return pulumi.get(self, "group_wait")

    @group_wait.setter
    def group_wait(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group_wait", value)

    @property
    @pulumi.getter
    def matchers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyMatcherArgs']]]]:
        """
        Describes which labels this rule should match. When multiple matchers are supplied, an alert must match ALL matchers to be accepted by this policy. When no matchers are supplied, the rule will match all alert instances.
        """
        return pulumi.get(self, "matchers")

    @matchers.setter
    def matchers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyMatcherArgs']]]]):
        pulumi.set(self, "matchers", value)

    @property
    @pulumi.getter(name="muteTimings")
    def mute_timings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of mute timing names to apply to alerts that match this policy.
        """
        return pulumi.get(self, "mute_timings")

    @mute_timings.setter
    def mute_timings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "mute_timings", value)

    @property
    @pulumi.getter
    def policies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyArgs']]]]:
        """
        Routing rules for specific label sets.
        """
        return pulumi.get(self, "policies")

    @policies.setter
    def policies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyArgs']]]]):
        pulumi.set(self, "policies", value)

    @property
    @pulumi.getter(name="repeatInterval")
    def repeat_interval(self) -> Optional[pulumi.Input[str]]:
        """
        Minimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.
        """
        return pulumi.get(self, "repeat_interval")

    @repeat_interval.setter
    def repeat_interval(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repeat_interval", value)


if not MYPY:
    class NotificationPolicyPolicyMatcherArgsDict(TypedDict):
        label: pulumi.Input[str]
        """
        The name of the label to match against.
        """
        match: pulumi.Input[str]
        """
        The operator to apply when matching values of the given label. Allowed operators are `=` for equality, `!=` for negated equality, `=~` for regex equality, and `!~` for negated regex equality.
        """
        value: pulumi.Input[str]
        """
        The label value to match against.
        """
elif False:
    NotificationPolicyPolicyMatcherArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NotificationPolicyPolicyMatcherArgs:
    def __init__(__self__, *,
                 label: pulumi.Input[str],
                 match: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] label: The name of the label to match against.
        :param pulumi.Input[str] match: The operator to apply when matching values of the given label. Allowed operators are `=` for equality, `!=` for negated equality, `=~` for regex equality, and `!~` for negated regex equality.
        :param pulumi.Input[str] value: The label value to match against.
        """
        pulumi.set(__self__, "label", label)
        pulumi.set(__self__, "match", match)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def label(self) -> pulumi.Input[str]:
        """
        The name of the label to match against.
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: pulumi.Input[str]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def match(self) -> pulumi.Input[str]:
        """
        The operator to apply when matching values of the given label. Allowed operators are `=` for equality, `!=` for negated equality, `=~` for regex equality, and `!~` for negated regex equality.
        """
        return pulumi.get(self, "match")

    @match.setter
    def match(self, value: pulumi.Input[str]):
        pulumi.set(self, "match", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The label value to match against.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NotificationPolicyPolicyPolicyArgsDict(TypedDict):
        contact_point: NotRequired[pulumi.Input[str]]
        """
        The contact point to route notifications that match this rule to.
        """
        continue_: NotRequired[pulumi.Input[bool]]
        """
        Whether to continue matching subsequent rules if an alert matches the current rule. Otherwise, the rule will be 'consumed' by the first policy to match it.
        """
        group_bies: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping. Required for root policy only. If empty, the parent grouping is used.
        """
        group_interval: NotRequired[pulumi.Input[str]]
        """
        Minimum time interval between two notifications for the same group. Default is 5 minutes.
        """
        group_wait: NotRequired[pulumi.Input[str]]
        """
        Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.
        """
        matchers: NotRequired[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyMatcherArgsDict']]]]
        """
        Describes which labels this rule should match. When multiple matchers are supplied, an alert must match ALL matchers to be accepted by this policy. When no matchers are supplied, the rule will match all alert instances.
        """
        mute_timings: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of mute timing names to apply to alerts that match this policy.
        """
        policies: NotRequired[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyPolicyArgsDict']]]]
        """
        Routing rules for specific label sets.
        """
        repeat_interval: NotRequired[pulumi.Input[str]]
        """
        Minimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.
        """
elif False:
    NotificationPolicyPolicyPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NotificationPolicyPolicyPolicyArgs:
    def __init__(__self__, *,
                 contact_point: Optional[pulumi.Input[str]] = None,
                 continue_: Optional[pulumi.Input[bool]] = None,
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 group_interval: Optional[pulumi.Input[str]] = None,
                 group_wait: Optional[pulumi.Input[str]] = None,
                 matchers: Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyMatcherArgs']]]] = None,
                 mute_timings: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 policies: Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyPolicyArgs']]]] = None,
                 repeat_interval: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] contact_point: The contact point to route notifications that match this rule to.
        :param pulumi.Input[bool] continue_: Whether to continue matching subsequent rules if an alert matches the current rule. Otherwise, the rule will be 'consumed' by the first policy to match it.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] group_bies: A list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping. Required for root policy only. If empty, the parent grouping is used.
        :param pulumi.Input[str] group_interval: Minimum time interval between two notifications for the same group. Default is 5 minutes.
        :param pulumi.Input[str] group_wait: Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.
        :param pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyMatcherArgs']]] matchers: Describes which labels this rule should match. When multiple matchers are supplied, an alert must match ALL matchers to be accepted by this policy. When no matchers are supplied, the rule will match all alert instances.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] mute_timings: A list of mute timing names to apply to alerts that match this policy.
        :param pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyPolicyArgs']]] policies: Routing rules for specific label sets.
        :param pulumi.Input[str] repeat_interval: Minimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.
        """
        if contact_point is not None:
            pulumi.set(__self__, "contact_point", contact_point)
        if continue_ is not None:
            pulumi.set(__self__, "continue_", continue_)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if group_interval is not None:
            pulumi.set(__self__, "group_interval", group_interval)
        if group_wait is not None:
            pulumi.set(__self__, "group_wait", group_wait)
        if matchers is not None:
            pulumi.set(__self__, "matchers", matchers)
        if mute_timings is not None:
            pulumi.set(__self__, "mute_timings", mute_timings)
        if policies is not None:
            pulumi.set(__self__, "policies", policies)
        if repeat_interval is not None:
            pulumi.set(__self__, "repeat_interval", repeat_interval)

    @property
    @pulumi.getter(name="contactPoint")
    def contact_point(self) -> Optional[pulumi.Input[str]]:
        """
        The contact point to route notifications that match this rule to.
        """
        return pulumi.get(self, "contact_point")

    @contact_point.setter
    def contact_point(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "contact_point", value)

    @property
    @pulumi.getter(name="continue")
    def continue_(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to continue matching subsequent rules if an alert matches the current rule. Otherwise, the rule will be 'consumed' by the first policy to match it.
        """
        return pulumi.get(self, "continue_")

    @continue_.setter
    def continue_(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "continue_", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping. Required for root policy only. If empty, the parent grouping is used.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="groupInterval")
    def group_interval(self) -> Optional[pulumi.Input[str]]:
        """
        Minimum time interval between two notifications for the same group. Default is 5 minutes.
        """
        return pulumi.get(self, "group_interval")

    @group_interval.setter
    def group_interval(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group_interval", value)

    @property
    @pulumi.getter(name="groupWait")
    def group_wait(self) -> Optional[pulumi.Input[str]]:
        """
        Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.
        """
        return pulumi.get(self, "group_wait")

    @group_wait.setter
    def group_wait(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group_wait", value)

    @property
    @pulumi.getter
    def matchers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyMatcherArgs']]]]:
        """
        Describes which labels this rule should match. When multiple matchers are supplied, an alert must match ALL matchers to be accepted by this policy. When no matchers are supplied, the rule will match all alert instances.
        """
        return pulumi.get(self, "matchers")

    @matchers.setter
    def matchers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyMatcherArgs']]]]):
        pulumi.set(self, "matchers", value)

    @property
    @pulumi.getter(name="muteTimings")
    def mute_timings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of mute timing names to apply to alerts that match this policy.
        """
        return pulumi.get(self, "mute_timings")

    @mute_timings.setter
    def mute_timings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "mute_timings", value)

    @property
    @pulumi.getter
    def policies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyPolicyArgs']]]]:
        """
        Routing rules for specific label sets.
        """
        return pulumi.get(self, "policies")

    @policies.setter
    def policies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyPolicyArgs']]]]):
        pulumi.set(self, "policies", value)

    @property
    @pulumi.getter(name="repeatInterval")
    def repeat_interval(self) -> Optional[pulumi.Input[str]]:
        """
        Minimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.
        """
        return pulumi.get(self, "repeat_interval")

    @repeat_interval.setter
    def repeat_interval(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repeat_interval", value)


if not MYPY:
    class NotificationPolicyPolicyPolicyMatcherArgsDict(TypedDict):
        label: pulumi.Input[str]
        """
        The name of the label to match against.
        """
        match: pulumi.Input[str]
        """
        The operator to apply when matching values of the given label. Allowed operators are `=` for equality, `!=` for negated equality, `=~` for regex equality, and `!~` for negated regex equality.
        """
        value: pulumi.Input[str]
        """
        The label value to match against.
        """
elif False:
    NotificationPolicyPolicyPolicyMatcherArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NotificationPolicyPolicyPolicyMatcherArgs:
    def __init__(__self__, *,
                 label: pulumi.Input[str],
                 match: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] label: The name of the label to match against.
        :param pulumi.Input[str] match: The operator to apply when matching values of the given label. Allowed operators are `=` for equality, `!=` for negated equality, `=~` for regex equality, and `!~` for negated regex equality.
        :param pulumi.Input[str] value: The label value to match against.
        """
        pulumi.set(__self__, "label", label)
        pulumi.set(__self__, "match", match)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def label(self) -> pulumi.Input[str]:
        """
        The name of the label to match against.
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: pulumi.Input[str]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def match(self) -> pulumi.Input[str]:
        """
        The operator to apply when matching values of the given label. Allowed operators are `=` for equality, `!=` for negated equality, `=~` for regex equality, and `!~` for negated regex equality.
        """
        return pulumi.get(self, "match")

    @match.setter
    def match(self, value: pulumi.Input[str]):
        pulumi.set(self, "match", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The label value to match against.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NotificationPolicyPolicyPolicyPolicyArgsDict(TypedDict):
        contact_point: NotRequired[pulumi.Input[str]]
        """
        The contact point to route notifications that match this rule to.
        """
        continue_: NotRequired[pulumi.Input[bool]]
        """
        Whether to continue matching subsequent rules if an alert matches the current rule. Otherwise, the rule will be 'consumed' by the first policy to match it.
        """
        group_bies: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping. Required for root policy only. If empty, the parent grouping is used.
        """
        group_interval: NotRequired[pulumi.Input[str]]
        """
        Minimum time interval between two notifications for the same group. Default is 5 minutes.
        """
        group_wait: NotRequired[pulumi.Input[str]]
        """
        Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.
        """
        matchers: NotRequired[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyPolicyMatcherArgsDict']]]]
        """
        Describes which labels this rule should match. When multiple matchers are supplied, an alert must match ALL matchers to be accepted by this policy. When no matchers are supplied, the rule will match all alert instances.
        """
        mute_timings: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of mute timing names to apply to alerts that match this policy.
        """
        policies: NotRequired[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyPolicyPolicyArgsDict']]]]
        """
        Routing rules for specific label sets.
        """
        repeat_interval: NotRequired[pulumi.Input[str]]
        """
        Minimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.
        """
elif False:
    NotificationPolicyPolicyPolicyPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NotificationPolicyPolicyPolicyPolicyArgs:
    def __init__(__self__, *,
                 contact_point: Optional[pulumi.Input[str]] = None,
                 continue_: Optional[pulumi.Input[bool]] = None,
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 group_interval: Optional[pulumi.Input[str]] = None,
                 group_wait: Optional[pulumi.Input[str]] = None,
                 matchers: Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyPolicyMatcherArgs']]]] = None,
                 mute_timings: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 policies: Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyPolicyPolicyArgs']]]] = None,
                 repeat_interval: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] contact_point: The contact point to route notifications that match this rule to.
        :param pulumi.Input[bool] continue_: Whether to continue matching subsequent rules if an alert matches the current rule. Otherwise, the rule will be 'consumed' by the first policy to match it.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] group_bies: A list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping. Required for root policy only. If empty, the parent grouping is used.
        :param pulumi.Input[str] group_interval: Minimum time interval between two notifications for the same group. Default is 5 minutes.
        :param pulumi.Input[str] group_wait: Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.
        :param pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyPolicyMatcherArgs']]] matchers: Describes which labels this rule should match. When multiple matchers are supplied, an alert must match ALL matchers to be accepted by this policy. When no matchers are supplied, the rule will match all alert instances.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] mute_timings: A list of mute timing names to apply to alerts that match this policy.
        :param pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyPolicyPolicyArgs']]] policies: Routing rules for specific label sets.
        :param pulumi.Input[str] repeat_interval: Minimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.
        """
        if contact_point is not None:
            pulumi.set(__self__, "contact_point", contact_point)
        if continue_ is not None:
            pulumi.set(__self__, "continue_", continue_)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if group_interval is not None:
            pulumi.set(__self__, "group_interval", group_interval)
        if group_wait is not None:
            pulumi.set(__self__, "group_wait", group_wait)
        if matchers is not None:
            pulumi.set(__self__, "matchers", matchers)
        if mute_timings is not None:
            pulumi.set(__self__, "mute_timings", mute_timings)
        if policies is not None:
            pulumi.set(__self__, "policies", policies)
        if repeat_interval is not None:
            pulumi.set(__self__, "repeat_interval", repeat_interval)

    @property
    @pulumi.getter(name="contactPoint")
    def contact_point(self) -> Optional[pulumi.Input[str]]:
        """
        The contact point to route notifications that match this rule to.
        """
        return pulumi.get(self, "contact_point")

    @contact_point.setter
    def contact_point(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "contact_point", value)

    @property
    @pulumi.getter(name="continue")
    def continue_(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to continue matching subsequent rules if an alert matches the current rule. Otherwise, the rule will be 'consumed' by the first policy to match it.
        """
        return pulumi.get(self, "continue_")

    @continue_.setter
    def continue_(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "continue_", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping. Required for root policy only. If empty, the parent grouping is used.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="groupInterval")
    def group_interval(self) -> Optional[pulumi.Input[str]]:
        """
        Minimum time interval between two notifications for the same group. Default is 5 minutes.
        """
        return pulumi.get(self, "group_interval")

    @group_interval.setter
    def group_interval(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group_interval", value)

    @property
    @pulumi.getter(name="groupWait")
    def group_wait(self) -> Optional[pulumi.Input[str]]:
        """
        Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.
        """
        return pulumi.get(self, "group_wait")

    @group_wait.setter
    def group_wait(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group_wait", value)

    @property
    @pulumi.getter
    def matchers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyPolicyMatcherArgs']]]]:
        """
        Describes which labels this rule should match. When multiple matchers are supplied, an alert must match ALL matchers to be accepted by this policy. When no matchers are supplied, the rule will match all alert instances.
        """
        return pulumi.get(self, "matchers")

    @matchers.setter
    def matchers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyPolicyMatcherArgs']]]]):
        pulumi.set(self, "matchers", value)

    @property
    @pulumi.getter(name="muteTimings")
    def mute_timings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of mute timing names to apply to alerts that match this policy.
        """
        return pulumi.get(self, "mute_timings")

    @mute_timings.setter
    def mute_timings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "mute_timings", value)

    @property
    @pulumi.getter
    def policies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyPolicyPolicyArgs']]]]:
        """
        Routing rules for specific label sets.
        """
        return pulumi.get(self, "policies")

    @policies.setter
    def policies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyPolicyPolicyArgs']]]]):
        pulumi.set(self, "policies", value)

    @property
    @pulumi.getter(name="repeatInterval")
    def repeat_interval(self) -> Optional[pulumi.Input[str]]:
        """
        Minimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.
        """
        return pulumi.get(self, "repeat_interval")

    @repeat_interval.setter
    def repeat_interval(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repeat_interval", value)


if not MYPY:
    class NotificationPolicyPolicyPolicyPolicyMatcherArgsDict(TypedDict):
        label: pulumi.Input[str]
        """
        The name of the label to match against.
        """
        match: pulumi.Input[str]
        """
        The operator to apply when matching values of the given label. Allowed operators are `=` for equality, `!=` for negated equality, `=~` for regex equality, and `!~` for negated regex equality.
        """
        value: pulumi.Input[str]
        """
        The label value to match against.
        """
elif False:
    NotificationPolicyPolicyPolicyPolicyMatcherArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NotificationPolicyPolicyPolicyPolicyMatcherArgs:
    def __init__(__self__, *,
                 label: pulumi.Input[str],
                 match: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] label: The name of the label to match against.
        :param pulumi.Input[str] match: The operator to apply when matching values of the given label. Allowed operators are `=` for equality, `!=` for negated equality, `=~` for regex equality, and `!~` for negated regex equality.
        :param pulumi.Input[str] value: The label value to match against.
        """
        pulumi.set(__self__, "label", label)
        pulumi.set(__self__, "match", match)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def label(self) -> pulumi.Input[str]:
        """
        The name of the label to match against.
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: pulumi.Input[str]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def match(self) -> pulumi.Input[str]:
        """
        The operator to apply when matching values of the given label. Allowed operators are `=` for equality, `!=` for negated equality, `=~` for regex equality, and `!~` for negated regex equality.
        """
        return pulumi.get(self, "match")

    @match.setter
    def match(self, value: pulumi.Input[str]):
        pulumi.set(self, "match", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The label value to match against.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NotificationPolicyPolicyPolicyPolicyPolicyArgsDict(TypedDict):
        group_bies: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        A list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping. Required for root policy only. If empty, the parent grouping is used.
        """
        contact_point: NotRequired[pulumi.Input[str]]
        """
        The contact point to route notifications that match this rule to.
        """
        continue_: NotRequired[pulumi.Input[bool]]
        """
        Whether to continue matching subsequent rules if an alert matches the current rule. Otherwise, the rule will be 'consumed' by the first policy to match it.
        """
        group_interval: NotRequired[pulumi.Input[str]]
        """
        Minimum time interval between two notifications for the same group. Default is 5 minutes.
        """
        group_wait: NotRequired[pulumi.Input[str]]
        """
        Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.
        """
        matchers: NotRequired[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyPolicyPolicyMatcherArgsDict']]]]
        """
        Describes which labels this rule should match. When multiple matchers are supplied, an alert must match ALL matchers to be accepted by this policy. When no matchers are supplied, the rule will match all alert instances.
        """
        mute_timings: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of mute timing names to apply to alerts that match this policy.
        """
        repeat_interval: NotRequired[pulumi.Input[str]]
        """
        Minimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.
        """
elif False:
    NotificationPolicyPolicyPolicyPolicyPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NotificationPolicyPolicyPolicyPolicyPolicyArgs:
    def __init__(__self__, *,
                 group_bies: pulumi.Input[Sequence[pulumi.Input[str]]],
                 contact_point: Optional[pulumi.Input[str]] = None,
                 continue_: Optional[pulumi.Input[bool]] = None,
                 group_interval: Optional[pulumi.Input[str]] = None,
                 group_wait: Optional[pulumi.Input[str]] = None,
                 matchers: Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyPolicyPolicyMatcherArgs']]]] = None,
                 mute_timings: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 repeat_interval: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] group_bies: A list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping. Required for root policy only. If empty, the parent grouping is used.
        :param pulumi.Input[str] contact_point: The contact point to route notifications that match this rule to.
        :param pulumi.Input[bool] continue_: Whether to continue matching subsequent rules if an alert matches the current rule. Otherwise, the rule will be 'consumed' by the first policy to match it.
        :param pulumi.Input[str] group_interval: Minimum time interval between two notifications for the same group. Default is 5 minutes.
        :param pulumi.Input[str] group_wait: Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.
        :param pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyPolicyPolicyMatcherArgs']]] matchers: Describes which labels this rule should match. When multiple matchers are supplied, an alert must match ALL matchers to be accepted by this policy. When no matchers are supplied, the rule will match all alert instances.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] mute_timings: A list of mute timing names to apply to alerts that match this policy.
        :param pulumi.Input[str] repeat_interval: Minimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.
        """
        pulumi.set(__self__, "group_bies", group_bies)
        if contact_point is not None:
            pulumi.set(__self__, "contact_point", contact_point)
        if continue_ is not None:
            pulumi.set(__self__, "continue_", continue_)
        if group_interval is not None:
            pulumi.set(__self__, "group_interval", group_interval)
        if group_wait is not None:
            pulumi.set(__self__, "group_wait", group_wait)
        if matchers is not None:
            pulumi.set(__self__, "matchers", matchers)
        if mute_timings is not None:
            pulumi.set(__self__, "mute_timings", mute_timings)
        if repeat_interval is not None:
            pulumi.set(__self__, "repeat_interval", repeat_interval)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping. Required for root policy only. If empty, the parent grouping is used.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="contactPoint")
    def contact_point(self) -> Optional[pulumi.Input[str]]:
        """
        The contact point to route notifications that match this rule to.
        """
        return pulumi.get(self, "contact_point")

    @contact_point.setter
    def contact_point(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "contact_point", value)

    @property
    @pulumi.getter(name="continue")
    def continue_(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to continue matching subsequent rules if an alert matches the current rule. Otherwise, the rule will be 'consumed' by the first policy to match it.
        """
        return pulumi.get(self, "continue_")

    @continue_.setter
    def continue_(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "continue_", value)

    @property
    @pulumi.getter(name="groupInterval")
    def group_interval(self) -> Optional[pulumi.Input[str]]:
        """
        Minimum time interval between two notifications for the same group. Default is 5 minutes.
        """
        return pulumi.get(self, "group_interval")

    @group_interval.setter
    def group_interval(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group_interval", value)

    @property
    @pulumi.getter(name="groupWait")
    def group_wait(self) -> Optional[pulumi.Input[str]]:
        """
        Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.
        """
        return pulumi.get(self, "group_wait")

    @group_wait.setter
    def group_wait(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group_wait", value)

    @property
    @pulumi.getter
    def matchers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyPolicyPolicyMatcherArgs']]]]:
        """
        Describes which labels this rule should match. When multiple matchers are supplied, an alert must match ALL matchers to be accepted by this policy. When no matchers are supplied, the rule will match all alert instances.
        """
        return pulumi.get(self, "matchers")

    @matchers.setter
    def matchers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyPolicyPolicyPolicyPolicyMatcherArgs']]]]):
        pulumi.set(self, "matchers", value)

    @property
    @pulumi.getter(name="muteTimings")
    def mute_timings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of mute timing names to apply to alerts that match this policy.
        """
        return pulumi.get(self, "mute_timings")

    @mute_timings.setter
    def mute_timings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "mute_timings", value)

    @property
    @pulumi.getter(name="repeatInterval")
    def repeat_interval(self) -> Optional[pulumi.Input[str]]:
        """
        Minimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.
        """
        return pulumi.get(self, "repeat_interval")

    @repeat_interval.setter
    def repeat_interval(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repeat_interval", value)


if not MYPY:
    class NotificationPolicyPolicyPolicyPolicyPolicyMatcherArgsDict(TypedDict):
        label: pulumi.Input[str]
        """
        The name of the label to match against.
        """
        match: pulumi.Input[str]
        """
        The operator to apply when matching values of the given label. Allowed operators are `=` for equality, `!=` for negated equality, `=~` for regex equality, and `!~` for negated regex equality.
        """
        value: pulumi.Input[str]
        """
        The label value to match against.
        """
elif False:
    NotificationPolicyPolicyPolicyPolicyPolicyMatcherArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NotificationPolicyPolicyPolicyPolicyPolicyMatcherArgs:
    def __init__(__self__, *,
                 label: pulumi.Input[str],
                 match: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] label: The name of the label to match against.
        :param pulumi.Input[str] match: The operator to apply when matching values of the given label. Allowed operators are `=` for equality, `!=` for negated equality, `=~` for regex equality, and `!~` for negated regex equality.
        :param pulumi.Input[str] value: The label value to match against.
        """
        pulumi.set(__self__, "label", label)
        pulumi.set(__self__, "match", match)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def label(self) -> pulumi.Input[str]:
        """
        The name of the label to match against.
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: pulumi.Input[str]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def match(self) -> pulumi.Input[str]:
        """
        The operator to apply when matching values of the given label. Allowed operators are `=` for equality, `!=` for negated equality, `=~` for regex equality, and `!~` for negated regex equality.
        """
        return pulumi.get(self, "match")

    @match.setter
    def match(self, value: pulumi.Input[str]):
        pulumi.set(self, "match", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The label value to match against.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class OncallIntegrationDefaultRouteArgsDict(TypedDict):
        escalation_chain_id: NotRequired[pulumi.Input[str]]
        """
        The ID of the escalation chain.
        """
        id: NotRequired[pulumi.Input[str]]
        msteams: NotRequired[pulumi.Input['OncallIntegrationDefaultRouteMsteamsArgsDict']]
        """
        MS teams-specific settings for a route.
        """
        slack: NotRequired[pulumi.Input['OncallIntegrationDefaultRouteSlackArgsDict']]
        """
        Slack-specific settings for a route.
        """
        telegram: NotRequired[pulumi.Input['OncallIntegrationDefaultRouteTelegramArgsDict']]
        """
        Telegram-specific settings for a route.
        """
elif False:
    OncallIntegrationDefaultRouteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OncallIntegrationDefaultRouteArgs:
    def __init__(__self__, *,
                 escalation_chain_id: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 msteams: Optional[pulumi.Input['OncallIntegrationDefaultRouteMsteamsArgs']] = None,
                 slack: Optional[pulumi.Input['OncallIntegrationDefaultRouteSlackArgs']] = None,
                 telegram: Optional[pulumi.Input['OncallIntegrationDefaultRouteTelegramArgs']] = None):
        """
        :param pulumi.Input[str] escalation_chain_id: The ID of the escalation chain.
        :param pulumi.Input['OncallIntegrationDefaultRouteMsteamsArgs'] msteams: MS teams-specific settings for a route.
        :param pulumi.Input['OncallIntegrationDefaultRouteSlackArgs'] slack: Slack-specific settings for a route.
        :param pulumi.Input['OncallIntegrationDefaultRouteTelegramArgs'] telegram: Telegram-specific settings for a route.
        """
        if escalation_chain_id is not None:
            pulumi.set(__self__, "escalation_chain_id", escalation_chain_id)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if msteams is not None:
            pulumi.set(__self__, "msteams", msteams)
        if slack is not None:
            pulumi.set(__self__, "slack", slack)
        if telegram is not None:
            pulumi.set(__self__, "telegram", telegram)

    @property
    @pulumi.getter(name="escalationChainId")
    def escalation_chain_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the escalation chain.
        """
        return pulumi.get(self, "escalation_chain_id")

    @escalation_chain_id.setter
    def escalation_chain_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "escalation_chain_id", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def msteams(self) -> Optional[pulumi.Input['OncallIntegrationDefaultRouteMsteamsArgs']]:
        """
        MS teams-specific settings for a route.
        """
        return pulumi.get(self, "msteams")

    @msteams.setter
    def msteams(self, value: Optional[pulumi.Input['OncallIntegrationDefaultRouteMsteamsArgs']]):
        pulumi.set(self, "msteams", value)

    @property
    @pulumi.getter
    def slack(self) -> Optional[pulumi.Input['OncallIntegrationDefaultRouteSlackArgs']]:
        """
        Slack-specific settings for a route.
        """
        return pulumi.get(self, "slack")

    @slack.setter
    def slack(self, value: Optional[pulumi.Input['OncallIntegrationDefaultRouteSlackArgs']]):
        pulumi.set(self, "slack", value)

    @property
    @pulumi.getter
    def telegram(self) -> Optional[pulumi.Input['OncallIntegrationDefaultRouteTelegramArgs']]:
        """
        Telegram-specific settings for a route.
        """
        return pulumi.get(self, "telegram")

    @telegram.setter
    def telegram(self, value: Optional[pulumi.Input['OncallIntegrationDefaultRouteTelegramArgs']]):
        pulumi.set(self, "telegram", value)


if not MYPY:
    class OncallIntegrationDefaultRouteMsteamsArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Enable notification in MS teams. Defaults to `true`.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        MS teams channel id. Alerts will be directed to this channel in Microsoft teams.
        """
elif False:
    OncallIntegrationDefaultRouteMsteamsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OncallIntegrationDefaultRouteMsteamsArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Enable notification in MS teams. Defaults to `true`.
        :param pulumi.Input[str] id: MS teams channel id. Alerts will be directed to this channel in Microsoft teams.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable notification in MS teams. Defaults to `true`.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        MS teams channel id. Alerts will be directed to this channel in Microsoft teams.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class OncallIntegrationDefaultRouteSlackArgsDict(TypedDict):
        channel_id: NotRequired[pulumi.Input[str]]
        """
        Slack channel id. Alerts will be directed to this channel in Slack.
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Enable notification in Slack. Defaults to `true`.
        """
elif False:
    OncallIntegrationDefaultRouteSlackArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OncallIntegrationDefaultRouteSlackArgs:
    def __init__(__self__, *,
                 channel_id: Optional[pulumi.Input[str]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] channel_id: Slack channel id. Alerts will be directed to this channel in Slack.
        :param pulumi.Input[bool] enabled: Enable notification in Slack. Defaults to `true`.
        """
        if channel_id is not None:
            pulumi.set(__self__, "channel_id", channel_id)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="channelId")
    def channel_id(self) -> Optional[pulumi.Input[str]]:
        """
        Slack channel id. Alerts will be directed to this channel in Slack.
        """
        return pulumi.get(self, "channel_id")

    @channel_id.setter
    def channel_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "channel_id", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable notification in Slack. Defaults to `true`.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class OncallIntegrationDefaultRouteTelegramArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Enable notification in Telegram. Defaults to `true`.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        Telegram channel id. Alerts will be directed to this channel in Telegram.
        """
elif False:
    OncallIntegrationDefaultRouteTelegramArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OncallIntegrationDefaultRouteTelegramArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Enable notification in Telegram. Defaults to `true`.
        :param pulumi.Input[str] id: Telegram channel id. Alerts will be directed to this channel in Telegram.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable notification in Telegram. Defaults to `true`.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Telegram channel id. Alerts will be directed to this channel in Telegram.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class OncallIntegrationTemplatesArgsDict(TypedDict):
        acknowledge_signal: NotRequired[pulumi.Input[str]]
        """
        Template for sending a signal to acknowledge the Incident.
        """
        email: NotRequired[pulumi.Input['OncallIntegrationTemplatesEmailArgsDict']]
        """
        Templates for Email.
        """
        grouping_key: NotRequired[pulumi.Input[str]]
        """
        Template for the key by which alerts are grouped.
        """
        microsoft_teams: NotRequired[pulumi.Input['OncallIntegrationTemplatesMicrosoftTeamsArgsDict']]
        """
        Templates for Microsoft Teams. **NOTE**: Microsoft Teams templates are only available on Grafana Cloud.
        """
        mobile_app: NotRequired[pulumi.Input['OncallIntegrationTemplatesMobileAppArgsDict']]
        """
        Templates for Mobile app push notifications.
        """
        phone_call: NotRequired[pulumi.Input['OncallIntegrationTemplatesPhoneCallArgsDict']]
        """
        Templates for Phone Call.
        """
        resolve_signal: NotRequired[pulumi.Input[str]]
        """
        Template for sending a signal to resolve the Incident.
        """
        slack: NotRequired[pulumi.Input['OncallIntegrationTemplatesSlackArgsDict']]
        """
        Templates for Slack.
        """
        sms: NotRequired[pulumi.Input['OncallIntegrationTemplatesSmsArgsDict']]
        """
        Templates for SMS.
        """
        source_link: NotRequired[pulumi.Input[str]]
        """
        Template for a source link.
        """
        telegram: NotRequired[pulumi.Input['OncallIntegrationTemplatesTelegramArgsDict']]
        """
        Templates for Telegram.
        """
        web: NotRequired[pulumi.Input['OncallIntegrationTemplatesWebArgsDict']]
        """
        Templates for Web.
        """
elif False:
    OncallIntegrationTemplatesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OncallIntegrationTemplatesArgs:
    def __init__(__self__, *,
                 acknowledge_signal: Optional[pulumi.Input[str]] = None,
                 email: Optional[pulumi.Input['OncallIntegrationTemplatesEmailArgs']] = None,
                 grouping_key: Optional[pulumi.Input[str]] = None,
                 microsoft_teams: Optional[pulumi.Input['OncallIntegrationTemplatesMicrosoftTeamsArgs']] = None,
                 mobile_app: Optional[pulumi.Input['OncallIntegrationTemplatesMobileAppArgs']] = None,
                 phone_call: Optional[pulumi.Input['OncallIntegrationTemplatesPhoneCallArgs']] = None,
                 resolve_signal: Optional[pulumi.Input[str]] = None,
                 slack: Optional[pulumi.Input['OncallIntegrationTemplatesSlackArgs']] = None,
                 sms: Optional[pulumi.Input['OncallIntegrationTemplatesSmsArgs']] = None,
                 source_link: Optional[pulumi.Input[str]] = None,
                 telegram: Optional[pulumi.Input['OncallIntegrationTemplatesTelegramArgs']] = None,
                 web: Optional[pulumi.Input['OncallIntegrationTemplatesWebArgs']] = None):
        """
        :param pulumi.Input[str] acknowledge_signal: Template for sending a signal to acknowledge the Incident.
        :param pulumi.Input['OncallIntegrationTemplatesEmailArgs'] email: Templates for Email.
        :param pulumi.Input[str] grouping_key: Template for the key by which alerts are grouped.
        :param pulumi.Input['OncallIntegrationTemplatesMicrosoftTeamsArgs'] microsoft_teams: Templates for Microsoft Teams. **NOTE**: Microsoft Teams templates are only available on Grafana Cloud.
        :param pulumi.Input['OncallIntegrationTemplatesMobileAppArgs'] mobile_app: Templates for Mobile app push notifications.
        :param pulumi.Input['OncallIntegrationTemplatesPhoneCallArgs'] phone_call: Templates for Phone Call.
        :param pulumi.Input[str] resolve_signal: Template for sending a signal to resolve the Incident.
        :param pulumi.Input['OncallIntegrationTemplatesSlackArgs'] slack: Templates for Slack.
        :param pulumi.Input['OncallIntegrationTemplatesSmsArgs'] sms: Templates for SMS.
        :param pulumi.Input[str] source_link: Template for a source link.
        :param pulumi.Input['OncallIntegrationTemplatesTelegramArgs'] telegram: Templates for Telegram.
        :param pulumi.Input['OncallIntegrationTemplatesWebArgs'] web: Templates for Web.
        """
        if acknowledge_signal is not None:
            pulumi.set(__self__, "acknowledge_signal", acknowledge_signal)
        if email is not None:
            pulumi.set(__self__, "email", email)
        if grouping_key is not None:
            pulumi.set(__self__, "grouping_key", grouping_key)
        if microsoft_teams is not None:
            pulumi.set(__self__, "microsoft_teams", microsoft_teams)
        if mobile_app is not None:
            pulumi.set(__self__, "mobile_app", mobile_app)
        if phone_call is not None:
            pulumi.set(__self__, "phone_call", phone_call)
        if resolve_signal is not None:
            pulumi.set(__self__, "resolve_signal", resolve_signal)
        if slack is not None:
            pulumi.set(__self__, "slack", slack)
        if sms is not None:
            pulumi.set(__self__, "sms", sms)
        if source_link is not None:
            pulumi.set(__self__, "source_link", source_link)
        if telegram is not None:
            pulumi.set(__self__, "telegram", telegram)
        if web is not None:
            pulumi.set(__self__, "web", web)

    @property
    @pulumi.getter(name="acknowledgeSignal")
    def acknowledge_signal(self) -> Optional[pulumi.Input[str]]:
        """
        Template for sending a signal to acknowledge the Incident.
        """
        return pulumi.get(self, "acknowledge_signal")

    @acknowledge_signal.setter
    def acknowledge_signal(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "acknowledge_signal", value)

    @property
    @pulumi.getter
    def email(self) -> Optional[pulumi.Input['OncallIntegrationTemplatesEmailArgs']]:
        """
        Templates for Email.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: Optional[pulumi.Input['OncallIntegrationTemplatesEmailArgs']]):
        pulumi.set(self, "email", value)

    @property
    @pulumi.getter(name="groupingKey")
    def grouping_key(self) -> Optional[pulumi.Input[str]]:
        """
        Template for the key by which alerts are grouped.
        """
        return pulumi.get(self, "grouping_key")

    @grouping_key.setter
    def grouping_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "grouping_key", value)

    @property
    @pulumi.getter(name="microsoftTeams")
    def microsoft_teams(self) -> Optional[pulumi.Input['OncallIntegrationTemplatesMicrosoftTeamsArgs']]:
        """
        Templates for Microsoft Teams. **NOTE**: Microsoft Teams templates are only available on Grafana Cloud.
        """
        return pulumi.get(self, "microsoft_teams")

    @microsoft_teams.setter
    def microsoft_teams(self, value: Optional[pulumi.Input['OncallIntegrationTemplatesMicrosoftTeamsArgs']]):
        pulumi.set(self, "microsoft_teams", value)

    @property
    @pulumi.getter(name="mobileApp")
    def mobile_app(self) -> Optional[pulumi.Input['OncallIntegrationTemplatesMobileAppArgs']]:
        """
        Templates for Mobile app push notifications.
        """
        return pulumi.get(self, "mobile_app")

    @mobile_app.setter
    def mobile_app(self, value: Optional[pulumi.Input['OncallIntegrationTemplatesMobileAppArgs']]):
        pulumi.set(self, "mobile_app", value)

    @property
    @pulumi.getter(name="phoneCall")
    def phone_call(self) -> Optional[pulumi.Input['OncallIntegrationTemplatesPhoneCallArgs']]:
        """
        Templates for Phone Call.
        """
        return pulumi.get(self, "phone_call")

    @phone_call.setter
    def phone_call(self, value: Optional[pulumi.Input['OncallIntegrationTemplatesPhoneCallArgs']]):
        pulumi.set(self, "phone_call", value)

    @property
    @pulumi.getter(name="resolveSignal")
    def resolve_signal(self) -> Optional[pulumi.Input[str]]:
        """
        Template for sending a signal to resolve the Incident.
        """
        return pulumi.get(self, "resolve_signal")

    @resolve_signal.setter
    def resolve_signal(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resolve_signal", value)

    @property
    @pulumi.getter
    def slack(self) -> Optional[pulumi.Input['OncallIntegrationTemplatesSlackArgs']]:
        """
        Templates for Slack.
        """
        return pulumi.get(self, "slack")

    @slack.setter
    def slack(self, value: Optional[pulumi.Input['OncallIntegrationTemplatesSlackArgs']]):
        pulumi.set(self, "slack", value)

    @property
    @pulumi.getter
    def sms(self) -> Optional[pulumi.Input['OncallIntegrationTemplatesSmsArgs']]:
        """
        Templates for SMS.
        """
        return pulumi.get(self, "sms")

    @sms.setter
    def sms(self, value: Optional[pulumi.Input['OncallIntegrationTemplatesSmsArgs']]):
        pulumi.set(self, "sms", value)

    @property
    @pulumi.getter(name="sourceLink")
    def source_link(self) -> Optional[pulumi.Input[str]]:
        """
        Template for a source link.
        """
        return pulumi.get(self, "source_link")

    @source_link.setter
    def source_link(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_link", value)

    @property
    @pulumi.getter
    def telegram(self) -> Optional[pulumi.Input['OncallIntegrationTemplatesTelegramArgs']]:
        """
        Templates for Telegram.
        """
        return pulumi.get(self, "telegram")

    @telegram.setter
    def telegram(self, value: Optional[pulumi.Input['OncallIntegrationTemplatesTelegramArgs']]):
        pulumi.set(self, "telegram", value)

    @property
    @pulumi.getter
    def web(self) -> Optional[pulumi.Input['OncallIntegrationTemplatesWebArgs']]:
        """
        Templates for Web.
        """
        return pulumi.get(self, "web")

    @web.setter
    def web(self, value: Optional[pulumi.Input['OncallIntegrationTemplatesWebArgs']]):
        pulumi.set(self, "web", value)


if not MYPY:
    class OncallIntegrationTemplatesEmailArgsDict(TypedDict):
        message: NotRequired[pulumi.Input[str]]
        """
        Template for Alert message.
        """
        title: NotRequired[pulumi.Input[str]]
        """
        Template for Alert title.
        """
elif False:
    OncallIntegrationTemplatesEmailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OncallIntegrationTemplatesEmailArgs:
    def __init__(__self__, *,
                 message: Optional[pulumi.Input[str]] = None,
                 title: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] message: Template for Alert message.
        :param pulumi.Input[str] title: Template for Alert title.
        """
        if message is not None:
            pulumi.set(__self__, "message", message)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        Template for Alert message.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        Template for Alert title.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)


if not MYPY:
    class OncallIntegrationTemplatesMicrosoftTeamsArgsDict(TypedDict):
        image_url: NotRequired[pulumi.Input[str]]
        """
        Template for Alert image url.
        """
        message: NotRequired[pulumi.Input[str]]
        """
        Template for Alert message.
        """
        title: NotRequired[pulumi.Input[str]]
        """
        Template for Alert title.
        """
elif False:
    OncallIntegrationTemplatesMicrosoftTeamsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OncallIntegrationTemplatesMicrosoftTeamsArgs:
    def __init__(__self__, *,
                 image_url: Optional[pulumi.Input[str]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 title: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] image_url: Template for Alert image url.
        :param pulumi.Input[str] message: Template for Alert message.
        :param pulumi.Input[str] title: Template for Alert title.
        """
        if image_url is not None:
            pulumi.set(__self__, "image_url", image_url)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[pulumi.Input[str]]:
        """
        Template for Alert image url.
        """
        return pulumi.get(self, "image_url")

    @image_url.setter
    def image_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image_url", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        Template for Alert message.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        Template for Alert title.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)


if not MYPY:
    class OncallIntegrationTemplatesMobileAppArgsDict(TypedDict):
        message: NotRequired[pulumi.Input[str]]
        """
        Template for Alert message.
        """
        title: NotRequired[pulumi.Input[str]]
        """
        Template for Alert title.
        """
elif False:
    OncallIntegrationTemplatesMobileAppArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OncallIntegrationTemplatesMobileAppArgs:
    def __init__(__self__, *,
                 message: Optional[pulumi.Input[str]] = None,
                 title: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] message: Template for Alert message.
        :param pulumi.Input[str] title: Template for Alert title.
        """
        if message is not None:
            pulumi.set(__self__, "message", message)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        Template for Alert message.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        Template for Alert title.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)


if not MYPY:
    class OncallIntegrationTemplatesPhoneCallArgsDict(TypedDict):
        title: NotRequired[pulumi.Input[str]]
        """
        Template for Alert title.
        """
elif False:
    OncallIntegrationTemplatesPhoneCallArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OncallIntegrationTemplatesPhoneCallArgs:
    def __init__(__self__, *,
                 title: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] title: Template for Alert title.
        """
        if title is not None:
            pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        Template for Alert title.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)


if not MYPY:
    class OncallIntegrationTemplatesSlackArgsDict(TypedDict):
        image_url: NotRequired[pulumi.Input[str]]
        """
        Template for Alert image url.
        """
        message: NotRequired[pulumi.Input[str]]
        """
        Template for Alert message.
        """
        title: NotRequired[pulumi.Input[str]]
        """
        Template for Alert title.
        """
elif False:
    OncallIntegrationTemplatesSlackArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OncallIntegrationTemplatesSlackArgs:
    def __init__(__self__, *,
                 image_url: Optional[pulumi.Input[str]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 title: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] image_url: Template for Alert image url.
        :param pulumi.Input[str] message: Template for Alert message.
        :param pulumi.Input[str] title: Template for Alert title.
        """
        if image_url is not None:
            pulumi.set(__self__, "image_url", image_url)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[pulumi.Input[str]]:
        """
        Template for Alert image url.
        """
        return pulumi.get(self, "image_url")

    @image_url.setter
    def image_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image_url", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        Template for Alert message.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        Template for Alert title.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)


if not MYPY:
    class OncallIntegrationTemplatesSmsArgsDict(TypedDict):
        title: NotRequired[pulumi.Input[str]]
        """
        Template for Alert title.
        """
elif False:
    OncallIntegrationTemplatesSmsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OncallIntegrationTemplatesSmsArgs:
    def __init__(__self__, *,
                 title: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] title: Template for Alert title.
        """
        if title is not None:
            pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        Template for Alert title.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)


if not MYPY:
    class OncallIntegrationTemplatesTelegramArgsDict(TypedDict):
        image_url: NotRequired[pulumi.Input[str]]
        """
        Template for Alert image url.
        """
        message: NotRequired[pulumi.Input[str]]
        """
        Template for Alert message.
        """
        title: NotRequired[pulumi.Input[str]]
        """
        Template for Alert title.
        """
elif False:
    OncallIntegrationTemplatesTelegramArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OncallIntegrationTemplatesTelegramArgs:
    def __init__(__self__, *,
                 image_url: Optional[pulumi.Input[str]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 title: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] image_url: Template for Alert image url.
        :param pulumi.Input[str] message: Template for Alert message.
        :param pulumi.Input[str] title: Template for Alert title.
        """
        if image_url is not None:
            pulumi.set(__self__, "image_url", image_url)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[pulumi.Input[str]]:
        """
        Template for Alert image url.
        """
        return pulumi.get(self, "image_url")

    @image_url.setter
    def image_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image_url", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        Template for Alert message.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        Template for Alert title.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)


if not MYPY:
    class OncallIntegrationTemplatesWebArgsDict(TypedDict):
        image_url: NotRequired[pulumi.Input[str]]
        """
        Template for Alert image url.
        """
        message: NotRequired[pulumi.Input[str]]
        """
        Template for Alert message.
        """
        title: NotRequired[pulumi.Input[str]]
        """
        Template for Alert title.
        """
elif False:
    OncallIntegrationTemplatesWebArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OncallIntegrationTemplatesWebArgs:
    def __init__(__self__, *,
                 image_url: Optional[pulumi.Input[str]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 title: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] image_url: Template for Alert image url.
        :param pulumi.Input[str] message: Template for Alert message.
        :param pulumi.Input[str] title: Template for Alert title.
        """
        if image_url is not None:
            pulumi.set(__self__, "image_url", image_url)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[pulumi.Input[str]]:
        """
        Template for Alert image url.
        """
        return pulumi.get(self, "image_url")

    @image_url.setter
    def image_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image_url", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        Template for Alert message.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        Template for Alert title.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)


if not MYPY:
    class OncallRouteMsteamsArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Enable notification in MS teams. Defaults to `true`.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        MS teams channel id. Alerts will be directed to this channel in Microsoft teams.
        """
elif False:
    OncallRouteMsteamsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OncallRouteMsteamsArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Enable notification in MS teams. Defaults to `true`.
        :param pulumi.Input[str] id: MS teams channel id. Alerts will be directed to this channel in Microsoft teams.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable notification in MS teams. Defaults to `true`.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        MS teams channel id. Alerts will be directed to this channel in Microsoft teams.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class OncallRouteSlackArgsDict(TypedDict):
        channel_id: NotRequired[pulumi.Input[str]]
        """
        Slack channel id. Alerts will be directed to this channel in Slack.
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Enable notification in Slack. Defaults to `true`.
        """
elif False:
    OncallRouteSlackArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OncallRouteSlackArgs:
    def __init__(__self__, *,
                 channel_id: Optional[pulumi.Input[str]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] channel_id: Slack channel id. Alerts will be directed to this channel in Slack.
        :param pulumi.Input[bool] enabled: Enable notification in Slack. Defaults to `true`.
        """
        if channel_id is not None:
            pulumi.set(__self__, "channel_id", channel_id)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="channelId")
    def channel_id(self) -> Optional[pulumi.Input[str]]:
        """
        Slack channel id. Alerts will be directed to this channel in Slack.
        """
        return pulumi.get(self, "channel_id")

    @channel_id.setter
    def channel_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "channel_id", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable notification in Slack. Defaults to `true`.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class OncallRouteTelegramArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Enable notification in Telegram. Defaults to `true`.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        Telegram channel id. Alerts will be directed to this channel in Telegram.
        """
elif False:
    OncallRouteTelegramArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OncallRouteTelegramArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Enable notification in Telegram. Defaults to `true`.
        :param pulumi.Input[str] id: Telegram channel id. Alerts will be directed to this channel in Telegram.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable notification in Telegram. Defaults to `true`.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Telegram channel id. Alerts will be directed to this channel in Telegram.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class OncallScheduleSlackArgsDict(TypedDict):
        channel_id: NotRequired[pulumi.Input[str]]
        """
        Slack channel id. Reminder about schedule shifts will be directed to this channel in Slack.
        """
        user_group_id: NotRequired[pulumi.Input[str]]
        """
        Slack user group id. Members of user group will be updated when on-call users change.
        """
elif False:
    OncallScheduleSlackArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OncallScheduleSlackArgs:
    def __init__(__self__, *,
                 channel_id: Optional[pulumi.Input[str]] = None,
                 user_group_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] channel_id: Slack channel id. Reminder about schedule shifts will be directed to this channel in Slack.
        :param pulumi.Input[str] user_group_id: Slack user group id. Members of user group will be updated when on-call users change.
        """
        if channel_id is not None:
            pulumi.set(__self__, "channel_id", channel_id)
        if user_group_id is not None:
            pulumi.set(__self__, "user_group_id", user_group_id)

    @property
    @pulumi.getter(name="channelId")
    def channel_id(self) -> Optional[pulumi.Input[str]]:
        """
        Slack channel id. Reminder about schedule shifts will be directed to this channel in Slack.
        """
        return pulumi.get(self, "channel_id")

    @channel_id.setter
    def channel_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "channel_id", value)

    @property
    @pulumi.getter(name="userGroupId")
    def user_group_id(self) -> Optional[pulumi.Input[str]]:
        """
        Slack user group id. Members of user group will be updated when on-call users change.
        """
        return pulumi.get(self, "user_group_id")

    @user_group_id.setter
    def user_group_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_group_id", value)


if not MYPY:
    class PlaylistItemArgsDict(TypedDict):
        order: pulumi.Input[int]
        title: pulumi.Input[str]
        id: NotRequired[pulumi.Input[str]]
        type: NotRequired[pulumi.Input[str]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    PlaylistItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlaylistItemArgs:
    def __init__(__self__, *,
                 order: pulumi.Input[int],
                 title: pulumi.Input[str],
                 id: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "order", order)
        pulumi.set(__self__, "title", title)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[int]:
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[int]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def title(self) -> pulumi.Input[str]:
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[str]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ReportDashboardArgsDict(TypedDict):
        uid: pulumi.Input[str]
        """
        Dashboard uid.
        """
        report_variables: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Add report variables to the dashboard. Values should be separated by commas.
        """
        time_range: NotRequired[pulumi.Input['ReportDashboardTimeRangeArgsDict']]
        """
        Time range of the report.
        """
elif False:
    ReportDashboardArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ReportDashboardArgs:
    def __init__(__self__, *,
                 uid: pulumi.Input[str],
                 report_variables: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 time_range: Optional[pulumi.Input['ReportDashboardTimeRangeArgs']] = None):
        """
        :param pulumi.Input[str] uid: Dashboard uid.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] report_variables: Add report variables to the dashboard. Values should be separated by commas.
        :param pulumi.Input['ReportDashboardTimeRangeArgs'] time_range: Time range of the report.
        """
        pulumi.set(__self__, "uid", uid)
        if report_variables is not None:
            pulumi.set(__self__, "report_variables", report_variables)
        if time_range is not None:
            pulumi.set(__self__, "time_range", time_range)

    @property
    @pulumi.getter
    def uid(self) -> pulumi.Input[str]:
        """
        Dashboard uid.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: pulumi.Input[str]):
        pulumi.set(self, "uid", value)

    @property
    @pulumi.getter(name="reportVariables")
    def report_variables(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Add report variables to the dashboard. Values should be separated by commas.
        """
        return pulumi.get(self, "report_variables")

    @report_variables.setter
    def report_variables(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "report_variables", value)

    @property
    @pulumi.getter(name="timeRange")
    def time_range(self) -> Optional[pulumi.Input['ReportDashboardTimeRangeArgs']]:
        """
        Time range of the report.
        """
        return pulumi.get(self, "time_range")

    @time_range.setter
    def time_range(self, value: Optional[pulumi.Input['ReportDashboardTimeRangeArgs']]):
        pulumi.set(self, "time_range", value)


if not MYPY:
    class ReportDashboardTimeRangeArgsDict(TypedDict):
        from_: NotRequired[pulumi.Input[str]]
        """
        Start of the time range.
        """
        to: NotRequired[pulumi.Input[str]]
        """
        End of the time range.
        """
elif False:
    ReportDashboardTimeRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ReportDashboardTimeRangeArgs:
    def __init__(__self__, *,
                 from_: Optional[pulumi.Input[str]] = None,
                 to: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] from_: Start of the time range.
        :param pulumi.Input[str] to: End of the time range.
        """
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[pulumi.Input[str]]:
        """
        Start of the time range.
        """
        return pulumi.get(self, "from_")

    @from_.setter
    def from_(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "from_", value)

    @property
    @pulumi.getter
    def to(self) -> Optional[pulumi.Input[str]]:
        """
        End of the time range.
        """
        return pulumi.get(self, "to")

    @to.setter
    def to(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "to", value)


if not MYPY:
    class ReportScheduleArgsDict(TypedDict):
        frequency: pulumi.Input[str]
        """
        Frequency of the report. Allowed values: `never`, `once`, `hourly`, `daily`, `weekly`, `monthly`, `custom`.
        """
        custom_interval: NotRequired[pulumi.Input[str]]
        """
        Custom interval of the report.
        **Note:** This field is only available when frequency is set to `custom`.
        """
        end_time: NotRequired[pulumi.Input[str]]
        """
        End time of the report. If empty, the report will be sent indefinitely (according to frequency). Note that times will be saved as UTC in Grafana. Use 2006-01-02T15:04:05 format if you want to set a custom timezone
        """
        last_day_of_month: NotRequired[pulumi.Input[bool]]
        """
        Send the report on the last day of the month Defaults to `false`.
        """
        start_time: NotRequired[pulumi.Input[str]]
        """
        Start time of the report. If empty, the start date will be set to the creation time. Note that times will be saved as UTC in Grafana. Use 2006-01-02T15:04:05 format if you want to set a custom timezone
        """
        timezone: NotRequired[pulumi.Input[str]]
        """
        Set the report time zone. Defaults to `GMT`.
        """
        workdays_only: NotRequired[pulumi.Input[bool]]
        """
        Whether to send the report only on work days. Defaults to `false`.
        """
elif False:
    ReportScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ReportScheduleArgs:
    def __init__(__self__, *,
                 frequency: pulumi.Input[str],
                 custom_interval: Optional[pulumi.Input[str]] = None,
                 end_time: Optional[pulumi.Input[str]] = None,
                 last_day_of_month: Optional[pulumi.Input[bool]] = None,
                 start_time: Optional[pulumi.Input[str]] = None,
                 timezone: Optional[pulumi.Input[str]] = None,
                 workdays_only: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] frequency: Frequency of the report. Allowed values: `never`, `once`, `hourly`, `daily`, `weekly`, `monthly`, `custom`.
        :param pulumi.Input[str] custom_interval: Custom interval of the report.
               **Note:** This field is only available when frequency is set to `custom`.
        :param pulumi.Input[str] end_time: End time of the report. If empty, the report will be sent indefinitely (according to frequency). Note that times will be saved as UTC in Grafana. Use 2006-01-02T15:04:05 format if you want to set a custom timezone
        :param pulumi.Input[bool] last_day_of_month: Send the report on the last day of the month Defaults to `false`.
        :param pulumi.Input[str] start_time: Start time of the report. If empty, the start date will be set to the creation time. Note that times will be saved as UTC in Grafana. Use 2006-01-02T15:04:05 format if you want to set a custom timezone
        :param pulumi.Input[str] timezone: Set the report time zone. Defaults to `GMT`.
        :param pulumi.Input[bool] workdays_only: Whether to send the report only on work days. Defaults to `false`.
        """
        pulumi.set(__self__, "frequency", frequency)
        if custom_interval is not None:
            pulumi.set(__self__, "custom_interval", custom_interval)
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if last_day_of_month is not None:
            pulumi.set(__self__, "last_day_of_month", last_day_of_month)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)
        if timezone is not None:
            pulumi.set(__self__, "timezone", timezone)
        if workdays_only is not None:
            pulumi.set(__self__, "workdays_only", workdays_only)

    @property
    @pulumi.getter
    def frequency(self) -> pulumi.Input[str]:
        """
        Frequency of the report. Allowed values: `never`, `once`, `hourly`, `daily`, `weekly`, `monthly`, `custom`.
        """
        return pulumi.get(self, "frequency")

    @frequency.setter
    def frequency(self, value: pulumi.Input[str]):
        pulumi.set(self, "frequency", value)

    @property
    @pulumi.getter(name="customInterval")
    def custom_interval(self) -> Optional[pulumi.Input[str]]:
        """
        Custom interval of the report.
        **Note:** This field is only available when frequency is set to `custom`.
        """
        return pulumi.get(self, "custom_interval")

    @custom_interval.setter
    def custom_interval(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_interval", value)

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[pulumi.Input[str]]:
        """
        End time of the report. If empty, the report will be sent indefinitely (according to frequency). Note that times will be saved as UTC in Grafana. Use 2006-01-02T15:04:05 format if you want to set a custom timezone
        """
        return pulumi.get(self, "end_time")

    @end_time.setter
    def end_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "end_time", value)

    @property
    @pulumi.getter(name="lastDayOfMonth")
    def last_day_of_month(self) -> Optional[pulumi.Input[bool]]:
        """
        Send the report on the last day of the month Defaults to `false`.
        """
        return pulumi.get(self, "last_day_of_month")

    @last_day_of_month.setter
    def last_day_of_month(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "last_day_of_month", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input[str]]:
        """
        Start time of the report. If empty, the start date will be set to the creation time. Note that times will be saved as UTC in Grafana. Use 2006-01-02T15:04:05 format if you want to set a custom timezone
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_time", value)

    @property
    @pulumi.getter
    def timezone(self) -> Optional[pulumi.Input[str]]:
        """
        Set the report time zone. Defaults to `GMT`.
        """
        return pulumi.get(self, "timezone")

    @timezone.setter
    def timezone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timezone", value)

    @property
    @pulumi.getter(name="workdaysOnly")
    def workdays_only(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to send the report only on work days. Defaults to `false`.
        """
        return pulumi.get(self, "workdays_only")

    @workdays_only.setter
    def workdays_only(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "workdays_only", value)


if not MYPY:
    class RolePermissionArgsDict(TypedDict):
        action: pulumi.Input[str]
        """
        Specific action users granted with the role will be allowed to perform (for example: `users:read`)
        """
        scope: NotRequired[pulumi.Input[str]]
        """
        Scope to restrict the action to a set of resources (for example: `users:*` or `roles:customrole1`) Defaults to ``.
        """
elif False:
    RolePermissionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RolePermissionArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[str],
                 scope: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] action: Specific action users granted with the role will be allowed to perform (for example: `users:read`)
        :param pulumi.Input[str] scope: Scope to restrict the action to a set of resources (for example: `users:*` or `roles:customrole1`) Defaults to ``.
        """
        pulumi.set(__self__, "action", action)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input[str]:
        """
        Specific action users granted with the role will be allowed to perform (for example: `users:read`)
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[str]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def scope(self) -> Optional[pulumi.Input[str]]:
        """
        Scope to restrict the action to a set of resources (for example: `users:*` or `roles:customrole1`) Defaults to ``.
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scope", value)


if not MYPY:
    class RuleGroupRuleArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        The `ref_id` of the query node in the `data` field to use as the alert condition.
        """
        datas: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleDataArgsDict']]]
        """
        A sequence of stages that describe the contents of the rule.
        """
        name: pulumi.Input[str]
        """
        The name of the alert rule.
        """
        annotations: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Key-value pairs of metadata to attach to the alert rule. They add additional information, such as a `summary` or `runbook_url`, to help identify and investigate alerts. The `dashboardUId` and `panelId` annotations, which link alerts to a panel, must be set together. Defaults to `map[]`.
        """
        exec_err_state: NotRequired[pulumi.Input[str]]
        """
        Describes what state to enter when the rule's query is invalid and the rule cannot be executed. Options are OK, Error, KeepLast, and Alerting. Defaults to `Alerting`.
        """
        for_: NotRequired[pulumi.Input[str]]
        """
        The amount of time for which the rule must be breached for the rule to be considered to be Firing. Before this time has elapsed, the rule is only considered to be Pending. Defaults to `0`.
        """
        is_paused: NotRequired[pulumi.Input[bool]]
        """
        Sets whether the alert should be paused or not. Defaults to `false`.
        """
        labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Key-value pairs to attach to the alert rule that can be used in matching, grouping, and routing. Defaults to `map[]`.
        """
        no_data_state: NotRequired[pulumi.Input[str]]
        """
        Describes what state to enter when the rule's query returns No Data. Options are OK, NoData, KeepLast, and Alerting. Defaults to `NoData`.
        """
        notification_settings: NotRequired[pulumi.Input['RuleGroupRuleNotificationSettingsArgsDict']]
        """
        Notification settings for the rule. If specified, it overrides the notification policies. Available since Grafana 10.4, requires feature flag 'alertingSimplifiedRouting' to be enabled.
        """
        record: NotRequired[pulumi.Input['RuleGroupRuleRecordArgsDict']]
        """
        Settings for a recording rule. Available since Grafana 11.2, requires feature flag 'grafanaManagedRecordingRules' to be enabled.
        """
        uid: NotRequired[pulumi.Input[str]]
        """
        The unique identifier of the alert rule.
        """
elif False:
    RuleGroupRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 datas: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleDataArgs']]],
                 name: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 exec_err_state: Optional[pulumi.Input[str]] = None,
                 for_: Optional[pulumi.Input[str]] = None,
                 is_paused: Optional[pulumi.Input[bool]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 no_data_state: Optional[pulumi.Input[str]] = None,
                 notification_settings: Optional[pulumi.Input['RuleGroupRuleNotificationSettingsArgs']] = None,
                 record: Optional[pulumi.Input['RuleGroupRuleRecordArgs']] = None,
                 uid: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] condition: The `ref_id` of the query node in the `data` field to use as the alert condition.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleDataArgs']]] datas: A sequence of stages that describe the contents of the rule.
        :param pulumi.Input[str] name: The name of the alert rule.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] annotations: Key-value pairs of metadata to attach to the alert rule. They add additional information, such as a `summary` or `runbook_url`, to help identify and investigate alerts. The `dashboardUId` and `panelId` annotations, which link alerts to a panel, must be set together. Defaults to `map[]`.
        :param pulumi.Input[str] exec_err_state: Describes what state to enter when the rule's query is invalid and the rule cannot be executed. Options are OK, Error, KeepLast, and Alerting. Defaults to `Alerting`.
        :param pulumi.Input[str] for_: The amount of time for which the rule must be breached for the rule to be considered to be Firing. Before this time has elapsed, the rule is only considered to be Pending. Defaults to `0`.
        :param pulumi.Input[bool] is_paused: Sets whether the alert should be paused or not. Defaults to `false`.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] labels: Key-value pairs to attach to the alert rule that can be used in matching, grouping, and routing. Defaults to `map[]`.
        :param pulumi.Input[str] no_data_state: Describes what state to enter when the rule's query returns No Data. Options are OK, NoData, KeepLast, and Alerting. Defaults to `NoData`.
        :param pulumi.Input['RuleGroupRuleNotificationSettingsArgs'] notification_settings: Notification settings for the rule. If specified, it overrides the notification policies. Available since Grafana 10.4, requires feature flag 'alertingSimplifiedRouting' to be enabled.
        :param pulumi.Input['RuleGroupRuleRecordArgs'] record: Settings for a recording rule. Available since Grafana 11.2, requires feature flag 'grafanaManagedRecordingRules' to be enabled.
        :param pulumi.Input[str] uid: The unique identifier of the alert rule.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "datas", datas)
        pulumi.set(__self__, "name", name)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if exec_err_state is not None:
            pulumi.set(__self__, "exec_err_state", exec_err_state)
        if for_ is not None:
            pulumi.set(__self__, "for_", for_)
        if is_paused is not None:
            pulumi.set(__self__, "is_paused", is_paused)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if no_data_state is not None:
            pulumi.set(__self__, "no_data_state", no_data_state)
        if notification_settings is not None:
            pulumi.set(__self__, "notification_settings", notification_settings)
        if record is not None:
            pulumi.set(__self__, "record", record)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        The `ref_id` of the query node in the `data` field to use as the alert condition.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def datas(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleDataArgs']]]:
        """
        A sequence of stages that describe the contents of the rule.
        """
        return pulumi.get(self, "datas")

    @datas.setter
    def datas(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleDataArgs']]]):
        pulumi.set(self, "datas", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the alert rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Key-value pairs of metadata to attach to the alert rule. They add additional information, such as a `summary` or `runbook_url`, to help identify and investigate alerts. The `dashboardUId` and `panelId` annotations, which link alerts to a panel, must be set together. Defaults to `map[]`.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="execErrState")
    def exec_err_state(self) -> Optional[pulumi.Input[str]]:
        """
        Describes what state to enter when the rule's query is invalid and the rule cannot be executed. Options are OK, Error, KeepLast, and Alerting. Defaults to `Alerting`.
        """
        return pulumi.get(self, "exec_err_state")

    @exec_err_state.setter
    def exec_err_state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exec_err_state", value)

    @property
    @pulumi.getter(name="for")
    def for_(self) -> Optional[pulumi.Input[str]]:
        """
        The amount of time for which the rule must be breached for the rule to be considered to be Firing. Before this time has elapsed, the rule is only considered to be Pending. Defaults to `0`.
        """
        return pulumi.get(self, "for_")

    @for_.setter
    def for_(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "for_", value)

    @property
    @pulumi.getter(name="isPaused")
    def is_paused(self) -> Optional[pulumi.Input[bool]]:
        """
        Sets whether the alert should be paused or not. Defaults to `false`.
        """
        return pulumi.get(self, "is_paused")

    @is_paused.setter
    def is_paused(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_paused", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Key-value pairs to attach to the alert rule that can be used in matching, grouping, and routing. Defaults to `map[]`.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "labels", value)

    @property
    @pulumi.getter(name="noDataState")
    def no_data_state(self) -> Optional[pulumi.Input[str]]:
        """
        Describes what state to enter when the rule's query returns No Data. Options are OK, NoData, KeepLast, and Alerting. Defaults to `NoData`.
        """
        return pulumi.get(self, "no_data_state")

    @no_data_state.setter
    def no_data_state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "no_data_state", value)

    @property
    @pulumi.getter(name="notificationSettings")
    def notification_settings(self) -> Optional[pulumi.Input['RuleGroupRuleNotificationSettingsArgs']]:
        """
        Notification settings for the rule. If specified, it overrides the notification policies. Available since Grafana 10.4, requires feature flag 'alertingSimplifiedRouting' to be enabled.
        """
        return pulumi.get(self, "notification_settings")

    @notification_settings.setter
    def notification_settings(self, value: Optional[pulumi.Input['RuleGroupRuleNotificationSettingsArgs']]):
        pulumi.set(self, "notification_settings", value)

    @property
    @pulumi.getter
    def record(self) -> Optional[pulumi.Input['RuleGroupRuleRecordArgs']]:
        """
        Settings for a recording rule. Available since Grafana 11.2, requires feature flag 'grafanaManagedRecordingRules' to be enabled.
        """
        return pulumi.get(self, "record")

    @record.setter
    def record(self, value: Optional[pulumi.Input['RuleGroupRuleRecordArgs']]):
        pulumi.set(self, "record", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        The unique identifier of the alert rule.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)


if not MYPY:
    class RuleGroupRuleDataArgsDict(TypedDict):
        datasource_uid: pulumi.Input[str]
        """
        The UID of the datasource being queried, or "-100" if this stage is an expression stage.
        """
        model: pulumi.Input[str]
        """
        Custom JSON data to send to the specified datasource when querying.
        """
        ref_id: pulumi.Input[str]
        """
        A unique string to identify this query stage within a rule.
        """
        relative_time_range: pulumi.Input['RuleGroupRuleDataRelativeTimeRangeArgsDict']
        """
        The time range, relative to when the query is executed, across which to query.
        """
        query_type: NotRequired[pulumi.Input[str]]
        """
        An optional identifier for the type of query being executed. Defaults to ``.
        """
elif False:
    RuleGroupRuleDataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleDataArgs:
    def __init__(__self__, *,
                 datasource_uid: pulumi.Input[str],
                 model: pulumi.Input[str],
                 ref_id: pulumi.Input[str],
                 relative_time_range: pulumi.Input['RuleGroupRuleDataRelativeTimeRangeArgs'],
                 query_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] datasource_uid: The UID of the datasource being queried, or "-100" if this stage is an expression stage.
        :param pulumi.Input[str] model: Custom JSON data to send to the specified datasource when querying.
        :param pulumi.Input[str] ref_id: A unique string to identify this query stage within a rule.
        :param pulumi.Input['RuleGroupRuleDataRelativeTimeRangeArgs'] relative_time_range: The time range, relative to when the query is executed, across which to query.
        :param pulumi.Input[str] query_type: An optional identifier for the type of query being executed. Defaults to ``.
        """
        pulumi.set(__self__, "datasource_uid", datasource_uid)
        pulumi.set(__self__, "model", model)
        pulumi.set(__self__, "ref_id", ref_id)
        pulumi.set(__self__, "relative_time_range", relative_time_range)
        if query_type is not None:
            pulumi.set(__self__, "query_type", query_type)

    @property
    @pulumi.getter(name="datasourceUid")
    def datasource_uid(self) -> pulumi.Input[str]:
        """
        The UID of the datasource being queried, or "-100" if this stage is an expression stage.
        """
        return pulumi.get(self, "datasource_uid")

    @datasource_uid.setter
    def datasource_uid(self, value: pulumi.Input[str]):
        pulumi.set(self, "datasource_uid", value)

    @property
    @pulumi.getter
    def model(self) -> pulumi.Input[str]:
        """
        Custom JSON data to send to the specified datasource when querying.
        """
        return pulumi.get(self, "model")

    @model.setter
    def model(self, value: pulumi.Input[str]):
        pulumi.set(self, "model", value)

    @property
    @pulumi.getter(name="refId")
    def ref_id(self) -> pulumi.Input[str]:
        """
        A unique string to identify this query stage within a rule.
        """
        return pulumi.get(self, "ref_id")

    @ref_id.setter
    def ref_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "ref_id", value)

    @property
    @pulumi.getter(name="relativeTimeRange")
    def relative_time_range(self) -> pulumi.Input['RuleGroupRuleDataRelativeTimeRangeArgs']:
        """
        The time range, relative to when the query is executed, across which to query.
        """
        return pulumi.get(self, "relative_time_range")

    @relative_time_range.setter
    def relative_time_range(self, value: pulumi.Input['RuleGroupRuleDataRelativeTimeRangeArgs']):
        pulumi.set(self, "relative_time_range", value)

    @property
    @pulumi.getter(name="queryType")
    def query_type(self) -> Optional[pulumi.Input[str]]:
        """
        An optional identifier for the type of query being executed. Defaults to ``.
        """
        return pulumi.get(self, "query_type")

    @query_type.setter
    def query_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "query_type", value)


if not MYPY:
    class RuleGroupRuleDataRelativeTimeRangeArgsDict(TypedDict):
        from_: pulumi.Input[int]
        """
        The number of seconds in the past, relative to when the rule is evaluated, at which the time range begins.
        """
        to: pulumi.Input[int]
        """
        The number of seconds in the past, relative to when the rule is evaluated, at which the time range ends.
        """
elif False:
    RuleGroupRuleDataRelativeTimeRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleDataRelativeTimeRangeArgs:
    def __init__(__self__, *,
                 from_: pulumi.Input[int],
                 to: pulumi.Input[int]):
        """
        :param pulumi.Input[int] from_: The number of seconds in the past, relative to when the rule is evaluated, at which the time range begins.
        :param pulumi.Input[int] to: The number of seconds in the past, relative to when the rule is evaluated, at which the time range ends.
        """
        pulumi.set(__self__, "from_", from_)
        pulumi.set(__self__, "to", to)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> pulumi.Input[int]:
        """
        The number of seconds in the past, relative to when the rule is evaluated, at which the time range begins.
        """
        return pulumi.get(self, "from_")

    @from_.setter
    def from_(self, value: pulumi.Input[int]):
        pulumi.set(self, "from_", value)

    @property
    @pulumi.getter
    def to(self) -> pulumi.Input[int]:
        """
        The number of seconds in the past, relative to when the rule is evaluated, at which the time range ends.
        """
        return pulumi.get(self, "to")

    @to.setter
    def to(self, value: pulumi.Input[int]):
        pulumi.set(self, "to", value)


if not MYPY:
    class RuleGroupRuleNotificationSettingsArgsDict(TypedDict):
        contact_point: pulumi.Input[str]
        """
        The contact point to route notifications that match this rule to.
        """
        group_bies: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping. If empty, no grouping is used. If specified, requires labels 'alertname' and 'grafana_folder' to be included.
        """
        group_interval: NotRequired[pulumi.Input[str]]
        """
        Minimum time interval between two notifications for the same group. Default is 5 minutes.
        """
        group_wait: NotRequired[pulumi.Input[str]]
        """
        Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.
        """
        mute_timings: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of mute timing names to apply to alerts that match this policy.
        """
        repeat_interval: NotRequired[pulumi.Input[str]]
        """
        Minimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.
        """
elif False:
    RuleGroupRuleNotificationSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleNotificationSettingsArgs:
    def __init__(__self__, *,
                 contact_point: pulumi.Input[str],
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 group_interval: Optional[pulumi.Input[str]] = None,
                 group_wait: Optional[pulumi.Input[str]] = None,
                 mute_timings: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 repeat_interval: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] contact_point: The contact point to route notifications that match this rule to.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] group_bies: A list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping. If empty, no grouping is used. If specified, requires labels 'alertname' and 'grafana_folder' to be included.
        :param pulumi.Input[str] group_interval: Minimum time interval between two notifications for the same group. Default is 5 minutes.
        :param pulumi.Input[str] group_wait: Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] mute_timings: A list of mute timing names to apply to alerts that match this policy.
        :param pulumi.Input[str] repeat_interval: Minimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.
        """
        pulumi.set(__self__, "contact_point", contact_point)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if group_interval is not None:
            pulumi.set(__self__, "group_interval", group_interval)
        if group_wait is not None:
            pulumi.set(__self__, "group_wait", group_wait)
        if mute_timings is not None:
            pulumi.set(__self__, "mute_timings", mute_timings)
        if repeat_interval is not None:
            pulumi.set(__self__, "repeat_interval", repeat_interval)

    @property
    @pulumi.getter(name="contactPoint")
    def contact_point(self) -> pulumi.Input[str]:
        """
        The contact point to route notifications that match this rule to.
        """
        return pulumi.get(self, "contact_point")

    @contact_point.setter
    def contact_point(self, value: pulumi.Input[str]):
        pulumi.set(self, "contact_point", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping. If empty, no grouping is used. If specified, requires labels 'alertname' and 'grafana_folder' to be included.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="groupInterval")
    def group_interval(self) -> Optional[pulumi.Input[str]]:
        """
        Minimum time interval between two notifications for the same group. Default is 5 minutes.
        """
        return pulumi.get(self, "group_interval")

    @group_interval.setter
    def group_interval(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group_interval", value)

    @property
    @pulumi.getter(name="groupWait")
    def group_wait(self) -> Optional[pulumi.Input[str]]:
        """
        Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.
        """
        return pulumi.get(self, "group_wait")

    @group_wait.setter
    def group_wait(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group_wait", value)

    @property
    @pulumi.getter(name="muteTimings")
    def mute_timings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of mute timing names to apply to alerts that match this policy.
        """
        return pulumi.get(self, "mute_timings")

    @mute_timings.setter
    def mute_timings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "mute_timings", value)

    @property
    @pulumi.getter(name="repeatInterval")
    def repeat_interval(self) -> Optional[pulumi.Input[str]]:
        """
        Minimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.
        """
        return pulumi.get(self, "repeat_interval")

    @repeat_interval.setter
    def repeat_interval(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repeat_interval", value)


if not MYPY:
    class RuleGroupRuleRecordArgsDict(TypedDict):
        from_: pulumi.Input[str]
        """
        The ref id of the query node in the data field to use as the source of the metric.
        """
        metric: pulumi.Input[str]
        """
        The name of the metric to write to.
        """
elif False:
    RuleGroupRuleRecordArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleRecordArgs:
    def __init__(__self__, *,
                 from_: pulumi.Input[str],
                 metric: pulumi.Input[str]):
        """
        :param pulumi.Input[str] from_: The ref id of the query node in the data field to use as the source of the metric.
        :param pulumi.Input[str] metric: The name of the metric to write to.
        """
        pulumi.set(__self__, "from_", from_)
        pulumi.set(__self__, "metric", metric)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> pulumi.Input[str]:
        """
        The ref id of the query node in the data field to use as the source of the metric.
        """
        return pulumi.get(self, "from_")

    @from_.setter
    def from_(self, value: pulumi.Input[str]):
        pulumi.set(self, "from_", value)

    @property
    @pulumi.getter
    def metric(self) -> pulumi.Input[str]:
        """
        The name of the metric to write to.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric", value)


if not MYPY:
    class SLOAlertingArgsDict(TypedDict):
        advanced_options: NotRequired[pulumi.Input['SLOAlertingAdvancedOptionsArgsDict']]
        """
        Advanced Options for Alert Rules
        """
        annotations: NotRequired[pulumi.Input[Sequence[pulumi.Input['SLOAlertingAnnotationArgsDict']]]]
        """
        Annotations will be attached to all alerts generated by any of these rules.
        """
        fastburns: NotRequired[pulumi.Input[Sequence[pulumi.Input['SLOAlertingFastburnArgsDict']]]]
        """
        Alerting Rules generated for Fast Burn alerts
        """
        labels: NotRequired[pulumi.Input[Sequence[pulumi.Input['SLOAlertingLabelArgsDict']]]]
        """
        Labels will be attached to all alerts generated by any of these rules.
        """
        slowburns: NotRequired[pulumi.Input[Sequence[pulumi.Input['SLOAlertingSlowburnArgsDict']]]]
        """
        Alerting Rules generated for Slow Burn alerts
        """
elif False:
    SLOAlertingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SLOAlertingArgs:
    def __init__(__self__, *,
                 advanced_options: Optional[pulumi.Input['SLOAlertingAdvancedOptionsArgs']] = None,
                 annotations: Optional[pulumi.Input[Sequence[pulumi.Input['SLOAlertingAnnotationArgs']]]] = None,
                 fastburns: Optional[pulumi.Input[Sequence[pulumi.Input['SLOAlertingFastburnArgs']]]] = None,
                 labels: Optional[pulumi.Input[Sequence[pulumi.Input['SLOAlertingLabelArgs']]]] = None,
                 slowburns: Optional[pulumi.Input[Sequence[pulumi.Input['SLOAlertingSlowburnArgs']]]] = None):
        """
        :param pulumi.Input['SLOAlertingAdvancedOptionsArgs'] advanced_options: Advanced Options for Alert Rules
        :param pulumi.Input[Sequence[pulumi.Input['SLOAlertingAnnotationArgs']]] annotations: Annotations will be attached to all alerts generated by any of these rules.
        :param pulumi.Input[Sequence[pulumi.Input['SLOAlertingFastburnArgs']]] fastburns: Alerting Rules generated for Fast Burn alerts
        :param pulumi.Input[Sequence[pulumi.Input['SLOAlertingLabelArgs']]] labels: Labels will be attached to all alerts generated by any of these rules.
        :param pulumi.Input[Sequence[pulumi.Input['SLOAlertingSlowburnArgs']]] slowburns: Alerting Rules generated for Slow Burn alerts
        """
        if advanced_options is not None:
            pulumi.set(__self__, "advanced_options", advanced_options)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if fastburns is not None:
            pulumi.set(__self__, "fastburns", fastburns)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if slowburns is not None:
            pulumi.set(__self__, "slowburns", slowburns)

    @property
    @pulumi.getter(name="advancedOptions")
    def advanced_options(self) -> Optional[pulumi.Input['SLOAlertingAdvancedOptionsArgs']]:
        """
        Advanced Options for Alert Rules
        """
        return pulumi.get(self, "advanced_options")

    @advanced_options.setter
    def advanced_options(self, value: Optional[pulumi.Input['SLOAlertingAdvancedOptionsArgs']]):
        pulumi.set(self, "advanced_options", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SLOAlertingAnnotationArgs']]]]:
        """
        Annotations will be attached to all alerts generated by any of these rules.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SLOAlertingAnnotationArgs']]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def fastburns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SLOAlertingFastburnArgs']]]]:
        """
        Alerting Rules generated for Fast Burn alerts
        """
        return pulumi.get(self, "fastburns")

    @fastburns.setter
    def fastburns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SLOAlertingFastburnArgs']]]]):
        pulumi.set(self, "fastburns", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SLOAlertingLabelArgs']]]]:
        """
        Labels will be attached to all alerts generated by any of these rules.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SLOAlertingLabelArgs']]]]):
        pulumi.set(self, "labels", value)

    @property
    @pulumi.getter
    def slowburns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SLOAlertingSlowburnArgs']]]]:
        """
        Alerting Rules generated for Slow Burn alerts
        """
        return pulumi.get(self, "slowburns")

    @slowburns.setter
    def slowburns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SLOAlertingSlowburnArgs']]]]):
        pulumi.set(self, "slowburns", value)


if not MYPY:
    class SLOAlertingAdvancedOptionsArgsDict(TypedDict):
        min_failures: NotRequired[pulumi.Input[int]]
        """
        Minimum number of failed events to trigger an alert
        """
elif False:
    SLOAlertingAdvancedOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SLOAlertingAdvancedOptionsArgs:
    def __init__(__self__, *,
                 min_failures: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] min_failures: Minimum number of failed events to trigger an alert
        """
        if min_failures is not None:
            pulumi.set(__self__, "min_failures", min_failures)

    @property
    @pulumi.getter(name="minFailures")
    def min_failures(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum number of failed events to trigger an alert
        """
        return pulumi.get(self, "min_failures")

    @min_failures.setter
    def min_failures(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_failures", value)


if not MYPY:
    class SLOAlertingAnnotationArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        Key for filtering and identification
        """
        value: pulumi.Input[str]
        """
        Templatable value
        """
elif False:
    SLOAlertingAnnotationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SLOAlertingAnnotationArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: Key for filtering and identification
        :param pulumi.Input[str] value: Templatable value
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Key for filtering and identification
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Templatable value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class SLOAlertingFastburnArgsDict(TypedDict):
        annotations: NotRequired[pulumi.Input[Sequence[pulumi.Input['SLOAlertingFastburnAnnotationArgsDict']]]]
        """
        Annotations to attach only to Fast Burn alerts.
        """
        labels: NotRequired[pulumi.Input[Sequence[pulumi.Input['SLOAlertingFastburnLabelArgsDict']]]]
        """
        Labels to attach only to Fast Burn alerts.
        """
elif False:
    SLOAlertingFastburnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SLOAlertingFastburnArgs:
    def __init__(__self__, *,
                 annotations: Optional[pulumi.Input[Sequence[pulumi.Input['SLOAlertingFastburnAnnotationArgs']]]] = None,
                 labels: Optional[pulumi.Input[Sequence[pulumi.Input['SLOAlertingFastburnLabelArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['SLOAlertingFastburnAnnotationArgs']]] annotations: Annotations to attach only to Fast Burn alerts.
        :param pulumi.Input[Sequence[pulumi.Input['SLOAlertingFastburnLabelArgs']]] labels: Labels to attach only to Fast Burn alerts.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SLOAlertingFastburnAnnotationArgs']]]]:
        """
        Annotations to attach only to Fast Burn alerts.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SLOAlertingFastburnAnnotationArgs']]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SLOAlertingFastburnLabelArgs']]]]:
        """
        Labels to attach only to Fast Burn alerts.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SLOAlertingFastburnLabelArgs']]]]):
        pulumi.set(self, "labels", value)


if not MYPY:
    class SLOAlertingFastburnAnnotationArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        Key for filtering and identification
        """
        value: pulumi.Input[str]
        """
        Templatable value
        """
elif False:
    SLOAlertingFastburnAnnotationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SLOAlertingFastburnAnnotationArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: Key for filtering and identification
        :param pulumi.Input[str] value: Templatable value
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Key for filtering and identification
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Templatable value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class SLOAlertingFastburnLabelArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        Key for filtering and identification
        """
        value: pulumi.Input[str]
        """
        Templatable value
        """
elif False:
    SLOAlertingFastburnLabelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SLOAlertingFastburnLabelArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: Key for filtering and identification
        :param pulumi.Input[str] value: Templatable value
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Key for filtering and identification
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Templatable value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class SLOAlertingLabelArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        Key for filtering and identification
        """
        value: pulumi.Input[str]
        """
        Templatable value
        """
elif False:
    SLOAlertingLabelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SLOAlertingLabelArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: Key for filtering and identification
        :param pulumi.Input[str] value: Templatable value
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Key for filtering and identification
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Templatable value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class SLOAlertingSlowburnArgsDict(TypedDict):
        annotations: NotRequired[pulumi.Input[Sequence[pulumi.Input['SLOAlertingSlowburnAnnotationArgsDict']]]]
        """
        Annotations to attach only to Slow Burn alerts.
        """
        labels: NotRequired[pulumi.Input[Sequence[pulumi.Input['SLOAlertingSlowburnLabelArgsDict']]]]
        """
        Labels to attach only to Slow Burn alerts.
        """
elif False:
    SLOAlertingSlowburnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SLOAlertingSlowburnArgs:
    def __init__(__self__, *,
                 annotations: Optional[pulumi.Input[Sequence[pulumi.Input['SLOAlertingSlowburnAnnotationArgs']]]] = None,
                 labels: Optional[pulumi.Input[Sequence[pulumi.Input['SLOAlertingSlowburnLabelArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['SLOAlertingSlowburnAnnotationArgs']]] annotations: Annotations to attach only to Slow Burn alerts.
        :param pulumi.Input[Sequence[pulumi.Input['SLOAlertingSlowburnLabelArgs']]] labels: Labels to attach only to Slow Burn alerts.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SLOAlertingSlowburnAnnotationArgs']]]]:
        """
        Annotations to attach only to Slow Burn alerts.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SLOAlertingSlowburnAnnotationArgs']]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SLOAlertingSlowburnLabelArgs']]]]:
        """
        Labels to attach only to Slow Burn alerts.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SLOAlertingSlowburnLabelArgs']]]]):
        pulumi.set(self, "labels", value)


if not MYPY:
    class SLOAlertingSlowburnAnnotationArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        Key for filtering and identification
        """
        value: pulumi.Input[str]
        """
        Templatable value
        """
elif False:
    SLOAlertingSlowburnAnnotationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SLOAlertingSlowburnAnnotationArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: Key for filtering and identification
        :param pulumi.Input[str] value: Templatable value
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Key for filtering and identification
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Templatable value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class SLOAlertingSlowburnLabelArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        Key for filtering and identification
        """
        value: pulumi.Input[str]
        """
        Templatable value
        """
elif False:
    SLOAlertingSlowburnLabelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SLOAlertingSlowburnLabelArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: Key for filtering and identification
        :param pulumi.Input[str] value: Templatable value
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Key for filtering and identification
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Templatable value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class SLODestinationDatasourceArgsDict(TypedDict):
        uid: pulumi.Input[str]
        """
        UID for the Datasource
        """
elif False:
    SLODestinationDatasourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SLODestinationDatasourceArgs:
    def __init__(__self__, *,
                 uid: pulumi.Input[str]):
        """
        :param pulumi.Input[str] uid: UID for the Datasource
        """
        pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter
    def uid(self) -> pulumi.Input[str]:
        """
        UID for the Datasource
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: pulumi.Input[str]):
        pulumi.set(self, "uid", value)


if not MYPY:
    class SLOLabelArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        Key for filtering and identification
        """
        value: pulumi.Input[str]
        """
        Templatable value
        """
elif False:
    SLOLabelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SLOLabelArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: Key for filtering and identification
        :param pulumi.Input[str] value: Templatable value
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Key for filtering and identification
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Templatable value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class SLOObjectiveArgsDict(TypedDict):
        value: pulumi.Input[float]
        """
        Value between 0 and 1. If the value of the query is above the objective, the SLO is met.
        """
        window: pulumi.Input[str]
        """
        A Prometheus-parsable time duration string like 24h, 60m. This is the time window the objective is measured over.
        """
elif False:
    SLOObjectiveArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SLOObjectiveArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[float],
                 window: pulumi.Input[str]):
        """
        :param pulumi.Input[float] value: Value between 0 and 1. If the value of the query is above the objective, the SLO is met.
        :param pulumi.Input[str] window: A Prometheus-parsable time duration string like 24h, 60m. This is the time window the objective is measured over.
        """
        pulumi.set(__self__, "value", value)
        pulumi.set(__self__, "window", window)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[float]:
        """
        Value between 0 and 1. If the value of the query is above the objective, the SLO is met.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[float]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def window(self) -> pulumi.Input[str]:
        """
        A Prometheus-parsable time duration string like 24h, 60m. This is the time window the objective is measured over.
        """
        return pulumi.get(self, "window")

    @window.setter
    def window(self, value: pulumi.Input[str]):
        pulumi.set(self, "window", value)


if not MYPY:
    class SLOQueryArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        Query type must be one of: "freeform", "query", "ratio", or "threshold"
        """
        freeform: NotRequired[pulumi.Input['SLOQueryFreeformArgsDict']]
        ratio: NotRequired[pulumi.Input['SLOQueryRatioArgsDict']]
elif False:
    SLOQueryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SLOQueryArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 freeform: Optional[pulumi.Input['SLOQueryFreeformArgs']] = None,
                 ratio: Optional[pulumi.Input['SLOQueryRatioArgs']] = None):
        """
        :param pulumi.Input[str] type: Query type must be one of: "freeform", "query", "ratio", or "threshold"
        """
        pulumi.set(__self__, "type", type)
        if freeform is not None:
            pulumi.set(__self__, "freeform", freeform)
        if ratio is not None:
            pulumi.set(__self__, "ratio", ratio)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Query type must be one of: "freeform", "query", "ratio", or "threshold"
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def freeform(self) -> Optional[pulumi.Input['SLOQueryFreeformArgs']]:
        return pulumi.get(self, "freeform")

    @freeform.setter
    def freeform(self, value: Optional[pulumi.Input['SLOQueryFreeformArgs']]):
        pulumi.set(self, "freeform", value)

    @property
    @pulumi.getter
    def ratio(self) -> Optional[pulumi.Input['SLOQueryRatioArgs']]:
        return pulumi.get(self, "ratio")

    @ratio.setter
    def ratio(self, value: Optional[pulumi.Input['SLOQueryRatioArgs']]):
        pulumi.set(self, "ratio", value)


if not MYPY:
    class SLOQueryFreeformArgsDict(TypedDict):
        query: pulumi.Input[str]
        """
        Freeform Query Field
        """
elif False:
    SLOQueryFreeformArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SLOQueryFreeformArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str]):
        """
        :param pulumi.Input[str] query: Freeform Query Field
        """
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        Freeform Query Field
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)


if not MYPY:
    class SLOQueryRatioArgsDict(TypedDict):
        success_metric: pulumi.Input[str]
        """
        Counter metric for success events (numerator)
        """
        total_metric: pulumi.Input[str]
        """
        Metric for total events (denominator)
        """
        group_by_labels: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Defines Group By Labels used for per-label alerting. These appear as variables on SLO dashboards to enable filtering and aggregation. Labels must adhere to Prometheus label name schema - "^[a-zA-Z*][a-zA-Z0-9*]*$"
        """
elif False:
    SLOQueryRatioArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SLOQueryRatioArgs:
    def __init__(__self__, *,
                 success_metric: pulumi.Input[str],
                 total_metric: pulumi.Input[str],
                 group_by_labels: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] success_metric: Counter metric for success events (numerator)
        :param pulumi.Input[str] total_metric: Metric for total events (denominator)
        :param pulumi.Input[Sequence[pulumi.Input[str]]] group_by_labels: Defines Group By Labels used for per-label alerting. These appear as variables on SLO dashboards to enable filtering and aggregation. Labels must adhere to Prometheus label name schema - "^[a-zA-Z*][a-zA-Z0-9*]*$"
        """
        pulumi.set(__self__, "success_metric", success_metric)
        pulumi.set(__self__, "total_metric", total_metric)
        if group_by_labels is not None:
            pulumi.set(__self__, "group_by_labels", group_by_labels)

    @property
    @pulumi.getter(name="successMetric")
    def success_metric(self) -> pulumi.Input[str]:
        """
        Counter metric for success events (numerator)
        """
        return pulumi.get(self, "success_metric")

    @success_metric.setter
    def success_metric(self, value: pulumi.Input[str]):
        pulumi.set(self, "success_metric", value)

    @property
    @pulumi.getter(name="totalMetric")
    def total_metric(self) -> pulumi.Input[str]:
        """
        Metric for total events (denominator)
        """
        return pulumi.get(self, "total_metric")

    @total_metric.setter
    def total_metric(self, value: pulumi.Input[str]):
        pulumi.set(self, "total_metric", value)

    @property
    @pulumi.getter(name="groupByLabels")
    def group_by_labels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Defines Group By Labels used for per-label alerting. These appear as variables on SLO dashboards to enable filtering and aggregation. Labels must adhere to Prometheus label name schema - "^[a-zA-Z*][a-zA-Z0-9*]*$"
        """
        return pulumi.get(self, "group_by_labels")

    @group_by_labels.setter
    def group_by_labels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "group_by_labels", value)


if not MYPY:
    class ServiceAccountPermissionPermissionArgsDict(TypedDict):
        permission: pulumi.Input[str]
        """
        Permission to associate with item. Must be one of `View`, `Edit`, or `Admin`.
        """
        team_id: NotRequired[pulumi.Input[str]]
        """
        ID of the team to manage permissions for. Defaults to `0`.
        """
        user_id: NotRequired[pulumi.Input[str]]
        """
        ID of the user or service account to manage permissions for. Defaults to `0`.
        """
elif False:
    ServiceAccountPermissionPermissionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceAccountPermissionPermissionArgs:
    def __init__(__self__, *,
                 permission: pulumi.Input[str],
                 team_id: Optional[pulumi.Input[str]] = None,
                 user_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] permission: Permission to associate with item. Must be one of `View`, `Edit`, or `Admin`.
        :param pulumi.Input[str] team_id: ID of the team to manage permissions for. Defaults to `0`.
        :param pulumi.Input[str] user_id: ID of the user or service account to manage permissions for. Defaults to `0`.
        """
        pulumi.set(__self__, "permission", permission)
        if team_id is not None:
            pulumi.set(__self__, "team_id", team_id)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)

    @property
    @pulumi.getter
    def permission(self) -> pulumi.Input[str]:
        """
        Permission to associate with item. Must be one of `View`, `Edit`, or `Admin`.
        """
        return pulumi.get(self, "permission")

    @permission.setter
    def permission(self, value: pulumi.Input[str]):
        pulumi.set(self, "permission", value)

    @property
    @pulumi.getter(name="teamId")
    def team_id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the team to manage permissions for. Defaults to `0`.
        """
        return pulumi.get(self, "team_id")

    @team_id.setter
    def team_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "team_id", value)

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the user or service account to manage permissions for. Defaults to `0`.
        """
        return pulumi.get(self, "user_id")

    @user_id.setter
    def user_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_id", value)


if not MYPY:
    class SsoSettingsLdapSettingsArgsDict(TypedDict):
        config: pulumi.Input['SsoSettingsLdapSettingsConfigArgsDict']
        """
        The LDAP configuration.
        """
        allow_sign_up: NotRequired[pulumi.Input[bool]]
        """
        Whether to allow new Grafana user creation through LDAP login. If set to false, then only existing Grafana users can log in with LDAP.
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Define whether this configuration is enabled for LDAP. Defaults to `true`.
        """
        skip_org_role_sync: NotRequired[pulumi.Input[bool]]
        """
        Prevent synchronizing users’ organization roles from LDAP.
        """
elif False:
    SsoSettingsLdapSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SsoSettingsLdapSettingsArgs:
    def __init__(__self__, *,
                 config: pulumi.Input['SsoSettingsLdapSettingsConfigArgs'],
                 allow_sign_up: Optional[pulumi.Input[bool]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 skip_org_role_sync: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input['SsoSettingsLdapSettingsConfigArgs'] config: The LDAP configuration.
        :param pulumi.Input[bool] allow_sign_up: Whether to allow new Grafana user creation through LDAP login. If set to false, then only existing Grafana users can log in with LDAP.
        :param pulumi.Input[bool] enabled: Define whether this configuration is enabled for LDAP. Defaults to `true`.
        :param pulumi.Input[bool] skip_org_role_sync: Prevent synchronizing users’ organization roles from LDAP.
        """
        pulumi.set(__self__, "config", config)
        if allow_sign_up is not None:
            pulumi.set(__self__, "allow_sign_up", allow_sign_up)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if skip_org_role_sync is not None:
            pulumi.set(__self__, "skip_org_role_sync", skip_org_role_sync)

    @property
    @pulumi.getter
    def config(self) -> pulumi.Input['SsoSettingsLdapSettingsConfigArgs']:
        """
        The LDAP configuration.
        """
        return pulumi.get(self, "config")

    @config.setter
    def config(self, value: pulumi.Input['SsoSettingsLdapSettingsConfigArgs']):
        pulumi.set(self, "config", value)

    @property
    @pulumi.getter(name="allowSignUp")
    def allow_sign_up(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to allow new Grafana user creation through LDAP login. If set to false, then only existing Grafana users can log in with LDAP.
        """
        return pulumi.get(self, "allow_sign_up")

    @allow_sign_up.setter
    def allow_sign_up(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_sign_up", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Define whether this configuration is enabled for LDAP. Defaults to `true`.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="skipOrgRoleSync")
    def skip_org_role_sync(self) -> Optional[pulumi.Input[bool]]:
        """
        Prevent synchronizing users’ organization roles from LDAP.
        """
        return pulumi.get(self, "skip_org_role_sync")

    @skip_org_role_sync.setter
    def skip_org_role_sync(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "skip_org_role_sync", value)


if not MYPY:
    class SsoSettingsLdapSettingsConfigArgsDict(TypedDict):
        servers: pulumi.Input[Sequence[pulumi.Input['SsoSettingsLdapSettingsConfigServerArgsDict']]]
        """
        The LDAP servers configuration.
        """
elif False:
    SsoSettingsLdapSettingsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SsoSettingsLdapSettingsConfigArgs:
    def __init__(__self__, *,
                 servers: pulumi.Input[Sequence[pulumi.Input['SsoSettingsLdapSettingsConfigServerArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['SsoSettingsLdapSettingsConfigServerArgs']]] servers: The LDAP servers configuration.
        """
        pulumi.set(__self__, "servers", servers)

    @property
    @pulumi.getter
    def servers(self) -> pulumi.Input[Sequence[pulumi.Input['SsoSettingsLdapSettingsConfigServerArgs']]]:
        """
        The LDAP servers configuration.
        """
        return pulumi.get(self, "servers")

    @servers.setter
    def servers(self, value: pulumi.Input[Sequence[pulumi.Input['SsoSettingsLdapSettingsConfigServerArgs']]]):
        pulumi.set(self, "servers", value)


if not MYPY:
    class SsoSettingsLdapSettingsConfigServerArgsDict(TypedDict):
        host: pulumi.Input[str]
        """
        The LDAP server host.
        """
        search_base_dns: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        An array of base DNs to search through.
        """
        search_filter: pulumi.Input[str]
        """
        The user search filter, for example "(cn=%s)" or "(sAMAccountName=%s)" or "(uid=%s)".
        """
        attributes: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        The LDAP server attributes. The following attributes can be configured: email, member_of, name, surname, username.
        """
        bind_dn: NotRequired[pulumi.Input[str]]
        """
        The search user bind DN.
        """
        bind_password: NotRequired[pulumi.Input[str]]
        """
        The search user bind password.
        """
        client_cert: NotRequired[pulumi.Input[str]]
        """
        The path to the client certificate.
        """
        client_cert_value: NotRequired[pulumi.Input[str]]
        """
        The Base64 encoded value of the client certificate.
        """
        client_key: NotRequired[pulumi.Input[str]]
        """
        The path to the client private key.
        """
        client_key_value: NotRequired[pulumi.Input[str]]
        """
        The Base64 encoded value of the client private key.
        """
        group_mappings: NotRequired[pulumi.Input[Sequence[pulumi.Input['SsoSettingsLdapSettingsConfigServerGroupMappingArgsDict']]]]
        """
        For mapping an LDAP group to a Grafana organization and role.
        """
        group_search_base_dns: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        An array of the base DNs to search through for groups. Typically uses ou=groups.
        """
        group_search_filter: NotRequired[pulumi.Input[str]]
        """
        Group search filter, to retrieve the groups of which the user is a member (only set if memberOf attribute is not available).
        """
        group_search_filter_user_attribute: NotRequired[pulumi.Input[str]]
        """
        The %s in the search filter will be replaced with the attribute defined in this field.
        """
        min_tls_version: NotRequired[pulumi.Input[str]]
        """
        Minimum TLS version allowed. Accepted values are: TLS1.2, TLS1.3.
        """
        port: NotRequired[pulumi.Input[int]]
        """
        The LDAP server port.
        """
        root_ca_cert: NotRequired[pulumi.Input[str]]
        """
        The path to the root CA certificate.
        """
        root_ca_cert_values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The Base64 encoded values of the root CA certificates.
        """
        ssl_skip_verify: NotRequired[pulumi.Input[bool]]
        """
        If set to true, the SSL cert validation will be skipped.
        """
        start_tls: NotRequired[pulumi.Input[bool]]
        """
        If set to true, use LDAP with STARTTLS instead of LDAPS.
        """
        timeout: NotRequired[pulumi.Input[int]]
        """
        The timeout in seconds for connecting to the LDAP host.
        """
        tls_ciphers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Accepted TLS ciphers. For a complete list of supported ciphers, refer to: https://go.dev/src/crypto/tls/cipher_suites.go.
        """
        use_ssl: NotRequired[pulumi.Input[bool]]
        """
        Set to true if LDAP server should use an encrypted TLS connection (either with STARTTLS or LDAPS).
        """
elif False:
    SsoSettingsLdapSettingsConfigServerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SsoSettingsLdapSettingsConfigServerArgs:
    def __init__(__self__, *,
                 host: pulumi.Input[str],
                 search_base_dns: pulumi.Input[Sequence[pulumi.Input[str]]],
                 search_filter: pulumi.Input[str],
                 attributes: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 bind_dn: Optional[pulumi.Input[str]] = None,
                 bind_password: Optional[pulumi.Input[str]] = None,
                 client_cert: Optional[pulumi.Input[str]] = None,
                 client_cert_value: Optional[pulumi.Input[str]] = None,
                 client_key: Optional[pulumi.Input[str]] = None,
                 client_key_value: Optional[pulumi.Input[str]] = None,
                 group_mappings: Optional[pulumi.Input[Sequence[pulumi.Input['SsoSettingsLdapSettingsConfigServerGroupMappingArgs']]]] = None,
                 group_search_base_dns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 group_search_filter: Optional[pulumi.Input[str]] = None,
                 group_search_filter_user_attribute: Optional[pulumi.Input[str]] = None,
                 min_tls_version: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 root_ca_cert: Optional[pulumi.Input[str]] = None,
                 root_ca_cert_values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 ssl_skip_verify: Optional[pulumi.Input[bool]] = None,
                 start_tls: Optional[pulumi.Input[bool]] = None,
                 timeout: Optional[pulumi.Input[int]] = None,
                 tls_ciphers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 use_ssl: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] host: The LDAP server host.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] search_base_dns: An array of base DNs to search through.
        :param pulumi.Input[str] search_filter: The user search filter, for example "(cn=%s)" or "(sAMAccountName=%s)" or "(uid=%s)".
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] attributes: The LDAP server attributes. The following attributes can be configured: email, member_of, name, surname, username.
        :param pulumi.Input[str] bind_dn: The search user bind DN.
        :param pulumi.Input[str] bind_password: The search user bind password.
        :param pulumi.Input[str] client_cert: The path to the client certificate.
        :param pulumi.Input[str] client_cert_value: The Base64 encoded value of the client certificate.
        :param pulumi.Input[str] client_key: The path to the client private key.
        :param pulumi.Input[str] client_key_value: The Base64 encoded value of the client private key.
        :param pulumi.Input[Sequence[pulumi.Input['SsoSettingsLdapSettingsConfigServerGroupMappingArgs']]] group_mappings: For mapping an LDAP group to a Grafana organization and role.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] group_search_base_dns: An array of the base DNs to search through for groups. Typically uses ou=groups.
        :param pulumi.Input[str] group_search_filter: Group search filter, to retrieve the groups of which the user is a member (only set if memberOf attribute is not available).
        :param pulumi.Input[str] group_search_filter_user_attribute: The %s in the search filter will be replaced with the attribute defined in this field.
        :param pulumi.Input[str] min_tls_version: Minimum TLS version allowed. Accepted values are: TLS1.2, TLS1.3.
        :param pulumi.Input[int] port: The LDAP server port.
        :param pulumi.Input[str] root_ca_cert: The path to the root CA certificate.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] root_ca_cert_values: The Base64 encoded values of the root CA certificates.
        :param pulumi.Input[bool] ssl_skip_verify: If set to true, the SSL cert validation will be skipped.
        :param pulumi.Input[bool] start_tls: If set to true, use LDAP with STARTTLS instead of LDAPS.
        :param pulumi.Input[int] timeout: The timeout in seconds for connecting to the LDAP host.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] tls_ciphers: Accepted TLS ciphers. For a complete list of supported ciphers, refer to: https://go.dev/src/crypto/tls/cipher_suites.go.
        :param pulumi.Input[bool] use_ssl: Set to true if LDAP server should use an encrypted TLS connection (either with STARTTLS or LDAPS).
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "search_base_dns", search_base_dns)
        pulumi.set(__self__, "search_filter", search_filter)
        if attributes is not None:
            pulumi.set(__self__, "attributes", attributes)
        if bind_dn is not None:
            pulumi.set(__self__, "bind_dn", bind_dn)
        if bind_password is not None:
            pulumi.set(__self__, "bind_password", bind_password)
        if client_cert is not None:
            pulumi.set(__self__, "client_cert", client_cert)
        if client_cert_value is not None:
            pulumi.set(__self__, "client_cert_value", client_cert_value)
        if client_key is not None:
            pulumi.set(__self__, "client_key", client_key)
        if client_key_value is not None:
            pulumi.set(__self__, "client_key_value", client_key_value)
        if group_mappings is not None:
            pulumi.set(__self__, "group_mappings", group_mappings)
        if group_search_base_dns is not None:
            pulumi.set(__self__, "group_search_base_dns", group_search_base_dns)
        if group_search_filter is not None:
            pulumi.set(__self__, "group_search_filter", group_search_filter)
        if group_search_filter_user_attribute is not None:
            pulumi.set(__self__, "group_search_filter_user_attribute", group_search_filter_user_attribute)
        if min_tls_version is not None:
            pulumi.set(__self__, "min_tls_version", min_tls_version)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if root_ca_cert is not None:
            pulumi.set(__self__, "root_ca_cert", root_ca_cert)
        if root_ca_cert_values is not None:
            pulumi.set(__self__, "root_ca_cert_values", root_ca_cert_values)
        if ssl_skip_verify is not None:
            pulumi.set(__self__, "ssl_skip_verify", ssl_skip_verify)
        if start_tls is not None:
            pulumi.set(__self__, "start_tls", start_tls)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if tls_ciphers is not None:
            pulumi.set(__self__, "tls_ciphers", tls_ciphers)
        if use_ssl is not None:
            pulumi.set(__self__, "use_ssl", use_ssl)

    @property
    @pulumi.getter
    def host(self) -> pulumi.Input[str]:
        """
        The LDAP server host.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[str]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter(name="searchBaseDns")
    def search_base_dns(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        An array of base DNs to search through.
        """
        return pulumi.get(self, "search_base_dns")

    @search_base_dns.setter
    def search_base_dns(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "search_base_dns", value)

    @property
    @pulumi.getter(name="searchFilter")
    def search_filter(self) -> pulumi.Input[str]:
        """
        The user search filter, for example "(cn=%s)" or "(sAMAccountName=%s)" or "(uid=%s)".
        """
        return pulumi.get(self, "search_filter")

    @search_filter.setter
    def search_filter(self, value: pulumi.Input[str]):
        pulumi.set(self, "search_filter", value)

    @property
    @pulumi.getter
    def attributes(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        The LDAP server attributes. The following attributes can be configured: email, member_of, name, surname, username.
        """
        return pulumi.get(self, "attributes")

    @attributes.setter
    def attributes(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "attributes", value)

    @property
    @pulumi.getter(name="bindDn")
    def bind_dn(self) -> Optional[pulumi.Input[str]]:
        """
        The search user bind DN.
        """
        return pulumi.get(self, "bind_dn")

    @bind_dn.setter
    def bind_dn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bind_dn", value)

    @property
    @pulumi.getter(name="bindPassword")
    def bind_password(self) -> Optional[pulumi.Input[str]]:
        """
        The search user bind password.
        """
        return pulumi.get(self, "bind_password")

    @bind_password.setter
    def bind_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bind_password", value)

    @property
    @pulumi.getter(name="clientCert")
    def client_cert(self) -> Optional[pulumi.Input[str]]:
        """
        The path to the client certificate.
        """
        return pulumi.get(self, "client_cert")

    @client_cert.setter
    def client_cert(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_cert", value)

    @property
    @pulumi.getter(name="clientCertValue")
    def client_cert_value(self) -> Optional[pulumi.Input[str]]:
        """
        The Base64 encoded value of the client certificate.
        """
        return pulumi.get(self, "client_cert_value")

    @client_cert_value.setter
    def client_cert_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_cert_value", value)

    @property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> Optional[pulumi.Input[str]]:
        """
        The path to the client private key.
        """
        return pulumi.get(self, "client_key")

    @client_key.setter
    def client_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_key", value)

    @property
    @pulumi.getter(name="clientKeyValue")
    def client_key_value(self) -> Optional[pulumi.Input[str]]:
        """
        The Base64 encoded value of the client private key.
        """
        return pulumi.get(self, "client_key_value")

    @client_key_value.setter
    def client_key_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_key_value", value)

    @property
    @pulumi.getter(name="groupMappings")
    def group_mappings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SsoSettingsLdapSettingsConfigServerGroupMappingArgs']]]]:
        """
        For mapping an LDAP group to a Grafana organization and role.
        """
        return pulumi.get(self, "group_mappings")

    @group_mappings.setter
    def group_mappings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SsoSettingsLdapSettingsConfigServerGroupMappingArgs']]]]):
        pulumi.set(self, "group_mappings", value)

    @property
    @pulumi.getter(name="groupSearchBaseDns")
    def group_search_base_dns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of the base DNs to search through for groups. Typically uses ou=groups.
        """
        return pulumi.get(self, "group_search_base_dns")

    @group_search_base_dns.setter
    def group_search_base_dns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "group_search_base_dns", value)

    @property
    @pulumi.getter(name="groupSearchFilter")
    def group_search_filter(self) -> Optional[pulumi.Input[str]]:
        """
        Group search filter, to retrieve the groups of which the user is a member (only set if memberOf attribute is not available).
        """
        return pulumi.get(self, "group_search_filter")

    @group_search_filter.setter
    def group_search_filter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group_search_filter", value)

    @property
    @pulumi.getter(name="groupSearchFilterUserAttribute")
    def group_search_filter_user_attribute(self) -> Optional[pulumi.Input[str]]:
        """
        The %s in the search filter will be replaced with the attribute defined in this field.
        """
        return pulumi.get(self, "group_search_filter_user_attribute")

    @group_search_filter_user_attribute.setter
    def group_search_filter_user_attribute(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group_search_filter_user_attribute", value)

    @property
    @pulumi.getter(name="minTlsVersion")
    def min_tls_version(self) -> Optional[pulumi.Input[str]]:
        """
        Minimum TLS version allowed. Accepted values are: TLS1.2, TLS1.3.
        """
        return pulumi.get(self, "min_tls_version")

    @min_tls_version.setter
    def min_tls_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "min_tls_version", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        The LDAP server port.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="rootCaCert")
    def root_ca_cert(self) -> Optional[pulumi.Input[str]]:
        """
        The path to the root CA certificate.
        """
        return pulumi.get(self, "root_ca_cert")

    @root_ca_cert.setter
    def root_ca_cert(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "root_ca_cert", value)

    @property
    @pulumi.getter(name="rootCaCertValues")
    def root_ca_cert_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The Base64 encoded values of the root CA certificates.
        """
        return pulumi.get(self, "root_ca_cert_values")

    @root_ca_cert_values.setter
    def root_ca_cert_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "root_ca_cert_values", value)

    @property
    @pulumi.getter(name="sslSkipVerify")
    def ssl_skip_verify(self) -> Optional[pulumi.Input[bool]]:
        """
        If set to true, the SSL cert validation will be skipped.
        """
        return pulumi.get(self, "ssl_skip_verify")

    @ssl_skip_verify.setter
    def ssl_skip_verify(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ssl_skip_verify", value)

    @property
    @pulumi.getter(name="startTls")
    def start_tls(self) -> Optional[pulumi.Input[bool]]:
        """
        If set to true, use LDAP with STARTTLS instead of LDAPS.
        """
        return pulumi.get(self, "start_tls")

    @start_tls.setter
    def start_tls(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "start_tls", value)

    @property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[int]]:
        """
        The timeout in seconds for connecting to the LDAP host.
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout", value)

    @property
    @pulumi.getter(name="tlsCiphers")
    def tls_ciphers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Accepted TLS ciphers. For a complete list of supported ciphers, refer to: https://go.dev/src/crypto/tls/cipher_suites.go.
        """
        return pulumi.get(self, "tls_ciphers")

    @tls_ciphers.setter
    def tls_ciphers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "tls_ciphers", value)

    @property
    @pulumi.getter(name="useSsl")
    def use_ssl(self) -> Optional[pulumi.Input[bool]]:
        """
        Set to true if LDAP server should use an encrypted TLS connection (either with STARTTLS or LDAPS).
        """
        return pulumi.get(self, "use_ssl")

    @use_ssl.setter
    def use_ssl(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_ssl", value)


if not MYPY:
    class SsoSettingsLdapSettingsConfigServerGroupMappingArgsDict(TypedDict):
        group_dn: pulumi.Input[str]
        """
        LDAP distinguished name (DN) of LDAP group. If you want to match all (or no LDAP groups) then you can use wildcard ("*").
        """
        org_role: pulumi.Input[str]
        """
        Assign users of group_dn the organization role Admin, Editor, or Viewer.
        """
        grafana_admin: NotRequired[pulumi.Input[bool]]
        """
        If set to true, it makes the user of group_dn Grafana server admin.
        """
        org_id: NotRequired[pulumi.Input[int]]
        """
        The Grafana organization database id.
        """
elif False:
    SsoSettingsLdapSettingsConfigServerGroupMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SsoSettingsLdapSettingsConfigServerGroupMappingArgs:
    def __init__(__self__, *,
                 group_dn: pulumi.Input[str],
                 org_role: pulumi.Input[str],
                 grafana_admin: Optional[pulumi.Input[bool]] = None,
                 org_id: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] group_dn: LDAP distinguished name (DN) of LDAP group. If you want to match all (or no LDAP groups) then you can use wildcard ("*").
        :param pulumi.Input[str] org_role: Assign users of group_dn the organization role Admin, Editor, or Viewer.
        :param pulumi.Input[bool] grafana_admin: If set to true, it makes the user of group_dn Grafana server admin.
        :param pulumi.Input[int] org_id: The Grafana organization database id.
        """
        pulumi.set(__self__, "group_dn", group_dn)
        pulumi.set(__self__, "org_role", org_role)
        if grafana_admin is not None:
            pulumi.set(__self__, "grafana_admin", grafana_admin)
        if org_id is not None:
            pulumi.set(__self__, "org_id", org_id)

    @property
    @pulumi.getter(name="groupDn")
    def group_dn(self) -> pulumi.Input[str]:
        """
        LDAP distinguished name (DN) of LDAP group. If you want to match all (or no LDAP groups) then you can use wildcard ("*").
        """
        return pulumi.get(self, "group_dn")

    @group_dn.setter
    def group_dn(self, value: pulumi.Input[str]):
        pulumi.set(self, "group_dn", value)

    @property
    @pulumi.getter(name="orgRole")
    def org_role(self) -> pulumi.Input[str]:
        """
        Assign users of group_dn the organization role Admin, Editor, or Viewer.
        """
        return pulumi.get(self, "org_role")

    @org_role.setter
    def org_role(self, value: pulumi.Input[str]):
        pulumi.set(self, "org_role", value)

    @property
    @pulumi.getter(name="grafanaAdmin")
    def grafana_admin(self) -> Optional[pulumi.Input[bool]]:
        """
        If set to true, it makes the user of group_dn Grafana server admin.
        """
        return pulumi.get(self, "grafana_admin")

    @grafana_admin.setter
    def grafana_admin(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "grafana_admin", value)

    @property
    @pulumi.getter(name="orgId")
    def org_id(self) -> Optional[pulumi.Input[int]]:
        """
        The Grafana organization database id.
        """
        return pulumi.get(self, "org_id")

    @org_id.setter
    def org_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "org_id", value)


if not MYPY:
    class SsoSettingsOauth2SettingsArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The client Id of your OAuth2 app.
        """
        allow_assign_grafana_admin: NotRequired[pulumi.Input[bool]]
        """
        If enabled, it will automatically sync the Grafana server administrator role.
        """
        allow_sign_up: NotRequired[pulumi.Input[bool]]
        """
        If not enabled, only existing Grafana users can log in using OAuth.
        """
        allowed_domains: NotRequired[pulumi.Input[str]]
        """
        List of comma- or space-separated domains. The user should belong to at least one domain to log in.
        """
        allowed_groups: NotRequired[pulumi.Input[str]]
        """
        List of comma- or space-separated groups. The user should be a member of at least one group to log in. For Generic OAuth, if you configure allowed*groups, you must also configure groups*attribute_path.
        """
        allowed_organizations: NotRequired[pulumi.Input[str]]
        """
        List of comma- or space-separated organizations. The user should be a member of at least one organization to log in.
        """
        api_url: NotRequired[pulumi.Input[str]]
        """
        The user information endpoint of your OAuth2 provider. Required for okta and generic_oauth providers.
        """
        auth_style: NotRequired[pulumi.Input[str]]
        """
        It determines how client*id and client*secret are sent to Oauth2 provider. Possible values are AutoDetect, InParams, InHeader. Default is AutoDetect.
        """
        auth_url: NotRequired[pulumi.Input[str]]
        """
        The authorization endpoint of your OAuth2 provider. Required for azuread, okta and generic_oauth providers.
        """
        auto_login: NotRequired[pulumi.Input[bool]]
        """
        Log in automatically, skipping the login screen.
        """
        client_secret: NotRequired[pulumi.Input[str]]
        """
        The client secret of your OAuth2 app.
        """
        custom: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Custom fields to configure for OAuth2 such as the [force*use*graph_api](https://grafana.com/docs/grafana/latest/setup-grafana/configure-security/configure-authentication/azuread/#force-fetching-groups-from-microsoft-graph-api) field.
        """
        define_allowed_groups: NotRequired[pulumi.Input[bool]]
        """
        Define allowed groups.
        """
        define_allowed_teams_ids: NotRequired[pulumi.Input[bool]]
        """
        Define allowed teams ids.
        """
        email_attribute_name: NotRequired[pulumi.Input[str]]
        """
        Name of the key to use for user email lookup within the attributes map of OAuth2 ID token. Only applicable to Generic OAuth.
        """
        email_attribute_path: NotRequired[pulumi.Input[str]]
        """
        JMESPath expression to use for user email lookup from the user information. Only applicable to Generic OAuth.
        """
        empty_scopes: NotRequired[pulumi.Input[bool]]
        """
        If enabled, no scopes will be sent to the OAuth2 provider.
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Define whether this configuration is enabled for the specified provider. Defaults to `true`.
        """
        groups_attribute_path: NotRequired[pulumi.Input[str]]
        """
        JMESPath expression to use for user group lookup. If you configure allowed*groups, you must also configure groups*attribute_path.
        """
        id_token_attribute_name: NotRequired[pulumi.Input[str]]
        """
        The name of the key used to extract the ID token from the returned OAuth2 token. Only applicable to Generic OAuth.
        """
        login_attribute_path: NotRequired[pulumi.Input[str]]
        """
        JMESPath expression to use for user login lookup from the user ID token. Only applicable to Generic OAuth.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Helpful if you use more than one identity providers or SSO protocols.
        """
        name_attribute_path: NotRequired[pulumi.Input[str]]
        """
        JMESPath expression to use for user name lookup from the user ID token. This name will be used as the user’s display name. Only applicable to Generic OAuth.
        """
        org_attribute_path: NotRequired[pulumi.Input[str]]
        """
        JMESPath expression to use for the organization mapping lookup from the user ID token. The extracted list will be used for the organization mapping (to match "Organization" in the "org_mapping"). Only applicable to Generic OAuth and Okta.
        """
        org_mapping: NotRequired[pulumi.Input[str]]
        """
        List of comma- or space-separated Organization:OrgIdOrOrgName:Role mappings. Organization can be * meaning “All users”. Role is optional and can have the following values: None, Viewer, Editor or Admin.
        """
        role_attribute_path: NotRequired[pulumi.Input[str]]
        """
        JMESPath expression to use for Grafana role lookup.
        """
        role_attribute_strict: NotRequired[pulumi.Input[bool]]
        """
        If enabled, denies user login if the Grafana role cannot be extracted using Role attribute path.
        """
        scopes: NotRequired[pulumi.Input[str]]
        """
        List of comma- or space-separated OAuth2 scopes.
        """
        signout_redirect_url: NotRequired[pulumi.Input[str]]
        """
        The URL to redirect the user to after signing out from Grafana.
        """
        skip_org_role_sync: NotRequired[pulumi.Input[bool]]
        """
        Prevent synchronizing users’ organization roles from your IdP.
        """
        team_ids: NotRequired[pulumi.Input[str]]
        """
        String list of Team Ids. If set, the user must be a member of one of the given teams to log in. If you configure team*ids, you must also configure teams*url and team*ids*attribute_path.
        """
        team_ids_attribute_path: NotRequired[pulumi.Input[str]]
        """
        The JMESPath expression to use for Grafana Team Id lookup within the results returned by the teams_url endpoint. Only applicable to Generic OAuth.
        """
        teams_url: NotRequired[pulumi.Input[str]]
        """
        The URL used to query for Team Ids. If not set, the default value is /teams. If you configure teams*url, you must also configure team*ids*attribute*path. Only applicable to Generic OAuth.
        """
        tls_client_ca: NotRequired[pulumi.Input[str]]
        """
        The path to the trusted certificate authority list. Is not applicable on Grafana Cloud.
        """
        tls_client_cert: NotRequired[pulumi.Input[str]]
        """
        The path to the certificate. Is not applicable on Grafana Cloud.
        """
        tls_client_key: NotRequired[pulumi.Input[str]]
        """
        The path to the key. Is not applicable on Grafana Cloud.
        """
        tls_skip_verify_insecure: NotRequired[pulumi.Input[bool]]
        """
        If enabled, the client accepts any certificate presented by the server and any host name in that certificate. You should only use this for testing, because this mode leaves SSL/TLS susceptible to man-in-the-middle attacks.
        """
        token_url: NotRequired[pulumi.Input[str]]
        """
        The token endpoint of your OAuth2 provider. Required for azuread, okta and generic_oauth providers.
        """
        use_pkce: NotRequired[pulumi.Input[bool]]
        """
        If enabled, Grafana will use Proof Key for Code Exchange (PKCE) with the OAuth2 Authorization Code Grant.
        """
        use_refresh_token: NotRequired[pulumi.Input[bool]]
        """
        If enabled, Grafana will fetch a new access token using the refresh token provided by the OAuth2 provider.
        """
elif False:
    SsoSettingsOauth2SettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SsoSettingsOauth2SettingsArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 allow_assign_grafana_admin: Optional[pulumi.Input[bool]] = None,
                 allow_sign_up: Optional[pulumi.Input[bool]] = None,
                 allowed_domains: Optional[pulumi.Input[str]] = None,
                 allowed_groups: Optional[pulumi.Input[str]] = None,
                 allowed_organizations: Optional[pulumi.Input[str]] = None,
                 api_url: Optional[pulumi.Input[str]] = None,
                 auth_style: Optional[pulumi.Input[str]] = None,
                 auth_url: Optional[pulumi.Input[str]] = None,
                 auto_login: Optional[pulumi.Input[bool]] = None,
                 client_secret: Optional[pulumi.Input[str]] = None,
                 custom: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 define_allowed_groups: Optional[pulumi.Input[bool]] = None,
                 define_allowed_teams_ids: Optional[pulumi.Input[bool]] = None,
                 email_attribute_name: Optional[pulumi.Input[str]] = None,
                 email_attribute_path: Optional[pulumi.Input[str]] = None,
                 empty_scopes: Optional[pulumi.Input[bool]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 groups_attribute_path: Optional[pulumi.Input[str]] = None,
                 id_token_attribute_name: Optional[pulumi.Input[str]] = None,
                 login_attribute_path: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 name_attribute_path: Optional[pulumi.Input[str]] = None,
                 org_attribute_path: Optional[pulumi.Input[str]] = None,
                 org_mapping: Optional[pulumi.Input[str]] = None,
                 role_attribute_path: Optional[pulumi.Input[str]] = None,
                 role_attribute_strict: Optional[pulumi.Input[bool]] = None,
                 scopes: Optional[pulumi.Input[str]] = None,
                 signout_redirect_url: Optional[pulumi.Input[str]] = None,
                 skip_org_role_sync: Optional[pulumi.Input[bool]] = None,
                 team_ids: Optional[pulumi.Input[str]] = None,
                 team_ids_attribute_path: Optional[pulumi.Input[str]] = None,
                 teams_url: Optional[pulumi.Input[str]] = None,
                 tls_client_ca: Optional[pulumi.Input[str]] = None,
                 tls_client_cert: Optional[pulumi.Input[str]] = None,
                 tls_client_key: Optional[pulumi.Input[str]] = None,
                 tls_skip_verify_insecure: Optional[pulumi.Input[bool]] = None,
                 token_url: Optional[pulumi.Input[str]] = None,
                 use_pkce: Optional[pulumi.Input[bool]] = None,
                 use_refresh_token: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] client_id: The client Id of your OAuth2 app.
        :param pulumi.Input[bool] allow_assign_grafana_admin: If enabled, it will automatically sync the Grafana server administrator role.
        :param pulumi.Input[bool] allow_sign_up: If not enabled, only existing Grafana users can log in using OAuth.
        :param pulumi.Input[str] allowed_domains: List of comma- or space-separated domains. The user should belong to at least one domain to log in.
        :param pulumi.Input[str] allowed_groups: List of comma- or space-separated groups. The user should be a member of at least one group to log in. For Generic OAuth, if you configure allowed*groups, you must also configure groups*attribute_path.
        :param pulumi.Input[str] allowed_organizations: List of comma- or space-separated organizations. The user should be a member of at least one organization to log in.
        :param pulumi.Input[str] api_url: The user information endpoint of your OAuth2 provider. Required for okta and generic_oauth providers.
        :param pulumi.Input[str] auth_style: It determines how client*id and client*secret are sent to Oauth2 provider. Possible values are AutoDetect, InParams, InHeader. Default is AutoDetect.
        :param pulumi.Input[str] auth_url: The authorization endpoint of your OAuth2 provider. Required for azuread, okta and generic_oauth providers.
        :param pulumi.Input[bool] auto_login: Log in automatically, skipping the login screen.
        :param pulumi.Input[str] client_secret: The client secret of your OAuth2 app.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] custom: Custom fields to configure for OAuth2 such as the [force*use*graph_api](https://grafana.com/docs/grafana/latest/setup-grafana/configure-security/configure-authentication/azuread/#force-fetching-groups-from-microsoft-graph-api) field.
        :param pulumi.Input[bool] define_allowed_groups: Define allowed groups.
        :param pulumi.Input[bool] define_allowed_teams_ids: Define allowed teams ids.
        :param pulumi.Input[str] email_attribute_name: Name of the key to use for user email lookup within the attributes map of OAuth2 ID token. Only applicable to Generic OAuth.
        :param pulumi.Input[str] email_attribute_path: JMESPath expression to use for user email lookup from the user information. Only applicable to Generic OAuth.
        :param pulumi.Input[bool] empty_scopes: If enabled, no scopes will be sent to the OAuth2 provider.
        :param pulumi.Input[bool] enabled: Define whether this configuration is enabled for the specified provider. Defaults to `true`.
        :param pulumi.Input[str] groups_attribute_path: JMESPath expression to use for user group lookup. If you configure allowed*groups, you must also configure groups*attribute_path.
        :param pulumi.Input[str] id_token_attribute_name: The name of the key used to extract the ID token from the returned OAuth2 token. Only applicable to Generic OAuth.
        :param pulumi.Input[str] login_attribute_path: JMESPath expression to use for user login lookup from the user ID token. Only applicable to Generic OAuth.
        :param pulumi.Input[str] name: Helpful if you use more than one identity providers or SSO protocols.
        :param pulumi.Input[str] name_attribute_path: JMESPath expression to use for user name lookup from the user ID token. This name will be used as the user’s display name. Only applicable to Generic OAuth.
        :param pulumi.Input[str] org_attribute_path: JMESPath expression to use for the organization mapping lookup from the user ID token. The extracted list will be used for the organization mapping (to match "Organization" in the "org_mapping"). Only applicable to Generic OAuth and Okta.
        :param pulumi.Input[str] org_mapping: List of comma- or space-separated Organization:OrgIdOrOrgName:Role mappings. Organization can be * meaning “All users”. Role is optional and can have the following values: None, Viewer, Editor or Admin.
        :param pulumi.Input[str] role_attribute_path: JMESPath expression to use for Grafana role lookup.
        :param pulumi.Input[bool] role_attribute_strict: If enabled, denies user login if the Grafana role cannot be extracted using Role attribute path.
        :param pulumi.Input[str] scopes: List of comma- or space-separated OAuth2 scopes.
        :param pulumi.Input[str] signout_redirect_url: The URL to redirect the user to after signing out from Grafana.
        :param pulumi.Input[bool] skip_org_role_sync: Prevent synchronizing users’ organization roles from your IdP.
        :param pulumi.Input[str] team_ids: String list of Team Ids. If set, the user must be a member of one of the given teams to log in. If you configure team*ids, you must also configure teams*url and team*ids*attribute_path.
        :param pulumi.Input[str] team_ids_attribute_path: The JMESPath expression to use for Grafana Team Id lookup within the results returned by the teams_url endpoint. Only applicable to Generic OAuth.
        :param pulumi.Input[str] teams_url: The URL used to query for Team Ids. If not set, the default value is /teams. If you configure teams*url, you must also configure team*ids*attribute*path. Only applicable to Generic OAuth.
        :param pulumi.Input[str] tls_client_ca: The path to the trusted certificate authority list. Is not applicable on Grafana Cloud.
        :param pulumi.Input[str] tls_client_cert: The path to the certificate. Is not applicable on Grafana Cloud.
        :param pulumi.Input[str] tls_client_key: The path to the key. Is not applicable on Grafana Cloud.
        :param pulumi.Input[bool] tls_skip_verify_insecure: If enabled, the client accepts any certificate presented by the server and any host name in that certificate. You should only use this for testing, because this mode leaves SSL/TLS susceptible to man-in-the-middle attacks.
        :param pulumi.Input[str] token_url: The token endpoint of your OAuth2 provider. Required for azuread, okta and generic_oauth providers.
        :param pulumi.Input[bool] use_pkce: If enabled, Grafana will use Proof Key for Code Exchange (PKCE) with the OAuth2 Authorization Code Grant.
        :param pulumi.Input[bool] use_refresh_token: If enabled, Grafana will fetch a new access token using the refresh token provided by the OAuth2 provider.
        """
        pulumi.set(__self__, "client_id", client_id)
        if allow_assign_grafana_admin is not None:
            pulumi.set(__self__, "allow_assign_grafana_admin", allow_assign_grafana_admin)
        if allow_sign_up is not None:
            pulumi.set(__self__, "allow_sign_up", allow_sign_up)
        if allowed_domains is not None:
            pulumi.set(__self__, "allowed_domains", allowed_domains)
        if allowed_groups is not None:
            pulumi.set(__self__, "allowed_groups", allowed_groups)
        if allowed_organizations is not None:
            pulumi.set(__self__, "allowed_organizations", allowed_organizations)
        if api_url is not None:
            pulumi.set(__self__, "api_url", api_url)
        if auth_style is not None:
            pulumi.set(__self__, "auth_style", auth_style)
        if auth_url is not None:
            pulumi.set(__self__, "auth_url", auth_url)
        if auto_login is not None:
            pulumi.set(__self__, "auto_login", auto_login)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if custom is not None:
            pulumi.set(__self__, "custom", custom)
        if define_allowed_groups is not None:
            pulumi.set(__self__, "define_allowed_groups", define_allowed_groups)
        if define_allowed_teams_ids is not None:
            pulumi.set(__self__, "define_allowed_teams_ids", define_allowed_teams_ids)
        if email_attribute_name is not None:
            pulumi.set(__self__, "email_attribute_name", email_attribute_name)
        if email_attribute_path is not None:
            pulumi.set(__self__, "email_attribute_path", email_attribute_path)
        if empty_scopes is not None:
            pulumi.set(__self__, "empty_scopes", empty_scopes)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if groups_attribute_path is not None:
            pulumi.set(__self__, "groups_attribute_path", groups_attribute_path)
        if id_token_attribute_name is not None:
            pulumi.set(__self__, "id_token_attribute_name", id_token_attribute_name)
        if login_attribute_path is not None:
            pulumi.set(__self__, "login_attribute_path", login_attribute_path)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if name_attribute_path is not None:
            pulumi.set(__self__, "name_attribute_path", name_attribute_path)
        if org_attribute_path is not None:
            pulumi.set(__self__, "org_attribute_path", org_attribute_path)
        if org_mapping is not None:
            pulumi.set(__self__, "org_mapping", org_mapping)
        if role_attribute_path is not None:
            pulumi.set(__self__, "role_attribute_path", role_attribute_path)
        if role_attribute_strict is not None:
            pulumi.set(__self__, "role_attribute_strict", role_attribute_strict)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if signout_redirect_url is not None:
            pulumi.set(__self__, "signout_redirect_url", signout_redirect_url)
        if skip_org_role_sync is not None:
            pulumi.set(__self__, "skip_org_role_sync", skip_org_role_sync)
        if team_ids is not None:
            pulumi.set(__self__, "team_ids", team_ids)
        if team_ids_attribute_path is not None:
            pulumi.set(__self__, "team_ids_attribute_path", team_ids_attribute_path)
        if teams_url is not None:
            pulumi.set(__self__, "teams_url", teams_url)
        if tls_client_ca is not None:
            pulumi.set(__self__, "tls_client_ca", tls_client_ca)
        if tls_client_cert is not None:
            pulumi.set(__self__, "tls_client_cert", tls_client_cert)
        if tls_client_key is not None:
            pulumi.set(__self__, "tls_client_key", tls_client_key)
        if tls_skip_verify_insecure is not None:
            pulumi.set(__self__, "tls_skip_verify_insecure", tls_skip_verify_insecure)
        if token_url is not None:
            pulumi.set(__self__, "token_url", token_url)
        if use_pkce is not None:
            pulumi.set(__self__, "use_pkce", use_pkce)
        if use_refresh_token is not None:
            pulumi.set(__self__, "use_refresh_token", use_refresh_token)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The client Id of your OAuth2 app.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="allowAssignGrafanaAdmin")
    def allow_assign_grafana_admin(self) -> Optional[pulumi.Input[bool]]:
        """
        If enabled, it will automatically sync the Grafana server administrator role.
        """
        return pulumi.get(self, "allow_assign_grafana_admin")

    @allow_assign_grafana_admin.setter
    def allow_assign_grafana_admin(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_assign_grafana_admin", value)

    @property
    @pulumi.getter(name="allowSignUp")
    def allow_sign_up(self) -> Optional[pulumi.Input[bool]]:
        """
        If not enabled, only existing Grafana users can log in using OAuth.
        """
        return pulumi.get(self, "allow_sign_up")

    @allow_sign_up.setter
    def allow_sign_up(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_sign_up", value)

    @property
    @pulumi.getter(name="allowedDomains")
    def allowed_domains(self) -> Optional[pulumi.Input[str]]:
        """
        List of comma- or space-separated domains. The user should belong to at least one domain to log in.
        """
        return pulumi.get(self, "allowed_domains")

    @allowed_domains.setter
    def allowed_domains(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "allowed_domains", value)

    @property
    @pulumi.getter(name="allowedGroups")
    def allowed_groups(self) -> Optional[pulumi.Input[str]]:
        """
        List of comma- or space-separated groups. The user should be a member of at least one group to log in. For Generic OAuth, if you configure allowed*groups, you must also configure groups*attribute_path.
        """
        return pulumi.get(self, "allowed_groups")

    @allowed_groups.setter
    def allowed_groups(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "allowed_groups", value)

    @property
    @pulumi.getter(name="allowedOrganizations")
    def allowed_organizations(self) -> Optional[pulumi.Input[str]]:
        """
        List of comma- or space-separated organizations. The user should be a member of at least one organization to log in.
        """
        return pulumi.get(self, "allowed_organizations")

    @allowed_organizations.setter
    def allowed_organizations(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "allowed_organizations", value)

    @property
    @pulumi.getter(name="apiUrl")
    def api_url(self) -> Optional[pulumi.Input[str]]:
        """
        The user information endpoint of your OAuth2 provider. Required for okta and generic_oauth providers.
        """
        return pulumi.get(self, "api_url")

    @api_url.setter
    def api_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_url", value)

    @property
    @pulumi.getter(name="authStyle")
    def auth_style(self) -> Optional[pulumi.Input[str]]:
        """
        It determines how client*id and client*secret are sent to Oauth2 provider. Possible values are AutoDetect, InParams, InHeader. Default is AutoDetect.
        """
        return pulumi.get(self, "auth_style")

    @auth_style.setter
    def auth_style(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auth_style", value)

    @property
    @pulumi.getter(name="authUrl")
    def auth_url(self) -> Optional[pulumi.Input[str]]:
        """
        The authorization endpoint of your OAuth2 provider. Required for azuread, okta and generic_oauth providers.
        """
        return pulumi.get(self, "auth_url")

    @auth_url.setter
    def auth_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auth_url", value)

    @property
    @pulumi.getter(name="autoLogin")
    def auto_login(self) -> Optional[pulumi.Input[bool]]:
        """
        Log in automatically, skipping the login screen.
        """
        return pulumi.get(self, "auto_login")

    @auto_login.setter
    def auto_login(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "auto_login", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[str]]:
        """
        The client secret of your OAuth2 app.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter
    def custom(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Custom fields to configure for OAuth2 such as the [force*use*graph_api](https://grafana.com/docs/grafana/latest/setup-grafana/configure-security/configure-authentication/azuread/#force-fetching-groups-from-microsoft-graph-api) field.
        """
        return pulumi.get(self, "custom")

    @custom.setter
    def custom(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "custom", value)

    @property
    @pulumi.getter(name="defineAllowedGroups")
    def define_allowed_groups(self) -> Optional[pulumi.Input[bool]]:
        """
        Define allowed groups.
        """
        return pulumi.get(self, "define_allowed_groups")

    @define_allowed_groups.setter
    def define_allowed_groups(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "define_allowed_groups", value)

    @property
    @pulumi.getter(name="defineAllowedTeamsIds")
    def define_allowed_teams_ids(self) -> Optional[pulumi.Input[bool]]:
        """
        Define allowed teams ids.
        """
        return pulumi.get(self, "define_allowed_teams_ids")

    @define_allowed_teams_ids.setter
    def define_allowed_teams_ids(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "define_allowed_teams_ids", value)

    @property
    @pulumi.getter(name="emailAttributeName")
    def email_attribute_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the key to use for user email lookup within the attributes map of OAuth2 ID token. Only applicable to Generic OAuth.
        """
        return pulumi.get(self, "email_attribute_name")

    @email_attribute_name.setter
    def email_attribute_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "email_attribute_name", value)

    @property
    @pulumi.getter(name="emailAttributePath")
    def email_attribute_path(self) -> Optional[pulumi.Input[str]]:
        """
        JMESPath expression to use for user email lookup from the user information. Only applicable to Generic OAuth.
        """
        return pulumi.get(self, "email_attribute_path")

    @email_attribute_path.setter
    def email_attribute_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "email_attribute_path", value)

    @property
    @pulumi.getter(name="emptyScopes")
    def empty_scopes(self) -> Optional[pulumi.Input[bool]]:
        """
        If enabled, no scopes will be sent to the OAuth2 provider.
        """
        return pulumi.get(self, "empty_scopes")

    @empty_scopes.setter
    def empty_scopes(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "empty_scopes", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Define whether this configuration is enabled for the specified provider. Defaults to `true`.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="groupsAttributePath")
    def groups_attribute_path(self) -> Optional[pulumi.Input[str]]:
        """
        JMESPath expression to use for user group lookup. If you configure allowed*groups, you must also configure groups*attribute_path.
        """
        return pulumi.get(self, "groups_attribute_path")

    @groups_attribute_path.setter
    def groups_attribute_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "groups_attribute_path", value)

    @property
    @pulumi.getter(name="idTokenAttributeName")
    def id_token_attribute_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the key used to extract the ID token from the returned OAuth2 token. Only applicable to Generic OAuth.
        """
        return pulumi.get(self, "id_token_attribute_name")

    @id_token_attribute_name.setter
    def id_token_attribute_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id_token_attribute_name", value)

    @property
    @pulumi.getter(name="loginAttributePath")
    def login_attribute_path(self) -> Optional[pulumi.Input[str]]:
        """
        JMESPath expression to use for user login lookup from the user ID token. Only applicable to Generic OAuth.
        """
        return pulumi.get(self, "login_attribute_path")

    @login_attribute_path.setter
    def login_attribute_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "login_attribute_path", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Helpful if you use more than one identity providers or SSO protocols.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="nameAttributePath")
    def name_attribute_path(self) -> Optional[pulumi.Input[str]]:
        """
        JMESPath expression to use for user name lookup from the user ID token. This name will be used as the user’s display name. Only applicable to Generic OAuth.
        """
        return pulumi.get(self, "name_attribute_path")

    @name_attribute_path.setter
    def name_attribute_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name_attribute_path", value)

    @property
    @pulumi.getter(name="orgAttributePath")
    def org_attribute_path(self) -> Optional[pulumi.Input[str]]:
        """
        JMESPath expression to use for the organization mapping lookup from the user ID token. The extracted list will be used for the organization mapping (to match "Organization" in the "org_mapping"). Only applicable to Generic OAuth and Okta.
        """
        return pulumi.get(self, "org_attribute_path")

    @org_attribute_path.setter
    def org_attribute_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "org_attribute_path", value)

    @property
    @pulumi.getter(name="orgMapping")
    def org_mapping(self) -> Optional[pulumi.Input[str]]:
        """
        List of comma- or space-separated Organization:OrgIdOrOrgName:Role mappings. Organization can be * meaning “All users”. Role is optional and can have the following values: None, Viewer, Editor or Admin.
        """
        return pulumi.get(self, "org_mapping")

    @org_mapping.setter
    def org_mapping(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "org_mapping", value)

    @property
    @pulumi.getter(name="roleAttributePath")
    def role_attribute_path(self) -> Optional[pulumi.Input[str]]:
        """
        JMESPath expression to use for Grafana role lookup.
        """
        return pulumi.get(self, "role_attribute_path")

    @role_attribute_path.setter
    def role_attribute_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role_attribute_path", value)

    @property
    @pulumi.getter(name="roleAttributeStrict")
    def role_attribute_strict(self) -> Optional[pulumi.Input[bool]]:
        """
        If enabled, denies user login if the Grafana role cannot be extracted using Role attribute path.
        """
        return pulumi.get(self, "role_attribute_strict")

    @role_attribute_strict.setter
    def role_attribute_strict(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "role_attribute_strict", value)

    @property
    @pulumi.getter
    def scopes(self) -> Optional[pulumi.Input[str]]:
        """
        List of comma- or space-separated OAuth2 scopes.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scopes", value)

    @property
    @pulumi.getter(name="signoutRedirectUrl")
    def signout_redirect_url(self) -> Optional[pulumi.Input[str]]:
        """
        The URL to redirect the user to after signing out from Grafana.
        """
        return pulumi.get(self, "signout_redirect_url")

    @signout_redirect_url.setter
    def signout_redirect_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "signout_redirect_url", value)

    @property
    @pulumi.getter(name="skipOrgRoleSync")
    def skip_org_role_sync(self) -> Optional[pulumi.Input[bool]]:
        """
        Prevent synchronizing users’ organization roles from your IdP.
        """
        return pulumi.get(self, "skip_org_role_sync")

    @skip_org_role_sync.setter
    def skip_org_role_sync(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "skip_org_role_sync", value)

    @property
    @pulumi.getter(name="teamIds")
    def team_ids(self) -> Optional[pulumi.Input[str]]:
        """
        String list of Team Ids. If set, the user must be a member of one of the given teams to log in. If you configure team*ids, you must also configure teams*url and team*ids*attribute_path.
        """
        return pulumi.get(self, "team_ids")

    @team_ids.setter
    def team_ids(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "team_ids", value)

    @property
    @pulumi.getter(name="teamIdsAttributePath")
    def team_ids_attribute_path(self) -> Optional[pulumi.Input[str]]:
        """
        The JMESPath expression to use for Grafana Team Id lookup within the results returned by the teams_url endpoint. Only applicable to Generic OAuth.
        """
        return pulumi.get(self, "team_ids_attribute_path")

    @team_ids_attribute_path.setter
    def team_ids_attribute_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "team_ids_attribute_path", value)

    @property
    @pulumi.getter(name="teamsUrl")
    def teams_url(self) -> Optional[pulumi.Input[str]]:
        """
        The URL used to query for Team Ids. If not set, the default value is /teams. If you configure teams*url, you must also configure team*ids*attribute*path. Only applicable to Generic OAuth.
        """
        return pulumi.get(self, "teams_url")

    @teams_url.setter
    def teams_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "teams_url", value)

    @property
    @pulumi.getter(name="tlsClientCa")
    def tls_client_ca(self) -> Optional[pulumi.Input[str]]:
        """
        The path to the trusted certificate authority list. Is not applicable on Grafana Cloud.
        """
        return pulumi.get(self, "tls_client_ca")

    @tls_client_ca.setter
    def tls_client_ca(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tls_client_ca", value)

    @property
    @pulumi.getter(name="tlsClientCert")
    def tls_client_cert(self) -> Optional[pulumi.Input[str]]:
        """
        The path to the certificate. Is not applicable on Grafana Cloud.
        """
        return pulumi.get(self, "tls_client_cert")

    @tls_client_cert.setter
    def tls_client_cert(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tls_client_cert", value)

    @property
    @pulumi.getter(name="tlsClientKey")
    def tls_client_key(self) -> Optional[pulumi.Input[str]]:
        """
        The path to the key. Is not applicable on Grafana Cloud.
        """
        return pulumi.get(self, "tls_client_key")

    @tls_client_key.setter
    def tls_client_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tls_client_key", value)

    @property
    @pulumi.getter(name="tlsSkipVerifyInsecure")
    def tls_skip_verify_insecure(self) -> Optional[pulumi.Input[bool]]:
        """
        If enabled, the client accepts any certificate presented by the server and any host name in that certificate. You should only use this for testing, because this mode leaves SSL/TLS susceptible to man-in-the-middle attacks.
        """
        return pulumi.get(self, "tls_skip_verify_insecure")

    @tls_skip_verify_insecure.setter
    def tls_skip_verify_insecure(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "tls_skip_verify_insecure", value)

    @property
    @pulumi.getter(name="tokenUrl")
    def token_url(self) -> Optional[pulumi.Input[str]]:
        """
        The token endpoint of your OAuth2 provider. Required for azuread, okta and generic_oauth providers.
        """
        return pulumi.get(self, "token_url")

    @token_url.setter
    def token_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "token_url", value)

    @property
    @pulumi.getter(name="usePkce")
    def use_pkce(self) -> Optional[pulumi.Input[bool]]:
        """
        If enabled, Grafana will use Proof Key for Code Exchange (PKCE) with the OAuth2 Authorization Code Grant.
        """
        return pulumi.get(self, "use_pkce")

    @use_pkce.setter
    def use_pkce(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_pkce", value)

    @property
    @pulumi.getter(name="useRefreshToken")
    def use_refresh_token(self) -> Optional[pulumi.Input[bool]]:
        """
        If enabled, Grafana will fetch a new access token using the refresh token provided by the OAuth2 provider.
        """
        return pulumi.get(self, "use_refresh_token")

    @use_refresh_token.setter
    def use_refresh_token(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_refresh_token", value)


if not MYPY:
    class SsoSettingsSamlSettingsArgsDict(TypedDict):
        allow_idp_initiated: NotRequired[pulumi.Input[bool]]
        """
        Whether SAML IdP-initiated login is allowed.
        """
        allow_sign_up: NotRequired[pulumi.Input[bool]]
        """
        Whether to allow new Grafana user creation through SAML login. If set to false, then only existing Grafana users can log in with SAML.
        """
        allowed_organizations: NotRequired[pulumi.Input[str]]
        """
        List of comma- or space-separated organizations. User should be a member of at least one organization to log in.
        """
        assertion_attribute_email: NotRequired[pulumi.Input[str]]
        """
        Friendly name or name of the attribute within the SAML assertion to use as the user email.
        """
        assertion_attribute_groups: NotRequired[pulumi.Input[str]]
        """
        Friendly name or name of the attribute within the SAML assertion to use as the user groups.
        """
        assertion_attribute_login: NotRequired[pulumi.Input[str]]
        """
        Friendly name or name of the attribute within the SAML assertion to use as the user login handle.
        """
        assertion_attribute_name: NotRequired[pulumi.Input[str]]
        """
        Friendly name or name of the attribute within the SAML assertion to use as the user name. Alternatively, this can be a template with variables that match the names of attributes within the SAML assertion.
        """
        assertion_attribute_org: NotRequired[pulumi.Input[str]]
        """
        Friendly name or name of the attribute within the SAML assertion to use as the user organization.
        """
        assertion_attribute_role: NotRequired[pulumi.Input[str]]
        """
        Friendly name or name of the attribute within the SAML assertion to use as the user roles.
        """
        auto_login: NotRequired[pulumi.Input[bool]]
        """
        Whether SAML auto login is enabled.
        """
        certificate: NotRequired[pulumi.Input[str]]
        """
        Base64-encoded string for the SP X.509 certificate.
        """
        certificate_path: NotRequired[pulumi.Input[str]]
        """
        Path for the SP X.509 certificate.
        """
        client_id: NotRequired[pulumi.Input[str]]
        """
        The client Id of your OAuth2 app.
        """
        client_secret: NotRequired[pulumi.Input[str]]
        """
        The client secret of your OAuth2 app.
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Define whether this configuration is enabled for SAML. Defaults to `true`.
        """
        entity_id: NotRequired[pulumi.Input[str]]
        """
        The entity ID is a globally unique identifier for the service provider. It is used to identify the service provider to the identity provider. Defaults to the URL of the Grafana instance if not set.
        """
        force_use_graph_api: NotRequired[pulumi.Input[bool]]
        """
        If enabled, Grafana will fetch groups from Microsoft Graph API instead of using the groups claim from the ID token.
        """
        idp_metadata: NotRequired[pulumi.Input[str]]
        """
        Base64-encoded string for the IdP SAML metadata XML.
        """
        idp_metadata_path: NotRequired[pulumi.Input[str]]
        """
        Path for the IdP SAML metadata XML.
        """
        idp_metadata_url: NotRequired[pulumi.Input[str]]
        """
        URL for the IdP SAML metadata XML.
        """
        max_issue_delay: NotRequired[pulumi.Input[str]]
        """
        Duration, since the IdP issued a response and the SP is allowed to process it. For example: 90s, 1h.
        """
        metadata_valid_duration: NotRequired[pulumi.Input[str]]
        """
        Duration, for how long the SP metadata is valid. For example: 48h, 5d.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name used to refer to the SAML authentication.
        """
        name_id_format: NotRequired[pulumi.Input[str]]
        """
        The Name ID Format to request within the SAML assertion. Defaults to urn:oasis:names:tc:SAML:2.0:nameid-format:transient
        """
        org_mapping: NotRequired[pulumi.Input[str]]
        """
        List of comma- or space-separated Organization:OrgId:Role mappings. Organization can be * meaning “All users”. Role is optional and can have the following values: Viewer, Editor or Admin.
        """
        private_key: NotRequired[pulumi.Input[str]]
        """
        Base64-encoded string for the SP private key.
        """
        private_key_path: NotRequired[pulumi.Input[str]]
        """
        Path for the SP private key.
        """
        relay_state: NotRequired[pulumi.Input[str]]
        """
        Relay state for IdP-initiated login. Should match relay state configured in IdP.
        """
        role_values_admin: NotRequired[pulumi.Input[str]]
        """
        List of comma- or space-separated roles which will be mapped into the Admin role.
        """
        role_values_editor: NotRequired[pulumi.Input[str]]
        """
        List of comma- or space-separated roles which will be mapped into the Editor role.
        """
        role_values_grafana_admin: NotRequired[pulumi.Input[str]]
        """
        List of comma- or space-separated roles which will be mapped into the Grafana Admin (Super Admin) role.
        """
        role_values_none: NotRequired[pulumi.Input[str]]
        """
        List of comma- or space-separated roles which will be mapped into the None role.
        """
        role_values_viewer: NotRequired[pulumi.Input[str]]
        """
        List of comma- or space-separated roles which will be mapped into the Viewer role.
        """
        signature_algorithm: NotRequired[pulumi.Input[str]]
        """
        Signature algorithm used for signing requests to the IdP. Supported values are rsa-sha1, rsa-sha256, rsa-sha512.
        """
        single_logout: NotRequired[pulumi.Input[bool]]
        """
        Whether SAML Single Logout is enabled.
        """
        skip_org_role_sync: NotRequired[pulumi.Input[bool]]
        """
        Prevent synchronizing users’ organization roles from your IdP.
        """
        token_url: NotRequired[pulumi.Input[str]]
        """
        The token endpoint of your OAuth2 provider. Required for Azure AD providers.
        """
elif False:
    SsoSettingsSamlSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SsoSettingsSamlSettingsArgs:
    def __init__(__self__, *,
                 allow_idp_initiated: Optional[pulumi.Input[bool]] = None,
                 allow_sign_up: Optional[pulumi.Input[bool]] = None,
                 allowed_organizations: Optional[pulumi.Input[str]] = None,
                 assertion_attribute_email: Optional[pulumi.Input[str]] = None,
                 assertion_attribute_groups: Optional[pulumi.Input[str]] = None,
                 assertion_attribute_login: Optional[pulumi.Input[str]] = None,
                 assertion_attribute_name: Optional[pulumi.Input[str]] = None,
                 assertion_attribute_org: Optional[pulumi.Input[str]] = None,
                 assertion_attribute_role: Optional[pulumi.Input[str]] = None,
                 auto_login: Optional[pulumi.Input[bool]] = None,
                 certificate: Optional[pulumi.Input[str]] = None,
                 certificate_path: Optional[pulumi.Input[str]] = None,
                 client_id: Optional[pulumi.Input[str]] = None,
                 client_secret: Optional[pulumi.Input[str]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 entity_id: Optional[pulumi.Input[str]] = None,
                 force_use_graph_api: Optional[pulumi.Input[bool]] = None,
                 idp_metadata: Optional[pulumi.Input[str]] = None,
                 idp_metadata_path: Optional[pulumi.Input[str]] = None,
                 idp_metadata_url: Optional[pulumi.Input[str]] = None,
                 max_issue_delay: Optional[pulumi.Input[str]] = None,
                 metadata_valid_duration: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 name_id_format: Optional[pulumi.Input[str]] = None,
                 org_mapping: Optional[pulumi.Input[str]] = None,
                 private_key: Optional[pulumi.Input[str]] = None,
                 private_key_path: Optional[pulumi.Input[str]] = None,
                 relay_state: Optional[pulumi.Input[str]] = None,
                 role_values_admin: Optional[pulumi.Input[str]] = None,
                 role_values_editor: Optional[pulumi.Input[str]] = None,
                 role_values_grafana_admin: Optional[pulumi.Input[str]] = None,
                 role_values_none: Optional[pulumi.Input[str]] = None,
                 role_values_viewer: Optional[pulumi.Input[str]] = None,
                 signature_algorithm: Optional[pulumi.Input[str]] = None,
                 single_logout: Optional[pulumi.Input[bool]] = None,
                 skip_org_role_sync: Optional[pulumi.Input[bool]] = None,
                 token_url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] allow_idp_initiated: Whether SAML IdP-initiated login is allowed.
        :param pulumi.Input[bool] allow_sign_up: Whether to allow new Grafana user creation through SAML login. If set to false, then only existing Grafana users can log in with SAML.
        :param pulumi.Input[str] allowed_organizations: List of comma- or space-separated organizations. User should be a member of at least one organization to log in.
        :param pulumi.Input[str] assertion_attribute_email: Friendly name or name of the attribute within the SAML assertion to use as the user email.
        :param pulumi.Input[str] assertion_attribute_groups: Friendly name or name of the attribute within the SAML assertion to use as the user groups.
        :param pulumi.Input[str] assertion_attribute_login: Friendly name or name of the attribute within the SAML assertion to use as the user login handle.
        :param pulumi.Input[str] assertion_attribute_name: Friendly name or name of the attribute within the SAML assertion to use as the user name. Alternatively, this can be a template with variables that match the names of attributes within the SAML assertion.
        :param pulumi.Input[str] assertion_attribute_org: Friendly name or name of the attribute within the SAML assertion to use as the user organization.
        :param pulumi.Input[str] assertion_attribute_role: Friendly name or name of the attribute within the SAML assertion to use as the user roles.
        :param pulumi.Input[bool] auto_login: Whether SAML auto login is enabled.
        :param pulumi.Input[str] certificate: Base64-encoded string for the SP X.509 certificate.
        :param pulumi.Input[str] certificate_path: Path for the SP X.509 certificate.
        :param pulumi.Input[str] client_id: The client Id of your OAuth2 app.
        :param pulumi.Input[str] client_secret: The client secret of your OAuth2 app.
        :param pulumi.Input[bool] enabled: Define whether this configuration is enabled for SAML. Defaults to `true`.
        :param pulumi.Input[str] entity_id: The entity ID is a globally unique identifier for the service provider. It is used to identify the service provider to the identity provider. Defaults to the URL of the Grafana instance if not set.
        :param pulumi.Input[bool] force_use_graph_api: If enabled, Grafana will fetch groups from Microsoft Graph API instead of using the groups claim from the ID token.
        :param pulumi.Input[str] idp_metadata: Base64-encoded string for the IdP SAML metadata XML.
        :param pulumi.Input[str] idp_metadata_path: Path for the IdP SAML metadata XML.
        :param pulumi.Input[str] idp_metadata_url: URL for the IdP SAML metadata XML.
        :param pulumi.Input[str] max_issue_delay: Duration, since the IdP issued a response and the SP is allowed to process it. For example: 90s, 1h.
        :param pulumi.Input[str] metadata_valid_duration: Duration, for how long the SP metadata is valid. For example: 48h, 5d.
        :param pulumi.Input[str] name: Name used to refer to the SAML authentication.
        :param pulumi.Input[str] name_id_format: The Name ID Format to request within the SAML assertion. Defaults to urn:oasis:names:tc:SAML:2.0:nameid-format:transient
        :param pulumi.Input[str] org_mapping: List of comma- or space-separated Organization:OrgId:Role mappings. Organization can be * meaning “All users”. Role is optional and can have the following values: Viewer, Editor or Admin.
        :param pulumi.Input[str] private_key: Base64-encoded string for the SP private key.
        :param pulumi.Input[str] private_key_path: Path for the SP private key.
        :param pulumi.Input[str] relay_state: Relay state for IdP-initiated login. Should match relay state configured in IdP.
        :param pulumi.Input[str] role_values_admin: List of comma- or space-separated roles which will be mapped into the Admin role.
        :param pulumi.Input[str] role_values_editor: List of comma- or space-separated roles which will be mapped into the Editor role.
        :param pulumi.Input[str] role_values_grafana_admin: List of comma- or space-separated roles which will be mapped into the Grafana Admin (Super Admin) role.
        :param pulumi.Input[str] role_values_none: List of comma- or space-separated roles which will be mapped into the None role.
        :param pulumi.Input[str] role_values_viewer: List of comma- or space-separated roles which will be mapped into the Viewer role.
        :param pulumi.Input[str] signature_algorithm: Signature algorithm used for signing requests to the IdP. Supported values are rsa-sha1, rsa-sha256, rsa-sha512.
        :param pulumi.Input[bool] single_logout: Whether SAML Single Logout is enabled.
        :param pulumi.Input[bool] skip_org_role_sync: Prevent synchronizing users’ organization roles from your IdP.
        :param pulumi.Input[str] token_url: The token endpoint of your OAuth2 provider. Required for Azure AD providers.
        """
        if allow_idp_initiated is not None:
            pulumi.set(__self__, "allow_idp_initiated", allow_idp_initiated)
        if allow_sign_up is not None:
            pulumi.set(__self__, "allow_sign_up", allow_sign_up)
        if allowed_organizations is not None:
            pulumi.set(__self__, "allowed_organizations", allowed_organizations)
        if assertion_attribute_email is not None:
            pulumi.set(__self__, "assertion_attribute_email", assertion_attribute_email)
        if assertion_attribute_groups is not None:
            pulumi.set(__self__, "assertion_attribute_groups", assertion_attribute_groups)
        if assertion_attribute_login is not None:
            pulumi.set(__self__, "assertion_attribute_login", assertion_attribute_login)
        if assertion_attribute_name is not None:
            pulumi.set(__self__, "assertion_attribute_name", assertion_attribute_name)
        if assertion_attribute_org is not None:
            pulumi.set(__self__, "assertion_attribute_org", assertion_attribute_org)
        if assertion_attribute_role is not None:
            pulumi.set(__self__, "assertion_attribute_role", assertion_attribute_role)
        if auto_login is not None:
            pulumi.set(__self__, "auto_login", auto_login)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if certificate_path is not None:
            pulumi.set(__self__, "certificate_path", certificate_path)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if entity_id is not None:
            pulumi.set(__self__, "entity_id", entity_id)
        if force_use_graph_api is not None:
            pulumi.set(__self__, "force_use_graph_api", force_use_graph_api)
        if idp_metadata is not None:
            pulumi.set(__self__, "idp_metadata", idp_metadata)
        if idp_metadata_path is not None:
            pulumi.set(__self__, "idp_metadata_path", idp_metadata_path)
        if idp_metadata_url is not None:
            pulumi.set(__self__, "idp_metadata_url", idp_metadata_url)
        if max_issue_delay is not None:
            pulumi.set(__self__, "max_issue_delay", max_issue_delay)
        if metadata_valid_duration is not None:
            pulumi.set(__self__, "metadata_valid_duration", metadata_valid_duration)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if name_id_format is not None:
            pulumi.set(__self__, "name_id_format", name_id_format)
        if org_mapping is not None:
            pulumi.set(__self__, "org_mapping", org_mapping)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if private_key_path is not None:
            pulumi.set(__self__, "private_key_path", private_key_path)
        if relay_state is not None:
            pulumi.set(__self__, "relay_state", relay_state)
        if role_values_admin is not None:
            pulumi.set(__self__, "role_values_admin", role_values_admin)
        if role_values_editor is not None:
            pulumi.set(__self__, "role_values_editor", role_values_editor)
        if role_values_grafana_admin is not None:
            pulumi.set(__self__, "role_values_grafana_admin", role_values_grafana_admin)
        if role_values_none is not None:
            pulumi.set(__self__, "role_values_none", role_values_none)
        if role_values_viewer is not None:
            pulumi.set(__self__, "role_values_viewer", role_values_viewer)
        if signature_algorithm is not None:
            pulumi.set(__self__, "signature_algorithm", signature_algorithm)
        if single_logout is not None:
            pulumi.set(__self__, "single_logout", single_logout)
        if skip_org_role_sync is not None:
            pulumi.set(__self__, "skip_org_role_sync", skip_org_role_sync)
        if token_url is not None:
            pulumi.set(__self__, "token_url", token_url)

    @property
    @pulumi.getter(name="allowIdpInitiated")
    def allow_idp_initiated(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether SAML IdP-initiated login is allowed.
        """
        return pulumi.get(self, "allow_idp_initiated")

    @allow_idp_initiated.setter
    def allow_idp_initiated(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_idp_initiated", value)

    @property
    @pulumi.getter(name="allowSignUp")
    def allow_sign_up(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to allow new Grafana user creation through SAML login. If set to false, then only existing Grafana users can log in with SAML.
        """
        return pulumi.get(self, "allow_sign_up")

    @allow_sign_up.setter
    def allow_sign_up(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_sign_up", value)

    @property
    @pulumi.getter(name="allowedOrganizations")
    def allowed_organizations(self) -> Optional[pulumi.Input[str]]:
        """
        List of comma- or space-separated organizations. User should be a member of at least one organization to log in.
        """
        return pulumi.get(self, "allowed_organizations")

    @allowed_organizations.setter
    def allowed_organizations(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "allowed_organizations", value)

    @property
    @pulumi.getter(name="assertionAttributeEmail")
    def assertion_attribute_email(self) -> Optional[pulumi.Input[str]]:
        """
        Friendly name or name of the attribute within the SAML assertion to use as the user email.
        """
        return pulumi.get(self, "assertion_attribute_email")

    @assertion_attribute_email.setter
    def assertion_attribute_email(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "assertion_attribute_email", value)

    @property
    @pulumi.getter(name="assertionAttributeGroups")
    def assertion_attribute_groups(self) -> Optional[pulumi.Input[str]]:
        """
        Friendly name or name of the attribute within the SAML assertion to use as the user groups.
        """
        return pulumi.get(self, "assertion_attribute_groups")

    @assertion_attribute_groups.setter
    def assertion_attribute_groups(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "assertion_attribute_groups", value)

    @property
    @pulumi.getter(name="assertionAttributeLogin")
    def assertion_attribute_login(self) -> Optional[pulumi.Input[str]]:
        """
        Friendly name or name of the attribute within the SAML assertion to use as the user login handle.
        """
        return pulumi.get(self, "assertion_attribute_login")

    @assertion_attribute_login.setter
    def assertion_attribute_login(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "assertion_attribute_login", value)

    @property
    @pulumi.getter(name="assertionAttributeName")
    def assertion_attribute_name(self) -> Optional[pulumi.Input[str]]:
        """
        Friendly name or name of the attribute within the SAML assertion to use as the user name. Alternatively, this can be a template with variables that match the names of attributes within the SAML assertion.
        """
        return pulumi.get(self, "assertion_attribute_name")

    @assertion_attribute_name.setter
    def assertion_attribute_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "assertion_attribute_name", value)

    @property
    @pulumi.getter(name="assertionAttributeOrg")
    def assertion_attribute_org(self) -> Optional[pulumi.Input[str]]:
        """
        Friendly name or name of the attribute within the SAML assertion to use as the user organization.
        """
        return pulumi.get(self, "assertion_attribute_org")

    @assertion_attribute_org.setter
    def assertion_attribute_org(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "assertion_attribute_org", value)

    @property
    @pulumi.getter(name="assertionAttributeRole")
    def assertion_attribute_role(self) -> Optional[pulumi.Input[str]]:
        """
        Friendly name or name of the attribute within the SAML assertion to use as the user roles.
        """
        return pulumi.get(self, "assertion_attribute_role")

    @assertion_attribute_role.setter
    def assertion_attribute_role(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "assertion_attribute_role", value)

    @property
    @pulumi.getter(name="autoLogin")
    def auto_login(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether SAML auto login is enabled.
        """
        return pulumi.get(self, "auto_login")

    @auto_login.setter
    def auto_login(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "auto_login", value)

    @property
    @pulumi.getter
    def certificate(self) -> Optional[pulumi.Input[str]]:
        """
        Base64-encoded string for the SP X.509 certificate.
        """
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "certificate", value)

    @property
    @pulumi.getter(name="certificatePath")
    def certificate_path(self) -> Optional[pulumi.Input[str]]:
        """
        Path for the SP X.509 certificate.
        """
        return pulumi.get(self, "certificate_path")

    @certificate_path.setter
    def certificate_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "certificate_path", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[str]]:
        """
        The client Id of your OAuth2 app.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[str]]:
        """
        The client secret of your OAuth2 app.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Define whether this configuration is enabled for SAML. Defaults to `true`.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="entityId")
    def entity_id(self) -> Optional[pulumi.Input[str]]:
        """
        The entity ID is a globally unique identifier for the service provider. It is used to identify the service provider to the identity provider. Defaults to the URL of the Grafana instance if not set.
        """
        return pulumi.get(self, "entity_id")

    @entity_id.setter
    def entity_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "entity_id", value)

    @property
    @pulumi.getter(name="forceUseGraphApi")
    def force_use_graph_api(self) -> Optional[pulumi.Input[bool]]:
        """
        If enabled, Grafana will fetch groups from Microsoft Graph API instead of using the groups claim from the ID token.
        """
        return pulumi.get(self, "force_use_graph_api")

    @force_use_graph_api.setter
    def force_use_graph_api(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "force_use_graph_api", value)

    @property
    @pulumi.getter(name="idpMetadata")
    def idp_metadata(self) -> Optional[pulumi.Input[str]]:
        """
        Base64-encoded string for the IdP SAML metadata XML.
        """
        return pulumi.get(self, "idp_metadata")

    @idp_metadata.setter
    def idp_metadata(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "idp_metadata", value)

    @property
    @pulumi.getter(name="idpMetadataPath")
    def idp_metadata_path(self) -> Optional[pulumi.Input[str]]:
        """
        Path for the IdP SAML metadata XML.
        """
        return pulumi.get(self, "idp_metadata_path")

    @idp_metadata_path.setter
    def idp_metadata_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "idp_metadata_path", value)

    @property
    @pulumi.getter(name="idpMetadataUrl")
    def idp_metadata_url(self) -> Optional[pulumi.Input[str]]:
        """
        URL for the IdP SAML metadata XML.
        """
        return pulumi.get(self, "idp_metadata_url")

    @idp_metadata_url.setter
    def idp_metadata_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "idp_metadata_url", value)

    @property
    @pulumi.getter(name="maxIssueDelay")
    def max_issue_delay(self) -> Optional[pulumi.Input[str]]:
        """
        Duration, since the IdP issued a response and the SP is allowed to process it. For example: 90s, 1h.
        """
        return pulumi.get(self, "max_issue_delay")

    @max_issue_delay.setter
    def max_issue_delay(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_issue_delay", value)

    @property
    @pulumi.getter(name="metadataValidDuration")
    def metadata_valid_duration(self) -> Optional[pulumi.Input[str]]:
        """
        Duration, for how long the SP metadata is valid. For example: 48h, 5d.
        """
        return pulumi.get(self, "metadata_valid_duration")

    @metadata_valid_duration.setter
    def metadata_valid_duration(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metadata_valid_duration", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name used to refer to the SAML authentication.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="nameIdFormat")
    def name_id_format(self) -> Optional[pulumi.Input[str]]:
        """
        The Name ID Format to request within the SAML assertion. Defaults to urn:oasis:names:tc:SAML:2.0:nameid-format:transient
        """
        return pulumi.get(self, "name_id_format")

    @name_id_format.setter
    def name_id_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name_id_format", value)

    @property
    @pulumi.getter(name="orgMapping")
    def org_mapping(self) -> Optional[pulumi.Input[str]]:
        """
        List of comma- or space-separated Organization:OrgId:Role mappings. Organization can be * meaning “All users”. Role is optional and can have the following values: Viewer, Editor or Admin.
        """
        return pulumi.get(self, "org_mapping")

    @org_mapping.setter
    def org_mapping(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "org_mapping", value)

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[pulumi.Input[str]]:
        """
        Base64-encoded string for the SP private key.
        """
        return pulumi.get(self, "private_key")

    @private_key.setter
    def private_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_key", value)

    @property
    @pulumi.getter(name="privateKeyPath")
    def private_key_path(self) -> Optional[pulumi.Input[str]]:
        """
        Path for the SP private key.
        """
        return pulumi.get(self, "private_key_path")

    @private_key_path.setter
    def private_key_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_key_path", value)

    @property
    @pulumi.getter(name="relayState")
    def relay_state(self) -> Optional[pulumi.Input[str]]:
        """
        Relay state for IdP-initiated login. Should match relay state configured in IdP.
        """
        return pulumi.get(self, "relay_state")

    @relay_state.setter
    def relay_state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "relay_state", value)

    @property
    @pulumi.getter(name="roleValuesAdmin")
    def role_values_admin(self) -> Optional[pulumi.Input[str]]:
        """
        List of comma- or space-separated roles which will be mapped into the Admin role.
        """
        return pulumi.get(self, "role_values_admin")

    @role_values_admin.setter
    def role_values_admin(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role_values_admin", value)

    @property
    @pulumi.getter(name="roleValuesEditor")
    def role_values_editor(self) -> Optional[pulumi.Input[str]]:
        """
        List of comma- or space-separated roles which will be mapped into the Editor role.
        """
        return pulumi.get(self, "role_values_editor")

    @role_values_editor.setter
    def role_values_editor(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role_values_editor", value)

    @property
    @pulumi.getter(name="roleValuesGrafanaAdmin")
    def role_values_grafana_admin(self) -> Optional[pulumi.Input[str]]:
        """
        List of comma- or space-separated roles which will be mapped into the Grafana Admin (Super Admin) role.
        """
        return pulumi.get(self, "role_values_grafana_admin")

    @role_values_grafana_admin.setter
    def role_values_grafana_admin(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role_values_grafana_admin", value)

    @property
    @pulumi.getter(name="roleValuesNone")
    def role_values_none(self) -> Optional[pulumi.Input[str]]:
        """
        List of comma- or space-separated roles which will be mapped into the None role.
        """
        return pulumi.get(self, "role_values_none")

    @role_values_none.setter
    def role_values_none(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role_values_none", value)

    @property
    @pulumi.getter(name="roleValuesViewer")
    def role_values_viewer(self) -> Optional[pulumi.Input[str]]:
        """
        List of comma- or space-separated roles which will be mapped into the Viewer role.
        """
        return pulumi.get(self, "role_values_viewer")

    @role_values_viewer.setter
    def role_values_viewer(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role_values_viewer", value)

    @property
    @pulumi.getter(name="signatureAlgorithm")
    def signature_algorithm(self) -> Optional[pulumi.Input[str]]:
        """
        Signature algorithm used for signing requests to the IdP. Supported values are rsa-sha1, rsa-sha256, rsa-sha512.
        """
        return pulumi.get(self, "signature_algorithm")

    @signature_algorithm.setter
    def signature_algorithm(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "signature_algorithm", value)

    @property
    @pulumi.getter(name="singleLogout")
    def single_logout(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether SAML Single Logout is enabled.
        """
        return pulumi.get(self, "single_logout")

    @single_logout.setter
    def single_logout(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "single_logout", value)

    @property
    @pulumi.getter(name="skipOrgRoleSync")
    def skip_org_role_sync(self) -> Optional[pulumi.Input[bool]]:
        """
        Prevent synchronizing users’ organization roles from your IdP.
        """
        return pulumi.get(self, "skip_org_role_sync")

    @skip_org_role_sync.setter
    def skip_org_role_sync(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "skip_org_role_sync", value)

    @property
    @pulumi.getter(name="tokenUrl")
    def token_url(self) -> Optional[pulumi.Input[str]]:
        """
        The token endpoint of your OAuth2 provider. Required for Azure AD providers.
        """
        return pulumi.get(self, "token_url")

    @token_url.setter
    def token_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "token_url", value)


if not MYPY:
    class SyntheticMonitoringCheckSettingsArgsDict(TypedDict):
        browser: NotRequired[pulumi.Input['SyntheticMonitoringCheckSettingsBrowserArgsDict']]
        """
        Settings for browser check. See https://grafana.com/docs/grafana-cloud/testing/synthetic-monitoring/create-checks/checks/k6-browser/.
        """
        dns: NotRequired[pulumi.Input['SyntheticMonitoringCheckSettingsDnsArgsDict']]
        """
        Settings for DNS check. The target must be a valid hostname (or IP address for `PTR` records).
        """
        grpc: NotRequired[pulumi.Input['SyntheticMonitoringCheckSettingsGrpcArgsDict']]
        """
        Settings for gRPC Health check. The target must be of the form `<host>:<port>`, where the host portion must be a valid hostname or IP address.
        """
        http: NotRequired[pulumi.Input['SyntheticMonitoringCheckSettingsHttpArgsDict']]
        """
        Settings for HTTP check. The target must be a URL (http or https).
        """
        multihttp: NotRequired[pulumi.Input['SyntheticMonitoringCheckSettingsMultihttpArgsDict']]
        """
        Settings for MultiHTTP check. The target must be a URL (http or https)
        """
        ping: NotRequired[pulumi.Input['SyntheticMonitoringCheckSettingsPingArgsDict']]
        """
        Settings for ping (ICMP) check. The target must be a valid hostname or IP address.
        """
        scripted: NotRequired[pulumi.Input['SyntheticMonitoringCheckSettingsScriptedArgsDict']]
        """
        Settings for scripted check. See https://grafana.com/docs/grafana-cloud/testing/synthetic-monitoring/create-checks/checks/k6/.
        """
        tcp: NotRequired[pulumi.Input['SyntheticMonitoringCheckSettingsTcpArgsDict']]
        """
        Settings for TCP check. The target must be of the form `<host>:<port>`, where the host portion must be a valid hostname or IP address.
        """
        traceroute: NotRequired[pulumi.Input['SyntheticMonitoringCheckSettingsTracerouteArgsDict']]
        """
        Settings for traceroute check. The target must be a valid hostname or IP address
        """
elif False:
    SyntheticMonitoringCheckSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SyntheticMonitoringCheckSettingsArgs:
    def __init__(__self__, *,
                 browser: Optional[pulumi.Input['SyntheticMonitoringCheckSettingsBrowserArgs']] = None,
                 dns: Optional[pulumi.Input['SyntheticMonitoringCheckSettingsDnsArgs']] = None,
                 grpc: Optional[pulumi.Input['SyntheticMonitoringCheckSettingsGrpcArgs']] = None,
                 http: Optional[pulumi.Input['SyntheticMonitoringCheckSettingsHttpArgs']] = None,
                 multihttp: Optional[pulumi.Input['SyntheticMonitoringCheckSettingsMultihttpArgs']] = None,
                 ping: Optional[pulumi.Input['SyntheticMonitoringCheckSettingsPingArgs']] = None,
                 scripted: Optional[pulumi.Input['SyntheticMonitoringCheckSettingsScriptedArgs']] = None,
                 tcp: Optional[pulumi.Input['SyntheticMonitoringCheckSettingsTcpArgs']] = None,
                 traceroute: Optional[pulumi.Input['SyntheticMonitoringCheckSettingsTracerouteArgs']] = None):
        """
        :param pulumi.Input['SyntheticMonitoringCheckSettingsBrowserArgs'] browser: Settings for browser check. See https://grafana.com/docs/grafana-cloud/testing/synthetic-monitoring/create-checks/checks/k6-browser/.
        :param pulumi.Input['SyntheticMonitoringCheckSettingsDnsArgs'] dns: Settings for DNS check. The target must be a valid hostname (or IP address for `PTR` records).
        :param pulumi.Input['SyntheticMonitoringCheckSettingsGrpcArgs'] grpc: Settings for gRPC Health check. The target must be of the form `<host>:<port>`, where the host portion must be a valid hostname or IP address.
        :param pulumi.Input['SyntheticMonitoringCheckSettingsHttpArgs'] http: Settings for HTTP check. The target must be a URL (http or https).
        :param pulumi.Input['SyntheticMonitoringCheckSettingsMultihttpArgs'] multihttp: Settings for MultiHTTP check. The target must be a URL (http or https)
        :param pulumi.Input['SyntheticMonitoringCheckSettingsPingArgs'] ping: Settings for ping (ICMP) check. The target must be a valid hostname or IP address.
        :param pulumi.Input['SyntheticMonitoringCheckSettingsScriptedArgs'] scripted: Settings for scripted check. See https://grafana.com/docs/grafana-cloud/testing/synthetic-monitoring/create-checks/checks/k6/.
        :param pulumi.Input['SyntheticMonitoringCheckSettingsTcpArgs'] tcp: Settings for TCP check. The target must be of the form `<host>:<port>`, where the host portion must be a valid hostname or IP address.
        :param pulumi.Input['SyntheticMonitoringCheckSettingsTracerouteArgs'] traceroute: Settings for traceroute check. The target must be a valid hostname or IP address
        """
        if browser is not None:
            pulumi.set(__self__, "browser", browser)
        if dns is not None:
            pulumi.set(__self__, "dns", dns)
        if grpc is not None:
            pulumi.set(__self__, "grpc", grpc)
        if http is not None:
            pulumi.set(__self__, "http", http)
        if multihttp is not None:
            pulumi.set(__self__, "multihttp", multihttp)
        if ping is not None:
            pulumi.set(__self__, "ping", ping)
        if scripted is not None:
            pulumi.set(__self__, "scripted", scripted)
        if tcp is not None:
            pulumi.set(__self__, "tcp", tcp)
        if traceroute is not None:
            pulumi.set(__self__, "traceroute", traceroute)

    @property
    @pulumi.getter
    def browser(self) -> Optional[pulumi.Input['SyntheticMonitoringCheckSettingsBrowserArgs']]:
        """
        Settings for browser check. See https://grafana.com/docs/grafana-cloud/testing/synthetic-monitoring/create-checks/checks/k6-browser/.
        """
        return pulumi.get(self, "browser")

    @browser.setter
    def browser(self, value: Optional[pulumi.Input['SyntheticMonitoringCheckSettingsBrowserArgs']]):
        pulumi.set(self, "browser", value)

    @property
    @pulumi.getter
    def dns(self) -> Optional[pulumi.Input['SyntheticMonitoringCheckSettingsDnsArgs']]:
        """
        Settings for DNS check. The target must be a valid hostname (or IP address for `PTR` records).
        """
        return pulumi.get(self, "dns")

    @dns.setter
    def dns(self, value: Optional[pulumi.Input['SyntheticMonitoringCheckSettingsDnsArgs']]):
        pulumi.set(self, "dns", value)

    @property
    @pulumi.getter
    def grpc(self) -> Optional[pulumi.Input['SyntheticMonitoringCheckSettingsGrpcArgs']]:
        """
        Settings for gRPC Health check. The target must be of the form `<host>:<port>`, where the host portion must be a valid hostname or IP address.
        """
        return pulumi.get(self, "grpc")

    @grpc.setter
    def grpc(self, value: Optional[pulumi.Input['SyntheticMonitoringCheckSettingsGrpcArgs']]):
        pulumi.set(self, "grpc", value)

    @property
    @pulumi.getter
    def http(self) -> Optional[pulumi.Input['SyntheticMonitoringCheckSettingsHttpArgs']]:
        """
        Settings for HTTP check. The target must be a URL (http or https).
        """
        return pulumi.get(self, "http")

    @http.setter
    def http(self, value: Optional[pulumi.Input['SyntheticMonitoringCheckSettingsHttpArgs']]):
        pulumi.set(self, "http", value)

    @property
    @pulumi.getter
    def multihttp(self) -> Optional[pulumi.Input['SyntheticMonitoringCheckSettingsMultihttpArgs']]:
        """
        Settings for MultiHTTP check. The target must be a URL (http or https)
        """
        return pulumi.get(self, "multihttp")

    @multihttp.setter
    def multihttp(self, value: Optional[pulumi.Input['SyntheticMonitoringCheckSettingsMultihttpArgs']]):
        pulumi.set(self, "multihttp", value)

    @property
    @pulumi.getter
    def ping(self) -> Optional[pulumi.Input['SyntheticMonitoringCheckSettingsPingArgs']]:
        """
        Settings for ping (ICMP) check. The target must be a valid hostname or IP address.
        """
        return pulumi.get(self, "ping")

    @ping.setter
    def ping(self, value: Optional[pulumi.Input['SyntheticMonitoringCheckSettingsPingArgs']]):
        pulumi.set(self, "ping", value)

    @property
    @pulumi.getter
    def scripted(self) -> Optional[pulumi.Input['SyntheticMonitoringCheckSettingsScriptedArgs']]:
        """
        Settings for scripted check. See https://grafana.com/docs/grafana-cloud/testing/synthetic-monitoring/create-checks/checks/k6/.
        """
        return pulumi.get(self, "scripted")

    @scripted.setter
    def scripted(self, value: Optional[pulumi.Input['SyntheticMonitoringCheckSettingsScriptedArgs']]):
        pulumi.set(self, "scripted", value)

    @property
    @pulumi.getter
    def tcp(self) -> Optional[pulumi.Input['SyntheticMonitoringCheckSettingsTcpArgs']]:
        """
        Settings for TCP check. The target must be of the form `<host>:<port>`, where the host portion must be a valid hostname or IP address.
        """
        return pulumi.get(self, "tcp")

    @tcp.setter
    def tcp(self, value: Optional[pulumi.Input['SyntheticMonitoringCheckSettingsTcpArgs']]):
        pulumi.set(self, "tcp", value)

    @property
    @pulumi.getter
    def traceroute(self) -> Optional[pulumi.Input['SyntheticMonitoringCheckSettingsTracerouteArgs']]:
        """
        Settings for traceroute check. The target must be a valid hostname or IP address
        """
        return pulumi.get(self, "traceroute")

    @traceroute.setter
    def traceroute(self, value: Optional[pulumi.Input['SyntheticMonitoringCheckSettingsTracerouteArgs']]):
        pulumi.set(self, "traceroute", value)


if not MYPY:
    class SyntheticMonitoringCheckSettingsBrowserArgsDict(TypedDict):
        script: pulumi.Input[str]
elif False:
    SyntheticMonitoringCheckSettingsBrowserArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SyntheticMonitoringCheckSettingsBrowserArgs:
    def __init__(__self__, *,
                 script: pulumi.Input[str]):
        pulumi.set(__self__, "script", script)

    @property
    @pulumi.getter
    def script(self) -> pulumi.Input[str]:
        return pulumi.get(self, "script")

    @script.setter
    def script(self, value: pulumi.Input[str]):
        pulumi.set(self, "script", value)


if not MYPY:
    class SyntheticMonitoringCheckSettingsDnsArgsDict(TypedDict):
        ip_version: NotRequired[pulumi.Input[str]]
        """
        Options are `V4`, `V6`, `Any`. Specifies whether the corresponding check will be performed using IPv4 or IPv6. The `Any` value indicates that IPv6 should be used, falling back to IPv4 if that's not available. Defaults to `V4`.
        """
        port: NotRequired[pulumi.Input[int]]
        """
        Port to target. Defaults to `53`.
        """
        protocol: NotRequired[pulumi.Input[str]]
        """
        `TCP` or `UDP`. Defaults to `UDP`.
        """
        record_type: NotRequired[pulumi.Input[str]]
        """
        One of `ANY`, `A`, `AAAA`, `CNAME`, `MX`, `NS`, `PTR`, `SOA`, `SRV`, `TXT`. Defaults to `A`.
        """
        server: NotRequired[pulumi.Input[str]]
        """
        DNS server address to target. Defaults to `8.8.8.8`.
        """
        source_ip_address: NotRequired[pulumi.Input[str]]
        """
        Source IP address.
        """
        valid_r_codes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of valid response codes. Options include `NOERROR`, `BADALG`, `BADMODE`, `BADKEY`, `BADCOOKIE`, `BADNAME`, `BADSIG`, `BADTIME`, `BADTRUNC`, `BADVERS`, `FORMERR`, `NOTIMP`, `NOTAUTH`, `NOTZONE`, `NXDOMAIN`, `NXRRSET`, `REFUSED`, `SERVFAIL`, `YXDOMAIN`, `YXRRSET`.
        """
        validate_additional_rrs: NotRequired[pulumi.Input[Sequence[pulumi.Input['SyntheticMonitoringCheckSettingsDnsValidateAdditionalRrArgsDict']]]]
        """
        Validate additional matches.
        """
        validate_answer_rrs: NotRequired[pulumi.Input['SyntheticMonitoringCheckSettingsDnsValidateAnswerRrsArgsDict']]
        """
        Validate response answer.
        """
        validate_authority_rrs: NotRequired[pulumi.Input['SyntheticMonitoringCheckSettingsDnsValidateAuthorityRrsArgsDict']]
        """
        Validate response authority.
        """
elif False:
    SyntheticMonitoringCheckSettingsDnsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SyntheticMonitoringCheckSettingsDnsArgs:
    def __init__(__self__, *,
                 ip_version: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 protocol: Optional[pulumi.Input[str]] = None,
                 record_type: Optional[pulumi.Input[str]] = None,
                 server: Optional[pulumi.Input[str]] = None,
                 source_ip_address: Optional[pulumi.Input[str]] = None,
                 valid_r_codes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 validate_additional_rrs: Optional[pulumi.Input[Sequence[pulumi.Input['SyntheticMonitoringCheckSettingsDnsValidateAdditionalRrArgs']]]] = None,
                 validate_answer_rrs: Optional[pulumi.Input['SyntheticMonitoringCheckSettingsDnsValidateAnswerRrsArgs']] = None,
                 validate_authority_rrs: Optional[pulumi.Input['SyntheticMonitoringCheckSettingsDnsValidateAuthorityRrsArgs']] = None):
        """
        :param pulumi.Input[str] ip_version: Options are `V4`, `V6`, `Any`. Specifies whether the corresponding check will be performed using IPv4 or IPv6. The `Any` value indicates that IPv6 should be used, falling back to IPv4 if that's not available. Defaults to `V4`.
        :param pulumi.Input[int] port: Port to target. Defaults to `53`.
        :param pulumi.Input[str] protocol: `TCP` or `UDP`. Defaults to `UDP`.
        :param pulumi.Input[str] record_type: One of `ANY`, `A`, `AAAA`, `CNAME`, `MX`, `NS`, `PTR`, `SOA`, `SRV`, `TXT`. Defaults to `A`.
        :param pulumi.Input[str] server: DNS server address to target. Defaults to `8.8.8.8`.
        :param pulumi.Input[str] source_ip_address: Source IP address.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] valid_r_codes: List of valid response codes. Options include `NOERROR`, `BADALG`, `BADMODE`, `BADKEY`, `BADCOOKIE`, `BADNAME`, `BADSIG`, `BADTIME`, `BADTRUNC`, `BADVERS`, `FORMERR`, `NOTIMP`, `NOTAUTH`, `NOTZONE`, `NXDOMAIN`, `NXRRSET`, `REFUSED`, `SERVFAIL`, `YXDOMAIN`, `YXRRSET`.
        :param pulumi.Input[Sequence[pulumi.Input['SyntheticMonitoringCheckSettingsDnsValidateAdditionalRrArgs']]] validate_additional_rrs: Validate additional matches.
        :param pulumi.Input['SyntheticMonitoringCheckSettingsDnsValidateAnswerRrsArgs'] validate_answer_rrs: Validate response answer.
        :param pulumi.Input['SyntheticMonitoringCheckSettingsDnsValidateAuthorityRrsArgs'] validate_authority_rrs: Validate response authority.
        """
        if ip_version is not None:
            pulumi.set(__self__, "ip_version", ip_version)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if record_type is not None:
            pulumi.set(__self__, "record_type", record_type)
        if server is not None:
            pulumi.set(__self__, "server", server)
        if source_ip_address is not None:
            pulumi.set(__self__, "source_ip_address", source_ip_address)
        if valid_r_codes is not None:
            pulumi.set(__self__, "valid_r_codes", valid_r_codes)
        if validate_additional_rrs is not None:
            pulumi.set(__self__, "validate_additional_rrs", validate_additional_rrs)
        if validate_answer_rrs is not None:
            pulumi.set(__self__, "validate_answer_rrs", validate_answer_rrs)
        if validate_authority_rrs is not None:
            pulumi.set(__self__, "validate_authority_rrs", validate_authority_rrs)

    @property
    @pulumi.getter(name="ipVersion")
    def ip_version(self) -> Optional[pulumi.Input[str]]:
        """
        Options are `V4`, `V6`, `Any`. Specifies whether the corresponding check will be performed using IPv4 or IPv6. The `Any` value indicates that IPv6 should be used, falling back to IPv4 if that's not available. Defaults to `V4`.
        """
        return pulumi.get(self, "ip_version")

    @ip_version.setter
    def ip_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_version", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        Port to target. Defaults to `53`.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[str]]:
        """
        `TCP` or `UDP`. Defaults to `UDP`.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="recordType")
    def record_type(self) -> Optional[pulumi.Input[str]]:
        """
        One of `ANY`, `A`, `AAAA`, `CNAME`, `MX`, `NS`, `PTR`, `SOA`, `SRV`, `TXT`. Defaults to `A`.
        """
        return pulumi.get(self, "record_type")

    @record_type.setter
    def record_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "record_type", value)

    @property
    @pulumi.getter
    def server(self) -> Optional[pulumi.Input[str]]:
        """
        DNS server address to target. Defaults to `8.8.8.8`.
        """
        return pulumi.get(self, "server")

    @server.setter
    def server(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "server", value)

    @property
    @pulumi.getter(name="sourceIpAddress")
    def source_ip_address(self) -> Optional[pulumi.Input[str]]:
        """
        Source IP address.
        """
        return pulumi.get(self, "source_ip_address")

    @source_ip_address.setter
    def source_ip_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_ip_address", value)

    @property
    @pulumi.getter(name="validRCodes")
    def valid_r_codes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of valid response codes. Options include `NOERROR`, `BADALG`, `BADMODE`, `BADKEY`, `BADCOOKIE`, `BADNAME`, `BADSIG`, `BADTIME`, `BADTRUNC`, `BADVERS`, `FORMERR`, `NOTIMP`, `NOTAUTH`, `NOTZONE`, `NXDOMAIN`, `NXRRSET`, `REFUSED`, `SERVFAIL`, `YXDOMAIN`, `YXRRSET`.
        """
        return pulumi.get(self, "valid_r_codes")

    @valid_r_codes.setter
    def valid_r_codes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "valid_r_codes", value)

    @property
    @pulumi.getter(name="validateAdditionalRrs")
    def validate_additional_rrs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SyntheticMonitoringCheckSettingsDnsValidateAdditionalRrArgs']]]]:
        """
        Validate additional matches.
        """
        return pulumi.get(self, "validate_additional_rrs")

    @validate_additional_rrs.setter
    def validate_additional_rrs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SyntheticMonitoringCheckSettingsDnsValidateAdditionalRrArgs']]]]):
        pulumi.set(self, "validate_additional_rrs", value)

    @property
    @pulumi.getter(name="validateAnswerRrs")
    def validate_answer_rrs(self) -> Optional[pulumi.Input['SyntheticMonitoringCheckSettingsDnsValidateAnswerRrsArgs']]:
        """
        Validate response answer.
        """
        return pulumi.get(self, "validate_answer_rrs")

    @validate_answer_rrs.setter
    def validate_answer_rrs(self, value: Optional[pulumi.Input['SyntheticMonitoringCheckSettingsDnsValidateAnswerRrsArgs']]):
        pulumi.set(self, "validate_answer_rrs", value)

    @property
    @pulumi.getter(name="validateAuthorityRrs")
    def validate_authority_rrs(self) -> Optional[pulumi.Input['SyntheticMonitoringCheckSettingsDnsValidateAuthorityRrsArgs']]:
        """
        Validate response authority.
        """
        return pulumi.get(self, "validate_authority_rrs")

    @validate_authority_rrs.setter
    def validate_authority_rrs(self, value: Optional[pulumi.Input['SyntheticMonitoringCheckSettingsDnsValidateAuthorityRrsArgs']]):
        pulumi.set(self, "validate_authority_rrs", value)


if not MYPY:
    class SyntheticMonitoringCheckSettingsDnsValidateAdditionalRrArgsDict(TypedDict):
        fail_if_matches_regexps: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Fail if value matches regex.
        """
        fail_if_not_matches_regexps: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Fail if value does not match regex.
        """
elif False:
    SyntheticMonitoringCheckSettingsDnsValidateAdditionalRrArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SyntheticMonitoringCheckSettingsDnsValidateAdditionalRrArgs:
    def __init__(__self__, *,
                 fail_if_matches_regexps: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 fail_if_not_matches_regexps: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] fail_if_matches_regexps: Fail if value matches regex.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] fail_if_not_matches_regexps: Fail if value does not match regex.
        """
        if fail_if_matches_regexps is not None:
            pulumi.set(__self__, "fail_if_matches_regexps", fail_if_matches_regexps)
        if fail_if_not_matches_regexps is not None:
            pulumi.set(__self__, "fail_if_not_matches_regexps", fail_if_not_matches_regexps)

    @property
    @pulumi.getter(name="failIfMatchesRegexps")
    def fail_if_matches_regexps(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Fail if value matches regex.
        """
        return pulumi.get(self, "fail_if_matches_regexps")

    @fail_if_matches_regexps.setter
    def fail_if_matches_regexps(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "fail_if_matches_regexps", value)

    @property
    @pulumi.getter(name="failIfNotMatchesRegexps")
    def fail_if_not_matches_regexps(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Fail if value does not match regex.
        """
        return pulumi.get(self, "fail_if_not_matches_regexps")

    @fail_if_not_matches_regexps.setter
    def fail_if_not_matches_regexps(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "fail_if_not_matches_regexps", value)


if not MYPY:
    class SyntheticMonitoringCheckSettingsDnsValidateAnswerRrsArgsDict(TypedDict):
        fail_if_matches_regexps: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Fail if value matches regex.
        """
        fail_if_not_matches_regexps: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Fail if value does not match regex.
        """
elif False:
    SyntheticMonitoringCheckSettingsDnsValidateAnswerRrsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SyntheticMonitoringCheckSettingsDnsValidateAnswerRrsArgs:
    def __init__(__self__, *,
                 fail_if_matches_regexps: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 fail_if_not_matches_regexps: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] fail_if_matches_regexps: Fail if value matches regex.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] fail_if_not_matches_regexps: Fail if value does not match regex.
        """
        if fail_if_matches_regexps is not None:
            pulumi.set(__self__, "fail_if_matches_regexps", fail_if_matches_regexps)
        if fail_if_not_matches_regexps is not None:
            pulumi.set(__self__, "fail_if_not_matches_regexps", fail_if_not_matches_regexps)

    @property
    @pulumi.getter(name="failIfMatchesRegexps")
    def fail_if_matches_regexps(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Fail if value matches regex.
        """
        return pulumi.get(self, "fail_if_matches_regexps")

    @fail_if_matches_regexps.setter
    def fail_if_matches_regexps(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "fail_if_matches_regexps", value)

    @property
    @pulumi.getter(name="failIfNotMatchesRegexps")
    def fail_if_not_matches_regexps(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Fail if value does not match regex.
        """
        return pulumi.get(self, "fail_if_not_matches_regexps")

    @fail_if_not_matches_regexps.setter
    def fail_if_not_matches_regexps(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "fail_if_not_matches_regexps", value)


if not MYPY:
    class SyntheticMonitoringCheckSettingsDnsValidateAuthorityRrsArgsDict(TypedDict):
        fail_if_matches_regexps: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Fail if value matches regex.
        """
        fail_if_not_matches_regexps: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Fail if value does not match regex.
        """
elif False:
    SyntheticMonitoringCheckSettingsDnsValidateAuthorityRrsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SyntheticMonitoringCheckSettingsDnsValidateAuthorityRrsArgs:
    def __init__(__self__, *,
                 fail_if_matches_regexps: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 fail_if_not_matches_regexps: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] fail_if_matches_regexps: Fail if value matches regex.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] fail_if_not_matches_regexps: Fail if value does not match regex.
        """
        if fail_if_matches_regexps is not None:
            pulumi.set(__self__, "fail_if_matches_regexps", fail_if_matches_regexps)
        if fail_if_not_matches_regexps is not None:
            pulumi.set(__self__, "fail_if_not_matches_regexps", fail_if_not_matches_regexps)

    @property
    @pulumi.getter(name="failIfMatchesRegexps")
    def fail_if_matches_regexps(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Fail if value matches regex.
        """
        return pulumi.get(self, "fail_if_matches_regexps")

    @fail_if_matches_regexps.setter
    def fail_if_matches_regexps(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "fail_if_matches_regexps", value)

    @property
    @pulumi.getter(name="failIfNotMatchesRegexps")
    def fail_if_not_matches_regexps(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Fail if value does not match regex.
        """
        return pulumi.get(self, "fail_if_not_matches_regexps")

    @fail_if_not_matches_regexps.setter
    def fail_if_not_matches_regexps(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "fail_if_not_matches_regexps", value)


if not MYPY:
    class SyntheticMonitoringCheckSettingsGrpcArgsDict(TypedDict):
        ip_version: NotRequired[pulumi.Input[str]]
        """
        Options are `V4`, `V6`, `Any`. Specifies whether the corresponding check will be performed using IPv4 or IPv6. The `Any` value indicates that IPv6 should be used, falling back to IPv4 if that's not available. Defaults to `V4`.
        """
        service: NotRequired[pulumi.Input[str]]
        """
        gRPC service.
        """
        tls: NotRequired[pulumi.Input[bool]]
        """
        Whether or not TLS is used when the connection is initiated. Defaults to `false`.
        """
        tls_config: NotRequired[pulumi.Input['SyntheticMonitoringCheckSettingsGrpcTlsConfigArgsDict']]
        """
        TLS config.
        """
elif False:
    SyntheticMonitoringCheckSettingsGrpcArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SyntheticMonitoringCheckSettingsGrpcArgs:
    def __init__(__self__, *,
                 ip_version: Optional[pulumi.Input[str]] = None,
                 service: Optional[pulumi.Input[str]] = None,
                 tls: Optional[pulumi.Input[bool]] = None,
                 tls_config: Optional[pulumi.Input['SyntheticMonitoringCheckSettingsGrpcTlsConfigArgs']] = None):
        """
        :param pulumi.Input[str] ip_version: Options are `V4`, `V6`, `Any`. Specifies whether the corresponding check will be performed using IPv4 or IPv6. The `Any` value indicates that IPv6 should be used, falling back to IPv4 if that's not available. Defaults to `V4`.
        :param pulumi.Input[str] service: gRPC service.
        :param pulumi.Input[bool] tls: Whether or not TLS is used when the connection is initiated. Defaults to `false`.
        :param pulumi.Input['SyntheticMonitoringCheckSettingsGrpcTlsConfigArgs'] tls_config: TLS config.
        """
        if ip_version is not None:
            pulumi.set(__self__, "ip_version", ip_version)
        if service is not None:
            pulumi.set(__self__, "service", service)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)
        if tls_config is not None:
            pulumi.set(__self__, "tls_config", tls_config)

    @property
    @pulumi.getter(name="ipVersion")
    def ip_version(self) -> Optional[pulumi.Input[str]]:
        """
        Options are `V4`, `V6`, `Any`. Specifies whether the corresponding check will be performed using IPv4 or IPv6. The `Any` value indicates that IPv6 should be used, falling back to IPv4 if that's not available. Defaults to `V4`.
        """
        return pulumi.get(self, "ip_version")

    @ip_version.setter
    def ip_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_version", value)

    @property
    @pulumi.getter
    def service(self) -> Optional[pulumi.Input[str]]:
        """
        gRPC service.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service", value)

    @property
    @pulumi.getter
    def tls(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether or not TLS is used when the connection is initiated. Defaults to `false`.
        """
        return pulumi.get(self, "tls")

    @tls.setter
    def tls(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "tls", value)

    @property
    @pulumi.getter(name="tlsConfig")
    def tls_config(self) -> Optional[pulumi.Input['SyntheticMonitoringCheckSettingsGrpcTlsConfigArgs']]:
        """
        TLS config.
        """
        return pulumi.get(self, "tls_config")

    @tls_config.setter
    def tls_config(self, value: Optional[pulumi.Input['SyntheticMonitoringCheckSettingsGrpcTlsConfigArgs']]):
        pulumi.set(self, "tls_config", value)


if not MYPY:
    class SyntheticMonitoringCheckSettingsGrpcTlsConfigArgsDict(TypedDict):
        ca_cert: NotRequired[pulumi.Input[str]]
        """
        CA certificate in PEM format.
        """
        client_cert: NotRequired[pulumi.Input[str]]
        """
        Client certificate in PEM format.
        """
        client_key: NotRequired[pulumi.Input[str]]
        """
        Client key in PEM format.
        """
        insecure_skip_verify: NotRequired[pulumi.Input[bool]]
        """
        Disable target certificate validation. Defaults to `false`.
        """
        server_name: NotRequired[pulumi.Input[str]]
        """
        Used to verify the hostname for the targets.
        """
elif False:
    SyntheticMonitoringCheckSettingsGrpcTlsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SyntheticMonitoringCheckSettingsGrpcTlsConfigArgs:
    def __init__(__self__, *,
                 ca_cert: Optional[pulumi.Input[str]] = None,
                 client_cert: Optional[pulumi.Input[str]] = None,
                 client_key: Optional[pulumi.Input[str]] = None,
                 insecure_skip_verify: Optional[pulumi.Input[bool]] = None,
                 server_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ca_cert: CA certificate in PEM format.
        :param pulumi.Input[str] client_cert: Client certificate in PEM format.
        :param pulumi.Input[str] client_key: Client key in PEM format.
        :param pulumi.Input[bool] insecure_skip_verify: Disable target certificate validation. Defaults to `false`.
        :param pulumi.Input[str] server_name: Used to verify the hostname for the targets.
        """
        if ca_cert is not None:
            pulumi.set(__self__, "ca_cert", ca_cert)
        if client_cert is not None:
            pulumi.set(__self__, "client_cert", client_cert)
        if client_key is not None:
            pulumi.set(__self__, "client_key", client_key)
        if insecure_skip_verify is not None:
            pulumi.set(__self__, "insecure_skip_verify", insecure_skip_verify)
        if server_name is not None:
            pulumi.set(__self__, "server_name", server_name)

    @property
    @pulumi.getter(name="caCert")
    def ca_cert(self) -> Optional[pulumi.Input[str]]:
        """
        CA certificate in PEM format.
        """
        return pulumi.get(self, "ca_cert")

    @ca_cert.setter
    def ca_cert(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ca_cert", value)

    @property
    @pulumi.getter(name="clientCert")
    def client_cert(self) -> Optional[pulumi.Input[str]]:
        """
        Client certificate in PEM format.
        """
        return pulumi.get(self, "client_cert")

    @client_cert.setter
    def client_cert(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_cert", value)

    @property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> Optional[pulumi.Input[str]]:
        """
        Client key in PEM format.
        """
        return pulumi.get(self, "client_key")

    @client_key.setter
    def client_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_key", value)

    @property
    @pulumi.getter(name="insecureSkipVerify")
    def insecure_skip_verify(self) -> Optional[pulumi.Input[bool]]:
        """
        Disable target certificate validation. Defaults to `false`.
        """
        return pulumi.get(self, "insecure_skip_verify")

    @insecure_skip_verify.setter
    def insecure_skip_verify(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "insecure_skip_verify", value)

    @property
    @pulumi.getter(name="serverName")
    def server_name(self) -> Optional[pulumi.Input[str]]:
        """
        Used to verify the hostname for the targets.
        """
        return pulumi.get(self, "server_name")

    @server_name.setter
    def server_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "server_name", value)


if not MYPY:
    class SyntheticMonitoringCheckSettingsHttpArgsDict(TypedDict):
        basic_auth: NotRequired[pulumi.Input['SyntheticMonitoringCheckSettingsHttpBasicAuthArgsDict']]
        """
        Basic auth settings.
        """
        bearer_token: NotRequired[pulumi.Input[str]]
        """
        Token for use with bearer authorization header.
        """
        body: NotRequired[pulumi.Input[str]]
        """
        The body of the HTTP request used in probe.
        """
        cache_busting_query_param_name: NotRequired[pulumi.Input[str]]
        """
        The name of the query parameter used to prevent the server from using a cached response. Each probe will assign a random value to this parameter each time a request is made.
        """
        compression: NotRequired[pulumi.Input[str]]
        """
        Check fails if the response body is not compressed using this compression algorithm. One of `none`, `identity`, `br`, `gzip`, `deflate`.
        """
        fail_if_body_matches_regexps: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of regexes. If any match the response body, the check will fail.
        """
        fail_if_body_not_matches_regexps: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of regexes. If any do not match the response body, the check will fail.
        """
        fail_if_header_matches_regexps: NotRequired[pulumi.Input[Sequence[pulumi.Input['SyntheticMonitoringCheckSettingsHttpFailIfHeaderMatchesRegexpArgsDict']]]]
        """
        Check fails if headers match.
        """
        fail_if_header_not_matches_regexps: NotRequired[pulumi.Input[Sequence[pulumi.Input['SyntheticMonitoringCheckSettingsHttpFailIfHeaderNotMatchesRegexpArgsDict']]]]
        """
        Check fails if headers do not match.
        """
        fail_if_not_ssl: NotRequired[pulumi.Input[bool]]
        """
        Fail if SSL is not present. Defaults to `false`.
        """
        fail_if_ssl: NotRequired[pulumi.Input[bool]]
        """
        Fail if SSL is present. Defaults to `false`.
        """
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The HTTP headers set for the probe.
        """
        ip_version: NotRequired[pulumi.Input[str]]
        """
        Options are `V4`, `V6`, `Any`. Specifies whether the corresponding check will be performed using IPv4 or IPv6. The `Any` value indicates that IPv6 should be used, falling back to IPv4 if that's not available. Defaults to `V4`.
        """
        method: NotRequired[pulumi.Input[str]]
        """
        Request method. One of `GET`, `CONNECT`, `DELETE`, `HEAD`, `OPTIONS`, `POST`, `PUT`, `TRACE` Defaults to `GET`.
        """
        no_follow_redirects: NotRequired[pulumi.Input[bool]]
        """
        Do not follow redirects. Defaults to `false`.
        """
        proxy_connect_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The HTTP headers sent to the proxy URL
        """
        proxy_url: NotRequired[pulumi.Input[str]]
        """
        Proxy URL.
        """
        tls_config: NotRequired[pulumi.Input['SyntheticMonitoringCheckSettingsHttpTlsConfigArgsDict']]
        """
        TLS config.
        """
        valid_http_versions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of valid HTTP versions. Options include `HTTP/1.0`, `HTTP/1.1`, `HTTP/2.0`
        """
        valid_status_codes: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        """
        Accepted status codes. If unset, defaults to 2xx.
        """
elif False:
    SyntheticMonitoringCheckSettingsHttpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SyntheticMonitoringCheckSettingsHttpArgs:
    def __init__(__self__, *,
                 basic_auth: Optional[pulumi.Input['SyntheticMonitoringCheckSettingsHttpBasicAuthArgs']] = None,
                 bearer_token: Optional[pulumi.Input[str]] = None,
                 body: Optional[pulumi.Input[str]] = None,
                 cache_busting_query_param_name: Optional[pulumi.Input[str]] = None,
                 compression: Optional[pulumi.Input[str]] = None,
                 fail_if_body_matches_regexps: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 fail_if_body_not_matches_regexps: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 fail_if_header_matches_regexps: Optional[pulumi.Input[Sequence[pulumi.Input['SyntheticMonitoringCheckSettingsHttpFailIfHeaderMatchesRegexpArgs']]]] = None,
                 fail_if_header_not_matches_regexps: Optional[pulumi.Input[Sequence[pulumi.Input['SyntheticMonitoringCheckSettingsHttpFailIfHeaderNotMatchesRegexpArgs']]]] = None,
                 fail_if_not_ssl: Optional[pulumi.Input[bool]] = None,
                 fail_if_ssl: Optional[pulumi.Input[bool]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 ip_version: Optional[pulumi.Input[str]] = None,
                 method: Optional[pulumi.Input[str]] = None,
                 no_follow_redirects: Optional[pulumi.Input[bool]] = None,
                 proxy_connect_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 proxy_url: Optional[pulumi.Input[str]] = None,
                 tls_config: Optional[pulumi.Input['SyntheticMonitoringCheckSettingsHttpTlsConfigArgs']] = None,
                 valid_http_versions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 valid_status_codes: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None):
        """
        :param pulumi.Input['SyntheticMonitoringCheckSettingsHttpBasicAuthArgs'] basic_auth: Basic auth settings.
        :param pulumi.Input[str] bearer_token: Token for use with bearer authorization header.
        :param pulumi.Input[str] body: The body of the HTTP request used in probe.
        :param pulumi.Input[str] cache_busting_query_param_name: The name of the query parameter used to prevent the server from using a cached response. Each probe will assign a random value to this parameter each time a request is made.
        :param pulumi.Input[str] compression: Check fails if the response body is not compressed using this compression algorithm. One of `none`, `identity`, `br`, `gzip`, `deflate`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] fail_if_body_matches_regexps: List of regexes. If any match the response body, the check will fail.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] fail_if_body_not_matches_regexps: List of regexes. If any do not match the response body, the check will fail.
        :param pulumi.Input[Sequence[pulumi.Input['SyntheticMonitoringCheckSettingsHttpFailIfHeaderMatchesRegexpArgs']]] fail_if_header_matches_regexps: Check fails if headers match.
        :param pulumi.Input[Sequence[pulumi.Input['SyntheticMonitoringCheckSettingsHttpFailIfHeaderNotMatchesRegexpArgs']]] fail_if_header_not_matches_regexps: Check fails if headers do not match.
        :param pulumi.Input[bool] fail_if_not_ssl: Fail if SSL is not present. Defaults to `false`.
        :param pulumi.Input[bool] fail_if_ssl: Fail if SSL is present. Defaults to `false`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] headers: The HTTP headers set for the probe.
        :param pulumi.Input[str] ip_version: Options are `V4`, `V6`, `Any`. Specifies whether the corresponding check will be performed using IPv4 or IPv6. The `Any` value indicates that IPv6 should be used, falling back to IPv4 if that's not available. Defaults to `V4`.
        :param pulumi.Input[str] method: Request method. One of `GET`, `CONNECT`, `DELETE`, `HEAD`, `OPTIONS`, `POST`, `PUT`, `TRACE` Defaults to `GET`.
        :param pulumi.Input[bool] no_follow_redirects: Do not follow redirects. Defaults to `false`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] proxy_connect_headers: The HTTP headers sent to the proxy URL
        :param pulumi.Input[str] proxy_url: Proxy URL.
        :param pulumi.Input['SyntheticMonitoringCheckSettingsHttpTlsConfigArgs'] tls_config: TLS config.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] valid_http_versions: List of valid HTTP versions. Options include `HTTP/1.0`, `HTTP/1.1`, `HTTP/2.0`
        :param pulumi.Input[Sequence[pulumi.Input[int]]] valid_status_codes: Accepted status codes. If unset, defaults to 2xx.
        """
        if basic_auth is not None:
            pulumi.set(__self__, "basic_auth", basic_auth)
        if bearer_token is not None:
            pulumi.set(__self__, "bearer_token", bearer_token)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cache_busting_query_param_name is not None:
            pulumi.set(__self__, "cache_busting_query_param_name", cache_busting_query_param_name)
        if compression is not None:
            pulumi.set(__self__, "compression", compression)
        if fail_if_body_matches_regexps is not None:
            pulumi.set(__self__, "fail_if_body_matches_regexps", fail_if_body_matches_regexps)
        if fail_if_body_not_matches_regexps is not None:
            pulumi.set(__self__, "fail_if_body_not_matches_regexps", fail_if_body_not_matches_regexps)
        if fail_if_header_matches_regexps is not None:
            pulumi.set(__self__, "fail_if_header_matches_regexps", fail_if_header_matches_regexps)
        if fail_if_header_not_matches_regexps is not None:
            pulumi.set(__self__, "fail_if_header_not_matches_regexps", fail_if_header_not_matches_regexps)
        if fail_if_not_ssl is not None:
            pulumi.set(__self__, "fail_if_not_ssl", fail_if_not_ssl)
        if fail_if_ssl is not None:
            pulumi.set(__self__, "fail_if_ssl", fail_if_ssl)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ip_version is not None:
            pulumi.set(__self__, "ip_version", ip_version)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if no_follow_redirects is not None:
            pulumi.set(__self__, "no_follow_redirects", no_follow_redirects)
        if proxy_connect_headers is not None:
            pulumi.set(__self__, "proxy_connect_headers", proxy_connect_headers)
        if proxy_url is not None:
            pulumi.set(__self__, "proxy_url", proxy_url)
        if tls_config is not None:
            pulumi.set(__self__, "tls_config", tls_config)
        if valid_http_versions is not None:
            pulumi.set(__self__, "valid_http_versions", valid_http_versions)
        if valid_status_codes is not None:
            pulumi.set(__self__, "valid_status_codes", valid_status_codes)

    @property
    @pulumi.getter(name="basicAuth")
    def basic_auth(self) -> Optional[pulumi.Input['SyntheticMonitoringCheckSettingsHttpBasicAuthArgs']]:
        """
        Basic auth settings.
        """
        return pulumi.get(self, "basic_auth")

    @basic_auth.setter
    def basic_auth(self, value: Optional[pulumi.Input['SyntheticMonitoringCheckSettingsHttpBasicAuthArgs']]):
        pulumi.set(self, "basic_auth", value)

    @property
    @pulumi.getter(name="bearerToken")
    def bearer_token(self) -> Optional[pulumi.Input[str]]:
        """
        Token for use with bearer authorization header.
        """
        return pulumi.get(self, "bearer_token")

    @bearer_token.setter
    def bearer_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bearer_token", value)

    @property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input[str]]:
        """
        The body of the HTTP request used in probe.
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "body", value)

    @property
    @pulumi.getter(name="cacheBustingQueryParamName")
    def cache_busting_query_param_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the query parameter used to prevent the server from using a cached response. Each probe will assign a random value to this parameter each time a request is made.
        """
        return pulumi.get(self, "cache_busting_query_param_name")

    @cache_busting_query_param_name.setter
    def cache_busting_query_param_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cache_busting_query_param_name", value)

    @property
    @pulumi.getter
    def compression(self) -> Optional[pulumi.Input[str]]:
        """
        Check fails if the response body is not compressed using this compression algorithm. One of `none`, `identity`, `br`, `gzip`, `deflate`.
        """
        return pulumi.get(self, "compression")

    @compression.setter
    def compression(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compression", value)

    @property
    @pulumi.getter(name="failIfBodyMatchesRegexps")
    def fail_if_body_matches_regexps(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of regexes. If any match the response body, the check will fail.
        """
        return pulumi.get(self, "fail_if_body_matches_regexps")

    @fail_if_body_matches_regexps.setter
    def fail_if_body_matches_regexps(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "fail_if_body_matches_regexps", value)

    @property
    @pulumi.getter(name="failIfBodyNotMatchesRegexps")
    def fail_if_body_not_matches_regexps(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of regexes. If any do not match the response body, the check will fail.
        """
        return pulumi.get(self, "fail_if_body_not_matches_regexps")

    @fail_if_body_not_matches_regexps.setter
    def fail_if_body_not_matches_regexps(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "fail_if_body_not_matches_regexps", value)

    @property
    @pulumi.getter(name="failIfHeaderMatchesRegexps")
    def fail_if_header_matches_regexps(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SyntheticMonitoringCheckSettingsHttpFailIfHeaderMatchesRegexpArgs']]]]:
        """
        Check fails if headers match.
        """
        return pulumi.get(self, "fail_if_header_matches_regexps")

    @fail_if_header_matches_regexps.setter
    def fail_if_header_matches_regexps(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SyntheticMonitoringCheckSettingsHttpFailIfHeaderMatchesRegexpArgs']]]]):
        pulumi.set(self, "fail_if_header_matches_regexps", value)

    @property
    @pulumi.getter(name="failIfHeaderNotMatchesRegexps")
    def fail_if_header_not_matches_regexps(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SyntheticMonitoringCheckSettingsHttpFailIfHeaderNotMatchesRegexpArgs']]]]:
        """
        Check fails if headers do not match.
        """
        return pulumi.get(self, "fail_if_header_not_matches_regexps")

    @fail_if_header_not_matches_regexps.setter
    def fail_if_header_not_matches_regexps(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SyntheticMonitoringCheckSettingsHttpFailIfHeaderNotMatchesRegexpArgs']]]]):
        pulumi.set(self, "fail_if_header_not_matches_regexps", value)

    @property
    @pulumi.getter(name="failIfNotSsl")
    def fail_if_not_ssl(self) -> Optional[pulumi.Input[bool]]:
        """
        Fail if SSL is not present. Defaults to `false`.
        """
        return pulumi.get(self, "fail_if_not_ssl")

    @fail_if_not_ssl.setter
    def fail_if_not_ssl(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "fail_if_not_ssl", value)

    @property
    @pulumi.getter(name="failIfSsl")
    def fail_if_ssl(self) -> Optional[pulumi.Input[bool]]:
        """
        Fail if SSL is present. Defaults to `false`.
        """
        return pulumi.get(self, "fail_if_ssl")

    @fail_if_ssl.setter
    def fail_if_ssl(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "fail_if_ssl", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The HTTP headers set for the probe.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="ipVersion")
    def ip_version(self) -> Optional[pulumi.Input[str]]:
        """
        Options are `V4`, `V6`, `Any`. Specifies whether the corresponding check will be performed using IPv4 or IPv6. The `Any` value indicates that IPv6 should be used, falling back to IPv4 if that's not available. Defaults to `V4`.
        """
        return pulumi.get(self, "ip_version")

    @ip_version.setter
    def ip_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_version", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input[str]]:
        """
        Request method. One of `GET`, `CONNECT`, `DELETE`, `HEAD`, `OPTIONS`, `POST`, `PUT`, `TRACE` Defaults to `GET`.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter(name="noFollowRedirects")
    def no_follow_redirects(self) -> Optional[pulumi.Input[bool]]:
        """
        Do not follow redirects. Defaults to `false`.
        """
        return pulumi.get(self, "no_follow_redirects")

    @no_follow_redirects.setter
    def no_follow_redirects(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "no_follow_redirects", value)

    @property
    @pulumi.getter(name="proxyConnectHeaders")
    def proxy_connect_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The HTTP headers sent to the proxy URL
        """
        return pulumi.get(self, "proxy_connect_headers")

    @proxy_connect_headers.setter
    def proxy_connect_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "proxy_connect_headers", value)

    @property
    @pulumi.getter(name="proxyUrl")
    def proxy_url(self) -> Optional[pulumi.Input[str]]:
        """
        Proxy URL.
        """
        return pulumi.get(self, "proxy_url")

    @proxy_url.setter
    def proxy_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proxy_url", value)

    @property
    @pulumi.getter(name="tlsConfig")
    def tls_config(self) -> Optional[pulumi.Input['SyntheticMonitoringCheckSettingsHttpTlsConfigArgs']]:
        """
        TLS config.
        """
        return pulumi.get(self, "tls_config")

    @tls_config.setter
    def tls_config(self, value: Optional[pulumi.Input['SyntheticMonitoringCheckSettingsHttpTlsConfigArgs']]):
        pulumi.set(self, "tls_config", value)

    @property
    @pulumi.getter(name="validHttpVersions")
    def valid_http_versions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of valid HTTP versions. Options include `HTTP/1.0`, `HTTP/1.1`, `HTTP/2.0`
        """
        return pulumi.get(self, "valid_http_versions")

    @valid_http_versions.setter
    def valid_http_versions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "valid_http_versions", value)

    @property
    @pulumi.getter(name="validStatusCodes")
    def valid_status_codes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        Accepted status codes. If unset, defaults to 2xx.
        """
        return pulumi.get(self, "valid_status_codes")

    @valid_status_codes.setter
    def valid_status_codes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "valid_status_codes", value)


if not MYPY:
    class SyntheticMonitoringCheckSettingsHttpBasicAuthArgsDict(TypedDict):
        password: pulumi.Input[str]
        """
        Basic auth password.
        """
        username: pulumi.Input[str]
        """
        Basic auth username.
        """
elif False:
    SyntheticMonitoringCheckSettingsHttpBasicAuthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SyntheticMonitoringCheckSettingsHttpBasicAuthArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[str],
                 username: pulumi.Input[str]):
        """
        :param pulumi.Input[str] password: Basic auth password.
        :param pulumi.Input[str] username: Basic auth username.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        """
        Basic auth password.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        """
        Basic auth username.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)


if not MYPY:
    class SyntheticMonitoringCheckSettingsHttpFailIfHeaderMatchesRegexpArgsDict(TypedDict):
        header: pulumi.Input[str]
        """
        Header name.
        """
        regexp: pulumi.Input[str]
        """
        Regex that header value should match.
        """
        allow_missing: NotRequired[pulumi.Input[bool]]
        """
        Allow header to be missing from responses. Defaults to `false`.
        """
elif False:
    SyntheticMonitoringCheckSettingsHttpFailIfHeaderMatchesRegexpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SyntheticMonitoringCheckSettingsHttpFailIfHeaderMatchesRegexpArgs:
    def __init__(__self__, *,
                 header: pulumi.Input[str],
                 regexp: pulumi.Input[str],
                 allow_missing: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] header: Header name.
        :param pulumi.Input[str] regexp: Regex that header value should match.
        :param pulumi.Input[bool] allow_missing: Allow header to be missing from responses. Defaults to `false`.
        """
        pulumi.set(__self__, "header", header)
        pulumi.set(__self__, "regexp", regexp)
        if allow_missing is not None:
            pulumi.set(__self__, "allow_missing", allow_missing)

    @property
    @pulumi.getter
    def header(self) -> pulumi.Input[str]:
        """
        Header name.
        """
        return pulumi.get(self, "header")

    @header.setter
    def header(self, value: pulumi.Input[str]):
        pulumi.set(self, "header", value)

    @property
    @pulumi.getter
    def regexp(self) -> pulumi.Input[str]:
        """
        Regex that header value should match.
        """
        return pulumi.get(self, "regexp")

    @regexp.setter
    def regexp(self, value: pulumi.Input[str]):
        pulumi.set(self, "regexp", value)

    @property
    @pulumi.getter(name="allowMissing")
    def allow_missing(self) -> Optional[pulumi.Input[bool]]:
        """
        Allow header to be missing from responses. Defaults to `false`.
        """
        return pulumi.get(self, "allow_missing")

    @allow_missing.setter
    def allow_missing(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_missing", value)


if not MYPY:
    class SyntheticMonitoringCheckSettingsHttpFailIfHeaderNotMatchesRegexpArgsDict(TypedDict):
        header: pulumi.Input[str]
        """
        Header name.
        """
        regexp: pulumi.Input[str]
        """
        Regex that header value should match.
        """
        allow_missing: NotRequired[pulumi.Input[bool]]
        """
        Allow header to be missing from responses. Defaults to `false`.
        """
elif False:
    SyntheticMonitoringCheckSettingsHttpFailIfHeaderNotMatchesRegexpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SyntheticMonitoringCheckSettingsHttpFailIfHeaderNotMatchesRegexpArgs:
    def __init__(__self__, *,
                 header: pulumi.Input[str],
                 regexp: pulumi.Input[str],
                 allow_missing: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] header: Header name.
        :param pulumi.Input[str] regexp: Regex that header value should match.
        :param pulumi.Input[bool] allow_missing: Allow header to be missing from responses. Defaults to `false`.
        """
        pulumi.set(__self__, "header", header)
        pulumi.set(__self__, "regexp", regexp)
        if allow_missing is not None:
            pulumi.set(__self__, "allow_missing", allow_missing)

    @property
    @pulumi.getter
    def header(self) -> pulumi.Input[str]:
        """
        Header name.
        """
        return pulumi.get(self, "header")

    @header.setter
    def header(self, value: pulumi.Input[str]):
        pulumi.set(self, "header", value)

    @property
    @pulumi.getter
    def regexp(self) -> pulumi.Input[str]:
        """
        Regex that header value should match.
        """
        return pulumi.get(self, "regexp")

    @regexp.setter
    def regexp(self, value: pulumi.Input[str]):
        pulumi.set(self, "regexp", value)

    @property
    @pulumi.getter(name="allowMissing")
    def allow_missing(self) -> Optional[pulumi.Input[bool]]:
        """
        Allow header to be missing from responses. Defaults to `false`.
        """
        return pulumi.get(self, "allow_missing")

    @allow_missing.setter
    def allow_missing(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_missing", value)


if not MYPY:
    class SyntheticMonitoringCheckSettingsHttpTlsConfigArgsDict(TypedDict):
        ca_cert: NotRequired[pulumi.Input[str]]
        """
        CA certificate in PEM format.
        """
        client_cert: NotRequired[pulumi.Input[str]]
        """
        Client certificate in PEM format.
        """
        client_key: NotRequired[pulumi.Input[str]]
        """
        Client key in PEM format.
        """
        insecure_skip_verify: NotRequired[pulumi.Input[bool]]
        """
        Disable target certificate validation. Defaults to `false`.
        """
        server_name: NotRequired[pulumi.Input[str]]
        """
        Used to verify the hostname for the targets.
        """
elif False:
    SyntheticMonitoringCheckSettingsHttpTlsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SyntheticMonitoringCheckSettingsHttpTlsConfigArgs:
    def __init__(__self__, *,
                 ca_cert: Optional[pulumi.Input[str]] = None,
                 client_cert: Optional[pulumi.Input[str]] = None,
                 client_key: Optional[pulumi.Input[str]] = None,
                 insecure_skip_verify: Optional[pulumi.Input[bool]] = None,
                 server_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ca_cert: CA certificate in PEM format.
        :param pulumi.Input[str] client_cert: Client certificate in PEM format.
        :param pulumi.Input[str] client_key: Client key in PEM format.
        :param pulumi.Input[bool] insecure_skip_verify: Disable target certificate validation. Defaults to `false`.
        :param pulumi.Input[str] server_name: Used to verify the hostname for the targets.
        """
        if ca_cert is not None:
            pulumi.set(__self__, "ca_cert", ca_cert)
        if client_cert is not None:
            pulumi.set(__self__, "client_cert", client_cert)
        if client_key is not None:
            pulumi.set(__self__, "client_key", client_key)
        if insecure_skip_verify is not None:
            pulumi.set(__self__, "insecure_skip_verify", insecure_skip_verify)
        if server_name is not None:
            pulumi.set(__self__, "server_name", server_name)

    @property
    @pulumi.getter(name="caCert")
    def ca_cert(self) -> Optional[pulumi.Input[str]]:
        """
        CA certificate in PEM format.
        """
        return pulumi.get(self, "ca_cert")

    @ca_cert.setter
    def ca_cert(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ca_cert", value)

    @property
    @pulumi.getter(name="clientCert")
    def client_cert(self) -> Optional[pulumi.Input[str]]:
        """
        Client certificate in PEM format.
        """
        return pulumi.get(self, "client_cert")

    @client_cert.setter
    def client_cert(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_cert", value)

    @property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> Optional[pulumi.Input[str]]:
        """
        Client key in PEM format.
        """
        return pulumi.get(self, "client_key")

    @client_key.setter
    def client_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_key", value)

    @property
    @pulumi.getter(name="insecureSkipVerify")
    def insecure_skip_verify(self) -> Optional[pulumi.Input[bool]]:
        """
        Disable target certificate validation. Defaults to `false`.
        """
        return pulumi.get(self, "insecure_skip_verify")

    @insecure_skip_verify.setter
    def insecure_skip_verify(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "insecure_skip_verify", value)

    @property
    @pulumi.getter(name="serverName")
    def server_name(self) -> Optional[pulumi.Input[str]]:
        """
        Used to verify the hostname for the targets.
        """
        return pulumi.get(self, "server_name")

    @server_name.setter
    def server_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "server_name", value)


if not MYPY:
    class SyntheticMonitoringCheckSettingsMultihttpArgsDict(TypedDict):
        entries: NotRequired[pulumi.Input[Sequence[pulumi.Input['SyntheticMonitoringCheckSettingsMultihttpEntryArgsDict']]]]
elif False:
    SyntheticMonitoringCheckSettingsMultihttpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SyntheticMonitoringCheckSettingsMultihttpArgs:
    def __init__(__self__, *,
                 entries: Optional[pulumi.Input[Sequence[pulumi.Input['SyntheticMonitoringCheckSettingsMultihttpEntryArgs']]]] = None):
        if entries is not None:
            pulumi.set(__self__, "entries", entries)

    @property
    @pulumi.getter
    def entries(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SyntheticMonitoringCheckSettingsMultihttpEntryArgs']]]]:
        return pulumi.get(self, "entries")

    @entries.setter
    def entries(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SyntheticMonitoringCheckSettingsMultihttpEntryArgs']]]]):
        pulumi.set(self, "entries", value)


if not MYPY:
    class SyntheticMonitoringCheckSettingsMultihttpEntryArgsDict(TypedDict):
        assertions: NotRequired[pulumi.Input[Sequence[pulumi.Input['SyntheticMonitoringCheckSettingsMultihttpEntryAssertionArgsDict']]]]
        """
        Assertions to make on the request response
        """
        request: NotRequired[pulumi.Input['SyntheticMonitoringCheckSettingsMultihttpEntryRequestArgsDict']]
        """
        An individual MultiHTTP request
        """
        variables: NotRequired[pulumi.Input[Sequence[pulumi.Input['SyntheticMonitoringCheckSettingsMultihttpEntryVariableArgsDict']]]]
        """
        Variables to extract from the request response
        """
elif False:
    SyntheticMonitoringCheckSettingsMultihttpEntryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SyntheticMonitoringCheckSettingsMultihttpEntryArgs:
    def __init__(__self__, *,
                 assertions: Optional[pulumi.Input[Sequence[pulumi.Input['SyntheticMonitoringCheckSettingsMultihttpEntryAssertionArgs']]]] = None,
                 request: Optional[pulumi.Input['SyntheticMonitoringCheckSettingsMultihttpEntryRequestArgs']] = None,
                 variables: Optional[pulumi.Input[Sequence[pulumi.Input['SyntheticMonitoringCheckSettingsMultihttpEntryVariableArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['SyntheticMonitoringCheckSettingsMultihttpEntryAssertionArgs']]] assertions: Assertions to make on the request response
        :param pulumi.Input['SyntheticMonitoringCheckSettingsMultihttpEntryRequestArgs'] request: An individual MultiHTTP request
        :param pulumi.Input[Sequence[pulumi.Input['SyntheticMonitoringCheckSettingsMultihttpEntryVariableArgs']]] variables: Variables to extract from the request response
        """
        if assertions is not None:
            pulumi.set(__self__, "assertions", assertions)
        if request is not None:
            pulumi.set(__self__, "request", request)
        if variables is not None:
            pulumi.set(__self__, "variables", variables)

    @property
    @pulumi.getter
    def assertions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SyntheticMonitoringCheckSettingsMultihttpEntryAssertionArgs']]]]:
        """
        Assertions to make on the request response
        """
        return pulumi.get(self, "assertions")

    @assertions.setter
    def assertions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SyntheticMonitoringCheckSettingsMultihttpEntryAssertionArgs']]]]):
        pulumi.set(self, "assertions", value)

    @property
    @pulumi.getter
    def request(self) -> Optional[pulumi.Input['SyntheticMonitoringCheckSettingsMultihttpEntryRequestArgs']]:
        """
        An individual MultiHTTP request
        """
        return pulumi.get(self, "request")

    @request.setter
    def request(self, value: Optional[pulumi.Input['SyntheticMonitoringCheckSettingsMultihttpEntryRequestArgs']]):
        pulumi.set(self, "request", value)

    @property
    @pulumi.getter
    def variables(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SyntheticMonitoringCheckSettingsMultihttpEntryVariableArgs']]]]:
        """
        Variables to extract from the request response
        """
        return pulumi.get(self, "variables")

    @variables.setter
    def variables(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SyntheticMonitoringCheckSettingsMultihttpEntryVariableArgs']]]]):
        pulumi.set(self, "variables", value)


if not MYPY:
    class SyntheticMonitoringCheckSettingsMultihttpEntryAssertionArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        The type of assertion to make: TEXT, JSON*PATH*VALUE, JSON*PATH*ASSERTION, REGEX_ASSERTION
        """
        condition: NotRequired[pulumi.Input[str]]
        """
        The condition of the assertion: NOT*CONTAINS, EQUALS, STARTS*WITH, ENDS*WITH, TYPE*OF, CONTAINS
        """
        expression: NotRequired[pulumi.Input[str]]
        """
        The expression of the assertion. Should start with $.
        """
        subject: NotRequired[pulumi.Input[str]]
        """
        The subject of the assertion: RESPONSE*HEADERS, HTTP*STATUS*CODE, RESPONSE*BODY
        """
        value: NotRequired[pulumi.Input[str]]
        """
        The value of the assertion
        """
elif False:
    SyntheticMonitoringCheckSettingsMultihttpEntryAssertionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SyntheticMonitoringCheckSettingsMultihttpEntryAssertionArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 condition: Optional[pulumi.Input[str]] = None,
                 expression: Optional[pulumi.Input[str]] = None,
                 subject: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: The type of assertion to make: TEXT, JSON*PATH*VALUE, JSON*PATH*ASSERTION, REGEX_ASSERTION
        :param pulumi.Input[str] condition: The condition of the assertion: NOT*CONTAINS, EQUALS, STARTS*WITH, ENDS*WITH, TYPE*OF, CONTAINS
        :param pulumi.Input[str] expression: The expression of the assertion. Should start with $.
        :param pulumi.Input[str] subject: The subject of the assertion: RESPONSE*HEADERS, HTTP*STATUS*CODE, RESPONSE*BODY
        :param pulumi.Input[str] value: The value of the assertion
        """
        pulumi.set(__self__, "type", type)
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if subject is not None:
            pulumi.set(__self__, "subject", subject)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of assertion to make: TEXT, JSON*PATH*VALUE, JSON*PATH*ASSERTION, REGEX_ASSERTION
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def condition(self) -> Optional[pulumi.Input[str]]:
        """
        The condition of the assertion: NOT*CONTAINS, EQUALS, STARTS*WITH, ENDS*WITH, TYPE*OF, CONTAINS
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def expression(self) -> Optional[pulumi.Input[str]]:
        """
        The expression of the assertion. Should start with $.
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def subject(self) -> Optional[pulumi.Input[str]]:
        """
        The subject of the assertion: RESPONSE*HEADERS, HTTP*STATUS*CODE, RESPONSE*BODY
        """
        return pulumi.get(self, "subject")

    @subject.setter
    def subject(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subject", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The value of the assertion
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class SyntheticMonitoringCheckSettingsMultihttpEntryRequestArgsDict(TypedDict):
        method: pulumi.Input[str]
        """
        The HTTP method to use
        """
        url: pulumi.Input[str]
        """
        The URL for the request
        """
        bodies: NotRequired[pulumi.Input[Sequence[pulumi.Input['SyntheticMonitoringCheckSettingsMultihttpEntryRequestBodyArgsDict']]]]
        """
        The body of the HTTP request used in probe.
        """
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['SyntheticMonitoringCheckSettingsMultihttpEntryRequestHeaderArgsDict']]]]
        """
        The headers to send with the request
        """
        query_fields: NotRequired[pulumi.Input[Sequence[pulumi.Input['SyntheticMonitoringCheckSettingsMultihttpEntryRequestQueryFieldArgsDict']]]]
        """
        Query fields to send with the request
        """
elif False:
    SyntheticMonitoringCheckSettingsMultihttpEntryRequestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SyntheticMonitoringCheckSettingsMultihttpEntryRequestArgs:
    def __init__(__self__, *,
                 method: pulumi.Input[str],
                 url: pulumi.Input[str],
                 bodies: Optional[pulumi.Input[Sequence[pulumi.Input['SyntheticMonitoringCheckSettingsMultihttpEntryRequestBodyArgs']]]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['SyntheticMonitoringCheckSettingsMultihttpEntryRequestHeaderArgs']]]] = None,
                 query_fields: Optional[pulumi.Input[Sequence[pulumi.Input['SyntheticMonitoringCheckSettingsMultihttpEntryRequestQueryFieldArgs']]]] = None):
        """
        :param pulumi.Input[str] method: The HTTP method to use
        :param pulumi.Input[str] url: The URL for the request
        :param pulumi.Input[Sequence[pulumi.Input['SyntheticMonitoringCheckSettingsMultihttpEntryRequestBodyArgs']]] bodies: The body of the HTTP request used in probe.
        :param pulumi.Input[Sequence[pulumi.Input['SyntheticMonitoringCheckSettingsMultihttpEntryRequestHeaderArgs']]] headers: The headers to send with the request
        :param pulumi.Input[Sequence[pulumi.Input['SyntheticMonitoringCheckSettingsMultihttpEntryRequestQueryFieldArgs']]] query_fields: Query fields to send with the request
        """
        pulumi.set(__self__, "method", method)
        pulumi.set(__self__, "url", url)
        if bodies is not None:
            pulumi.set(__self__, "bodies", bodies)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if query_fields is not None:
            pulumi.set(__self__, "query_fields", query_fields)

    @property
    @pulumi.getter
    def method(self) -> pulumi.Input[str]:
        """
        The HTTP method to use
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: pulumi.Input[str]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        The URL for the request
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter
    def bodies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SyntheticMonitoringCheckSettingsMultihttpEntryRequestBodyArgs']]]]:
        """
        The body of the HTTP request used in probe.
        """
        return pulumi.get(self, "bodies")

    @bodies.setter
    def bodies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SyntheticMonitoringCheckSettingsMultihttpEntryRequestBodyArgs']]]]):
        pulumi.set(self, "bodies", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SyntheticMonitoringCheckSettingsMultihttpEntryRequestHeaderArgs']]]]:
        """
        The headers to send with the request
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SyntheticMonitoringCheckSettingsMultihttpEntryRequestHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="queryFields")
    def query_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SyntheticMonitoringCheckSettingsMultihttpEntryRequestQueryFieldArgs']]]]:
        """
        Query fields to send with the request
        """
        return pulumi.get(self, "query_fields")

    @query_fields.setter
    def query_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SyntheticMonitoringCheckSettingsMultihttpEntryRequestQueryFieldArgs']]]]):
        pulumi.set(self, "query_fields", value)


if not MYPY:
    class SyntheticMonitoringCheckSettingsMultihttpEntryRequestBodyArgsDict(TypedDict):
        content_encoding: NotRequired[pulumi.Input[str]]
        """
        The content encoding of the body
        """
        content_type: NotRequired[pulumi.Input[str]]
        """
        The content type of the body
        """
        payload: NotRequired[pulumi.Input[str]]
        """
        The body payload
        """
elif False:
    SyntheticMonitoringCheckSettingsMultihttpEntryRequestBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SyntheticMonitoringCheckSettingsMultihttpEntryRequestBodyArgs:
    def __init__(__self__, *,
                 content_encoding: Optional[pulumi.Input[str]] = None,
                 content_type: Optional[pulumi.Input[str]] = None,
                 payload: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] content_encoding: The content encoding of the body
        :param pulumi.Input[str] content_type: The content type of the body
        :param pulumi.Input[str] payload: The body payload
        """
        if content_encoding is not None:
            pulumi.set(__self__, "content_encoding", content_encoding)
        if content_type is not None:
            pulumi.set(__self__, "content_type", content_type)
        if payload is not None:
            pulumi.set(__self__, "payload", payload)

    @property
    @pulumi.getter(name="contentEncoding")
    def content_encoding(self) -> Optional[pulumi.Input[str]]:
        """
        The content encoding of the body
        """
        return pulumi.get(self, "content_encoding")

    @content_encoding.setter
    def content_encoding(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "content_encoding", value)

    @property
    @pulumi.getter(name="contentType")
    def content_type(self) -> Optional[pulumi.Input[str]]:
        """
        The content type of the body
        """
        return pulumi.get(self, "content_type")

    @content_type.setter
    def content_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "content_type", value)

    @property
    @pulumi.getter
    def payload(self) -> Optional[pulumi.Input[str]]:
        """
        The body payload
        """
        return pulumi.get(self, "payload")

    @payload.setter
    def payload(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "payload", value)


if not MYPY:
    class SyntheticMonitoringCheckSettingsMultihttpEntryRequestHeaderArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the header to send
        """
        value: pulumi.Input[str]
        """
        Value of the header to send
        """
elif False:
    SyntheticMonitoringCheckSettingsMultihttpEntryRequestHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SyntheticMonitoringCheckSettingsMultihttpEntryRequestHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the header to send
        :param pulumi.Input[str] value: Value of the header to send
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the header to send
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Value of the header to send
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class SyntheticMonitoringCheckSettingsMultihttpEntryRequestQueryFieldArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the query field to send
        """
        value: pulumi.Input[str]
        """
        Value of the query field to send
        """
elif False:
    SyntheticMonitoringCheckSettingsMultihttpEntryRequestQueryFieldArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SyntheticMonitoringCheckSettingsMultihttpEntryRequestQueryFieldArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the query field to send
        :param pulumi.Input[str] value: Value of the query field to send
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the query field to send
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Value of the query field to send
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class SyntheticMonitoringCheckSettingsMultihttpEntryVariableArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        The method of finding the variable value to extract. JSON*PATH, REGEX, CSS*SELECTOR
        """
        attribute: NotRequired[pulumi.Input[str]]
        """
        The attribute to use when finding the variable value. Only used when type is CSS_SELECTOR
        """
        expression: NotRequired[pulumi.Input[str]]
        """
        The expression to when finding the variable. Should start with $. Only use when type is JSON_PATH or REGEX
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name of the variable to extract
        """
elif False:
    SyntheticMonitoringCheckSettingsMultihttpEntryVariableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SyntheticMonitoringCheckSettingsMultihttpEntryVariableArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 attribute: Optional[pulumi.Input[str]] = None,
                 expression: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: The method of finding the variable value to extract. JSON*PATH, REGEX, CSS*SELECTOR
        :param pulumi.Input[str] attribute: The attribute to use when finding the variable value. Only used when type is CSS_SELECTOR
        :param pulumi.Input[str] expression: The expression to when finding the variable. Should start with $. Only use when type is JSON_PATH or REGEX
        :param pulumi.Input[str] name: The name of the variable to extract
        """
        pulumi.set(__self__, "type", type)
        if attribute is not None:
            pulumi.set(__self__, "attribute", attribute)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The method of finding the variable value to extract. JSON*PATH, REGEX, CSS*SELECTOR
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def attribute(self) -> Optional[pulumi.Input[str]]:
        """
        The attribute to use when finding the variable value. Only used when type is CSS_SELECTOR
        """
        return pulumi.get(self, "attribute")

    @attribute.setter
    def attribute(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "attribute", value)

    @property
    @pulumi.getter
    def expression(self) -> Optional[pulumi.Input[str]]:
        """
        The expression to when finding the variable. Should start with $. Only use when type is JSON_PATH or REGEX
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the variable to extract
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class SyntheticMonitoringCheckSettingsPingArgsDict(TypedDict):
        dont_fragment: NotRequired[pulumi.Input[bool]]
        """
        Set the DF-bit in the IP-header. Only works with ipV4. Defaults to `false`.
        """
        ip_version: NotRequired[pulumi.Input[str]]
        """
        Options are `V4`, `V6`, `Any`. Specifies whether the corresponding check will be performed using IPv4 or IPv6. The `Any` value indicates that IPv6 should be used, falling back to IPv4 if that's not available. Defaults to `V4`.
        """
        payload_size: NotRequired[pulumi.Input[int]]
        """
        Payload size. Defaults to `0`.
        """
        source_ip_address: NotRequired[pulumi.Input[str]]
        """
        Source IP address.
        """
elif False:
    SyntheticMonitoringCheckSettingsPingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SyntheticMonitoringCheckSettingsPingArgs:
    def __init__(__self__, *,
                 dont_fragment: Optional[pulumi.Input[bool]] = None,
                 ip_version: Optional[pulumi.Input[str]] = None,
                 payload_size: Optional[pulumi.Input[int]] = None,
                 source_ip_address: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] dont_fragment: Set the DF-bit in the IP-header. Only works with ipV4. Defaults to `false`.
        :param pulumi.Input[str] ip_version: Options are `V4`, `V6`, `Any`. Specifies whether the corresponding check will be performed using IPv4 or IPv6. The `Any` value indicates that IPv6 should be used, falling back to IPv4 if that's not available. Defaults to `V4`.
        :param pulumi.Input[int] payload_size: Payload size. Defaults to `0`.
        :param pulumi.Input[str] source_ip_address: Source IP address.
        """
        if dont_fragment is not None:
            pulumi.set(__self__, "dont_fragment", dont_fragment)
        if ip_version is not None:
            pulumi.set(__self__, "ip_version", ip_version)
        if payload_size is not None:
            pulumi.set(__self__, "payload_size", payload_size)
        if source_ip_address is not None:
            pulumi.set(__self__, "source_ip_address", source_ip_address)

    @property
    @pulumi.getter(name="dontFragment")
    def dont_fragment(self) -> Optional[pulumi.Input[bool]]:
        """
        Set the DF-bit in the IP-header. Only works with ipV4. Defaults to `false`.
        """
        return pulumi.get(self, "dont_fragment")

    @dont_fragment.setter
    def dont_fragment(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "dont_fragment", value)

    @property
    @pulumi.getter(name="ipVersion")
    def ip_version(self) -> Optional[pulumi.Input[str]]:
        """
        Options are `V4`, `V6`, `Any`. Specifies whether the corresponding check will be performed using IPv4 or IPv6. The `Any` value indicates that IPv6 should be used, falling back to IPv4 if that's not available. Defaults to `V4`.
        """
        return pulumi.get(self, "ip_version")

    @ip_version.setter
    def ip_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_version", value)

    @property
    @pulumi.getter(name="payloadSize")
    def payload_size(self) -> Optional[pulumi.Input[int]]:
        """
        Payload size. Defaults to `0`.
        """
        return pulumi.get(self, "payload_size")

    @payload_size.setter
    def payload_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "payload_size", value)

    @property
    @pulumi.getter(name="sourceIpAddress")
    def source_ip_address(self) -> Optional[pulumi.Input[str]]:
        """
        Source IP address.
        """
        return pulumi.get(self, "source_ip_address")

    @source_ip_address.setter
    def source_ip_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_ip_address", value)


if not MYPY:
    class SyntheticMonitoringCheckSettingsScriptedArgsDict(TypedDict):
        script: pulumi.Input[str]
elif False:
    SyntheticMonitoringCheckSettingsScriptedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SyntheticMonitoringCheckSettingsScriptedArgs:
    def __init__(__self__, *,
                 script: pulumi.Input[str]):
        pulumi.set(__self__, "script", script)

    @property
    @pulumi.getter
    def script(self) -> pulumi.Input[str]:
        return pulumi.get(self, "script")

    @script.setter
    def script(self, value: pulumi.Input[str]):
        pulumi.set(self, "script", value)


if not MYPY:
    class SyntheticMonitoringCheckSettingsTcpArgsDict(TypedDict):
        ip_version: NotRequired[pulumi.Input[str]]
        """
        Options are `V4`, `V6`, `Any`. Specifies whether the corresponding check will be performed using IPv4 or IPv6. The `Any` value indicates that IPv6 should be used, falling back to IPv4 if that's not available. Defaults to `V4`.
        """
        query_responses: NotRequired[pulumi.Input[Sequence[pulumi.Input['SyntheticMonitoringCheckSettingsTcpQueryResponseArgsDict']]]]
        """
        The query sent in the TCP probe and the expected associated response.
        """
        source_ip_address: NotRequired[pulumi.Input[str]]
        """
        Source IP address.
        """
        tls: NotRequired[pulumi.Input[bool]]
        """
        Whether or not TLS is used when the connection is initiated. Defaults to `false`.
        """
        tls_config: NotRequired[pulumi.Input['SyntheticMonitoringCheckSettingsTcpTlsConfigArgsDict']]
        """
        TLS config.
        """
elif False:
    SyntheticMonitoringCheckSettingsTcpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SyntheticMonitoringCheckSettingsTcpArgs:
    def __init__(__self__, *,
                 ip_version: Optional[pulumi.Input[str]] = None,
                 query_responses: Optional[pulumi.Input[Sequence[pulumi.Input['SyntheticMonitoringCheckSettingsTcpQueryResponseArgs']]]] = None,
                 source_ip_address: Optional[pulumi.Input[str]] = None,
                 tls: Optional[pulumi.Input[bool]] = None,
                 tls_config: Optional[pulumi.Input['SyntheticMonitoringCheckSettingsTcpTlsConfigArgs']] = None):
        """
        :param pulumi.Input[str] ip_version: Options are `V4`, `V6`, `Any`. Specifies whether the corresponding check will be performed using IPv4 or IPv6. The `Any` value indicates that IPv6 should be used, falling back to IPv4 if that's not available. Defaults to `V4`.
        :param pulumi.Input[Sequence[pulumi.Input['SyntheticMonitoringCheckSettingsTcpQueryResponseArgs']]] query_responses: The query sent in the TCP probe and the expected associated response.
        :param pulumi.Input[str] source_ip_address: Source IP address.
        :param pulumi.Input[bool] tls: Whether or not TLS is used when the connection is initiated. Defaults to `false`.
        :param pulumi.Input['SyntheticMonitoringCheckSettingsTcpTlsConfigArgs'] tls_config: TLS config.
        """
        if ip_version is not None:
            pulumi.set(__self__, "ip_version", ip_version)
        if query_responses is not None:
            pulumi.set(__self__, "query_responses", query_responses)
        if source_ip_address is not None:
            pulumi.set(__self__, "source_ip_address", source_ip_address)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)
        if tls_config is not None:
            pulumi.set(__self__, "tls_config", tls_config)

    @property
    @pulumi.getter(name="ipVersion")
    def ip_version(self) -> Optional[pulumi.Input[str]]:
        """
        Options are `V4`, `V6`, `Any`. Specifies whether the corresponding check will be performed using IPv4 or IPv6. The `Any` value indicates that IPv6 should be used, falling back to IPv4 if that's not available. Defaults to `V4`.
        """
        return pulumi.get(self, "ip_version")

    @ip_version.setter
    def ip_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_version", value)

    @property
    @pulumi.getter(name="queryResponses")
    def query_responses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SyntheticMonitoringCheckSettingsTcpQueryResponseArgs']]]]:
        """
        The query sent in the TCP probe and the expected associated response.
        """
        return pulumi.get(self, "query_responses")

    @query_responses.setter
    def query_responses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SyntheticMonitoringCheckSettingsTcpQueryResponseArgs']]]]):
        pulumi.set(self, "query_responses", value)

    @property
    @pulumi.getter(name="sourceIpAddress")
    def source_ip_address(self) -> Optional[pulumi.Input[str]]:
        """
        Source IP address.
        """
        return pulumi.get(self, "source_ip_address")

    @source_ip_address.setter
    def source_ip_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_ip_address", value)

    @property
    @pulumi.getter
    def tls(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether or not TLS is used when the connection is initiated. Defaults to `false`.
        """
        return pulumi.get(self, "tls")

    @tls.setter
    def tls(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "tls", value)

    @property
    @pulumi.getter(name="tlsConfig")
    def tls_config(self) -> Optional[pulumi.Input['SyntheticMonitoringCheckSettingsTcpTlsConfigArgs']]:
        """
        TLS config.
        """
        return pulumi.get(self, "tls_config")

    @tls_config.setter
    def tls_config(self, value: Optional[pulumi.Input['SyntheticMonitoringCheckSettingsTcpTlsConfigArgs']]):
        pulumi.set(self, "tls_config", value)


if not MYPY:
    class SyntheticMonitoringCheckSettingsTcpQueryResponseArgsDict(TypedDict):
        expect: pulumi.Input[str]
        """
        Response to expect.
        """
        send: pulumi.Input[str]
        """
        Data to send.
        """
        start_tls: NotRequired[pulumi.Input[bool]]
        """
        Upgrade TCP connection to TLS. Defaults to `false`.
        """
elif False:
    SyntheticMonitoringCheckSettingsTcpQueryResponseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SyntheticMonitoringCheckSettingsTcpQueryResponseArgs:
    def __init__(__self__, *,
                 expect: pulumi.Input[str],
                 send: pulumi.Input[str],
                 start_tls: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] expect: Response to expect.
        :param pulumi.Input[str] send: Data to send.
        :param pulumi.Input[bool] start_tls: Upgrade TCP connection to TLS. Defaults to `false`.
        """
        pulumi.set(__self__, "expect", expect)
        pulumi.set(__self__, "send", send)
        if start_tls is not None:
            pulumi.set(__self__, "start_tls", start_tls)

    @property
    @pulumi.getter
    def expect(self) -> pulumi.Input[str]:
        """
        Response to expect.
        """
        return pulumi.get(self, "expect")

    @expect.setter
    def expect(self, value: pulumi.Input[str]):
        pulumi.set(self, "expect", value)

    @property
    @pulumi.getter
    def send(self) -> pulumi.Input[str]:
        """
        Data to send.
        """
        return pulumi.get(self, "send")

    @send.setter
    def send(self, value: pulumi.Input[str]):
        pulumi.set(self, "send", value)

    @property
    @pulumi.getter(name="startTls")
    def start_tls(self) -> Optional[pulumi.Input[bool]]:
        """
        Upgrade TCP connection to TLS. Defaults to `false`.
        """
        return pulumi.get(self, "start_tls")

    @start_tls.setter
    def start_tls(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "start_tls", value)


if not MYPY:
    class SyntheticMonitoringCheckSettingsTcpTlsConfigArgsDict(TypedDict):
        ca_cert: NotRequired[pulumi.Input[str]]
        """
        CA certificate in PEM format.
        """
        client_cert: NotRequired[pulumi.Input[str]]
        """
        Client certificate in PEM format.
        """
        client_key: NotRequired[pulumi.Input[str]]
        """
        Client key in PEM format.
        """
        insecure_skip_verify: NotRequired[pulumi.Input[bool]]
        """
        Disable target certificate validation. Defaults to `false`.
        """
        server_name: NotRequired[pulumi.Input[str]]
        """
        Used to verify the hostname for the targets.
        """
elif False:
    SyntheticMonitoringCheckSettingsTcpTlsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SyntheticMonitoringCheckSettingsTcpTlsConfigArgs:
    def __init__(__self__, *,
                 ca_cert: Optional[pulumi.Input[str]] = None,
                 client_cert: Optional[pulumi.Input[str]] = None,
                 client_key: Optional[pulumi.Input[str]] = None,
                 insecure_skip_verify: Optional[pulumi.Input[bool]] = None,
                 server_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ca_cert: CA certificate in PEM format.
        :param pulumi.Input[str] client_cert: Client certificate in PEM format.
        :param pulumi.Input[str] client_key: Client key in PEM format.
        :param pulumi.Input[bool] insecure_skip_verify: Disable target certificate validation. Defaults to `false`.
        :param pulumi.Input[str] server_name: Used to verify the hostname for the targets.
        """
        if ca_cert is not None:
            pulumi.set(__self__, "ca_cert", ca_cert)
        if client_cert is not None:
            pulumi.set(__self__, "client_cert", client_cert)
        if client_key is not None:
            pulumi.set(__self__, "client_key", client_key)
        if insecure_skip_verify is not None:
            pulumi.set(__self__, "insecure_skip_verify", insecure_skip_verify)
        if server_name is not None:
            pulumi.set(__self__, "server_name", server_name)

    @property
    @pulumi.getter(name="caCert")
    def ca_cert(self) -> Optional[pulumi.Input[str]]:
        """
        CA certificate in PEM format.
        """
        return pulumi.get(self, "ca_cert")

    @ca_cert.setter
    def ca_cert(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ca_cert", value)

    @property
    @pulumi.getter(name="clientCert")
    def client_cert(self) -> Optional[pulumi.Input[str]]:
        """
        Client certificate in PEM format.
        """
        return pulumi.get(self, "client_cert")

    @client_cert.setter
    def client_cert(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_cert", value)

    @property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> Optional[pulumi.Input[str]]:
        """
        Client key in PEM format.
        """
        return pulumi.get(self, "client_key")

    @client_key.setter
    def client_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_key", value)

    @property
    @pulumi.getter(name="insecureSkipVerify")
    def insecure_skip_verify(self) -> Optional[pulumi.Input[bool]]:
        """
        Disable target certificate validation. Defaults to `false`.
        """
        return pulumi.get(self, "insecure_skip_verify")

    @insecure_skip_verify.setter
    def insecure_skip_verify(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "insecure_skip_verify", value)

    @property
    @pulumi.getter(name="serverName")
    def server_name(self) -> Optional[pulumi.Input[str]]:
        """
        Used to verify the hostname for the targets.
        """
        return pulumi.get(self, "server_name")

    @server_name.setter
    def server_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "server_name", value)


if not MYPY:
    class SyntheticMonitoringCheckSettingsTracerouteArgsDict(TypedDict):
        max_hops: NotRequired[pulumi.Input[int]]
        """
        Maximum TTL for the trace Defaults to `64`.
        """
        max_unknown_hops: NotRequired[pulumi.Input[int]]
        """
        Maximum number of hosts to travers that give no response Defaults to `15`.
        """
        ptr_lookup: NotRequired[pulumi.Input[bool]]
        """
        Reverse lookup hostnames from IP addresses Defaults to `true`.
        """
elif False:
    SyntheticMonitoringCheckSettingsTracerouteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SyntheticMonitoringCheckSettingsTracerouteArgs:
    def __init__(__self__, *,
                 max_hops: Optional[pulumi.Input[int]] = None,
                 max_unknown_hops: Optional[pulumi.Input[int]] = None,
                 ptr_lookup: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[int] max_hops: Maximum TTL for the trace Defaults to `64`.
        :param pulumi.Input[int] max_unknown_hops: Maximum number of hosts to travers that give no response Defaults to `15`.
        :param pulumi.Input[bool] ptr_lookup: Reverse lookup hostnames from IP addresses Defaults to `true`.
        """
        if max_hops is not None:
            pulumi.set(__self__, "max_hops", max_hops)
        if max_unknown_hops is not None:
            pulumi.set(__self__, "max_unknown_hops", max_unknown_hops)
        if ptr_lookup is not None:
            pulumi.set(__self__, "ptr_lookup", ptr_lookup)

    @property
    @pulumi.getter(name="maxHops")
    def max_hops(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum TTL for the trace Defaults to `64`.
        """
        return pulumi.get(self, "max_hops")

    @max_hops.setter
    def max_hops(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_hops", value)

    @property
    @pulumi.getter(name="maxUnknownHops")
    def max_unknown_hops(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of hosts to travers that give no response Defaults to `15`.
        """
        return pulumi.get(self, "max_unknown_hops")

    @max_unknown_hops.setter
    def max_unknown_hops(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_unknown_hops", value)

    @property
    @pulumi.getter(name="ptrLookup")
    def ptr_lookup(self) -> Optional[pulumi.Input[bool]]:
        """
        Reverse lookup hostnames from IP addresses Defaults to `true`.
        """
        return pulumi.get(self, "ptr_lookup")

    @ptr_lookup.setter
    def ptr_lookup(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ptr_lookup", value)


if not MYPY:
    class TeamPreferencesArgsDict(TypedDict):
        home_dashboard_uid: NotRequired[pulumi.Input[str]]
        """
        The UID of the dashboard to display when a team member logs in.
        """
        theme: NotRequired[pulumi.Input[str]]
        """
        The default theme for this team. Available themes are `light`, `dark`, `system`, or an empty string for the default theme.
        """
        timezone: NotRequired[pulumi.Input[str]]
        """
        The default timezone for this team. Available values are `utc`, `browser`, or an empty string for the default.
        """
        week_start: NotRequired[pulumi.Input[str]]
        """
        The default week start day for this team. Available values are `sunday`, `monday`, `saturday`, or an empty string for the default.
        """
elif False:
    TeamPreferencesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TeamPreferencesArgs:
    def __init__(__self__, *,
                 home_dashboard_uid: Optional[pulumi.Input[str]] = None,
                 theme: Optional[pulumi.Input[str]] = None,
                 timezone: Optional[pulumi.Input[str]] = None,
                 week_start: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] home_dashboard_uid: The UID of the dashboard to display when a team member logs in.
        :param pulumi.Input[str] theme: The default theme for this team. Available themes are `light`, `dark`, `system`, or an empty string for the default theme.
        :param pulumi.Input[str] timezone: The default timezone for this team. Available values are `utc`, `browser`, or an empty string for the default.
        :param pulumi.Input[str] week_start: The default week start day for this team. Available values are `sunday`, `monday`, `saturday`, or an empty string for the default.
        """
        if home_dashboard_uid is not None:
            pulumi.set(__self__, "home_dashboard_uid", home_dashboard_uid)
        if theme is not None:
            pulumi.set(__self__, "theme", theme)
        if timezone is not None:
            pulumi.set(__self__, "timezone", timezone)
        if week_start is not None:
            pulumi.set(__self__, "week_start", week_start)

    @property
    @pulumi.getter(name="homeDashboardUid")
    def home_dashboard_uid(self) -> Optional[pulumi.Input[str]]:
        """
        The UID of the dashboard to display when a team member logs in.
        """
        return pulumi.get(self, "home_dashboard_uid")

    @home_dashboard_uid.setter
    def home_dashboard_uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "home_dashboard_uid", value)

    @property
    @pulumi.getter
    def theme(self) -> Optional[pulumi.Input[str]]:
        """
        The default theme for this team. Available themes are `light`, `dark`, `system`, or an empty string for the default theme.
        """
        return pulumi.get(self, "theme")

    @theme.setter
    def theme(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "theme", value)

    @property
    @pulumi.getter
    def timezone(self) -> Optional[pulumi.Input[str]]:
        """
        The default timezone for this team. Available values are `utc`, `browser`, or an empty string for the default.
        """
        return pulumi.get(self, "timezone")

    @timezone.setter
    def timezone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timezone", value)

    @property
    @pulumi.getter(name="weekStart")
    def week_start(self) -> Optional[pulumi.Input[str]]:
        """
        The default week start day for this team. Available values are `sunday`, `monday`, `saturday`, or an empty string for the default.
        """
        return pulumi.get(self, "week_start")

    @week_start.setter
    def week_start(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "week_start", value)


if not MYPY:
    class TeamTeamSyncArgsDict(TypedDict):
        groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    TeamTeamSyncArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TeamTeamSyncArgs:
    def __init__(__self__, *,
                 groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if groups is not None:
            pulumi.set(__self__, "groups", groups)

    @property
    @pulumi.getter
    def groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "groups", value)


