// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface CloudAccessPolicyRealm {
    /**
     * The identifier of the org or stack. For orgs, this is the slug, for stacks, this is the stack ID.
     */
    identifier: string;
    labelPolicies?: outputs.CloudAccessPolicyRealmLabelPolicy[];
    /**
     * Whether a policy applies to a Cloud org or a specific stack. Should be one of `org` or `stack`.
     */
    type: string;
}

export interface CloudAccessPolicyRealmLabelPolicy {
    /**
     * The label selector to match in metrics or logs query. Should be in PromQL or LogQL format.
     */
    selector: string;
}

export interface ContactPointAlertmanager {
    /**
     * The password component of the basic auth credentials to use.
     */
    basicAuthPassword?: string;
    /**
     * The username component of the basic auth credentials to use.
     */
    basicAuthUser?: string;
    /**
     * Whether to disable sending resolve messages. Defaults to `false`.
     */
    disableResolveMessage?: boolean;
    /**
     * Additional custom properties to attach to the notifier. Defaults to `map[]`.
     */
    settings?: {[key: string]: string};
    /**
     * The UID of the contact point.
     */
    uid: string;
    /**
     * The URL of the Alertmanager instance.
     */
    url: string;
}

export interface ContactPointDingding {
    /**
     * Whether to disable sending resolve messages. Defaults to `false`.
     */
    disableResolveMessage?: boolean;
    /**
     * The templated content of the message.
     */
    message?: string;
    /**
     * The format of message to send - either 'link' or 'actionCard'
     */
    messageType?: string;
    /**
     * Additional custom properties to attach to the notifier. Defaults to `map[]`.
     */
    settings?: {[key: string]: string};
    /**
     * The templated title of the message.
     */
    title?: string;
    /**
     * The UID of the contact point.
     */
    uid: string;
    /**
     * The DingDing webhook URL.
     */
    url: string;
}

export interface ContactPointDiscord {
    /**
     * The URL of a custom avatar image to use. Defaults to ``.
     */
    avatarUrl?: string;
    /**
     * Whether to disable sending resolve messages. Defaults to `false`.
     */
    disableResolveMessage?: boolean;
    /**
     * The templated content of the message. Defaults to ``.
     */
    message?: string;
    /**
     * Additional custom properties to attach to the notifier. Defaults to `map[]`.
     */
    settings?: {[key: string]: string};
    /**
     * The templated content of the title.
     */
    title?: string;
    /**
     * The UID of the contact point.
     */
    uid: string;
    /**
     * The discord webhook URL.
     */
    url: string;
    /**
     * Whether to use the bot account's plain username instead of "Grafana." Defaults to `false`.
     */
    useDiscordUsername?: boolean;
}

export interface ContactPointEmail {
    /**
     * The addresses to send emails to.
     */
    addresses: string[];
    /**
     * Whether to disable sending resolve messages. Defaults to `false`.
     */
    disableResolveMessage?: boolean;
    /**
     * The templated content of the email. Defaults to ``.
     */
    message?: string;
    /**
     * Additional custom properties to attach to the notifier. Defaults to `map[]`.
     */
    settings?: {[key: string]: string};
    /**
     * Whether to send a single email CC'ing all addresses, rather than a separate email to each address. Defaults to `false`.
     */
    singleEmail?: boolean;
    /**
     * The templated subject line of the email. Defaults to ``.
     */
    subject?: string;
    /**
     * The UID of the contact point.
     */
    uid: string;
}

export interface ContactPointGooglechat {
    /**
     * Whether to disable sending resolve messages. Defaults to `false`.
     */
    disableResolveMessage?: boolean;
    /**
     * The templated content of the message.
     */
    message?: string;
    /**
     * Additional custom properties to attach to the notifier. Defaults to `map[]`.
     */
    settings?: {[key: string]: string};
    /**
     * The templated content of the title.
     */
    title?: string;
    /**
     * The UID of the contact point.
     */
    uid: string;
    /**
     * The Google Chat webhook URL.
     */
    url: string;
}

export interface ContactPointKafka {
    /**
     * The API version to use when contacting the Kafka REST Server. Supported: v2 (default) and v3. Defaults to `v2`.
     */
    apiVersion?: string;
    /**
     * The Id of cluster to use when contacting the Kafka REST Server. Required apiVersion to be 'v3'
     */
    clusterId?: string;
    /**
     * The templated description of the Kafka message.
     */
    description?: string;
    /**
     * The templated details to include with the message.
     */
    details?: string;
    /**
     * Whether to disable sending resolve messages. Defaults to `false`.
     */
    disableResolveMessage?: boolean;
    /**
     * The password to use when making a call to the Kafka REST Proxy
     */
    password?: string;
    /**
     * The URL of the Kafka REST proxy to send requests to.
     */
    restProxyUrl: string;
    /**
     * Additional custom properties to attach to the notifier. Defaults to `map[]`.
     */
    settings?: {[key: string]: string};
    /**
     * The name of the Kafka topic to publish to.
     */
    topic: string;
    /**
     * The UID of the contact point.
     */
    uid: string;
    /**
     * The user name to use when making a call to the Kafka REST Proxy
     */
    username?: string;
}

export interface ContactPointLine {
    /**
     * The templated description of the message.
     */
    description?: string;
    /**
     * Whether to disable sending resolve messages. Defaults to `false`.
     */
    disableResolveMessage?: boolean;
    /**
     * Additional custom properties to attach to the notifier. Defaults to `map[]`.
     */
    settings?: {[key: string]: string};
    /**
     * The templated title of the message.
     */
    title?: string;
    /**
     * The bearer token used to authorize the client.
     */
    token: string;
    /**
     * The UID of the contact point.
     */
    uid: string;
}

export interface ContactPointOncall {
    /**
     * Allows a custom authorization scheme - attaches an auth header with this value. Do not use in conjunction with basic auth parameters.
     */
    authorizationCredentials?: string;
    /**
     * Allows a custom authorization scheme - attaches an auth header with this name. Do not use in conjunction with basic auth parameters.
     */
    authorizationScheme?: string;
    /**
     * The username to use in basic auth headers attached to the request. If omitted, basic auth will not be used.
     */
    basicAuthPassword?: string;
    /**
     * The username to use in basic auth headers attached to the request. If omitted, basic auth will not be used.
     */
    basicAuthUser?: string;
    /**
     * Whether to disable sending resolve messages. Defaults to `false`.
     */
    disableResolveMessage?: boolean;
    /**
     * The HTTP method to use in the request. Defaults to `POST`.
     */
    httpMethod?: string;
    /**
     * The maximum number of alerts to send in a single request. This can be helpful in limiting the size of the request body. The default is 0, which indicates no limit.
     */
    maxAlerts?: number;
    /**
     * Custom message. You can use template variables.
     */
    message?: string;
    /**
     * Additional custom properties to attach to the notifier. Defaults to `map[]`.
     */
    settings?: {[key: string]: string};
    /**
     * Templated title of the message.
     */
    title?: string;
    /**
     * The UID of the contact point.
     */
    uid: string;
    /**
     * The URL to send webhook requests to.
     */
    url: string;
}

export interface ContactPointOpsgeny {
    /**
     * The OpsGenie API key to use.
     */
    apiKey: string;
    /**
     * Whether to auto-close alerts in OpsGenie when they resolve in the Alertmanager.
     */
    autoClose?: boolean;
    /**
     * A templated high-level description to use for the alert.
     */
    description?: string;
    /**
     * Whether to disable sending resolve messages. Defaults to `false`.
     */
    disableResolveMessage?: boolean;
    /**
     * The templated content of the message.
     */
    message?: string;
    /**
     * Whether to allow the alert priority to be configured via the value of the `ogPriority` annotation on the alert.
     */
    overridePriority?: boolean;
    /**
     * Teams, users, escalations and schedules that the alert will be routed to send notifications. If the API Key belongs to a team integration, this field will be overwritten with the owner team. This feature is available from Grafana 10.3+.
     */
    responders?: outputs.ContactPointOpsgenyResponder[];
    /**
     * Whether to send annotations to OpsGenie as Tags, Details, or both. Supported values are `tags`, `details`, `both`, or empty to use the default behavior of Tags.
     */
    sendTagsAs?: string;
    /**
     * Additional custom properties to attach to the notifier. Defaults to `map[]`.
     */
    settings?: {[key: string]: string};
    /**
     * The UID of the contact point.
     */
    uid: string;
    /**
     * Allows customization of the OpsGenie API URL.
     */
    url?: string;
}

export interface ContactPointOpsgenyResponder {
    /**
     * ID of the responder. Must be specified if name and username are empty.
     */
    id?: string;
    /**
     * Name of the responder. Must be specified if username and id are empty.
     */
    name?: string;
    /**
     * Type of the responder. Supported: team, teams, user, escalation, schedule or a template that is expanded to one of these values.
     */
    type: string;
    /**
     * User name of the responder. Must be specified if name and id are empty.
     */
    username?: string;
}

export interface ContactPointPagerduty {
    /**
     * The class or type of event, for example `ping failure`.
     */
    class?: string;
    /**
     * The name of the monitoring client that is triggering this event.
     */
    client?: string;
    /**
     * The URL of the monitoring client that is triggering this event.
     */
    clientUrl?: string;
    /**
     * The component being affected by the event.
     */
    component?: string;
    /**
     * A set of arbitrary key/value pairs that provide further detail about the incident.
     */
    details?: {[key: string]: string};
    /**
     * Whether to disable sending resolve messages. Defaults to `false`.
     */
    disableResolveMessage?: boolean;
    /**
     * The group to which the provided component belongs to.
     */
    group?: string;
    /**
     * The PagerDuty API key.
     */
    integrationKey: string;
    /**
     * Additional custom properties to attach to the notifier. Defaults to `map[]`.
     */
    settings?: {[key: string]: string};
    /**
     * The PagerDuty event severity level. Default is `critical`.
     */
    severity?: string;
    /**
     * The unique location of the affected system.
     */
    source?: string;
    /**
     * The templated summary message of the event.
     */
    summary?: string;
    /**
     * The UID of the contact point.
     */
    uid: string;
    /**
     * The URL to send API requests to
     */
    url?: string;
}

export interface ContactPointPushover {
    /**
     * The Pushover API token.
     */
    apiToken: string;
    /**
     * Comma-separated list of devices to which the event is associated.
     */
    device?: string;
    /**
     * Whether to disable sending resolve messages. Defaults to `false`.
     */
    disableResolveMessage?: boolean;
    /**
     * How many seconds for which the notification will continue to be retried by Pushover.
     */
    expire?: number;
    /**
     * The templated notification message content.
     */
    message?: string;
    /**
     * The priority level of the resolved event.
     */
    okPriority?: number;
    /**
     * The sound associated with the resolved notification.
     */
    okSound?: string;
    /**
     * The priority level of the event.
     */
    priority?: number;
    /**
     * How often, in seconds, the Pushover servers will send the same notification to the user.
     */
    retry?: number;
    /**
     * Additional custom properties to attach to the notifier. Defaults to `map[]`.
     */
    settings?: {[key: string]: string};
    /**
     * The sound associated with the notification.
     */
    sound?: string;
    /**
     * The templated title of the message.
     */
    title?: string;
    /**
     * The UID of the contact point.
     */
    uid: string;
    /**
     * Whether to send images in the notification or not. Default is true. Requires Grafana to be configured to send images in notifications.
     */
    uploadImage?: boolean;
    /**
     * The Pushover user key.
     */
    userKey: string;
}

export interface ContactPointSensugo {
    /**
     * The SensuGo API key.
     */
    apiKey: string;
    /**
     * The SensuGo check to which the event should be routed.
     */
    check?: string;
    /**
     * Whether to disable sending resolve messages. Defaults to `false`.
     */
    disableResolveMessage?: boolean;
    /**
     * The entity being monitored.
     */
    entity?: string;
    /**
     * A custom handler to execute in addition to the check.
     */
    handler?: string;
    /**
     * Templated message content describing the alert.
     */
    message?: string;
    /**
     * The namespace in which the check resides.
     */
    namespace?: string;
    /**
     * Additional custom properties to attach to the notifier. Defaults to `map[]`.
     */
    settings?: {[key: string]: string};
    /**
     * The UID of the contact point.
     */
    uid: string;
    /**
     * The SensuGo URL to send requests to.
     */
    url: string;
}

export interface ContactPointSlack {
    /**
     * Whether to disable sending resolve messages. Defaults to `false`.
     */
    disableResolveMessage?: boolean;
    /**
     * Use this to override the Slack API endpoint URL to send requests to.
     */
    endpointUrl?: string;
    /**
     * The name of a Slack workspace emoji to use as the bot icon.
     */
    iconEmoji?: string;
    /**
     * A URL of an image to use as the bot icon.
     */
    iconUrl?: string;
    /**
     * Describes how to ping the slack channel that messages are being sent to. Options are `here` for an @here ping, `channel` for @channel, or empty for no ping.
     */
    mentionChannel?: string;
    /**
     * Comma-separated list of groups to mention in the message.
     */
    mentionGroups?: string;
    /**
     * Comma-separated list of users to mention in the message.
     */
    mentionUsers?: string;
    /**
     * Channel, private group, or IM channel (can be an encoded ID or a name) to send messages to.
     */
    recipient?: string;
    /**
     * Additional custom properties to attach to the notifier. Defaults to `map[]`.
     */
    settings?: {[key: string]: string};
    /**
     * Templated content of the message.
     */
    text?: string;
    /**
     * Templated title of the message.
     */
    title?: string;
    /**
     * A Slack API token,for sending messages directly without the webhook method.
     */
    token?: string;
    /**
     * The UID of the contact point.
     */
    uid: string;
    /**
     * A Slack webhook URL,for sending messages via the webhook method.
     */
    url?: string;
    /**
     * Username for the bot to use.
     */
    username?: string;
}

export interface ContactPointSn {
    /**
     * AWS access key ID used to authenticate with Amazon SNS.
     */
    accessKey?: string;
    /**
     * The Amazon Resource Name (ARN) of the role to assume to send notifications to Amazon SNS.
     */
    assumeRoleArn?: string;
    /**
     * The authentication provider to use. Valid values are `default`, `arn` and `keys`. Default is `default`. Defaults to `default`.
     */
    authProvider?: string;
    body?: string;
    /**
     * Whether to disable sending resolve messages. Defaults to `false`.
     */
    disableResolveMessage?: boolean;
    /**
     * The external ID to use when assuming the role.
     */
    externalId?: string;
    /**
     * The format of the message to send. Valid values are `text`, `body` and `json`. Default is `text`. Defaults to `text`.
     */
    messageFormat?: string;
    /**
     * AWS secret access key used to authenticate with Amazon SNS.
     */
    secretKey?: string;
    /**
     * Additional custom properties to attach to the notifier. Defaults to `map[]`.
     */
    settings?: {[key: string]: string};
    subject?: string;
    /**
     * The Amazon SNS topic to send notifications to.
     */
    topic: string;
    /**
     * The UID of the contact point.
     */
    uid: string;
}

export interface ContactPointTeam {
    /**
     * Whether to disable sending resolve messages. Defaults to `false`.
     */
    disableResolveMessage?: boolean;
    /**
     * The templated message content to send.
     */
    message?: string;
    /**
     * The templated subtitle for each message section.
     */
    sectionTitle?: string;
    /**
     * Additional custom properties to attach to the notifier. Defaults to `map[]`.
     */
    settings?: {[key: string]: string};
    /**
     * The templated title of the message.
     */
    title?: string;
    /**
     * The UID of the contact point.
     */
    uid: string;
    /**
     * A Teams webhook URL.
     */
    url: string;
}

export interface ContactPointTelegram {
    /**
     * The chat ID to send messages to.
     */
    chatId: string;
    /**
     * When set users will receive a notification with no sound.
     */
    disableNotifications?: boolean;
    /**
     * Whether to disable sending resolve messages. Defaults to `false`.
     */
    disableResolveMessage?: boolean;
    /**
     * When set it disables link previews for links in the message.
     */
    disableWebPagePreview?: boolean;
    /**
     * The templated content of the message.
     */
    message?: string;
    /**
     * The ID of the message thread to send the message to.
     */
    messageThreadId?: string;
    /**
     * Mode for parsing entities in the message text. Supported: None, Markdown, MarkdownV2, and HTML. HTML is the default.
     */
    parseMode?: string;
    /**
     * When set it protects the contents of the message from forwarding and saving.
     */
    protectContent?: boolean;
    /**
     * Additional custom properties to attach to the notifier. Defaults to `map[]`.
     */
    settings?: {[key: string]: string};
    /**
     * The Telegram bot token.
     */
    token: string;
    /**
     * The UID of the contact point.
     */
    uid: string;
}

export interface ContactPointThreema {
    /**
     * The Threema API key.
     */
    apiSecret: string;
    /**
     * The templated description of the message.
     */
    description?: string;
    /**
     * Whether to disable sending resolve messages. Defaults to `false`.
     */
    disableResolveMessage?: boolean;
    /**
     * The Threema gateway ID.
     */
    gatewayId: string;
    /**
     * The ID of the recipient of the message.
     */
    recipientId: string;
    /**
     * Additional custom properties to attach to the notifier. Defaults to `map[]`.
     */
    settings?: {[key: string]: string};
    /**
     * The templated title of the message.
     */
    title?: string;
    /**
     * The UID of the contact point.
     */
    uid: string;
}

export interface ContactPointVictorop {
    /**
     * Templated description of the message.
     */
    description?: string;
    /**
     * Whether to disable sending resolve messages. Defaults to `false`.
     */
    disableResolveMessage?: boolean;
    /**
     * The VictorOps alert state - typically either `CRITICAL` or `RECOVERY`.
     */
    messageType?: string;
    /**
     * Additional custom properties to attach to the notifier. Defaults to `map[]`.
     */
    settings?: {[key: string]: string};
    /**
     * Templated title to display.
     */
    title?: string;
    /**
     * The UID of the contact point.
     */
    uid: string;
    /**
     * The VictorOps webhook URL.
     */
    url: string;
}

export interface ContactPointWebex {
    /**
     * The URL to send webhook requests to.
     */
    apiUrl?: string;
    /**
     * Whether to disable sending resolve messages. Defaults to `false`.
     */
    disableResolveMessage?: boolean;
    /**
     * The templated title of the message to send.
     */
    message?: string;
    /**
     * ID of the Webex Teams room where to send the messages.
     */
    roomId?: string;
    /**
     * Additional custom properties to attach to the notifier. Defaults to `map[]`.
     */
    settings?: {[key: string]: string};
    /**
     * The bearer token used to authorize the client.
     */
    token?: string;
    /**
     * The UID of the contact point.
     */
    uid: string;
}

export interface ContactPointWebhook {
    /**
     * Allows a custom authorization scheme - attaches an auth header with this value. Do not use in conjunction with basic auth parameters.
     */
    authorizationCredentials?: string;
    /**
     * Allows a custom authorization scheme - attaches an auth header with this name. Do not use in conjunction with basic auth parameters.
     */
    authorizationScheme?: string;
    /**
     * The username to use in basic auth headers attached to the request. If omitted, basic auth will not be used.
     */
    basicAuthPassword?: string;
    /**
     * The username to use in basic auth headers attached to the request. If omitted, basic auth will not be used.
     */
    basicAuthUser?: string;
    /**
     * Whether to disable sending resolve messages. Defaults to `false`.
     */
    disableResolveMessage?: boolean;
    /**
     * The HTTP method to use in the request. Defaults to `POST`.
     */
    httpMethod?: string;
    /**
     * The maximum number of alerts to send in a single request. This can be helpful in limiting the size of the request body. The default is 0, which indicates no limit.
     */
    maxAlerts?: number;
    /**
     * Custom message. You can use template variables.
     */
    message?: string;
    /**
     * Additional custom properties to attach to the notifier. Defaults to `map[]`.
     */
    settings?: {[key: string]: string};
    /**
     * Templated title of the message.
     */
    title?: string;
    /**
     * The UID of the contact point.
     */
    uid: string;
    /**
     * The URL to send webhook requests to.
     */
    url: string;
}

export interface ContactPointWecom {
    /**
     * Agent ID added to the request payload when using APIAPP.
     */
    agentId?: string;
    /**
     * Corp ID used to get token when using APIAPP.
     */
    corpId?: string;
    /**
     * Whether to disable sending resolve messages. Defaults to `false`.
     */
    disableResolveMessage?: boolean;
    /**
     * The templated content of the message to send.
     */
    message?: string;
    /**
     * The type of them message. Supported: markdown, text. Default: text.
     */
    msgType?: string;
    /**
     * The secret key required to obtain access token when using APIAPP. See https://work.weixin.qq.com/wework_admin/frame#apps to create APIAPP.
     */
    secret?: string;
    /**
     * Additional custom properties to attach to the notifier. Defaults to `map[]`.
     */
    settings?: {[key: string]: string};
    /**
     * The templated title of the message to send.
     */
    title?: string;
    /**
     * The ID of user that should receive the message. Multiple entries should be separated by '|'. Default: @all.
     */
    toUser?: string;
    /**
     * The UID of the contact point.
     */
    uid: string;
    /**
     * The WeCom webhook URL. Required if using GroupRobot.
     */
    url?: string;
}

export interface DashboardPermissionPermission {
    /**
     * Permission to associate with item. Must be one of `View`, `Edit`, or `Admin`.
     */
    permission: string;
    /**
     * Name of the basic role to manage permissions for. Options: `Viewer`, `Editor` or `Admin`.
     */
    role?: string;
    /**
     * ID of the team to manage permissions for. Defaults to `0`.
     */
    teamId?: string;
    /**
     * ID of the user or service account to manage permissions for. Defaults to `0`.
     */
    userId?: string;
}

export interface DataSourcePermissionPermission {
    /**
     * Name of the basic role to manage permissions for. Options: `Viewer`, `Editor` or `Admin`.
     */
    builtInRole?: string;
    /**
     * Permission to associate with item. Options: `Query`, `Edit` or `Admin` (`Admin` can only be used with Grafana v10.3.0+).
     */
    permission: string;
    /**
     * ID of the team to manage permissions for. Defaults to `0`.
     */
    teamId?: string;
    /**
     * ID of the user or service account to manage permissions for. Defaults to `0`.
     */
    userId?: string;
}

export interface FolderPermissionPermission {
    /**
     * Permission to associate with item. Must be one of `View`, `Edit`, or `Admin`.
     */
    permission: string;
    /**
     * Name of the basic role to manage permissions for. Options: `Viewer`, `Editor` or `Admin`.
     */
    role?: string;
    /**
     * ID of the team to manage permissions for. Defaults to `0`.
     */
    teamId?: string;
    /**
     * ID of the user or service account to manage permissions for. Defaults to `0`.
     */
    userId?: string;
}

export interface GetDashboardsDashboard {
    folderTitle: string;
    title: string;
    uid: string;
}

export interface GetFoldersFolder {
    /**
     * The folder ID.
     */
    id: number;
    /**
     * The folder title.
     */
    title: string;
    /**
     * The folder's unique identifier.
     */
    uid: string;
    /**
     * The folder's URL
     */
    url: string;
}

export interface GetRolePermission {
    /**
     * Specific action users granted with the role will be allowed to perform (for example: `users:read`)
     */
    action: string;
    /**
     * Scope to restrict the action to a set of resources (for example: `users:*` or `roles:customrole1`)
     */
    scope?: string;
}

export interface GetSlosSlo {
    /**
     * Configures the alerting rules that will be generated for each
     * 				time window associated with the SLO. Grafana SLOs can generate
     * 				alerts when the short-term error budget burn is very high, the
     * 				long-term error budget burn rate is high, or when the remaining
     * 				error budget is below a certain threshold. Annotations and Labels support templating.
     */
    alertings: outputs.GetSlosSloAlerting[];
    /**
     * Description is a free-text field that can provide more context to an SLO.
     */
    description: string;
    /**
     * Destination Datasource sets the datasource defined for an SLO
     */
    destinationDatasources: outputs.GetSlosSloDestinationDatasource[];
    /**
     * UID for the SLO folder
     */
    folderUid: string;
    /**
     * Additional labels that will be attached to all metrics generated from the query. These labels are useful for grouping SLOs in dashboard views that you create by hand. Labels must adhere to Prometheus label name schema - "^[a-zA-Z_][a-zA-Z0-9_]*$"
     */
    labels: outputs.GetSlosSloLabel[];
    /**
     * Name should be a short description of your indicator. Consider names like "API Availability"
     */
    name: string;
    /**
     * Over each rolling time window, the remaining error budget will be calculated, and separate alerts can be generated for each time window based on the SLO burn rate or remaining error budget.
     */
    objectives: outputs.GetSlosSloObjective[];
    /**
     * Query describes the indicator that will be measured against the objective. Freeform Query types are currently supported.
     */
    queries: outputs.GetSlosSloQuery[];
    /**
     * A unique, random identifier. This value will also be the name of the resource stored in the API server. This value is read-only.
     */
    uuid: string;
}

export interface GetSlosSloAlerting {
    /**
     * Advanced Options for Alert Rules
     */
    advancedOptions?: outputs.GetSlosSloAlertingAdvancedOptions;
    /**
     * Annotations will be attached to all alerts generated by any of these rules.
     */
    annotations?: outputs.GetSlosSloAlertingAnnotation[];
    /**
     * Alerting Rules generated for Fast Burn alerts
     */
    fastburn?: outputs.GetSlosSloAlertingFastburn;
    /**
     * Labels will be attached to all alerts generated by any of these rules.
     */
    labels?: outputs.GetSlosSloAlertingLabel[];
    /**
     * Alerting Rules generated for Slow Burn alerts
     */
    slowburn?: outputs.GetSlosSloAlertingSlowburn;
}

export interface GetSlosSloAlertingAdvancedOptions {
    /**
     * Minimum number of failed events to trigger an alert
     */
    minFailures?: number;
}

export interface GetSlosSloAlertingAnnotation {
    key: string;
    value: string;
}

export interface GetSlosSloAlertingFastburn {
    /**
     * Annotations to attach only to Fast Burn alerts.
     */
    annotations?: outputs.GetSlosSloAlertingFastburnAnnotation[];
    /**
     * Labels to attach only to Fast Burn alerts.
     */
    labels?: outputs.GetSlosSloAlertingFastburnLabel[];
}

export interface GetSlosSloAlertingFastburnAnnotation {
    key: string;
    value: string;
}

export interface GetSlosSloAlertingFastburnLabel {
    key: string;
    value: string;
}

export interface GetSlosSloAlertingLabel {
    key: string;
    value: string;
}

export interface GetSlosSloAlertingSlowburn {
    /**
     * Annotations to attach only to Slow Burn alerts.
     */
    annotations?: outputs.GetSlosSloAlertingSlowburnAnnotation[];
    /**
     * Labels to attach only to Slow Burn alerts.
     */
    labels?: outputs.GetSlosSloAlertingSlowburnLabel[];
}

export interface GetSlosSloAlertingSlowburnAnnotation {
    key: string;
    value: string;
}

export interface GetSlosSloAlertingSlowburnLabel {
    key: string;
    value: string;
}

export interface GetSlosSloDestinationDatasource {
    /**
     * UID for the Mimir Datasource
     */
    uid?: string;
}

export interface GetSlosSloLabel {
    key: string;
    value: string;
}

export interface GetSlosSloObjective {
    /**
     * Value between 0 and 1. If the value of the query is above the objective, the SLO is met.
     */
    value: number;
    /**
     * A Prometheus-parsable time duration string like 24h, 60m. This is the time window the objective is measured over.
     */
    window: string;
}

export interface GetSlosSloQuery {
    freeform?: outputs.GetSlosSloQueryFreeform;
    ratio?: outputs.GetSlosSloQueryRatio;
    /**
     * Query type must be one of: "freeform", "query", "ratio", or "threshold"
     */
    type: string;
}

export interface GetSlosSloQueryFreeform {
    /**
     * Freeform Query Field
     */
    query: string;
}

export interface GetSlosSloQueryRatio {
    /**
     * Defines Group By Labels used for per-label alerting. These appear as variables on SLO dashboards to enable filtering and aggregation. Labels must adhere to Prometheus label name schema - "^[a-zA-Z_][a-zA-Z0-9_]*$"
     */
    groupByLabels?: string[];
    /**
     * Counter metric for success events (numerator)
     */
    successMetric: string;
    /**
     * Metric for total events (denominator)
     */
    totalMetric: string;
}

export interface GetTeamPreference {
    /**
     * The UID of the dashboard to display when a team member logs in.
     */
    homeDashboardUid?: string;
    /**
     * The default theme for this team. Available themes are `light`, `dark`, `system`, or an empty string for the default theme.
     */
    theme?: string;
    /**
     * The default timezone for this team. Available values are `utc`, `browser`, or an empty string for the default.
     */
    timezone?: string;
    /**
     * The default week start day for this team. Available values are `sunday`, `monday`, `saturday`, or an empty string for the default.
     */
    weekStart?: string;
}

export interface GetTeamTeamSync {
    groups?: string[];
}

export interface GetUsersUser {
    /**
     * The user's email.
     */
    email: string;
    /**
     * The user ID.
     */
    id: number;
    /**
     * Whether the user is admin or not.
     */
    isAdmin: boolean;
    /**
     * The user's login.
     */
    login: string;
    /**
     * The user's name.
     */
    name: string;
}

export interface MachineLearningHolidayCustomPeriod {
    endTime: string;
    /**
     * The name of the custom period.
     */
    name?: string;
    startTime: string;
}

export interface MachineLearningOutlierDetectorAlgorithm {
    /**
     * For DBSCAN only, specify the configuration map
     */
    config?: outputs.MachineLearningOutlierDetectorAlgorithmConfig;
    /**
     * The name of the algorithm to use ('mad' or 'dbscan').
     */
    name: string;
    /**
     * Specify the sensitivity of the detector (in range [0,1]).
     */
    sensitivity: number;
}

export interface MachineLearningOutlierDetectorAlgorithmConfig {
    /**
     * Specify the epsilon parameter (positive float)
     */
    epsilon: number;
}

export interface MuteTimingInterval {
    /**
     * An inclusive range of days, 1-31, within a month, e.g. "1" or "14:16". Negative values can be used to represent days counting from the end of a month, e.g. "-1".
     */
    daysOfMonths?: string[];
    /**
     * Provides the time zone for the time interval. Must be a location in the IANA time zone database, e.g "America/New_York"
     */
    location?: string;
    /**
     * An inclusive range of months, either numerical or full calendar month, e.g. "1:3", "december", or "may:august".
     */
    months?: string[];
    /**
     * The time ranges, represented in minutes, during which to mute in a given day.
     */
    times?: outputs.MuteTimingIntervalTime[];
    /**
     * An inclusive range of weekdays, e.g. "monday" or "tuesday:thursday".
     */
    weekdays?: string[];
    /**
     * A positive inclusive range of years, e.g. "2030" or "2025:2026".
     */
    years?: string[];
}

export interface MuteTimingIntervalTime {
    /**
     * The time, in hh:mm format, of when the interval should end exclusively.
     */
    end: string;
    /**
     * The time, in hh:mm format, of when the interval should begin inclusively.
     */
    start: string;
}

export interface NotificationPolicyPolicy {
    /**
     * The contact point to route notifications that match this rule to.
     */
    contactPoint?: string;
    /**
     * Whether to continue matching subsequent rules if an alert matches the current rule. Otherwise, the rule will be 'consumed' by the first policy to match it.
     */
    continue?: boolean;
    /**
     * A list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping. Required for root policy only. If empty, the parent grouping is used.
     */
    groupBies?: string[];
    /**
     * Minimum time interval between two notifications for the same group. Default is 5 minutes.
     */
    groupInterval?: string;
    /**
     * Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.
     */
    groupWait?: string;
    /**
     * Describes which labels this rule should match. When multiple matchers are supplied, an alert must match ALL matchers to be accepted by this policy. When no matchers are supplied, the rule will match all alert instances.
     */
    matchers?: outputs.NotificationPolicyPolicyMatcher[];
    /**
     * A list of mute timing names to apply to alerts that match this policy.
     */
    muteTimings?: string[];
    /**
     * Routing rules for specific label sets.
     */
    policies?: outputs.NotificationPolicyPolicyPolicy[];
    /**
     * Minimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.
     */
    repeatInterval?: string;
}

export interface NotificationPolicyPolicyMatcher {
    /**
     * The name of the label to match against.
     */
    label: string;
    /**
     * The operator to apply when matching values of the given label. Allowed operators are `=` for equality, `!=` for negated equality, `=~` for regex equality, and `!~` for negated regex equality.
     */
    match: string;
    /**
     * The label value to match against.
     */
    value: string;
}

export interface NotificationPolicyPolicyPolicy {
    /**
     * The contact point to route notifications that match this rule to.
     */
    contactPoint?: string;
    /**
     * Whether to continue matching subsequent rules if an alert matches the current rule. Otherwise, the rule will be 'consumed' by the first policy to match it.
     */
    continue?: boolean;
    /**
     * A list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping. Required for root policy only. If empty, the parent grouping is used.
     */
    groupBies?: string[];
    /**
     * Minimum time interval between two notifications for the same group. Default is 5 minutes.
     */
    groupInterval?: string;
    /**
     * Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.
     */
    groupWait?: string;
    /**
     * Describes which labels this rule should match. When multiple matchers are supplied, an alert must match ALL matchers to be accepted by this policy. When no matchers are supplied, the rule will match all alert instances.
     */
    matchers?: outputs.NotificationPolicyPolicyPolicyMatcher[];
    /**
     * A list of mute timing names to apply to alerts that match this policy.
     */
    muteTimings?: string[];
    /**
     * Routing rules for specific label sets.
     */
    policies?: outputs.NotificationPolicyPolicyPolicyPolicy[];
    /**
     * Minimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.
     */
    repeatInterval?: string;
}

export interface NotificationPolicyPolicyPolicyMatcher {
    /**
     * The name of the label to match against.
     */
    label: string;
    /**
     * The operator to apply when matching values of the given label. Allowed operators are `=` for equality, `!=` for negated equality, `=~` for regex equality, and `!~` for negated regex equality.
     */
    match: string;
    /**
     * The label value to match against.
     */
    value: string;
}

export interface NotificationPolicyPolicyPolicyPolicy {
    /**
     * The contact point to route notifications that match this rule to.
     */
    contactPoint?: string;
    /**
     * Whether to continue matching subsequent rules if an alert matches the current rule. Otherwise, the rule will be 'consumed' by the first policy to match it.
     */
    continue?: boolean;
    /**
     * A list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping. Required for root policy only. If empty, the parent grouping is used.
     */
    groupBies?: string[];
    /**
     * Minimum time interval between two notifications for the same group. Default is 5 minutes.
     */
    groupInterval?: string;
    /**
     * Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.
     */
    groupWait?: string;
    /**
     * Describes which labels this rule should match. When multiple matchers are supplied, an alert must match ALL matchers to be accepted by this policy. When no matchers are supplied, the rule will match all alert instances.
     */
    matchers?: outputs.NotificationPolicyPolicyPolicyPolicyMatcher[];
    /**
     * A list of mute timing names to apply to alerts that match this policy.
     */
    muteTimings?: string[];
    /**
     * Routing rules for specific label sets.
     */
    policies?: outputs.NotificationPolicyPolicyPolicyPolicyPolicy[];
    /**
     * Minimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.
     */
    repeatInterval?: string;
}

export interface NotificationPolicyPolicyPolicyPolicyMatcher {
    /**
     * The name of the label to match against.
     */
    label: string;
    /**
     * The operator to apply when matching values of the given label. Allowed operators are `=` for equality, `!=` for negated equality, `=~` for regex equality, and `!~` for negated regex equality.
     */
    match: string;
    /**
     * The label value to match against.
     */
    value: string;
}

export interface NotificationPolicyPolicyPolicyPolicyPolicy {
    /**
     * The contact point to route notifications that match this rule to.
     */
    contactPoint?: string;
    /**
     * Whether to continue matching subsequent rules if an alert matches the current rule. Otherwise, the rule will be 'consumed' by the first policy to match it.
     */
    continue?: boolean;
    /**
     * A list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping. Required for root policy only. If empty, the parent grouping is used.
     */
    groupBies: string[];
    /**
     * Minimum time interval between two notifications for the same group. Default is 5 minutes.
     */
    groupInterval?: string;
    /**
     * Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.
     */
    groupWait?: string;
    /**
     * Describes which labels this rule should match. When multiple matchers are supplied, an alert must match ALL matchers to be accepted by this policy. When no matchers are supplied, the rule will match all alert instances.
     */
    matchers?: outputs.NotificationPolicyPolicyPolicyPolicyPolicyMatcher[];
    /**
     * A list of mute timing names to apply to alerts that match this policy.
     */
    muteTimings?: string[];
    /**
     * Minimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.
     */
    repeatInterval?: string;
}

export interface NotificationPolicyPolicyPolicyPolicyPolicyMatcher {
    /**
     * The name of the label to match against.
     */
    label: string;
    /**
     * The operator to apply when matching values of the given label. Allowed operators are `=` for equality, `!=` for negated equality, `=~` for regex equality, and `!~` for negated regex equality.
     */
    match: string;
    /**
     * The label value to match against.
     */
    value: string;
}

export interface OncallIntegrationDefaultRoute {
    /**
     * The ID of the escalation chain.
     */
    escalationChainId?: string;
    id: string;
    /**
     * MS teams-specific settings for a route.
     */
    msteams?: outputs.OncallIntegrationDefaultRouteMsteams;
    /**
     * Slack-specific settings for a route.
     */
    slack?: outputs.OncallIntegrationDefaultRouteSlack;
    /**
     * Telegram-specific settings for a route.
     */
    telegram?: outputs.OncallIntegrationDefaultRouteTelegram;
}

export interface OncallIntegrationDefaultRouteMsteams {
    /**
     * Enable notification in MS teams. Defaults to `true`.
     */
    enabled?: boolean;
    /**
     * MS teams channel id. Alerts will be directed to this channel in Microsoft teams.
     */
    id?: string;
}

export interface OncallIntegrationDefaultRouteSlack {
    /**
     * Slack channel id. Alerts will be directed to this channel in Slack.
     */
    channelId?: string;
    /**
     * Enable notification in Slack. Defaults to `true`.
     */
    enabled?: boolean;
}

export interface OncallIntegrationDefaultRouteTelegram {
    /**
     * Enable notification in Telegram. Defaults to `true`.
     */
    enabled?: boolean;
    /**
     * Telegram channel id. Alerts will be directed to this channel in Telegram.
     */
    id?: string;
}

export interface OncallIntegrationTemplates {
    /**
     * Template for sending a signal to acknowledge the Incident.
     */
    acknowledgeSignal?: string;
    /**
     * Templates for Email.
     */
    email?: outputs.OncallIntegrationTemplatesEmail;
    /**
     * Template for the key by which alerts are grouped.
     */
    groupingKey?: string;
    /**
     * Templates for Microsoft Teams.
     */
    microsoftTeams?: outputs.OncallIntegrationTemplatesMicrosoftTeams;
    /**
     * Templates for Phone Call.
     */
    phoneCall?: outputs.OncallIntegrationTemplatesPhoneCall;
    /**
     * Template for sending a signal to resolve the Incident.
     */
    resolveSignal?: string;
    /**
     * Templates for Slack.
     */
    slack?: outputs.OncallIntegrationTemplatesSlack;
    /**
     * Templates for SMS.
     */
    sms?: outputs.OncallIntegrationTemplatesSms;
    /**
     * Template for a source link.
     */
    sourceLink?: string;
    /**
     * Templates for Telegram.
     */
    telegram?: outputs.OncallIntegrationTemplatesTelegram;
    /**
     * Templates for Web.
     */
    web?: outputs.OncallIntegrationTemplatesWeb;
}

export interface OncallIntegrationTemplatesEmail {
    /**
     * Template for Alert message.
     */
    message?: string;
    /**
     * Template for Alert title.
     */
    title?: string;
}

export interface OncallIntegrationTemplatesMicrosoftTeams {
    /**
     * Template for Alert image url.
     */
    imageUrl?: string;
    /**
     * Template for Alert message.
     */
    message?: string;
    /**
     * Template for Alert title.
     */
    title?: string;
}

export interface OncallIntegrationTemplatesPhoneCall {
    /**
     * Template for Alert title.
     */
    title?: string;
}

export interface OncallIntegrationTemplatesSlack {
    /**
     * Template for Alert image url.
     */
    imageUrl?: string;
    /**
     * Template for Alert message.
     */
    message?: string;
    /**
     * Template for Alert title.
     */
    title?: string;
}

export interface OncallIntegrationTemplatesSms {
    /**
     * Template for Alert title.
     */
    title?: string;
}

export interface OncallIntegrationTemplatesTelegram {
    /**
     * Template for Alert image url.
     */
    imageUrl?: string;
    /**
     * Template for Alert message.
     */
    message?: string;
    /**
     * Template for Alert title.
     */
    title?: string;
}

export interface OncallIntegrationTemplatesWeb {
    /**
     * Template for Alert image url.
     */
    imageUrl?: string;
    /**
     * Template for Alert message.
     */
    message?: string;
    /**
     * Template for Alert title.
     */
    title?: string;
}

export interface OncallRouteMsteams {
    /**
     * Enable notification in MS teams. Defaults to `true`.
     */
    enabled?: boolean;
    /**
     * MS teams channel id. Alerts will be directed to this channel in Microsoft teams.
     */
    id?: string;
}

export interface OncallRouteSlack {
    /**
     * Slack channel id. Alerts will be directed to this channel in Slack.
     */
    channelId?: string;
    /**
     * Enable notification in Slack. Defaults to `true`.
     */
    enabled?: boolean;
}

export interface OncallRouteTelegram {
    /**
     * Enable notification in Telegram. Defaults to `true`.
     */
    enabled?: boolean;
    /**
     * Telegram channel id. Alerts will be directed to this channel in Telegram.
     */
    id?: string;
}

export interface OncallScheduleSlack {
    /**
     * Slack channel id. Reminder about schedule shifts will be directed to this channel in Slack.
     */
    channelId?: string;
    /**
     * Slack user group id. Members of user group will be updated when on-call users change.
     */
    userGroupId?: string;
}

export interface PlaylistItem {
    id: string;
    order: number;
    title: string;
    type?: string;
    value?: string;
}

export interface ReportDashboard {
    /**
     * Add report variables to the dashboard. Values should be separated by commas.
     */
    reportVariables?: {[key: string]: string};
    /**
     * Time range of the report.
     */
    timeRange?: outputs.ReportDashboardTimeRange;
    /**
     * Dashboard uid.
     */
    uid: string;
}

export interface ReportDashboardTimeRange {
    /**
     * Start of the time range.
     */
    from?: string;
    /**
     * End of the time range.
     */
    to?: string;
}

export interface ReportSchedule {
    /**
     * Custom interval of the report.
     * **Note:** This field is only available when frequency is set to `custom`.
     */
    customInterval?: string;
    /**
     * End time of the report. If empty, the report will be sent indefinitely (according to frequency). Note that times will be saved as UTC in Grafana. Use 2006-01-02T15:04:05 format if you want to set a custom timezone
     */
    endTime?: string;
    /**
     * Frequency of the report. Allowed values: `never`, `once`, `hourly`, `daily`, `weekly`, `monthly`, `custom`.
     */
    frequency: string;
    /**
     * Send the report on the last day of the month Defaults to `false`.
     */
    lastDayOfMonth?: boolean;
    /**
     * Start time of the report. If empty, the start date will be set to the creation time. Note that times will be saved as UTC in Grafana. Use 2006-01-02T15:04:05 format if you want to set a custom timezone
     */
    startTime?: string;
    /**
     * Set the report time zone. Defaults to `GMT`.
     */
    timezone?: string;
    /**
     * Whether to send the report only on work days. Defaults to `false`.
     */
    workdaysOnly?: boolean;
}

export interface RolePermission {
    /**
     * Specific action users granted with the role will be allowed to perform (for example: `users:read`)
     */
    action: string;
    /**
     * Scope to restrict the action to a set of resources (for example: `users:*` or `roles:customrole1`) Defaults to ``.
     */
    scope?: string;
}

export interface RuleGroupRule {
    /**
     * Key-value pairs of metadata to attach to the alert rule that may add user-defined context, but cannot be used for matching, grouping, or routing. Defaults to `map[]`.
     */
    annotations?: {[key: string]: string};
    /**
     * The `refId` of the query node in the `data` field to use as the alert condition.
     */
    condition: string;
    /**
     * A sequence of stages that describe the contents of the rule.
     */
    datas: outputs.RuleGroupRuleData[];
    /**
     * Describes what state to enter when the rule's query is invalid and the rule cannot be executed. Options are OK, Error, KeepLast, and Alerting. Defaults to `Alerting`.
     */
    execErrState?: string;
    /**
     * The amount of time for which the rule must be breached for the rule to be considered to be Firing. Before this time has elapsed, the rule is only considered to be Pending. Defaults to `0`.
     */
    for?: string;
    /**
     * Sets whether the alert should be paused or not. Defaults to `false`.
     */
    isPaused?: boolean;
    /**
     * Key-value pairs to attach to the alert rule that can be used in matching, grouping, and routing. Defaults to `map[]`.
     */
    labels?: {[key: string]: string};
    /**
     * The name of the alert rule.
     */
    name: string;
    /**
     * Describes what state to enter when the rule's query returns No Data. Options are OK, NoData, KeepLast, and Alerting. Defaults to `NoData`.
     */
    noDataState?: string;
    /**
     * Notification settings for the rule. If specified, it overrides the notification policies. Available since Grafana 10.4, requires feature flag 'alertingSimplifiedRouting' enabled.
     */
    notificationSettings?: outputs.RuleGroupRuleNotificationSettings;
    /**
     * The unique identifier of the alert rule.
     */
    uid: string;
}

export interface RuleGroupRuleData {
    /**
     * The UID of the datasource being queried, or "-100" if this stage is an expression stage.
     */
    datasourceUid: string;
    /**
     * Custom JSON data to send to the specified datasource when querying.
     */
    model: string;
    /**
     * An optional identifier for the type of query being executed. Defaults to ``.
     */
    queryType?: string;
    /**
     * A unique string to identify this query stage within a rule.
     */
    refId: string;
    /**
     * The time range, relative to when the query is executed, across which to query.
     */
    relativeTimeRange: outputs.RuleGroupRuleDataRelativeTimeRange;
}

export interface RuleGroupRuleDataRelativeTimeRange {
    /**
     * The number of seconds in the past, relative to when the rule is evaluated, at which the time range begins.
     */
    from: number;
    /**
     * The number of seconds in the past, relative to when the rule is evaluated, at which the time range ends.
     */
    to: number;
}

export interface RuleGroupRuleNotificationSettings {
    /**
     * The contact point to route notifications that match this rule to.
     */
    contactPoint: string;
    /**
     * A list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping. If empty, no grouping is used. If specified, requires labels 'alertname' and 'grafana_folder' to be included.
     */
    groupBies?: string[];
    /**
     * Minimum time interval between two notifications for the same group. Default is 5 minutes.
     */
    groupInterval?: string;
    /**
     * Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.
     */
    groupWait?: string;
    /**
     * A list of mute timing names to apply to alerts that match this policy.
     */
    muteTimings?: string[];
    /**
     * Minimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.
     */
    repeatInterval?: string;
}

export interface SLOAlerting {
    /**
     * Advanced Options for Alert Rules
     */
    advancedOptions?: outputs.SLOAlertingAdvancedOptions;
    /**
     * Annotations will be attached to all alerts generated by any of these rules.
     */
    annotations?: outputs.SLOAlertingAnnotation[];
    /**
     * Alerting Rules generated for Fast Burn alerts
     */
    fastburns?: outputs.SLOAlertingFastburn[];
    /**
     * Labels will be attached to all alerts generated by any of these rules.
     */
    labels?: outputs.SLOAlertingLabel[];
    /**
     * Alerting Rules generated for Slow Burn alerts
     */
    slowburns?: outputs.SLOAlertingSlowburn[];
}

export interface SLOAlertingAdvancedOptions {
    /**
     * Minimum number of failed events to trigger an alert
     */
    minFailures?: number;
}

export interface SLOAlertingAnnotation {
    key: string;
    value: string;
}

export interface SLOAlertingFastburn {
    /**
     * Annotations to attach only to Fast Burn alerts.
     */
    annotations?: outputs.SLOAlertingFastburnAnnotation[];
    /**
     * Labels to attach only to Fast Burn alerts.
     */
    labels?: outputs.SLOAlertingFastburnLabel[];
}

export interface SLOAlertingFastburnAnnotation {
    key: string;
    value: string;
}

export interface SLOAlertingFastburnLabel {
    key: string;
    value: string;
}

export interface SLOAlertingLabel {
    key: string;
    value: string;
}

export interface SLOAlertingSlowburn {
    /**
     * Annotations to attach only to Slow Burn alerts.
     */
    annotations?: outputs.SLOAlertingSlowburnAnnotation[];
    /**
     * Labels to attach only to Slow Burn alerts.
     */
    labels?: outputs.SLOAlertingSlowburnLabel[];
}

export interface SLOAlertingSlowburnAnnotation {
    key: string;
    value: string;
}

export interface SLOAlertingSlowburnLabel {
    key: string;
    value: string;
}

export interface SLODestinationDatasource {
    /**
     * UID for the Mimir Datasource
     */
    uid?: string;
}

export interface SLOLabel {
    key: string;
    value: string;
}

export interface SLOObjective {
    /**
     * Value between 0 and 1. If the value of the query is above the objective, the SLO is met.
     */
    value: number;
    /**
     * A Prometheus-parsable time duration string like 24h, 60m. This is the time window the objective is measured over.
     */
    window: string;
}

export interface SLOQuery {
    freeform?: outputs.SLOQueryFreeform;
    ratio?: outputs.SLOQueryRatio;
    /**
     * Query type must be one of: "freeform", "query", "ratio", or "threshold"
     */
    type: string;
}

export interface SLOQueryFreeform {
    /**
     * Freeform Query Field
     */
    query: string;
}

export interface SLOQueryRatio {
    /**
     * Defines Group By Labels used for per-label alerting. These appear as variables on SLO dashboards to enable filtering and aggregation. Labels must adhere to Prometheus label name schema - "^[a-zA-Z*][a-zA-Z0-9*]*$"
     */
    groupByLabels?: string[];
    /**
     * Counter metric for success events (numerator)
     */
    successMetric: string;
    /**
     * Metric for total events (denominator)
     */
    totalMetric: string;
}

export interface ServiceAccountPermissionPermission {
    /**
     * Permission to associate with item. Must be one of `View`, `Edit`, or `Admin`.
     */
    permission: string;
    /**
     * ID of the team to manage permissions for. Defaults to `0`.
     */
    teamId?: string;
    /**
     * ID of the user or service account to manage permissions for. Defaults to `0`.
     */
    userId?: string;
}

export interface SsoSettingsOauth2Settings {
    /**
     * If enabled, it will automatically sync the Grafana server administrator role.
     */
    allowAssignGrafanaAdmin?: boolean;
    /**
     * If not enabled, only existing Grafana users can log in using OAuth.
     */
    allowSignUp?: boolean;
    /**
     * List of comma- or space-separated domains. The user should belong to at least one domain to log in.
     */
    allowedDomains?: string;
    /**
     * List of comma- or space-separated groups. The user should be a member of at least one group to log in. For Generic OAuth, if you configure allowed*groups, you must also configure groups*attribute_path.
     */
    allowedGroups?: string;
    /**
     * List of comma- or space-separated organizations. The user should be a member of at least one organization to log in.
     */
    allowedOrganizations?: string;
    /**
     * The user information endpoint of your OAuth2 provider. Required for okta and genericOauth providers.
     */
    apiUrl?: string;
    /**
     * It determines how client*id and client*secret are sent to Oauth2 provider. Possible values are AutoDetect, InParams, InHeader. Default is AutoDetect.
     */
    authStyle?: string;
    /**
     * The authorization endpoint of your OAuth2 provider. Required for azuread, okta and genericOauth providers.
     */
    authUrl?: string;
    /**
     * Log in automatically, skipping the login screen.
     */
    autoLogin?: boolean;
    /**
     * The client Id of your OAuth2 app.
     */
    clientId: string;
    /**
     * The client secret of your OAuth2 app.
     */
    clientSecret?: string;
    /**
     * Custom fields to configure for OAuth2 such as the [force*use*graph_api](https://grafana.com/docs/grafana/latest/setup-grafana/configure-security/configure-authentication/azuread/#force-fetching-groups-from-microsoft-graph-api) field.
     */
    custom?: {[key: string]: string};
    /**
     * Define allowed groups.
     */
    defineAllowedGroups?: boolean;
    /**
     * Define allowed teams ids.
     */
    defineAllowedTeamsIds?: boolean;
    /**
     * Name of the key to use for user email lookup within the attributes map of OAuth2 ID token. Only applicable to Generic OAuth.
     */
    emailAttributeName?: string;
    /**
     * JMESPath expression to use for user email lookup from the user information. Only applicable to Generic OAuth.
     */
    emailAttributePath?: string;
    /**
     * If enabled, no scopes will be sent to the OAuth2 provider.
     */
    emptyScopes?: boolean;
    /**
     * Define whether this configuration is enabled for the specified provider. Defaults to `true`.
     */
    enabled?: boolean;
    /**
     * JMESPath expression to use for user group lookup. If you configure allowed*groups, you must also configure groups*attribute_path.
     */
    groupsAttributePath?: string;
    /**
     * The name of the key used to extract the ID token from the returned OAuth2 token. Only applicable to Generic OAuth.
     */
    idTokenAttributeName?: string;
    /**
     * JMESPath expression to use for user login lookup from the user ID token. Only applicable to Generic OAuth.
     */
    loginAttributePath?: string;
    /**
     * Helpful if you use more than one identity providers or SSO protocols.
     */
    name?: string;
    /**
     * JMESPath expression to use for user name lookup from the user ID token. This name will be used as the user’s display name. Only applicable to Generic OAuth.
     */
    nameAttributePath?: string;
    /**
     * JMESPath expression to use for Grafana role lookup.
     */
    roleAttributePath?: string;
    /**
     * If enabled, denies user login if the Grafana role cannot be extracted using Role attribute path.
     */
    roleAttributeStrict?: boolean;
    /**
     * List of comma- or space-separated OAuth2 scopes.
     */
    scopes?: string;
    /**
     * The URL to redirect the user to after signing out from Grafana.
     */
    signoutRedirectUrl?: string;
    /**
     * Prevent synchronizing users’ organization roles from your IdP.
     */
    skipOrgRoleSync?: boolean;
    /**
     * String list of Team Ids. If set, the user must be a member of one of the given teams to log in. If you configure team*ids, you must also configure teams*url and team*ids*attribute_path.
     */
    teamIds?: string;
    /**
     * The JMESPath expression to use for Grafana Team Id lookup within the results returned by the teamsUrl endpoint. Only applicable to Generic OAuth.
     */
    teamIdsAttributePath?: string;
    /**
     * The URL used to query for Team Ids. If not set, the default value is /teams. If you configure teams*url, you must also configure team*ids*attribute*path. Only applicable to Generic OAuth.
     */
    teamsUrl?: string;
    /**
     * The path to the trusted certificate authority list. Is not applicable on Grafana Cloud.
     */
    tlsClientCa?: string;
    /**
     * The path to the certificate. Is not applicable on Grafana Cloud.
     */
    tlsClientCert?: string;
    /**
     * The path to the key. Is not applicable on Grafana Cloud.
     */
    tlsClientKey?: string;
    /**
     * If enabled, the client accepts any certificate presented by the server and any host name in that certificate. You should only use this for testing, because this mode leaves SSL/TLS susceptible to man-in-the-middle attacks.
     */
    tlsSkipVerifyInsecure?: boolean;
    /**
     * The token endpoint of your OAuth2 provider. Required for azuread, okta and genericOauth providers.
     */
    tokenUrl?: string;
    /**
     * If enabled, Grafana will use Proof Key for Code Exchange (PKCE) with the OAuth2 Authorization Code Grant.
     */
    usePkce?: boolean;
    /**
     * If enabled, Grafana will fetch a new access token using the refresh token provided by the OAuth2 provider.
     */
    useRefreshToken?: boolean;
}

export interface SsoSettingsSamlSettings {
    /**
     * Whether SAML IdP-initiated login is allowed.
     */
    allowIdpInitiated?: boolean;
    /**
     * Whether to allow new Grafana user creation through SAML login. If set to false, then only existing Grafana users can log in with SAML.
     */
    allowSignUp?: boolean;
    /**
     * List of comma- or space-separated organizations. User should be a member of at least one organization to log in.
     */
    allowedOrganizations?: string;
    /**
     * Friendly name or name of the attribute within the SAML assertion to use as the user email.
     */
    assertionAttributeEmail?: string;
    /**
     * Friendly name or name of the attribute within the SAML assertion to use as the user groups.
     */
    assertionAttributeGroups?: string;
    /**
     * Friendly name or name of the attribute within the SAML assertion to use as the user login handle.
     */
    assertionAttributeLogin?: string;
    /**
     * Friendly name or name of the attribute within the SAML assertion to use as the user name. Alternatively, this can be a template with variables that match the names of attributes within the SAML assertion.
     */
    assertionAttributeName?: string;
    /**
     * Friendly name or name of the attribute within the SAML assertion to use as the user organization.
     */
    assertionAttributeOrg?: string;
    /**
     * Friendly name or name of the attribute within the SAML assertion to use as the user roles.
     */
    assertionAttributeRole?: string;
    /**
     * Whether SAML auto login is enabled.
     */
    autoLogin?: boolean;
    /**
     * Base64-encoded string for the SP X.509 certificate.
     */
    certificate?: string;
    /**
     * Path for the SP X.509 certificate.
     */
    certificatePath?: string;
    /**
     * Define whether this configuration is enabled for SAML. Defaults to `true`.
     */
    enabled?: boolean;
    /**
     * Base64-encoded string for the IdP SAML metadata XML.
     */
    idpMetadata?: string;
    /**
     * Path for the IdP SAML metadata XML.
     */
    idpMetadataPath?: string;
    /**
     * URL for the IdP SAML metadata XML.
     */
    idpMetadataUrl?: string;
    /**
     * Duration, since the IdP issued a response and the SP is allowed to process it. For example: 90s, 1h.
     */
    maxIssueDelay?: string;
    /**
     * Duration, for how long the SP metadata is valid. For example: 48h, 5d.
     */
    metadataValidDuration?: string;
    /**
     * Name used to refer to the SAML authentication.
     */
    name?: string;
    /**
     * The Name ID Format to request within the SAML assertion. Defaults to urn:oasis:names:tc:SAML:2.0:nameid-format:transient
     */
    nameIdFormat?: string;
    /**
     * List of comma- or space-separated Organization:OrgId:Role mappings. Organization can be * meaning “All users”. Role is optional and can have the following values: Viewer, Editor or Admin.
     */
    orgMapping?: string;
    /**
     * Base64-encoded string for the SP private key.
     */
    privateKey?: string;
    /**
     * Path for the SP private key.
     */
    privateKeyPath?: string;
    /**
     * Relay state for IdP-initiated login. Should match relay state configured in IdP.
     */
    relayState?: string;
    /**
     * List of comma- or space-separated roles which will be mapped into the Admin role.
     */
    roleValuesAdmin?: string;
    /**
     * List of comma- or space-separated roles which will be mapped into the Editor role.
     */
    roleValuesEditor?: string;
    /**
     * List of comma- or space-separated roles which will be mapped into the Grafana Admin (Super Admin) role.
     */
    roleValuesGrafanaAdmin?: string;
    /**
     * List of comma- or space-separated roles which will be mapped into the None role.
     */
    roleValuesNone?: string;
    /**
     * List of comma- or space-separated roles which will be mapped into the Viewer role.
     */
    roleValuesViewer?: string;
    /**
     * Signature algorithm used for signing requests to the IdP. Supported values are rsa-sha1, rsa-sha256, rsa-sha512.
     */
    signatureAlgorithm?: string;
    /**
     * Whether SAML Single Logout is enabled.
     */
    singleLogout?: boolean;
    /**
     * Prevent synchronizing users’ organization roles from your IdP.
     */
    skipOrgRoleSync?: boolean;
}

export interface SyntheticMonitoringCheckSettings {
    /**
     * Settings for DNS check. The target must be a valid hostname (or IP address for `PTR` records).
     */
    dns?: outputs.SyntheticMonitoringCheckSettingsDns;
    /**
     * Settings for gRPC Health check. The target must be of the form `<host>:<port>`, where the host portion must be a valid hostname or IP address.
     */
    grpc?: outputs.SyntheticMonitoringCheckSettingsGrpc;
    /**
     * Settings for HTTP check. The target must be a URL (http or https).
     */
    http?: outputs.SyntheticMonitoringCheckSettingsHttp;
    /**
     * Settings for MultiHTTP check. The target must be a URL (http or https)
     */
    multihttp?: outputs.SyntheticMonitoringCheckSettingsMultihttp;
    /**
     * Settings for ping (ICMP) check. The target must be a valid hostname or IP address.
     */
    ping?: outputs.SyntheticMonitoringCheckSettingsPing;
    /**
     * Settings for scripted check. See https://grafana.com/docs/grafana-cloud/testing/synthetic-monitoring/create-checks/checks/k6/.
     */
    scripted?: outputs.SyntheticMonitoringCheckSettingsScripted;
    /**
     * Settings for TCP check. The target must be of the form `<host>:<port>`, where the host portion must be a valid hostname or IP address.
     */
    tcp?: outputs.SyntheticMonitoringCheckSettingsTcp;
    /**
     * Settings for traceroute check. The target must be a valid hostname or IP address
     */
    traceroute?: outputs.SyntheticMonitoringCheckSettingsTraceroute;
}

export interface SyntheticMonitoringCheckSettingsDns {
    /**
     * Options are `V4`, `V6`, `Any`. Specifies whether the corresponding check will be performed using IPv4 or IPv6. The `Any` value indicates that IPv6 should be used, falling back to IPv4 if that's not available. Defaults to `V4`.
     */
    ipVersion?: string;
    /**
     * Port to target. Defaults to `53`.
     */
    port?: number;
    /**
     * `TCP` or `UDP`. Defaults to `UDP`.
     */
    protocol?: string;
    /**
     * One of `ANY`, `A`, `AAAA`, `CNAME`, `MX`, `NS`, `PTR`, `SOA`, `SRV`, `TXT`. Defaults to `A`.
     */
    recordType?: string;
    /**
     * DNS server address to target. Defaults to `8.8.8.8`.
     */
    server?: string;
    /**
     * Source IP address.
     */
    sourceIpAddress?: string;
    /**
     * List of valid response codes. Options include `NOERROR`, `BADALG`, `BADMODE`, `BADKEY`, `BADCOOKIE`, `BADNAME`, `BADSIG`, `BADTIME`, `BADTRUNC`, `BADVERS`, `FORMERR`, `NOTIMP`, `NOTAUTH`, `NOTZONE`, `NXDOMAIN`, `NXRRSET`, `REFUSED`, `SERVFAIL`, `YXDOMAIN`, `YXRRSET`.
     */
    validRCodes?: string[];
    /**
     * Validate additional matches.
     */
    validateAdditionalRrs?: outputs.SyntheticMonitoringCheckSettingsDnsValidateAdditionalRr[];
    /**
     * Validate response answer.
     */
    validateAnswerRrs?: outputs.SyntheticMonitoringCheckSettingsDnsValidateAnswerRrs;
    /**
     * Validate response authority.
     */
    validateAuthorityRrs?: outputs.SyntheticMonitoringCheckSettingsDnsValidateAuthorityRrs;
}

export interface SyntheticMonitoringCheckSettingsDnsValidateAdditionalRr {
    /**
     * Fail if value matches regex.
     */
    failIfMatchesRegexps?: string[];
    /**
     * Fail if value does not match regex.
     */
    failIfNotMatchesRegexps?: string[];
}

export interface SyntheticMonitoringCheckSettingsDnsValidateAnswerRrs {
    /**
     * Fail if value matches regex.
     */
    failIfMatchesRegexps?: string[];
    /**
     * Fail if value does not match regex.
     */
    failIfNotMatchesRegexps?: string[];
}

export interface SyntheticMonitoringCheckSettingsDnsValidateAuthorityRrs {
    /**
     * Fail if value matches regex.
     */
    failIfMatchesRegexps?: string[];
    /**
     * Fail if value does not match regex.
     */
    failIfNotMatchesRegexps?: string[];
}

export interface SyntheticMonitoringCheckSettingsGrpc {
    /**
     * Options are `V4`, `V6`, `Any`. Specifies whether the corresponding check will be performed using IPv4 or IPv6. The `Any` value indicates that IPv6 should be used, falling back to IPv4 if that's not available. Defaults to `V4`.
     */
    ipVersion?: string;
    /**
     * gRPC service.
     */
    service?: string;
    /**
     * Whether or not TLS is used when the connection is initiated. Defaults to `false`.
     */
    tls?: boolean;
    /**
     * TLS config.
     */
    tlsConfig?: outputs.SyntheticMonitoringCheckSettingsGrpcTlsConfig;
}

export interface SyntheticMonitoringCheckSettingsGrpcTlsConfig {
    /**
     * CA certificate in PEM format.
     */
    caCert?: string;
    /**
     * Client certificate in PEM format.
     */
    clientCert?: string;
    /**
     * Client key in PEM format.
     */
    clientKey?: string;
    /**
     * Disable target certificate validation. Defaults to `false`.
     */
    insecureSkipVerify?: boolean;
    /**
     * Used to verify the hostname for the targets.
     */
    serverName?: string;
}

export interface SyntheticMonitoringCheckSettingsHttp {
    /**
     * Basic auth settings.
     */
    basicAuth?: outputs.SyntheticMonitoringCheckSettingsHttpBasicAuth;
    /**
     * Token for use with bearer authorization header.
     */
    bearerToken?: string;
    /**
     * The body of the HTTP request used in probe.
     */
    body?: string;
    /**
     * The name of the query parameter used to prevent the server from using a cached response. Each probe will assign a random value to this parameter each time a request is made.
     */
    cacheBustingQueryParamName?: string;
    /**
     * List of regexes. If any match the response body, the check will fail.
     */
    failIfBodyMatchesRegexps?: string[];
    /**
     * List of regexes. If any do not match the response body, the check will fail.
     */
    failIfBodyNotMatchesRegexps?: string[];
    /**
     * Check fails if headers match.
     */
    failIfHeaderMatchesRegexps?: outputs.SyntheticMonitoringCheckSettingsHttpFailIfHeaderMatchesRegexp[];
    /**
     * Check fails if headers do not match.
     */
    failIfHeaderNotMatchesRegexps?: outputs.SyntheticMonitoringCheckSettingsHttpFailIfHeaderNotMatchesRegexp[];
    /**
     * Fail if SSL is not present. Defaults to `false`.
     */
    failIfNotSsl?: boolean;
    /**
     * Fail if SSL is present. Defaults to `false`.
     */
    failIfSsl?: boolean;
    /**
     * The HTTP headers set for the probe.
     */
    headers?: string[];
    /**
     * Options are `V4`, `V6`, `Any`. Specifies whether the corresponding check will be performed using IPv4 or IPv6. The `Any` value indicates that IPv6 should be used, falling back to IPv4 if that's not available. Defaults to `V4`.
     */
    ipVersion?: string;
    /**
     * Request method. One of `GET`, `CONNECT`, `DELETE`, `HEAD`, `OPTIONS`, `POST`, `PUT`, `TRACE` Defaults to `GET`.
     */
    method?: string;
    /**
     * Do not follow redirects. Defaults to `false`.
     */
    noFollowRedirects?: boolean;
    /**
     * The HTTP headers sent to the proxy URL
     */
    proxyConnectHeaders?: string[];
    /**
     * Proxy URL.
     */
    proxyUrl?: string;
    /**
     * TLS config.
     */
    tlsConfig?: outputs.SyntheticMonitoringCheckSettingsHttpTlsConfig;
    /**
     * List of valid HTTP versions. Options include `HTTP/1.0`, `HTTP/1.1`, `HTTP/2.0`
     */
    validHttpVersions?: string[];
    /**
     * Accepted status codes. If unset, defaults to 2xx.
     */
    validStatusCodes?: number[];
}

export interface SyntheticMonitoringCheckSettingsHttpBasicAuth {
    /**
     * Basic auth password.
     */
    password: string;
    /**
     * Basic auth username.
     */
    username: string;
}

export interface SyntheticMonitoringCheckSettingsHttpFailIfHeaderMatchesRegexp {
    /**
     * Allow header to be missing from responses. Defaults to `false`.
     */
    allowMissing?: boolean;
    /**
     * Header name.
     */
    header: string;
    /**
     * Regex that header value should match.
     */
    regexp: string;
}

export interface SyntheticMonitoringCheckSettingsHttpFailIfHeaderNotMatchesRegexp {
    /**
     * Allow header to be missing from responses. Defaults to `false`.
     */
    allowMissing?: boolean;
    /**
     * Header name.
     */
    header: string;
    /**
     * Regex that header value should match.
     */
    regexp: string;
}

export interface SyntheticMonitoringCheckSettingsHttpTlsConfig {
    /**
     * CA certificate in PEM format.
     */
    caCert?: string;
    /**
     * Client certificate in PEM format.
     */
    clientCert?: string;
    /**
     * Client key in PEM format.
     */
    clientKey?: string;
    /**
     * Disable target certificate validation. Defaults to `false`.
     */
    insecureSkipVerify?: boolean;
    /**
     * Used to verify the hostname for the targets.
     */
    serverName?: string;
}

export interface SyntheticMonitoringCheckSettingsMultihttp {
    entries?: outputs.SyntheticMonitoringCheckSettingsMultihttpEntry[];
}

export interface SyntheticMonitoringCheckSettingsMultihttpEntry {
    /**
     * Assertions to make on the request response
     */
    assertions?: outputs.SyntheticMonitoringCheckSettingsMultihttpEntryAssertion[];
    /**
     * An individual MultiHTTP request
     */
    request?: outputs.SyntheticMonitoringCheckSettingsMultihttpEntryRequest;
    /**
     * Variables to extract from the request response
     */
    variables?: outputs.SyntheticMonitoringCheckSettingsMultihttpEntryVariable[];
}

export interface SyntheticMonitoringCheckSettingsMultihttpEntryAssertion {
    /**
     * The condition of the assertion: NOT*CONTAINS, EQUALS, STARTS*WITH, ENDS*WITH, TYPE*OF, CONTAINS
     */
    condition?: string;
    /**
     * The expression of the assertion. Should start with $.
     */
    expression?: string;
    /**
     * The subject of the assertion: RESPONSE*HEADERS, HTTP*STATUS*CODE, RESPONSE*BODY
     */
    subject?: string;
    /**
     * The type of assertion to make: TEXT, JSON*PATH*VALUE, JSON*PATH*ASSERTION, REGEX_ASSERTION
     */
    type: string;
    /**
     * The value of the assertion
     */
    value?: string;
}

export interface SyntheticMonitoringCheckSettingsMultihttpEntryRequest {
    /**
     * The body of the HTTP request used in probe.
     */
    bodies?: outputs.SyntheticMonitoringCheckSettingsMultihttpEntryRequestBody[];
    /**
     * The headers to send with the request
     */
    headers?: outputs.SyntheticMonitoringCheckSettingsMultihttpEntryRequestHeader[];
    /**
     * The HTTP method to use
     */
    method: string;
    /**
     * Query fields to send with the request
     */
    queryFields?: outputs.SyntheticMonitoringCheckSettingsMultihttpEntryRequestQueryField[];
    /**
     * The URL for the request
     */
    url: string;
}

export interface SyntheticMonitoringCheckSettingsMultihttpEntryRequestBody {
    /**
     * The content encoding of the body
     */
    contentEncoding?: string;
    /**
     * The content type of the body
     */
    contentType?: string;
    /**
     * The body payload
     */
    payload?: string;
}

export interface SyntheticMonitoringCheckSettingsMultihttpEntryRequestHeader {
    /**
     * Name of the header to send
     */
    name: string;
    /**
     * Value of the header to send
     */
    value: string;
}

export interface SyntheticMonitoringCheckSettingsMultihttpEntryRequestQueryField {
    /**
     * Name of the query field to send
     */
    name: string;
    /**
     * Value of the query field to send
     */
    value: string;
}

export interface SyntheticMonitoringCheckSettingsMultihttpEntryVariable {
    /**
     * The attribute to use when finding the variable value. Only used when type is CSS_SELECTOR
     */
    attribute?: string;
    /**
     * The expression to when finding the variable. Should start with $. Only use when type is JSON_PATH or REGEX
     */
    expression?: string;
    /**
     * The name of the variable to extract
     */
    name?: string;
    /**
     * The method of finding the variable value to extract. JSON*PATH, REGEX, CSS*SELECTOR
     */
    type: string;
}

export interface SyntheticMonitoringCheckSettingsPing {
    /**
     * Set the DF-bit in the IP-header. Only works with ipV4. Defaults to `false`.
     */
    dontFragment?: boolean;
    /**
     * Options are `V4`, `V6`, `Any`. Specifies whether the corresponding check will be performed using IPv4 or IPv6. The `Any` value indicates that IPv6 should be used, falling back to IPv4 if that's not available. Defaults to `V4`.
     */
    ipVersion?: string;
    /**
     * Payload size. Defaults to `0`.
     */
    payloadSize?: number;
    /**
     * Source IP address.
     */
    sourceIpAddress?: string;
}

export interface SyntheticMonitoringCheckSettingsScripted {
    script: string;
}

export interface SyntheticMonitoringCheckSettingsTcp {
    /**
     * Options are `V4`, `V6`, `Any`. Specifies whether the corresponding check will be performed using IPv4 or IPv6. The `Any` value indicates that IPv6 should be used, falling back to IPv4 if that's not available. Defaults to `V4`.
     */
    ipVersion?: string;
    /**
     * The query sent in the TCP probe and the expected associated response.
     */
    queryResponses?: outputs.SyntheticMonitoringCheckSettingsTcpQueryResponse[];
    /**
     * Source IP address.
     */
    sourceIpAddress?: string;
    /**
     * Whether or not TLS is used when the connection is initiated. Defaults to `false`.
     */
    tls?: boolean;
    /**
     * TLS config.
     */
    tlsConfig?: outputs.SyntheticMonitoringCheckSettingsTcpTlsConfig;
}

export interface SyntheticMonitoringCheckSettingsTcpQueryResponse {
    /**
     * Response to expect.
     */
    expect: string;
    /**
     * Data to send.
     */
    send: string;
    /**
     * Upgrade TCP connection to TLS. Defaults to `false`.
     */
    startTls?: boolean;
}

export interface SyntheticMonitoringCheckSettingsTcpTlsConfig {
    /**
     * CA certificate in PEM format.
     */
    caCert?: string;
    /**
     * Client certificate in PEM format.
     */
    clientCert?: string;
    /**
     * Client key in PEM format.
     */
    clientKey?: string;
    /**
     * Disable target certificate validation. Defaults to `false`.
     */
    insecureSkipVerify?: boolean;
    /**
     * Used to verify the hostname for the targets.
     */
    serverName?: string;
}

export interface SyntheticMonitoringCheckSettingsTraceroute {
    /**
     * Maximum TTL for the trace Defaults to `64`.
     */
    maxHops?: number;
    /**
     * Maximum number of hosts to travers that give no response Defaults to `15`.
     */
    maxUnknownHops?: number;
    /**
     * Reverse lookup hostnames from IP addresses Defaults to `true`.
     */
    ptrLookup?: boolean;
}

export interface TeamPreferences {
    /**
     * The UID of the dashboard to display when a team member logs in.
     */
    homeDashboardUid?: string;
    /**
     * The default theme for this team. Available themes are `light`, `dark`, `system`, or an empty string for the default theme.
     */
    theme?: string;
    /**
     * The default timezone for this team. Available values are `utc`, `browser`, or an empty string for the default.
     */
    timezone?: string;
    /**
     * The default week start day for this team. Available values are `sunday`, `monday`, `saturday`, or an empty string for the default.
     */
    weekStart?: string;
}

export interface TeamTeamSync {
    groups?: string[];
}

export namespace alerting {
    export interface ContactPointAlertmanager {
        /**
         * The password component of the basic auth credentials to use.
         */
        basicAuthPassword?: string;
        /**
         * The username component of the basic auth credentials to use.
         */
        basicAuthUser?: string;
        /**
         * Whether to disable sending resolve messages. Defaults to `false`.
         */
        disableResolveMessage?: boolean;
        /**
         * Additional custom properties to attach to the notifier. Defaults to `map[]`.
         */
        settings?: {[key: string]: string};
        /**
         * The UID of the contact point.
         */
        uid: string;
        /**
         * The URL of the Alertmanager instance.
         */
        url: string;
    }

    export interface ContactPointDingding {
        /**
         * Whether to disable sending resolve messages. Defaults to `false`.
         */
        disableResolveMessage?: boolean;
        /**
         * The templated content of the message.
         */
        message?: string;
        /**
         * The format of message to send - either 'link' or 'actionCard'
         */
        messageType?: string;
        /**
         * Additional custom properties to attach to the notifier. Defaults to `map[]`.
         */
        settings?: {[key: string]: string};
        /**
         * The templated title of the message.
         */
        title?: string;
        /**
         * The UID of the contact point.
         */
        uid: string;
        /**
         * The DingDing webhook URL.
         */
        url: string;
    }

    export interface ContactPointDiscord {
        /**
         * The URL of a custom avatar image to use. Defaults to ``.
         */
        avatarUrl?: string;
        /**
         * Whether to disable sending resolve messages. Defaults to `false`.
         */
        disableResolveMessage?: boolean;
        /**
         * The templated content of the message. Defaults to ``.
         */
        message?: string;
        /**
         * Additional custom properties to attach to the notifier. Defaults to `map[]`.
         */
        settings?: {[key: string]: string};
        /**
         * The templated content of the title.
         */
        title?: string;
        /**
         * The UID of the contact point.
         */
        uid: string;
        /**
         * The discord webhook URL.
         */
        url: string;
        /**
         * Whether to use the bot account's plain username instead of "Grafana." Defaults to `false`.
         */
        useDiscordUsername?: boolean;
    }

    export interface ContactPointEmail {
        /**
         * The addresses to send emails to.
         */
        addresses: string[];
        /**
         * Whether to disable sending resolve messages. Defaults to `false`.
         */
        disableResolveMessage?: boolean;
        /**
         * The templated content of the email. Defaults to ``.
         */
        message?: string;
        /**
         * Additional custom properties to attach to the notifier. Defaults to `map[]`.
         */
        settings?: {[key: string]: string};
        /**
         * Whether to send a single email CC'ing all addresses, rather than a separate email to each address. Defaults to `false`.
         */
        singleEmail?: boolean;
        /**
         * The templated subject line of the email. Defaults to ``.
         */
        subject?: string;
        /**
         * The UID of the contact point.
         */
        uid: string;
    }

    export interface ContactPointGooglechat {
        /**
         * Whether to disable sending resolve messages. Defaults to `false`.
         */
        disableResolveMessage?: boolean;
        /**
         * The templated content of the message.
         */
        message?: string;
        /**
         * Additional custom properties to attach to the notifier. Defaults to `map[]`.
         */
        settings?: {[key: string]: string};
        /**
         * The templated content of the title.
         */
        title?: string;
        /**
         * The UID of the contact point.
         */
        uid: string;
        /**
         * The Google Chat webhook URL.
         */
        url: string;
    }

    export interface ContactPointKafka {
        /**
         * The API version to use when contacting the Kafka REST Server. Supported: v2 (default) and v3. Defaults to `v2`.
         */
        apiVersion?: string;
        /**
         * The Id of cluster to use when contacting the Kafka REST Server. Required apiVersion to be 'v3'
         */
        clusterId?: string;
        /**
         * The templated description of the Kafka message.
         */
        description?: string;
        /**
         * The templated details to include with the message.
         */
        details?: string;
        /**
         * Whether to disable sending resolve messages. Defaults to `false`.
         */
        disableResolveMessage?: boolean;
        /**
         * The password to use when making a call to the Kafka REST Proxy
         */
        password?: string;
        /**
         * The URL of the Kafka REST proxy to send requests to.
         */
        restProxyUrl: string;
        /**
         * Additional custom properties to attach to the notifier. Defaults to `map[]`.
         */
        settings?: {[key: string]: string};
        /**
         * The name of the Kafka topic to publish to.
         */
        topic: string;
        /**
         * The UID of the contact point.
         */
        uid: string;
        /**
         * The user name to use when making a call to the Kafka REST Proxy
         */
        username?: string;
    }

    export interface ContactPointLine {
        /**
         * The templated description of the message.
         */
        description?: string;
        /**
         * Whether to disable sending resolve messages. Defaults to `false`.
         */
        disableResolveMessage?: boolean;
        /**
         * Additional custom properties to attach to the notifier. Defaults to `map[]`.
         */
        settings?: {[key: string]: string};
        /**
         * The templated title of the message.
         */
        title?: string;
        /**
         * The bearer token used to authorize the client.
         */
        token: string;
        /**
         * The UID of the contact point.
         */
        uid: string;
    }

    export interface ContactPointOncall {
        /**
         * Allows a custom authorization scheme - attaches an auth header with this value. Do not use in conjunction with basic auth parameters.
         */
        authorizationCredentials?: string;
        /**
         * Allows a custom authorization scheme - attaches an auth header with this name. Do not use in conjunction with basic auth parameters.
         */
        authorizationScheme?: string;
        /**
         * The username to use in basic auth headers attached to the request. If omitted, basic auth will not be used.
         */
        basicAuthPassword?: string;
        /**
         * The username to use in basic auth headers attached to the request. If omitted, basic auth will not be used.
         */
        basicAuthUser?: string;
        /**
         * Whether to disable sending resolve messages. Defaults to `false`.
         */
        disableResolveMessage?: boolean;
        /**
         * The HTTP method to use in the request. Defaults to `POST`.
         */
        httpMethod?: string;
        /**
         * The maximum number of alerts to send in a single request. This can be helpful in limiting the size of the request body. The default is 0, which indicates no limit.
         */
        maxAlerts?: number;
        /**
         * Custom message. You can use template variables.
         */
        message?: string;
        /**
         * Additional custom properties to attach to the notifier. Defaults to `map[]`.
         */
        settings?: {[key: string]: string};
        /**
         * Templated title of the message.
         */
        title?: string;
        /**
         * The UID of the contact point.
         */
        uid: string;
        /**
         * The URL to send webhook requests to.
         */
        url: string;
    }

    export interface ContactPointOpsgeny {
        /**
         * The OpsGenie API key to use.
         */
        apiKey: string;
        /**
         * Whether to auto-close alerts in OpsGenie when they resolve in the Alertmanager.
         */
        autoClose?: boolean;
        /**
         * A templated high-level description to use for the alert.
         */
        description?: string;
        /**
         * Whether to disable sending resolve messages. Defaults to `false`.
         */
        disableResolveMessage?: boolean;
        /**
         * The templated content of the message.
         */
        message?: string;
        /**
         * Whether to allow the alert priority to be configured via the value of the `ogPriority` annotation on the alert.
         */
        overridePriority?: boolean;
        /**
         * Teams, users, escalations and schedules that the alert will be routed to send notifications. If the API Key belongs to a team integration, this field will be overwritten with the owner team. This feature is available from Grafana 10.3+.
         */
        responders?: outputs.alerting.ContactPointOpsgenyResponder[];
        /**
         * Whether to send annotations to OpsGenie as Tags, Details, or both. Supported values are `tags`, `details`, `both`, or empty to use the default behavior of Tags.
         */
        sendTagsAs?: string;
        /**
         * Additional custom properties to attach to the notifier. Defaults to `map[]`.
         */
        settings?: {[key: string]: string};
        /**
         * The UID of the contact point.
         */
        uid: string;
        /**
         * Allows customization of the OpsGenie API URL.
         */
        url?: string;
    }

    export interface ContactPointOpsgenyResponder {
        /**
         * ID of the responder. Must be specified if name and username are empty.
         */
        id?: string;
        /**
         * Name of the responder. Must be specified if username and id are empty.
         */
        name?: string;
        /**
         * Type of the responder. Supported: team, teams, user, escalation, schedule or a template that is expanded to one of these values.
         */
        type: string;
        /**
         * User name of the responder. Must be specified if name and id are empty.
         */
        username?: string;
    }

    export interface ContactPointPagerduty {
        /**
         * The class or type of event, for example `ping failure`.
         */
        class?: string;
        /**
         * The name of the monitoring client that is triggering this event.
         */
        client?: string;
        /**
         * The URL of the monitoring client that is triggering this event.
         */
        clientUrl?: string;
        /**
         * The component being affected by the event.
         */
        component?: string;
        /**
         * A set of arbitrary key/value pairs that provide further detail about the incident.
         */
        details?: {[key: string]: string};
        /**
         * Whether to disable sending resolve messages. Defaults to `false`.
         */
        disableResolveMessage?: boolean;
        /**
         * The group to which the provided component belongs to.
         */
        group?: string;
        /**
         * The PagerDuty API key.
         */
        integrationKey: string;
        /**
         * Additional custom properties to attach to the notifier. Defaults to `map[]`.
         */
        settings?: {[key: string]: string};
        /**
         * The PagerDuty event severity level. Default is `critical`.
         */
        severity?: string;
        /**
         * The unique location of the affected system.
         */
        source?: string;
        /**
         * The templated summary message of the event.
         */
        summary?: string;
        /**
         * The UID of the contact point.
         */
        uid: string;
        /**
         * The URL to send API requests to
         */
        url?: string;
    }

    export interface ContactPointPushover {
        /**
         * The Pushover API token.
         */
        apiToken: string;
        /**
         * Comma-separated list of devices to which the event is associated.
         */
        device?: string;
        /**
         * Whether to disable sending resolve messages. Defaults to `false`.
         */
        disableResolveMessage?: boolean;
        /**
         * How many seconds for which the notification will continue to be retried by Pushover.
         */
        expire?: number;
        /**
         * The templated notification message content.
         */
        message?: string;
        /**
         * The priority level of the resolved event.
         */
        okPriority?: number;
        /**
         * The sound associated with the resolved notification.
         */
        okSound?: string;
        /**
         * The priority level of the event.
         */
        priority?: number;
        /**
         * How often, in seconds, the Pushover servers will send the same notification to the user.
         */
        retry?: number;
        /**
         * Additional custom properties to attach to the notifier. Defaults to `map[]`.
         */
        settings?: {[key: string]: string};
        /**
         * The sound associated with the notification.
         */
        sound?: string;
        /**
         * The templated title of the message.
         */
        title?: string;
        /**
         * The UID of the contact point.
         */
        uid: string;
        /**
         * Whether to send images in the notification or not. Default is true. Requires Grafana to be configured to send images in notifications.
         */
        uploadImage?: boolean;
        /**
         * The Pushover user key.
         */
        userKey: string;
    }

    export interface ContactPointSensugo {
        /**
         * The SensuGo API key.
         */
        apiKey: string;
        /**
         * The SensuGo check to which the event should be routed.
         */
        check?: string;
        /**
         * Whether to disable sending resolve messages. Defaults to `false`.
         */
        disableResolveMessage?: boolean;
        /**
         * The entity being monitored.
         */
        entity?: string;
        /**
         * A custom handler to execute in addition to the check.
         */
        handler?: string;
        /**
         * Templated message content describing the alert.
         */
        message?: string;
        /**
         * The namespace in which the check resides.
         */
        namespace?: string;
        /**
         * Additional custom properties to attach to the notifier. Defaults to `map[]`.
         */
        settings?: {[key: string]: string};
        /**
         * The UID of the contact point.
         */
        uid: string;
        /**
         * The SensuGo URL to send requests to.
         */
        url: string;
    }

    export interface ContactPointSlack {
        /**
         * Whether to disable sending resolve messages. Defaults to `false`.
         */
        disableResolveMessage?: boolean;
        /**
         * Use this to override the Slack API endpoint URL to send requests to.
         */
        endpointUrl?: string;
        /**
         * The name of a Slack workspace emoji to use as the bot icon.
         */
        iconEmoji?: string;
        /**
         * A URL of an image to use as the bot icon.
         */
        iconUrl?: string;
        /**
         * Describes how to ping the slack channel that messages are being sent to. Options are `here` for an @here ping, `channel` for @channel, or empty for no ping.
         */
        mentionChannel?: string;
        /**
         * Comma-separated list of groups to mention in the message.
         */
        mentionGroups?: string;
        /**
         * Comma-separated list of users to mention in the message.
         */
        mentionUsers?: string;
        /**
         * Channel, private group, or IM channel (can be an encoded ID or a name) to send messages to.
         */
        recipient?: string;
        /**
         * Additional custom properties to attach to the notifier. Defaults to `map[]`.
         */
        settings?: {[key: string]: string};
        /**
         * Templated content of the message.
         */
        text?: string;
        /**
         * Templated title of the message.
         */
        title?: string;
        /**
         * A Slack API token,for sending messages directly without the webhook method.
         */
        token?: string;
        /**
         * The UID of the contact point.
         */
        uid: string;
        /**
         * A Slack webhook URL,for sending messages via the webhook method.
         */
        url?: string;
        /**
         * Username for the bot to use.
         */
        username?: string;
    }

    export interface ContactPointSn {
        /**
         * AWS access key ID used to authenticate with Amazon SNS.
         */
        accessKey?: string;
        /**
         * The Amazon Resource Name (ARN) of the role to assume to send notifications to Amazon SNS.
         */
        assumeRoleArn?: string;
        /**
         * The authentication provider to use. Valid values are `default`, `arn` and `keys`. Default is `default`. Defaults to `default`.
         */
        authProvider?: string;
        body?: string;
        /**
         * Whether to disable sending resolve messages. Defaults to `false`.
         */
        disableResolveMessage?: boolean;
        /**
         * The external ID to use when assuming the role.
         */
        externalId?: string;
        /**
         * The format of the message to send. Valid values are `text`, `body` and `json`. Default is `text`. Defaults to `text`.
         */
        messageFormat?: string;
        /**
         * AWS secret access key used to authenticate with Amazon SNS.
         */
        secretKey?: string;
        /**
         * Additional custom properties to attach to the notifier. Defaults to `map[]`.
         */
        settings?: {[key: string]: string};
        subject?: string;
        /**
         * The Amazon SNS topic to send notifications to.
         */
        topic: string;
        /**
         * The UID of the contact point.
         */
        uid: string;
    }

    export interface ContactPointTeam {
        /**
         * Whether to disable sending resolve messages. Defaults to `false`.
         */
        disableResolveMessage?: boolean;
        /**
         * The templated message content to send.
         */
        message?: string;
        /**
         * The templated subtitle for each message section.
         */
        sectionTitle?: string;
        /**
         * Additional custom properties to attach to the notifier. Defaults to `map[]`.
         */
        settings?: {[key: string]: string};
        /**
         * The templated title of the message.
         */
        title?: string;
        /**
         * The UID of the contact point.
         */
        uid: string;
        /**
         * A Teams webhook URL.
         */
        url: string;
    }

    export interface ContactPointTelegram {
        /**
         * The chat ID to send messages to.
         */
        chatId: string;
        /**
         * When set users will receive a notification with no sound.
         */
        disableNotifications?: boolean;
        /**
         * Whether to disable sending resolve messages. Defaults to `false`.
         */
        disableResolveMessage?: boolean;
        /**
         * When set it disables link previews for links in the message.
         */
        disableWebPagePreview?: boolean;
        /**
         * The templated content of the message.
         */
        message?: string;
        /**
         * The ID of the message thread to send the message to.
         */
        messageThreadId?: string;
        /**
         * Mode for parsing entities in the message text. Supported: None, Markdown, MarkdownV2, and HTML. HTML is the default.
         */
        parseMode?: string;
        /**
         * When set it protects the contents of the message from forwarding and saving.
         */
        protectContent?: boolean;
        /**
         * Additional custom properties to attach to the notifier. Defaults to `map[]`.
         */
        settings?: {[key: string]: string};
        /**
         * The Telegram bot token.
         */
        token: string;
        /**
         * The UID of the contact point.
         */
        uid: string;
    }

    export interface ContactPointThreema {
        /**
         * The Threema API key.
         */
        apiSecret: string;
        /**
         * The templated description of the message.
         */
        description?: string;
        /**
         * Whether to disable sending resolve messages. Defaults to `false`.
         */
        disableResolveMessage?: boolean;
        /**
         * The Threema gateway ID.
         */
        gatewayId: string;
        /**
         * The ID of the recipient of the message.
         */
        recipientId: string;
        /**
         * Additional custom properties to attach to the notifier. Defaults to `map[]`.
         */
        settings?: {[key: string]: string};
        /**
         * The templated title of the message.
         */
        title?: string;
        /**
         * The UID of the contact point.
         */
        uid: string;
    }

    export interface ContactPointVictorop {
        /**
         * Templated description of the message.
         */
        description?: string;
        /**
         * Whether to disable sending resolve messages. Defaults to `false`.
         */
        disableResolveMessage?: boolean;
        /**
         * The VictorOps alert state - typically either `CRITICAL` or `RECOVERY`.
         */
        messageType?: string;
        /**
         * Additional custom properties to attach to the notifier. Defaults to `map[]`.
         */
        settings?: {[key: string]: string};
        /**
         * Templated title to display.
         */
        title?: string;
        /**
         * The UID of the contact point.
         */
        uid: string;
        /**
         * The VictorOps webhook URL.
         */
        url: string;
    }

    export interface ContactPointWebex {
        /**
         * The URL to send webhook requests to.
         */
        apiUrl?: string;
        /**
         * Whether to disable sending resolve messages. Defaults to `false`.
         */
        disableResolveMessage?: boolean;
        /**
         * The templated title of the message to send.
         */
        message?: string;
        /**
         * ID of the Webex Teams room where to send the messages.
         */
        roomId?: string;
        /**
         * Additional custom properties to attach to the notifier. Defaults to `map[]`.
         */
        settings?: {[key: string]: string};
        /**
         * The bearer token used to authorize the client.
         */
        token?: string;
        /**
         * The UID of the contact point.
         */
        uid: string;
    }

    export interface ContactPointWebhook {
        /**
         * Allows a custom authorization scheme - attaches an auth header with this value. Do not use in conjunction with basic auth parameters.
         */
        authorizationCredentials?: string;
        /**
         * Allows a custom authorization scheme - attaches an auth header with this name. Do not use in conjunction with basic auth parameters.
         */
        authorizationScheme?: string;
        /**
         * The username to use in basic auth headers attached to the request. If omitted, basic auth will not be used.
         */
        basicAuthPassword?: string;
        /**
         * The username to use in basic auth headers attached to the request. If omitted, basic auth will not be used.
         */
        basicAuthUser?: string;
        /**
         * Whether to disable sending resolve messages. Defaults to `false`.
         */
        disableResolveMessage?: boolean;
        /**
         * The HTTP method to use in the request. Defaults to `POST`.
         */
        httpMethod?: string;
        /**
         * The maximum number of alerts to send in a single request. This can be helpful in limiting the size of the request body. The default is 0, which indicates no limit.
         */
        maxAlerts?: number;
        /**
         * Custom message. You can use template variables.
         */
        message?: string;
        /**
         * Additional custom properties to attach to the notifier. Defaults to `map[]`.
         */
        settings?: {[key: string]: string};
        /**
         * Templated title of the message.
         */
        title?: string;
        /**
         * The UID of the contact point.
         */
        uid: string;
        /**
         * The URL to send webhook requests to.
         */
        url: string;
    }

    export interface ContactPointWecom {
        /**
         * Agent ID added to the request payload when using APIAPP.
         */
        agentId?: string;
        /**
         * Corp ID used to get token when using APIAPP.
         */
        corpId?: string;
        /**
         * Whether to disable sending resolve messages. Defaults to `false`.
         */
        disableResolveMessage?: boolean;
        /**
         * The templated content of the message to send.
         */
        message?: string;
        /**
         * The type of them message. Supported: markdown, text. Default: text.
         */
        msgType?: string;
        /**
         * The secret key required to obtain access token when using APIAPP. See https://work.weixin.qq.com/wework_admin/frame#apps to create APIAPP.
         */
        secret?: string;
        /**
         * Additional custom properties to attach to the notifier. Defaults to `map[]`.
         */
        settings?: {[key: string]: string};
        /**
         * The templated title of the message to send.
         */
        title?: string;
        /**
         * The ID of user that should receive the message. Multiple entries should be separated by '|'. Default: @all.
         */
        toUser?: string;
        /**
         * The UID of the contact point.
         */
        uid: string;
        /**
         * The WeCom webhook URL. Required if using GroupRobot.
         */
        url?: string;
    }

    export interface MuteTimingInterval {
        /**
         * An inclusive range of days, 1-31, within a month, e.g. "1" or "14:16". Negative values can be used to represent days counting from the end of a month, e.g. "-1".
         */
        daysOfMonths?: string[];
        /**
         * Provides the time zone for the time interval. Must be a location in the IANA time zone database, e.g "America/New_York"
         */
        location?: string;
        /**
         * An inclusive range of months, either numerical or full calendar month, e.g. "1:3", "december", or "may:august".
         */
        months?: string[];
        /**
         * The time ranges, represented in minutes, during which to mute in a given day.
         */
        times?: outputs.alerting.MuteTimingIntervalTime[];
        /**
         * An inclusive range of weekdays, e.g. "monday" or "tuesday:thursday".
         */
        weekdays?: string[];
        /**
         * A positive inclusive range of years, e.g. "2030" or "2025:2026".
         */
        years?: string[];
    }

    export interface MuteTimingIntervalTime {
        /**
         * The time, in hh:mm format, of when the interval should end exclusively.
         */
        end: string;
        /**
         * The time, in hh:mm format, of when the interval should begin inclusively.
         */
        start: string;
    }

    export interface NotificationPolicyPolicy {
        /**
         * The contact point to route notifications that match this rule to.
         */
        contactPoint?: string;
        /**
         * Whether to continue matching subsequent rules if an alert matches the current rule. Otherwise, the rule will be 'consumed' by the first policy to match it.
         */
        continue?: boolean;
        /**
         * A list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping. Required for root policy only. If empty, the parent grouping is used.
         */
        groupBies?: string[];
        /**
         * Minimum time interval between two notifications for the same group. Default is 5 minutes.
         */
        groupInterval?: string;
        /**
         * Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.
         */
        groupWait?: string;
        /**
         * Describes which labels this rule should match. When multiple matchers are supplied, an alert must match ALL matchers to be accepted by this policy. When no matchers are supplied, the rule will match all alert instances.
         */
        matchers?: outputs.alerting.NotificationPolicyPolicyMatcher[];
        /**
         * A list of mute timing names to apply to alerts that match this policy.
         */
        muteTimings?: string[];
        /**
         * Routing rules for specific label sets.
         */
        policies?: outputs.alerting.NotificationPolicyPolicyPolicy[];
        /**
         * Minimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.
         */
        repeatInterval?: string;
    }

    export interface NotificationPolicyPolicyMatcher {
        /**
         * The name of the label to match against.
         */
        label: string;
        /**
         * The operator to apply when matching values of the given label. Allowed operators are `=` for equality, `!=` for negated equality, `=~` for regex equality, and `!~` for negated regex equality.
         */
        match: string;
        /**
         * The label value to match against.
         */
        value: string;
    }

    export interface NotificationPolicyPolicyPolicy {
        /**
         * The contact point to route notifications that match this rule to.
         */
        contactPoint?: string;
        /**
         * Whether to continue matching subsequent rules if an alert matches the current rule. Otherwise, the rule will be 'consumed' by the first policy to match it.
         */
        continue?: boolean;
        /**
         * A list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping. Required for root policy only. If empty, the parent grouping is used.
         */
        groupBies?: string[];
        /**
         * Minimum time interval between two notifications for the same group. Default is 5 minutes.
         */
        groupInterval?: string;
        /**
         * Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.
         */
        groupWait?: string;
        /**
         * Describes which labels this rule should match. When multiple matchers are supplied, an alert must match ALL matchers to be accepted by this policy. When no matchers are supplied, the rule will match all alert instances.
         */
        matchers?: outputs.alerting.NotificationPolicyPolicyPolicyMatcher[];
        /**
         * A list of mute timing names to apply to alerts that match this policy.
         */
        muteTimings?: string[];
        /**
         * Routing rules for specific label sets.
         */
        policies?: outputs.alerting.NotificationPolicyPolicyPolicyPolicy[];
        /**
         * Minimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.
         */
        repeatInterval?: string;
    }

    export interface NotificationPolicyPolicyPolicyMatcher {
        /**
         * The name of the label to match against.
         */
        label: string;
        /**
         * The operator to apply when matching values of the given label. Allowed operators are `=` for equality, `!=` for negated equality, `=~` for regex equality, and `!~` for negated regex equality.
         */
        match: string;
        /**
         * The label value to match against.
         */
        value: string;
    }

    export interface NotificationPolicyPolicyPolicyPolicy {
        /**
         * The contact point to route notifications that match this rule to.
         */
        contactPoint?: string;
        /**
         * Whether to continue matching subsequent rules if an alert matches the current rule. Otherwise, the rule will be 'consumed' by the first policy to match it.
         */
        continue?: boolean;
        /**
         * A list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping. Required for root policy only. If empty, the parent grouping is used.
         */
        groupBies?: string[];
        /**
         * Minimum time interval between two notifications for the same group. Default is 5 minutes.
         */
        groupInterval?: string;
        /**
         * Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.
         */
        groupWait?: string;
        /**
         * Describes which labels this rule should match. When multiple matchers are supplied, an alert must match ALL matchers to be accepted by this policy. When no matchers are supplied, the rule will match all alert instances.
         */
        matchers?: outputs.alerting.NotificationPolicyPolicyPolicyPolicyMatcher[];
        /**
         * A list of mute timing names to apply to alerts that match this policy.
         */
        muteTimings?: string[];
        /**
         * Routing rules for specific label sets.
         */
        policies?: outputs.alerting.NotificationPolicyPolicyPolicyPolicyPolicy[];
        /**
         * Minimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.
         */
        repeatInterval?: string;
    }

    export interface NotificationPolicyPolicyPolicyPolicyMatcher {
        /**
         * The name of the label to match against.
         */
        label: string;
        /**
         * The operator to apply when matching values of the given label. Allowed operators are `=` for equality, `!=` for negated equality, `=~` for regex equality, and `!~` for negated regex equality.
         */
        match: string;
        /**
         * The label value to match against.
         */
        value: string;
    }

    export interface NotificationPolicyPolicyPolicyPolicyPolicy {
        /**
         * The contact point to route notifications that match this rule to.
         */
        contactPoint?: string;
        /**
         * Whether to continue matching subsequent rules if an alert matches the current rule. Otherwise, the rule will be 'consumed' by the first policy to match it.
         */
        continue?: boolean;
        /**
         * A list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping. Required for root policy only. If empty, the parent grouping is used.
         */
        groupBies: string[];
        /**
         * Minimum time interval between two notifications for the same group. Default is 5 minutes.
         */
        groupInterval?: string;
        /**
         * Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.
         */
        groupWait?: string;
        /**
         * Describes which labels this rule should match. When multiple matchers are supplied, an alert must match ALL matchers to be accepted by this policy. When no matchers are supplied, the rule will match all alert instances.
         */
        matchers?: outputs.alerting.NotificationPolicyPolicyPolicyPolicyPolicyMatcher[];
        /**
         * A list of mute timing names to apply to alerts that match this policy.
         */
        muteTimings?: string[];
        /**
         * Minimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.
         */
        repeatInterval?: string;
    }

    export interface NotificationPolicyPolicyPolicyPolicyPolicyMatcher {
        /**
         * The name of the label to match against.
         */
        label: string;
        /**
         * The operator to apply when matching values of the given label. Allowed operators are `=` for equality, `!=` for negated equality, `=~` for regex equality, and `!~` for negated regex equality.
         */
        match: string;
        /**
         * The label value to match against.
         */
        value: string;
    }

    export interface RuleGroupRule {
        /**
         * Key-value pairs of metadata to attach to the alert rule that may add user-defined context, but cannot be used for matching, grouping, or routing. Defaults to `map[]`.
         */
        annotations?: {[key: string]: string};
        /**
         * The `refId` of the query node in the `data` field to use as the alert condition.
         */
        condition: string;
        /**
         * A sequence of stages that describe the contents of the rule.
         */
        datas: outputs.alerting.RuleGroupRuleData[];
        /**
         * Describes what state to enter when the rule's query is invalid and the rule cannot be executed. Options are OK, Error, KeepLast, and Alerting. Defaults to `Alerting`.
         */
        execErrState?: string;
        /**
         * The amount of time for which the rule must be breached for the rule to be considered to be Firing. Before this time has elapsed, the rule is only considered to be Pending. Defaults to `0`.
         */
        for?: string;
        /**
         * Sets whether the alert should be paused or not. Defaults to `false`.
         */
        isPaused?: boolean;
        /**
         * Key-value pairs to attach to the alert rule that can be used in matching, grouping, and routing. Defaults to `map[]`.
         */
        labels?: {[key: string]: string};
        /**
         * The name of the alert rule.
         */
        name: string;
        /**
         * Describes what state to enter when the rule's query returns No Data. Options are OK, NoData, KeepLast, and Alerting. Defaults to `NoData`.
         */
        noDataState?: string;
        /**
         * Notification settings for the rule. If specified, it overrides the notification policies. Available since Grafana 10.4, requires feature flag 'alertingSimplifiedRouting' enabled.
         */
        notificationSettings?: outputs.alerting.RuleGroupRuleNotificationSettings;
        /**
         * The unique identifier of the alert rule.
         */
        uid: string;
    }

    export interface RuleGroupRuleData {
        /**
         * The UID of the datasource being queried, or "-100" if this stage is an expression stage.
         */
        datasourceUid: string;
        /**
         * Custom JSON data to send to the specified datasource when querying.
         */
        model: string;
        /**
         * An optional identifier for the type of query being executed. Defaults to ``.
         */
        queryType?: string;
        /**
         * A unique string to identify this query stage within a rule.
         */
        refId: string;
        /**
         * The time range, relative to when the query is executed, across which to query.
         */
        relativeTimeRange: outputs.alerting.RuleGroupRuleDataRelativeTimeRange;
    }

    export interface RuleGroupRuleDataRelativeTimeRange {
        /**
         * The number of seconds in the past, relative to when the rule is evaluated, at which the time range begins.
         */
        from: number;
        /**
         * The number of seconds in the past, relative to when the rule is evaluated, at which the time range ends.
         */
        to: number;
    }

    export interface RuleGroupRuleNotificationSettings {
        /**
         * The contact point to route notifications that match this rule to.
         */
        contactPoint: string;
        /**
         * A list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping. If empty, no grouping is used. If specified, requires labels 'alertname' and 'grafana_folder' to be included.
         */
        groupBies?: string[];
        /**
         * Minimum time interval between two notifications for the same group. Default is 5 minutes.
         */
        groupInterval?: string;
        /**
         * Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.
         */
        groupWait?: string;
        /**
         * A list of mute timing names to apply to alerts that match this policy.
         */
        muteTimings?: string[];
        /**
         * Minimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.
         */
        repeatInterval?: string;
    }

}

export namespace cloud {
    export interface AccessPolicyRealm {
        /**
         * The identifier of the org or stack. For orgs, this is the slug, for stacks, this is the stack ID.
         */
        identifier: string;
        labelPolicies?: outputs.cloud.AccessPolicyRealmLabelPolicy[];
        /**
         * Whether a policy applies to a Cloud org or a specific stack. Should be one of `org` or `stack`.
         */
        type: string;
    }

    export interface AccessPolicyRealmLabelPolicy {
        /**
         * The label selector to match in metrics or logs query. Should be in PromQL or LogQL format.
         */
        selector: string;
    }

}

export namespace enterprise {
    export interface DataSourcePermissionPermission {
        /**
         * Name of the basic role to manage permissions for. Options: `Viewer`, `Editor` or `Admin`.
         */
        builtInRole?: string;
        /**
         * Permission to associate with item. Options: `Query`, `Edit` or `Admin` (`Admin` can only be used with Grafana v10.3.0+).
         */
        permission: string;
        /**
         * ID of the team to manage permissions for. Defaults to `0`.
         */
        teamId?: string;
        /**
         * ID of the user or service account to manage permissions for. Defaults to `0`.
         */
        userId?: string;
    }

    export interface GetRolePermission {
        /**
         * Specific action users granted with the role will be allowed to perform (for example: `users:read`)
         */
        action: string;
        /**
         * Scope to restrict the action to a set of resources (for example: `users:*` or `roles:customrole1`)
         */
        scope?: string;
    }

    export interface ReportDashboard {
        /**
         * Add report variables to the dashboard. Values should be separated by commas.
         */
        reportVariables?: {[key: string]: string};
        /**
         * Time range of the report.
         */
        timeRange?: outputs.enterprise.ReportDashboardTimeRange;
        /**
         * Dashboard uid.
         */
        uid: string;
    }

    export interface ReportDashboardTimeRange {
        /**
         * Start of the time range.
         */
        from?: string;
        /**
         * End of the time range.
         */
        to?: string;
    }

    export interface ReportSchedule {
        /**
         * Custom interval of the report.
         * **Note:** This field is only available when frequency is set to `custom`.
         */
        customInterval?: string;
        /**
         * End time of the report. If empty, the report will be sent indefinitely (according to frequency). Note that times will be saved as UTC in Grafana. Use 2006-01-02T15:04:05 format if you want to set a custom timezone
         */
        endTime?: string;
        /**
         * Frequency of the report. Allowed values: `never`, `once`, `hourly`, `daily`, `weekly`, `monthly`, `custom`.
         */
        frequency: string;
        /**
         * Send the report on the last day of the month Defaults to `false`.
         */
        lastDayOfMonth?: boolean;
        /**
         * Start time of the report. If empty, the start date will be set to the creation time. Note that times will be saved as UTC in Grafana. Use 2006-01-02T15:04:05 format if you want to set a custom timezone
         */
        startTime?: string;
        /**
         * Set the report time zone. Defaults to `GMT`.
         */
        timezone?: string;
        /**
         * Whether to send the report only on work days. Defaults to `false`.
         */
        workdaysOnly?: boolean;
    }

    export interface RolePermission {
        /**
         * Specific action users granted with the role will be allowed to perform (for example: `users:read`)
         */
        action: string;
        /**
         * Scope to restrict the action to a set of resources (for example: `users:*` or `roles:customrole1`) Defaults to ``.
         */
        scope?: string;
    }

}

export namespace machineLearning {
    export interface HolidayCustomPeriod {
        endTime: string;
        /**
         * The name of the custom period.
         */
        name?: string;
        startTime: string;
    }

    export interface OutlierDetectorAlgorithm {
        /**
         * For DBSCAN only, specify the configuration map
         */
        config?: outputs.machineLearning.OutlierDetectorAlgorithmConfig;
        /**
         * The name of the algorithm to use ('mad' or 'dbscan').
         */
        name: string;
        /**
         * Specify the sensitivity of the detector (in range [0,1]).
         */
        sensitivity: number;
    }

    export interface OutlierDetectorAlgorithmConfig {
        /**
         * Specify the epsilon parameter (positive float)
         */
        epsilon: number;
    }

}

export namespace onCall {
    export interface IntegrationDefaultRoute {
        /**
         * The ID of the escalation chain.
         */
        escalationChainId?: string;
        id: string;
        /**
         * MS teams-specific settings for a route.
         */
        msteams?: outputs.onCall.IntegrationDefaultRouteMsteams;
        /**
         * Slack-specific settings for a route.
         */
        slack?: outputs.onCall.IntegrationDefaultRouteSlack;
        /**
         * Telegram-specific settings for a route.
         */
        telegram?: outputs.onCall.IntegrationDefaultRouteTelegram;
    }

    export interface IntegrationDefaultRouteMsteams {
        /**
         * Enable notification in MS teams. Defaults to `true`.
         */
        enabled?: boolean;
        /**
         * MS teams channel id. Alerts will be directed to this channel in Microsoft teams.
         */
        id?: string;
    }

    export interface IntegrationDefaultRouteSlack {
        /**
         * Slack channel id. Alerts will be directed to this channel in Slack.
         */
        channelId?: string;
        /**
         * Enable notification in Slack. Defaults to `true`.
         */
        enabled?: boolean;
    }

    export interface IntegrationDefaultRouteTelegram {
        /**
         * Enable notification in Telegram. Defaults to `true`.
         */
        enabled?: boolean;
        /**
         * Telegram channel id. Alerts will be directed to this channel in Telegram.
         */
        id?: string;
    }

    export interface IntegrationTemplates {
        /**
         * Template for sending a signal to acknowledge the Incident.
         */
        acknowledgeSignal?: string;
        /**
         * Templates for Email.
         */
        email?: outputs.onCall.IntegrationTemplatesEmail;
        /**
         * Template for the key by which alerts are grouped.
         */
        groupingKey?: string;
        /**
         * Templates for Microsoft Teams.
         */
        microsoftTeams?: outputs.onCall.IntegrationTemplatesMicrosoftTeams;
        /**
         * Templates for Phone Call.
         */
        phoneCall?: outputs.onCall.IntegrationTemplatesPhoneCall;
        /**
         * Template for sending a signal to resolve the Incident.
         */
        resolveSignal?: string;
        /**
         * Templates for Slack.
         */
        slack?: outputs.onCall.IntegrationTemplatesSlack;
        /**
         * Templates for SMS.
         */
        sms?: outputs.onCall.IntegrationTemplatesSms;
        /**
         * Template for a source link.
         */
        sourceLink?: string;
        /**
         * Templates for Telegram.
         */
        telegram?: outputs.onCall.IntegrationTemplatesTelegram;
        /**
         * Templates for Web.
         */
        web?: outputs.onCall.IntegrationTemplatesWeb;
    }

    export interface IntegrationTemplatesEmail {
        /**
         * Template for Alert message.
         */
        message?: string;
        /**
         * Template for Alert title.
         */
        title?: string;
    }

    export interface IntegrationTemplatesMicrosoftTeams {
        /**
         * Template for Alert image url.
         */
        imageUrl?: string;
        /**
         * Template for Alert message.
         */
        message?: string;
        /**
         * Template for Alert title.
         */
        title?: string;
    }

    export interface IntegrationTemplatesPhoneCall {
        /**
         * Template for Alert title.
         */
        title?: string;
    }

    export interface IntegrationTemplatesSlack {
        /**
         * Template for Alert image url.
         */
        imageUrl?: string;
        /**
         * Template for Alert message.
         */
        message?: string;
        /**
         * Template for Alert title.
         */
        title?: string;
    }

    export interface IntegrationTemplatesSms {
        /**
         * Template for Alert title.
         */
        title?: string;
    }

    export interface IntegrationTemplatesTelegram {
        /**
         * Template for Alert image url.
         */
        imageUrl?: string;
        /**
         * Template for Alert message.
         */
        message?: string;
        /**
         * Template for Alert title.
         */
        title?: string;
    }

    export interface IntegrationTemplatesWeb {
        /**
         * Template for Alert image url.
         */
        imageUrl?: string;
        /**
         * Template for Alert message.
         */
        message?: string;
        /**
         * Template for Alert title.
         */
        title?: string;
    }

    export interface RouteMsteams {
        /**
         * Enable notification in MS teams. Defaults to `true`.
         */
        enabled?: boolean;
        /**
         * MS teams channel id. Alerts will be directed to this channel in Microsoft teams.
         */
        id?: string;
    }

    export interface RouteSlack {
        /**
         * Slack channel id. Alerts will be directed to this channel in Slack.
         */
        channelId?: string;
        /**
         * Enable notification in Slack. Defaults to `true`.
         */
        enabled?: boolean;
    }

    export interface RouteTelegram {
        /**
         * Enable notification in Telegram. Defaults to `true`.
         */
        enabled?: boolean;
        /**
         * Telegram channel id. Alerts will be directed to this channel in Telegram.
         */
        id?: string;
    }

    export interface ScheduleSlack {
        /**
         * Slack channel id. Reminder about schedule shifts will be directed to this channel in Slack.
         */
        channelId?: string;
        /**
         * Slack user group id. Members of user group will be updated when on-call users change.
         */
        userGroupId?: string;
    }

}

export namespace oss {
    export interface DashboardPermissionPermission {
        /**
         * Permission to associate with item. Must be one of `View`, `Edit`, or `Admin`.
         */
        permission: string;
        /**
         * Name of the basic role to manage permissions for. Options: `Viewer`, `Editor` or `Admin`.
         */
        role?: string;
        /**
         * ID of the team to manage permissions for. Defaults to `0`.
         */
        teamId?: string;
        /**
         * ID of the user or service account to manage permissions for. Defaults to `0`.
         */
        userId?: string;
    }

    export interface FolderPermissionPermission {
        /**
         * Permission to associate with item. Must be one of `View`, `Edit`, or `Admin`.
         */
        permission: string;
        /**
         * Name of the basic role to manage permissions for. Options: `Viewer`, `Editor` or `Admin`.
         */
        role?: string;
        /**
         * ID of the team to manage permissions for. Defaults to `0`.
         */
        teamId?: string;
        /**
         * ID of the user or service account to manage permissions for. Defaults to `0`.
         */
        userId?: string;
    }

    export interface GetDashboardsDashboard {
        folderTitle: string;
        title: string;
        uid: string;
    }

    export interface GetFoldersFolder {
        /**
         * The folder ID.
         */
        id: number;
        /**
         * The folder title.
         */
        title: string;
        /**
         * The folder's unique identifier.
         */
        uid: string;
        /**
         * The folder's URL
         */
        url: string;
    }

    export interface GetTeamPreference {
        /**
         * The UID of the dashboard to display when a team member logs in.
         */
        homeDashboardUid?: string;
        /**
         * The default theme for this team. Available themes are `light`, `dark`, `system`, or an empty string for the default theme.
         */
        theme?: string;
        /**
         * The default timezone for this team. Available values are `utc`, `browser`, or an empty string for the default.
         */
        timezone?: string;
        /**
         * The default week start day for this team. Available values are `sunday`, `monday`, `saturday`, or an empty string for the default.
         */
        weekStart?: string;
    }

    export interface GetTeamTeamSync {
        groups?: string[];
    }

    export interface GetUsersUser {
        /**
         * The user's email.
         */
        email: string;
        /**
         * The user ID.
         */
        id: number;
        /**
         * Whether the user is admin or not.
         */
        isAdmin: boolean;
        /**
         * The user's login.
         */
        login: string;
        /**
         * The user's name.
         */
        name: string;
    }

    export interface PlaylistItem {
        id: string;
        order: number;
        title: string;
        type?: string;
        value?: string;
    }

    export interface ServiceAccountPermissionPermission {
        /**
         * Permission to associate with item. Must be one of `View`, `Edit`, or `Admin`.
         */
        permission: string;
        /**
         * ID of the team to manage permissions for. Defaults to `0`.
         */
        teamId?: string;
        /**
         * ID of the user or service account to manage permissions for. Defaults to `0`.
         */
        userId?: string;
    }

    export interface SsoSettingsOauth2Settings {
        /**
         * If enabled, it will automatically sync the Grafana server administrator role.
         */
        allowAssignGrafanaAdmin?: boolean;
        /**
         * If not enabled, only existing Grafana users can log in using OAuth.
         */
        allowSignUp?: boolean;
        /**
         * List of comma- or space-separated domains. The user should belong to at least one domain to log in.
         */
        allowedDomains?: string;
        /**
         * List of comma- or space-separated groups. The user should be a member of at least one group to log in. For Generic OAuth, if you configure allowed*groups, you must also configure groups*attribute_path.
         */
        allowedGroups?: string;
        /**
         * List of comma- or space-separated organizations. The user should be a member of at least one organization to log in.
         */
        allowedOrganizations?: string;
        /**
         * The user information endpoint of your OAuth2 provider. Required for okta and genericOauth providers.
         */
        apiUrl?: string;
        /**
         * It determines how client*id and client*secret are sent to Oauth2 provider. Possible values are AutoDetect, InParams, InHeader. Default is AutoDetect.
         */
        authStyle?: string;
        /**
         * The authorization endpoint of your OAuth2 provider. Required for azuread, okta and genericOauth providers.
         */
        authUrl?: string;
        /**
         * Log in automatically, skipping the login screen.
         */
        autoLogin?: boolean;
        /**
         * The client Id of your OAuth2 app.
         */
        clientId: string;
        /**
         * The client secret of your OAuth2 app.
         */
        clientSecret?: string;
        /**
         * Custom fields to configure for OAuth2 such as the [force*use*graph_api](https://grafana.com/docs/grafana/latest/setup-grafana/configure-security/configure-authentication/azuread/#force-fetching-groups-from-microsoft-graph-api) field.
         */
        custom?: {[key: string]: string};
        /**
         * Define allowed groups.
         */
        defineAllowedGroups?: boolean;
        /**
         * Define allowed teams ids.
         */
        defineAllowedTeamsIds?: boolean;
        /**
         * Name of the key to use for user email lookup within the attributes map of OAuth2 ID token. Only applicable to Generic OAuth.
         */
        emailAttributeName?: string;
        /**
         * JMESPath expression to use for user email lookup from the user information. Only applicable to Generic OAuth.
         */
        emailAttributePath?: string;
        /**
         * If enabled, no scopes will be sent to the OAuth2 provider.
         */
        emptyScopes?: boolean;
        /**
         * Define whether this configuration is enabled for the specified provider. Defaults to `true`.
         */
        enabled?: boolean;
        /**
         * JMESPath expression to use for user group lookup. If you configure allowed*groups, you must also configure groups*attribute_path.
         */
        groupsAttributePath?: string;
        /**
         * The name of the key used to extract the ID token from the returned OAuth2 token. Only applicable to Generic OAuth.
         */
        idTokenAttributeName?: string;
        /**
         * JMESPath expression to use for user login lookup from the user ID token. Only applicable to Generic OAuth.
         */
        loginAttributePath?: string;
        /**
         * Helpful if you use more than one identity providers or SSO protocols.
         */
        name?: string;
        /**
         * JMESPath expression to use for user name lookup from the user ID token. This name will be used as the user’s display name. Only applicable to Generic OAuth.
         */
        nameAttributePath?: string;
        /**
         * JMESPath expression to use for Grafana role lookup.
         */
        roleAttributePath?: string;
        /**
         * If enabled, denies user login if the Grafana role cannot be extracted using Role attribute path.
         */
        roleAttributeStrict?: boolean;
        /**
         * List of comma- or space-separated OAuth2 scopes.
         */
        scopes?: string;
        /**
         * The URL to redirect the user to after signing out from Grafana.
         */
        signoutRedirectUrl?: string;
        /**
         * Prevent synchronizing users’ organization roles from your IdP.
         */
        skipOrgRoleSync?: boolean;
        /**
         * String list of Team Ids. If set, the user must be a member of one of the given teams to log in. If you configure team*ids, you must also configure teams*url and team*ids*attribute_path.
         */
        teamIds?: string;
        /**
         * The JMESPath expression to use for Grafana Team Id lookup within the results returned by the teamsUrl endpoint. Only applicable to Generic OAuth.
         */
        teamIdsAttributePath?: string;
        /**
         * The URL used to query for Team Ids. If not set, the default value is /teams. If you configure teams*url, you must also configure team*ids*attribute*path. Only applicable to Generic OAuth.
         */
        teamsUrl?: string;
        /**
         * The path to the trusted certificate authority list. Is not applicable on Grafana Cloud.
         */
        tlsClientCa?: string;
        /**
         * The path to the certificate. Is not applicable on Grafana Cloud.
         */
        tlsClientCert?: string;
        /**
         * The path to the key. Is not applicable on Grafana Cloud.
         */
        tlsClientKey?: string;
        /**
         * If enabled, the client accepts any certificate presented by the server and any host name in that certificate. You should only use this for testing, because this mode leaves SSL/TLS susceptible to man-in-the-middle attacks.
         */
        tlsSkipVerifyInsecure?: boolean;
        /**
         * The token endpoint of your OAuth2 provider. Required for azuread, okta and genericOauth providers.
         */
        tokenUrl?: string;
        /**
         * If enabled, Grafana will use Proof Key for Code Exchange (PKCE) with the OAuth2 Authorization Code Grant.
         */
        usePkce?: boolean;
        /**
         * If enabled, Grafana will fetch a new access token using the refresh token provided by the OAuth2 provider.
         */
        useRefreshToken?: boolean;
    }

    export interface SsoSettingsSamlSettings {
        /**
         * Whether SAML IdP-initiated login is allowed.
         */
        allowIdpInitiated?: boolean;
        /**
         * Whether to allow new Grafana user creation through SAML login. If set to false, then only existing Grafana users can log in with SAML.
         */
        allowSignUp?: boolean;
        /**
         * List of comma- or space-separated organizations. User should be a member of at least one organization to log in.
         */
        allowedOrganizations?: string;
        /**
         * Friendly name or name of the attribute within the SAML assertion to use as the user email.
         */
        assertionAttributeEmail?: string;
        /**
         * Friendly name or name of the attribute within the SAML assertion to use as the user groups.
         */
        assertionAttributeGroups?: string;
        /**
         * Friendly name or name of the attribute within the SAML assertion to use as the user login handle.
         */
        assertionAttributeLogin?: string;
        /**
         * Friendly name or name of the attribute within the SAML assertion to use as the user name. Alternatively, this can be a template with variables that match the names of attributes within the SAML assertion.
         */
        assertionAttributeName?: string;
        /**
         * Friendly name or name of the attribute within the SAML assertion to use as the user organization.
         */
        assertionAttributeOrg?: string;
        /**
         * Friendly name or name of the attribute within the SAML assertion to use as the user roles.
         */
        assertionAttributeRole?: string;
        /**
         * Whether SAML auto login is enabled.
         */
        autoLogin?: boolean;
        /**
         * Base64-encoded string for the SP X.509 certificate.
         */
        certificate?: string;
        /**
         * Path for the SP X.509 certificate.
         */
        certificatePath?: string;
        /**
         * Define whether this configuration is enabled for SAML. Defaults to `true`.
         */
        enabled?: boolean;
        /**
         * Base64-encoded string for the IdP SAML metadata XML.
         */
        idpMetadata?: string;
        /**
         * Path for the IdP SAML metadata XML.
         */
        idpMetadataPath?: string;
        /**
         * URL for the IdP SAML metadata XML.
         */
        idpMetadataUrl?: string;
        /**
         * Duration, since the IdP issued a response and the SP is allowed to process it. For example: 90s, 1h.
         */
        maxIssueDelay?: string;
        /**
         * Duration, for how long the SP metadata is valid. For example: 48h, 5d.
         */
        metadataValidDuration?: string;
        /**
         * Name used to refer to the SAML authentication.
         */
        name?: string;
        /**
         * The Name ID Format to request within the SAML assertion. Defaults to urn:oasis:names:tc:SAML:2.0:nameid-format:transient
         */
        nameIdFormat?: string;
        /**
         * List of comma- or space-separated Organization:OrgId:Role mappings. Organization can be * meaning “All users”. Role is optional and can have the following values: Viewer, Editor or Admin.
         */
        orgMapping?: string;
        /**
         * Base64-encoded string for the SP private key.
         */
        privateKey?: string;
        /**
         * Path for the SP private key.
         */
        privateKeyPath?: string;
        /**
         * Relay state for IdP-initiated login. Should match relay state configured in IdP.
         */
        relayState?: string;
        /**
         * List of comma- or space-separated roles which will be mapped into the Admin role.
         */
        roleValuesAdmin?: string;
        /**
         * List of comma- or space-separated roles which will be mapped into the Editor role.
         */
        roleValuesEditor?: string;
        /**
         * List of comma- or space-separated roles which will be mapped into the Grafana Admin (Super Admin) role.
         */
        roleValuesGrafanaAdmin?: string;
        /**
         * List of comma- or space-separated roles which will be mapped into the None role.
         */
        roleValuesNone?: string;
        /**
         * List of comma- or space-separated roles which will be mapped into the Viewer role.
         */
        roleValuesViewer?: string;
        /**
         * Signature algorithm used for signing requests to the IdP. Supported values are rsa-sha1, rsa-sha256, rsa-sha512.
         */
        signatureAlgorithm?: string;
        /**
         * Whether SAML Single Logout is enabled.
         */
        singleLogout?: boolean;
        /**
         * Prevent synchronizing users’ organization roles from your IdP.
         */
        skipOrgRoleSync?: boolean;
    }

    export interface TeamPreferences {
        /**
         * The UID of the dashboard to display when a team member logs in.
         */
        homeDashboardUid?: string;
        /**
         * The default theme for this team. Available themes are `light`, `dark`, `system`, or an empty string for the default theme.
         */
        theme?: string;
        /**
         * The default timezone for this team. Available values are `utc`, `browser`, or an empty string for the default.
         */
        timezone?: string;
        /**
         * The default week start day for this team. Available values are `sunday`, `monday`, `saturday`, or an empty string for the default.
         */
        weekStart?: string;
    }

    export interface TeamTeamSync {
        groups?: string[];
    }

}

export namespace slo {
    export interface GetSlosSlo {
        /**
         * Configures the alerting rules that will be generated for each
         * 				time window associated with the SLO. Grafana SLOs can generate
         * 				alerts when the short-term error budget burn is very high, the
         * 				long-term error budget burn rate is high, or when the remaining
         * 				error budget is below a certain threshold. Annotations and Labels support templating.
         */
        alertings: outputs.slo.GetSlosSloAlerting[];
        /**
         * Description is a free-text field that can provide more context to an SLO.
         */
        description: string;
        /**
         * Destination Datasource sets the datasource defined for an SLO
         */
        destinationDatasources: outputs.slo.GetSlosSloDestinationDatasource[];
        /**
         * UID for the SLO folder
         */
        folderUid: string;
        /**
         * Additional labels that will be attached to all metrics generated from the query. These labels are useful for grouping SLOs in dashboard views that you create by hand. Labels must adhere to Prometheus label name schema - "^[a-zA-Z_][a-zA-Z0-9_]*$"
         */
        labels: outputs.slo.GetSlosSloLabel[];
        /**
         * Name should be a short description of your indicator. Consider names like "API Availability"
         */
        name: string;
        /**
         * Over each rolling time window, the remaining error budget will be calculated, and separate alerts can be generated for each time window based on the SLO burn rate or remaining error budget.
         */
        objectives: outputs.slo.GetSlosSloObjective[];
        /**
         * Query describes the indicator that will be measured against the objective. Freeform Query types are currently supported.
         */
        queries: outputs.slo.GetSlosSloQuery[];
        /**
         * A unique, random identifier. This value will also be the name of the resource stored in the API server. This value is read-only.
         */
        uuid: string;
    }

    export interface GetSlosSloAlerting {
        /**
         * Advanced Options for Alert Rules
         */
        advancedOptions?: outputs.slo.GetSlosSloAlertingAdvancedOptions;
        /**
         * Annotations will be attached to all alerts generated by any of these rules.
         */
        annotations?: outputs.slo.GetSlosSloAlertingAnnotation[];
        /**
         * Alerting Rules generated for Fast Burn alerts
         */
        fastburns?: outputs.slo.GetSlosSloAlertingFastburn[];
        /**
         * Labels will be attached to all alerts generated by any of these rules.
         */
        labels?: outputs.slo.GetSlosSloAlertingLabel[];
        /**
         * Alerting Rules generated for Slow Burn alerts
         */
        slowburns?: outputs.slo.GetSlosSloAlertingSlowburn[];
    }

    export interface GetSlosSloAlertingAdvancedOptions {
        /**
         * Minimum number of failed events to trigger an alert
         */
        minFailures?: number;
    }

    export interface GetSlosSloAlertingAnnotation {
        key: string;
        value: string;
    }

    export interface GetSlosSloAlertingFastburn {
        /**
         * Annotations to attach only to Fast Burn alerts.
         */
        annotations?: outputs.slo.GetSlosSloAlertingFastburnAnnotation[];
        /**
         * Labels to attach only to Fast Burn alerts.
         */
        labels?: outputs.slo.GetSlosSloAlertingFastburnLabel[];
    }

    export interface GetSlosSloAlertingFastburnAnnotation {
        key: string;
        value: string;
    }

    export interface GetSlosSloAlertingFastburnLabel {
        key: string;
        value: string;
    }

    export interface GetSlosSloAlertingLabel {
        key: string;
        value: string;
    }

    export interface GetSlosSloAlertingSlowburn {
        /**
         * Annotations to attach only to Slow Burn alerts.
         */
        annotations?: outputs.slo.GetSlosSloAlertingSlowburnAnnotation[];
        /**
         * Labels to attach only to Slow Burn alerts.
         */
        labels?: outputs.slo.GetSlosSloAlertingSlowburnLabel[];
    }

    export interface GetSlosSloAlertingSlowburnAnnotation {
        key: string;
        value: string;
    }

    export interface GetSlosSloAlertingSlowburnLabel {
        key: string;
        value: string;
    }

    export interface GetSlosSloDestinationDatasource {
        /**
         * UID for the Mimir Datasource
         */
        uid?: string;
    }

    export interface GetSlosSloLabel {
        key: string;
        value: string;
    }

    export interface GetSlosSloObjective {
        /**
         * Value between 0 and 1. If the value of the query is above the objective, the SLO is met.
         */
        value: number;
        /**
         * A Prometheus-parsable time duration string like 24h, 60m. This is the time window the objective is measured over.
         */
        window: string;
    }

    export interface GetSlosSloQuery {
        freeform?: outputs.slo.GetSlosSloQueryFreeform;
        ratio?: outputs.slo.GetSlosSloQueryRatio;
        /**
         * Query type must be one of: "freeform", "query", "ratio", or "threshold"
         */
        type: string;
    }

    export interface GetSlosSloQueryFreeform {
        /**
         * Freeform Query Field
         */
        query: string;
    }

    export interface GetSlosSloQueryRatio {
        /**
         * Defines Group By Labels used for per-label alerting. These appear as variables on SLO dashboards to enable filtering and aggregation. Labels must adhere to Prometheus label name schema - "^[a-zA-Z_][a-zA-Z0-9_]*$"
         */
        groupByLabels?: string[];
        /**
         * Counter metric for success events (numerator)
         */
        successMetric: string;
        /**
         * Metric for total events (denominator)
         */
        totalMetric: string;
    }

    export interface SLOAlerting {
        /**
         * Advanced Options for Alert Rules
         */
        advancedOptions?: outputs.slo.SLOAlertingAdvancedOptions;
        /**
         * Annotations will be attached to all alerts generated by any of these rules.
         */
        annotations?: outputs.slo.SLOAlertingAnnotation[];
        /**
         * Alerting Rules generated for Fast Burn alerts
         */
        fastburns?: outputs.slo.SLOAlertingFastburn[];
        /**
         * Labels will be attached to all alerts generated by any of these rules.
         */
        labels?: outputs.slo.SLOAlertingLabel[];
        /**
         * Alerting Rules generated for Slow Burn alerts
         */
        slowburns?: outputs.slo.SLOAlertingSlowburn[];
    }

    export interface SLOAlertingAdvancedOptions {
        /**
         * Minimum number of failed events to trigger an alert
         */
        minFailures?: number;
    }

    export interface SLOAlertingAnnotation {
        key: string;
        value: string;
    }

    export interface SLOAlertingFastburn {
        /**
         * Annotations to attach only to Fast Burn alerts.
         */
        annotations?: outputs.slo.SLOAlertingFastburnAnnotation[];
        /**
         * Labels to attach only to Fast Burn alerts.
         */
        labels?: outputs.slo.SLOAlertingFastburnLabel[];
    }

    export interface SLOAlertingFastburnAnnotation {
        key: string;
        value: string;
    }

    export interface SLOAlertingFastburnLabel {
        key: string;
        value: string;
    }

    export interface SLOAlertingLabel {
        key: string;
        value: string;
    }

    export interface SLOAlertingSlowburn {
        /**
         * Annotations to attach only to Slow Burn alerts.
         */
        annotations?: outputs.slo.SLOAlertingSlowburnAnnotation[];
        /**
         * Labels to attach only to Slow Burn alerts.
         */
        labels?: outputs.slo.SLOAlertingSlowburnLabel[];
    }

    export interface SLOAlertingSlowburnAnnotation {
        key: string;
        value: string;
    }

    export interface SLOAlertingSlowburnLabel {
        key: string;
        value: string;
    }

    export interface SLODestinationDatasource {
        /**
         * UID for the Mimir Datasource
         */
        uid?: string;
    }

    export interface SLOLabel {
        key: string;
        value: string;
    }

    export interface SLOObjective {
        /**
         * Value between 0 and 1. If the value of the query is above the objective, the SLO is met.
         */
        value: number;
        /**
         * A Prometheus-parsable time duration string like 24h, 60m. This is the time window the objective is measured over.
         */
        window: string;
    }

    export interface SLOQuery {
        freeform?: outputs.slo.SLOQueryFreeform;
        ratio?: outputs.slo.SLOQueryRatio;
        /**
         * Query type must be one of: "freeform", "query", "ratio", or "threshold"
         */
        type: string;
    }

    export interface SLOQueryFreeform {
        /**
         * Freeform Query Field
         */
        query: string;
    }

    export interface SLOQueryRatio {
        /**
         * Defines Group By Labels used for per-label alerting. These appear as variables on SLO dashboards to enable filtering and aggregation. Labels must adhere to Prometheus label name schema - "^[a-zA-Z*][a-zA-Z0-9*]*$"
         */
        groupByLabels?: string[];
        /**
         * Counter metric for success events (numerator)
         */
        successMetric: string;
        /**
         * Metric for total events (denominator)
         */
        totalMetric: string;
    }

}

export namespace syntheticMonitoring {
    export interface CheckSettings {
        /**
         * Settings for DNS check. The target must be a valid hostname (or IP address for `PTR` records).
         */
        dns?: outputs.syntheticMonitoring.CheckSettingsDns;
        /**
         * Settings for gRPC Health check. The target must be of the form `<host>:<port>`, where the host portion must be a valid hostname or IP address.
         */
        grpc?: outputs.syntheticMonitoring.CheckSettingsGrpc;
        /**
         * Settings for HTTP check. The target must be a URL (http or https).
         */
        http?: outputs.syntheticMonitoring.CheckSettingsHttp;
        /**
         * Settings for MultiHTTP check. The target must be a URL (http or https)
         */
        multihttp?: outputs.syntheticMonitoring.CheckSettingsMultihttp;
        /**
         * Settings for ping (ICMP) check. The target must be a valid hostname or IP address.
         */
        ping?: outputs.syntheticMonitoring.CheckSettingsPing;
        /**
         * Settings for scripted check. See https://grafana.com/docs/grafana-cloud/testing/synthetic-monitoring/create-checks/checks/k6/.
         */
        scripted?: outputs.syntheticMonitoring.CheckSettingsScripted;
        /**
         * Settings for TCP check. The target must be of the form `<host>:<port>`, where the host portion must be a valid hostname or IP address.
         */
        tcp?: outputs.syntheticMonitoring.CheckSettingsTcp;
        /**
         * Settings for traceroute check. The target must be a valid hostname or IP address
         */
        traceroute?: outputs.syntheticMonitoring.CheckSettingsTraceroute;
    }

    export interface CheckSettingsDns {
        /**
         * Options are `V4`, `V6`, `Any`. Specifies whether the corresponding check will be performed using IPv4 or IPv6. The `Any` value indicates that IPv6 should be used, falling back to IPv4 if that's not available. Defaults to `V4`.
         */
        ipVersion?: string;
        /**
         * Port to target. Defaults to `53`.
         */
        port?: number;
        /**
         * `TCP` or `UDP`. Defaults to `UDP`.
         */
        protocol?: string;
        /**
         * One of `ANY`, `A`, `AAAA`, `CNAME`, `MX`, `NS`, `PTR`, `SOA`, `SRV`, `TXT`. Defaults to `A`.
         */
        recordType?: string;
        /**
         * DNS server address to target. Defaults to `8.8.8.8`.
         */
        server?: string;
        /**
         * Source IP address.
         */
        sourceIpAddress?: string;
        /**
         * List of valid response codes. Options include `NOERROR`, `BADALG`, `BADMODE`, `BADKEY`, `BADCOOKIE`, `BADNAME`, `BADSIG`, `BADTIME`, `BADTRUNC`, `BADVERS`, `FORMERR`, `NOTIMP`, `NOTAUTH`, `NOTZONE`, `NXDOMAIN`, `NXRRSET`, `REFUSED`, `SERVFAIL`, `YXDOMAIN`, `YXRRSET`.
         */
        validRCodes?: string[];
        /**
         * Validate additional matches.
         */
        validateAdditionalRrs?: outputs.syntheticMonitoring.CheckSettingsDnsValidateAdditionalRr[];
        /**
         * Validate response answer.
         */
        validateAnswerRrs?: outputs.syntheticMonitoring.CheckSettingsDnsValidateAnswerRrs;
        /**
         * Validate response authority.
         */
        validateAuthorityRrs?: outputs.syntheticMonitoring.CheckSettingsDnsValidateAuthorityRrs;
    }

    export interface CheckSettingsDnsValidateAdditionalRr {
        /**
         * Fail if value matches regex.
         */
        failIfMatchesRegexps?: string[];
        /**
         * Fail if value does not match regex.
         */
        failIfNotMatchesRegexps?: string[];
    }

    export interface CheckSettingsDnsValidateAnswerRrs {
        /**
         * Fail if value matches regex.
         */
        failIfMatchesRegexps?: string[];
        /**
         * Fail if value does not match regex.
         */
        failIfNotMatchesRegexps?: string[];
    }

    export interface CheckSettingsDnsValidateAuthorityRrs {
        /**
         * Fail if value matches regex.
         */
        failIfMatchesRegexps?: string[];
        /**
         * Fail if value does not match regex.
         */
        failIfNotMatchesRegexps?: string[];
    }

    export interface CheckSettingsGrpc {
        /**
         * Options are `V4`, `V6`, `Any`. Specifies whether the corresponding check will be performed using IPv4 or IPv6. The `Any` value indicates that IPv6 should be used, falling back to IPv4 if that's not available. Defaults to `V4`.
         */
        ipVersion?: string;
        /**
         * gRPC service.
         */
        service?: string;
        /**
         * Whether or not TLS is used when the connection is initiated. Defaults to `false`.
         */
        tls?: boolean;
        /**
         * TLS config.
         */
        tlsConfig?: outputs.syntheticMonitoring.CheckSettingsGrpcTlsConfig;
    }

    export interface CheckSettingsGrpcTlsConfig {
        /**
         * CA certificate in PEM format.
         */
        caCert?: string;
        /**
         * Client certificate in PEM format.
         */
        clientCert?: string;
        /**
         * Client key in PEM format.
         */
        clientKey?: string;
        /**
         * Disable target certificate validation. Defaults to `false`.
         */
        insecureSkipVerify?: boolean;
        /**
         * Used to verify the hostname for the targets.
         */
        serverName?: string;
    }

    export interface CheckSettingsHttp {
        /**
         * Basic auth settings.
         */
        basicAuth?: outputs.syntheticMonitoring.CheckSettingsHttpBasicAuth;
        /**
         * Token for use with bearer authorization header.
         */
        bearerToken?: string;
        /**
         * The body of the HTTP request used in probe.
         */
        body?: string;
        /**
         * The name of the query parameter used to prevent the server from using a cached response. Each probe will assign a random value to this parameter each time a request is made.
         */
        cacheBustingQueryParamName?: string;
        /**
         * List of regexes. If any match the response body, the check will fail.
         */
        failIfBodyMatchesRegexps?: string[];
        /**
         * List of regexes. If any do not match the response body, the check will fail.
         */
        failIfBodyNotMatchesRegexps?: string[];
        /**
         * Check fails if headers match.
         */
        failIfHeaderMatchesRegexps?: outputs.syntheticMonitoring.CheckSettingsHttpFailIfHeaderMatchesRegexp[];
        /**
         * Check fails if headers do not match.
         */
        failIfHeaderNotMatchesRegexps?: outputs.syntheticMonitoring.CheckSettingsHttpFailIfHeaderNotMatchesRegexp[];
        /**
         * Fail if SSL is not present. Defaults to `false`.
         */
        failIfNotSsl?: boolean;
        /**
         * Fail if SSL is present. Defaults to `false`.
         */
        failIfSsl?: boolean;
        /**
         * The HTTP headers set for the probe.
         */
        headers?: string[];
        /**
         * Options are `V4`, `V6`, `Any`. Specifies whether the corresponding check will be performed using IPv4 or IPv6. The `Any` value indicates that IPv6 should be used, falling back to IPv4 if that's not available. Defaults to `V4`.
         */
        ipVersion?: string;
        /**
         * Request method. One of `GET`, `CONNECT`, `DELETE`, `HEAD`, `OPTIONS`, `POST`, `PUT`, `TRACE` Defaults to `GET`.
         */
        method?: string;
        /**
         * Do not follow redirects. Defaults to `false`.
         */
        noFollowRedirects?: boolean;
        /**
         * The HTTP headers sent to the proxy URL
         */
        proxyConnectHeaders?: string[];
        /**
         * Proxy URL.
         */
        proxyUrl?: string;
        /**
         * TLS config.
         */
        tlsConfig?: outputs.syntheticMonitoring.CheckSettingsHttpTlsConfig;
        /**
         * List of valid HTTP versions. Options include `HTTP/1.0`, `HTTP/1.1`, `HTTP/2.0`
         */
        validHttpVersions?: string[];
        /**
         * Accepted status codes. If unset, defaults to 2xx.
         */
        validStatusCodes?: number[];
    }

    export interface CheckSettingsHttpBasicAuth {
        /**
         * Basic auth password.
         */
        password: string;
        /**
         * Basic auth username.
         */
        username: string;
    }

    export interface CheckSettingsHttpFailIfHeaderMatchesRegexp {
        /**
         * Allow header to be missing from responses. Defaults to `false`.
         */
        allowMissing?: boolean;
        /**
         * Header name.
         */
        header: string;
        /**
         * Regex that header value should match.
         */
        regexp: string;
    }

    export interface CheckSettingsHttpFailIfHeaderNotMatchesRegexp {
        /**
         * Allow header to be missing from responses. Defaults to `false`.
         */
        allowMissing?: boolean;
        /**
         * Header name.
         */
        header: string;
        /**
         * Regex that header value should match.
         */
        regexp: string;
    }

    export interface CheckSettingsHttpTlsConfig {
        /**
         * CA certificate in PEM format.
         */
        caCert?: string;
        /**
         * Client certificate in PEM format.
         */
        clientCert?: string;
        /**
         * Client key in PEM format.
         */
        clientKey?: string;
        /**
         * Disable target certificate validation. Defaults to `false`.
         */
        insecureSkipVerify?: boolean;
        /**
         * Used to verify the hostname for the targets.
         */
        serverName?: string;
    }

    export interface CheckSettingsMultihttp {
        entries?: outputs.syntheticMonitoring.CheckSettingsMultihttpEntry[];
    }

    export interface CheckSettingsMultihttpEntry {
        /**
         * Assertions to make on the request response
         */
        assertions?: outputs.syntheticMonitoring.CheckSettingsMultihttpEntryAssertion[];
        /**
         * An individual MultiHTTP request
         */
        request?: outputs.syntheticMonitoring.CheckSettingsMultihttpEntryRequest;
        /**
         * Variables to extract from the request response
         */
        variables?: outputs.syntheticMonitoring.CheckSettingsMultihttpEntryVariable[];
    }

    export interface CheckSettingsMultihttpEntryAssertion {
        /**
         * The condition of the assertion: NOT*CONTAINS, EQUALS, STARTS*WITH, ENDS*WITH, TYPE*OF, CONTAINS
         */
        condition?: string;
        /**
         * The expression of the assertion. Should start with $.
         */
        expression?: string;
        /**
         * The subject of the assertion: RESPONSE*HEADERS, HTTP*STATUS*CODE, RESPONSE*BODY
         */
        subject?: string;
        /**
         * The type of assertion to make: TEXT, JSON*PATH*VALUE, JSON*PATH*ASSERTION, REGEX_ASSERTION
         */
        type: string;
        /**
         * The value of the assertion
         */
        value?: string;
    }

    export interface CheckSettingsMultihttpEntryRequest {
        /**
         * The body of the HTTP request used in probe.
         */
        bodies?: outputs.syntheticMonitoring.CheckSettingsMultihttpEntryRequestBody[];
        /**
         * The headers to send with the request
         */
        headers?: outputs.syntheticMonitoring.CheckSettingsMultihttpEntryRequestHeader[];
        /**
         * The HTTP method to use
         */
        method: string;
        /**
         * Query fields to send with the request
         */
        queryFields?: outputs.syntheticMonitoring.CheckSettingsMultihttpEntryRequestQueryField[];
        /**
         * The URL for the request
         */
        url: string;
    }

    export interface CheckSettingsMultihttpEntryRequestBody {
        /**
         * The content encoding of the body
         */
        contentEncoding?: string;
        /**
         * The content type of the body
         */
        contentType?: string;
        /**
         * The body payload
         */
        payload?: string;
    }

    export interface CheckSettingsMultihttpEntryRequestHeader {
        /**
         * Name of the header to send
         */
        name: string;
        /**
         * Value of the header to send
         */
        value: string;
    }

    export interface CheckSettingsMultihttpEntryRequestQueryField {
        /**
         * Name of the query field to send
         */
        name: string;
        /**
         * Value of the query field to send
         */
        value: string;
    }

    export interface CheckSettingsMultihttpEntryVariable {
        /**
         * The attribute to use when finding the variable value. Only used when type is CSS_SELECTOR
         */
        attribute?: string;
        /**
         * The expression to when finding the variable. Should start with $. Only use when type is JSON_PATH or REGEX
         */
        expression?: string;
        /**
         * The name of the variable to extract
         */
        name?: string;
        /**
         * The method of finding the variable value to extract. JSON*PATH, REGEX, CSS*SELECTOR
         */
        type: string;
    }

    export interface CheckSettingsPing {
        /**
         * Set the DF-bit in the IP-header. Only works with ipV4. Defaults to `false`.
         */
        dontFragment?: boolean;
        /**
         * Options are `V4`, `V6`, `Any`. Specifies whether the corresponding check will be performed using IPv4 or IPv6. The `Any` value indicates that IPv6 should be used, falling back to IPv4 if that's not available. Defaults to `V4`.
         */
        ipVersion?: string;
        /**
         * Payload size. Defaults to `0`.
         */
        payloadSize?: number;
        /**
         * Source IP address.
         */
        sourceIpAddress?: string;
    }

    export interface CheckSettingsScripted {
        script: string;
    }

    export interface CheckSettingsTcp {
        /**
         * Options are `V4`, `V6`, `Any`. Specifies whether the corresponding check will be performed using IPv4 or IPv6. The `Any` value indicates that IPv6 should be used, falling back to IPv4 if that's not available. Defaults to `V4`.
         */
        ipVersion?: string;
        /**
         * The query sent in the TCP probe and the expected associated response.
         */
        queryResponses?: outputs.syntheticMonitoring.CheckSettingsTcpQueryResponse[];
        /**
         * Source IP address.
         */
        sourceIpAddress?: string;
        /**
         * Whether or not TLS is used when the connection is initiated. Defaults to `false`.
         */
        tls?: boolean;
        /**
         * TLS config.
         */
        tlsConfig?: outputs.syntheticMonitoring.CheckSettingsTcpTlsConfig;
    }

    export interface CheckSettingsTcpQueryResponse {
        /**
         * Response to expect.
         */
        expect: string;
        /**
         * Data to send.
         */
        send: string;
        /**
         * Upgrade TCP connection to TLS. Defaults to `false`.
         */
        startTls?: boolean;
    }

    export interface CheckSettingsTcpTlsConfig {
        /**
         * CA certificate in PEM format.
         */
        caCert?: string;
        /**
         * Client certificate in PEM format.
         */
        clientCert?: string;
        /**
         * Client key in PEM format.
         */
        clientKey?: string;
        /**
         * Disable target certificate validation. Defaults to `false`.
         */
        insecureSkipVerify?: boolean;
        /**
         * Used to verify the hostname for the targets.
         */
        serverName?: string;
    }

    export interface CheckSettingsTraceroute {
        /**
         * Maximum TTL for the trace Defaults to `64`.
         */
        maxHops?: number;
        /**
         * Maximum number of hosts to travers that give no response Defaults to `15`.
         */
        maxUnknownHops?: number;
        /**
         * Reverse lookup hostnames from IP addresses Defaults to `true`.
         */
        ptrLookup?: boolean;
    }

}
